{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ark SDK","text":"<p>The official Python SDK and CLI for CyberArk's Identity Security Platform Services.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Ark SDK, an API first library, is used to automate different sets of operations in order to ease day to day development. Ark provides a CLI for general purpose automation as well as a Python SDK for code integration.</p>"},{"location":"#tldr","title":"TL;DR","text":""},{"location":"#enduser","title":"Enduser","text":""},{"location":"#admin","title":"Admin","text":""},{"location":"#license","title":"License","text":"<p>This project is licensed under Apache License 2.0 - see <code>LICENSE</code> for more details</p> <p>Copyright (c) 2023 CyberArk Software Ltd. All rights reserved.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>The library is designed as follows:</p> <p></p>"},{"location":"architecture/#design-perspectives","title":"Design Perspectives","text":"<p>The main components are:</p> <ul> <li>Profile: The profile defines a set of properties and information about the user's authentication methods. Profiles are persisted on the filesystem for subsequent actions.</li> <li>Authenticators: The integrations with specific authentication methods, which enable interaction with services. An authentication method can either be Identity (User/Service User) or a custom implementation.</li> <li>Services: The service providing functionality (requires one or more associated authenticators to perform actions). For example, the SIA service exposes SIA APIs in an secure manner.</li> <li>Services Model Schemes The models exposed by a service, which can be used to perform the service's actions.</li> <li>CLI Actions: CLI interface built on the SDK, which provides users with the following shell commands:<ul> <li><code>configure</code>: Configure a profile with authentication details</li> <li><code>login</code>: Log in with a configured profile authenticator</li> <li><code>exec</code>: Execute services actions</li> </ul> </li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>You can install the SDK via PyPI with the following command: <pre><code>pip3 install ark-sdk-python\n</code></pre></p> <p>You may also upgrade the SDK via PyPI to the latest version with the following command: <pre><code>pip3 install -U ark-sdk-python\n</code></pre></p>"},{"location":"getting_started/#cli-usage","title":"CLI Usage","text":"<p>Both the SDK and the CLI support profiles, which can be configured as needed and used for consecutive actions.</p> <p>The CLI has the following basic commands:</p> <ul> <li>configure: Configure profiles and their authentication methods (see Configure)</li> <li>login: Log in using the configured profile authentication methods (see Login)</li> <li>exec: Execute commands for supported services (see Exec)</li> <li>profiles: Manage multiple profiles on the machine (see Profiles)</li> <li>cache: Manage ark cache on the machine (see Cache)</li> </ul>"},{"location":"getting_started/#basic-flow","title":"Basic flow","text":"<ol> <li> <p>Install Ark SDK and then configure a profile (either silently or interactively): <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></p> </li> <li> <p>After the profile is configured, log in:     <pre><code>ark login --silent --isp-secret mysecret\n</code></pre></p> </li> <li> <p>Execute actions (such as generating a short-lived SSO password):     <pre><code>ark exec sia sso short-lived-password\n</code></pre></p> </li> </ol>"},{"location":"license/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2025\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <pre><code> APPENDIX: How to apply the Apache License to your work.\n\n  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"{}\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright \u00a9 2023 CyberArk Software Ltd</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"commands/cache/","title":"Cache","text":"<p>Use the <code>cache</code> command to manage the Ark data cached on your machine. Currently, you can only clear the filesystem cache (not data cached in the OS's keystore). </p>"},{"location":"commands/cache/#running","title":"Running","text":"<pre><code>ark cache\n</code></pre>"},{"location":"commands/cache/#usage","title":"Usage","text":"<pre><code>usage: ark cache [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}] [-dcv] [-tc TRUSTED_CERT] {clear} ...\n\npositional arguments:\n  {clear}\n    clear               Clears all profiles cache\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n</code></pre>"},{"location":"commands/configure/","title":"Configure command","text":"<p>The <code>configure</code> command is used to create a profile. Profiles define user and authentication information, such as which authentication methods to use, the method settings, and other information like MFA.</p> <p>Profiles are saved in the <code>~/.ark_profiles</code> folder.</p>"},{"location":"commands/configure/#run","title":"Run","text":"<pre><code>ark configure\n</code></pre> <p>When you run the command without arguments, you are prompted for the required information (alternatively, add the <code>--silent</code> flag with the required arguments).</p>"},{"location":"commands/configure/#usage","title":"Usage","text":"<pre><code>usage: ark configure [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                     [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-pd PROFILE_DESCRIPTION] [-wwis]\n                     [-isam {identity,identity_service_user}] [-iu ISP_USERNAME]\n                     [-iimm {pf,sms,email,otp}] [-iiu ISP_IDENTITY_URL]\n                     [-iiaa ISP_IDENTITY_AUTHORIZATION_APPLICATION]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name for storage\n  -pd PROFILE_DESCRIPTION, --profile-description PROFILE_DESCRIPTION\n                        Info about the profile\n  -wwis, --work-with-isp\n                        Whether to work with Identity Security Platform services\n  -isam {identity,identity_service_user}, --isp-auth-method {identity,identity_service_user}\n  -iu ISP_USERNAME, --isp-username ISP_USERNAME\n                        Username to authenticate with\n  -iimm {pf,sms,email,otp}, --isp-identity-mfa-method {pf,sms,email,otp}\n                        MFA method if mfa is needed\n  -iiu ISP_IDENTITY_URL, --isp-identity-url ISP_IDENTITY_URL\n                        Identity url to use for authentication instead of fqdn resolving\n  -iiaa ISP_IDENTITY_AUTHORIZATION_APPLICATION, --isp-identity-authorization-application ISP_IDENTITY_AUTHORIZATION_APPLICATION\n                        Identity application to authorize once logged in with the service user\n</code></pre>"},{"location":"commands/exec/","title":"Exec","text":"<p>You use the <code>exec</code> command is used to run commands on available services (the available services depend on the authorized user's account).</p>"},{"location":"commands/exec/#sia-services","title":"SIA services","text":"<p>The following SIA commands are supported:</p> <ul> <li><code>ark exec sia</code>: Root command for the SIA service<ul> <li><code>policies</code> - Policy management<ul> <li><code>db</code> - DB policies<ul> <li><code>editor</code> - DB policies interactive editor</li> </ul> </li> <li><code>vm</code> - SIA VM policies<ul> <li><code>editor</code> - SIA VM policies interactive editor</li> </ul> </li> </ul> </li> <li><code>certificates</code> - Certificate management</li> <li><code>db</code> - Databases end-user operations</li> <li><code>sso</code> - SSO end-user operations</li> <li><code>secrets</code> - Secrets service<ul> <li><code>db</code> - DB secrets service</li> <li><code>vm</code> - VM secrets service</li> </ul> </li> <li><code>workspaces</code> - Workspaces management<ul> <li><code>db</code> - DB workspace management</li> <li><code>target-sets</code> - Target Sets workspace management</li> </ul> </li> <li><code>k8s</code> - Kubernetes service</li> <li><code>access</code> - Access service</li> </ul> </li> <li><code>ark exec sm</code>: Root command for Session Monitoring service</li> <li><code>ark exec identity</code>: Root command for Identity service<ul> <li><code>roles</code> - Roles management</li> <li><code>users</code> - Users management</li> <li><code>policies</code> - Policies management</li> <li><code>directories</code> - Directories reading</li> </ul> </li> <li><code>ark exec pcloud</code>: Root command for PCloud service<ul> <li><code>accounts</code> - Accounts management</li> <li><code>safes</code> - Safes management</li> <li><code>platforms</code> - Platforms management</li> <li><code>applications</code> - Applications management</li> </ul> </li> <li><code>ark exec cmgr</code>: Root command for Connector Manager service</li> </ul> <p>All commands have their own subcommands and respective arguments.</p>"},{"location":"commands/exec/#running","title":"Running","text":"<pre><code>ark exec\n</code></pre>"},{"location":"commands/exec/#usage","title":"Usage","text":"<pre><code>usage: ark exec [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-op OUTPUT_PATH] [-rf REQUEST_FILE]\n                [-rc RETRY_COUNT] [-ra]\n                {identity,sia,sm,pcloud} ...\n\npositional arguments:\n  {identity,sia,sm,pcloud}\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name to load\n  -op OUTPUT_PATH, --output-path OUTPUT_PATH\n                        Output file to write data to\n  -rf REQUEST_FILE, --request-file REQUEST_FILE\n                        Request file containing the parameters for the exec action\n  -rc RETRY_COUNT, --retry-count RETRY_COUNT\n                        Retry count for execution\n  -ra, --refresh-auth   If possible, will try to refresh the active authentication before running the\n                        actual command\n</code></pre>"},{"location":"commands/login/","title":"Login","text":"<p>The <code>login</code> command is used to authenticate to Ark using the configured profile. When you run the command, you are prompted for the required login information (such as a password and MFA verifications).</p> <p>After you have logged in, the returned access tokens are stored in a secure location on your machine. After the tokens expire, a token refresh maybe attempted (see Refresh token) or a new login is required.</p>"},{"location":"commands/login/#run","title":"Run","text":"<pre><code>ark login\n</code></pre>"},{"location":"commands/login/#usage","title":"Usage","text":"<pre><code>usage: ark login [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                 [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-f] [-nss] [-st] [-ra]\n                 [-isu ISP_USERNAME] [-iss ISP_SECRET]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name to load\n  -f, --force           Whether to force login even thou token has not expired yet\n  -nss, --no-shared-secrets\n                        Do not share secrets between different authenticators with the\n                        same username\n  -st, --show-tokens    Print out tokens as well if not silent\n  -ra, --refresh-auth   If a cache exists, will also try to refresh it\n  -isu ISP_USERNAME, --isp-username ISP_USERNAME\n                        Username to authenticate with to Identity Security Platform\n  -iss ISP_SECRET, --isp-secret ISP_SECRET\n                        Secret to authenticate with to Identity Security Platform\n</code></pre>"},{"location":"commands/profiles/","title":"Profiles","text":"<p>Use the <code>profiles</code> command to manage multiple users and tenants. You can create, copy, modify, and delete profiles for different users and tenant, and to list all existing profiles.</p>"},{"location":"commands/profiles/#running","title":"Running","text":"<pre><code>ark profiles\n</code></pre>"},{"location":"commands/profiles/#usage","title":"Usage","text":"<pre><code>usage: ark profiles [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}] [-dcv] [-tc TRUSTED_CERT]\n                    {list,show,delete,clear,clone,add} ...\n\npositional arguments:\n  {list,show,delete,clear,clone,add}\n    list                List all profiles\n    show                Show a profile\n    delete              Delete a specific profile\n    clear               Clear all profiles\n    clone               Clones a profile\n    add                 Adds a profile to the profiles folder from a given path\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n</code></pre>"},{"location":"examples/commands_examples/","title":"Commands examples","text":"<p>This page lists some useful CLI examples.</p> <p>Note</p> <p>You can disable certificate validation for login to an authenticator using the <code>--disable-certificate-verification</code> flag. This option is not recommended.</p> <p>Useful environment variables</p> <ul> <li><code>ARK_PROFILE</code>: Sets the profile to be used across the CLI</li> <li><code>ARK_DISABLE_CERTIFICATE_VERIFICATION</code>: Disables certificate verification for REST APIs</li> </ul>"},{"location":"examples/commands_examples/#configure-command-example","title":"Configure command example","text":"<p>The <code>configure</code> command works in interactive or silent mode. When using silent mode, the required parameters need to specified. Here's an example of configuring ISP in silent mode:</p> <pre><code>ark configure --profile-name=\"PROD\" --work-with-isp --isp-username=\"tina@cyberark.cloud.12345\" --silent --allow-output\n</code></pre>"},{"location":"examples/commands_examples/#login-commands-example","title":"Login commands Example","text":"<p>The login command can work in interactive or silent mode. Here's an example of a silent login with the profile configured in the example above: <pre><code>ark login -s --isp-secret=CoolPassword\u00df\n</code></pre></p>"},{"location":"examples/commands_examples/#exec-command-examples","title":"Exec command examples","text":"<p>Use the <code>--help</code> flag to view all <code>exec</code> options.</p>"},{"location":"examples/commands_examples/#add-sia-database-secret","title":"Add SIA database secret","text":"<pre><code>ark exec sia secrets db add-secret --secret-name mysecret --secret-type username_password --username user --password mypass\n</code></pre>"},{"location":"examples/commands_examples/#delete-sia-database-secret","title":"Delete SIA database secret","text":"<pre><code>ark exec sia secrets db delete-secret --secret-name mysecret\n</code></pre>"},{"location":"examples/commands_examples/#add-sia-database","title":"Add SIA database","text":"<pre><code>ark exec sia workspaces db add-database --name mydb --provider-engine postgres-sh --read-write-endpoint myendpoint.domain.com\n</code></pre>"},{"location":"examples/commands_examples/#list-sia-databases","title":"List SIA databases","text":"<pre><code>ark exec sia workspaces db list-databases\n</code></pre>"},{"location":"examples/commands_examples/#get-vm-policies-stats","title":"Get VM policies stats","text":"<pre><code>ark exec sia policies vm policies-stats\n</code></pre>"},{"location":"examples/commands_examples/#edit-policies-interactively-example","title":"Edit policies interactively example","text":"<p>This example shows how to locally work with a policies workspace, and edit, reset, and create policies that are applied to both databases and VM policies. After the local policies are ready, you can commit all the policies changes to the remote workspace.</p> <p>To load and reload policies locally:</p> <pre><code>ark exec sia policies vm editor load-policies\n</code></pre> <p>After loading the policies, use these commands to edit them: <pre><code>ark exec sia policies vm editor edit-policies\nark exec sia policies vm editor view-policies\nark exec sia policies vm editor reset-policies\nark exec sia policies vm editor generate-policy\nark exec sia policies vm editor remove-policies\nark exec sia policies vm editor policies diff\n</code></pre></p> <p>When they are ready to be committed, run: <pre><code>ark exec sia policies vm editor commit-policies\n</code></pre></p>"},{"location":"examples/commands_examples/#generate-a-short-lived-sso-password-for-a-database-connection","title":"Generate a short-lived SSO password for a database connection","text":"<pre><code>ark exec sia sso short-lived-password\n</code></pre>"},{"location":"examples/commands_examples/#generate-a-short-lived-sso-oracle-wallet-for-an-oracle-database-connection","title":"Generate a short-lived SSO Oracle wallet for an Oracle database connection","text":"<pre><code>ark exec sia sso short-lived-oracle-wallet --folder ~/wallet\n</code></pre>"},{"location":"examples/commands_examples/#generate-a-kubectl-config-file","title":"Generate a kubectl config file","text":"<pre><code>ark exec sia k8s generate-kubeconfig \n</code></pre>"},{"location":"examples/commands_examples/#generate-a-kubectl-config-file-and-save-it-in-the-specified-path","title":"Generate a kubectl config file and save it in the specified path","text":"<pre><code>ark exec sia k8s generate-kubeconfig --folder=/Users/My.User/.kube\n</code></pre>"},{"location":"examples/commands_examples/#add-sia-vm-target-set","title":"Add SIA VM Target Set","text":"<pre><code>ark_public exec sia workspaces target-sets add-target-set --name mydomain.com --type Domain\n</code></pre>"},{"location":"examples/commands_examples/#add-sia-vm-secret","title":"Add SIA VM Secret","text":"<pre><code>ark_public exec sia secrets vm add-secret --secret-type ProvisionerUser --provisioner-username=myuser --provisioner-password=mypassword\n</code></pre>"},{"location":"examples/commands_examples/#get-sia-connector-installation-script","title":"Get SIA connector installation script","text":"<pre><code>ark exec sia access connector-setup-script -ct onprem -co windows -cpi 588741d5-e059-479d-b4c4-3d821a87f012\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-monitoring-sessions-from-the-last-24-hours","title":"List All Session Monitoring sessions from the last 24 hours","text":"<pre><code>ark exec sm list-sessions\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-monitoring-sessions-from-the-last-24-hours","title":"Count All Session Monitoring sessions from the last 24 hours","text":"<pre><code>ark exec sm count-sessions\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-monitoring-sessions-matching-search-query","title":"List All Session Monitoring sessions matching Search Query","text":"<pre><code>ark exec sm list-sessions-by --search 'startTime ge 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01 AND protocol IN SSH,RDP,Database'\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-monitoring-sessions-matching-search-query","title":"Count All Session Monitoring sessions matching Search Query","text":"<pre><code>ark exec sm count-sessions-by --search 'startTime ge 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01 AND protocol IN SSH,RDP,Database'\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-monitoring-sessions-from-the-last-24-hours_1","title":"Count All Session Monitoring sessions from the last 24 hours","text":"<pre><code>ark exec sm count-sessions\n</code></pre>"},{"location":"examples/commands_examples/#retrieve-a-session-by-id","title":"Retrieve a session by id","text":"<pre><code>ark exec sm session --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-activities","title":"List all session activities","text":"<pre><code>ark exec sm list-session-activities --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-activities","title":"Count all session activities","text":"<pre><code>ark exec sm count-session-activities --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-activities-with-specific-command","title":"List all session activities with specific command","text":"<pre><code>ark exec sm list-session-activities-by --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d --command-contains 'ls'\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-activities-with-specific-command","title":"Count all session activities with specific command","text":"<pre><code>ark exec sm count-session-activities-by --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d --command-contains 'ls'\n</code></pre>"},{"location":"examples/commands_examples/#display-general-sessions-statistics-from-the-last-30-days","title":"Display general sessions statistics from the last 30 days","text":"<pre><code>ark exec sm sessions-stats\n</code></pre>"},{"location":"examples/commands_examples/#list-all-identity-entities-including-roles-users-and-groups","title":"List all identity entities, including roles users and groups","text":"<pre><code>ark exec identity directories list-directories-entities\n</code></pre>"},{"location":"examples/commands_examples/#list-only-identity-roles","title":"List only identity roles","text":"<pre><code>ark exec identity directories list-directories-entities --entity-types ROLE\n</code></pre>"},{"location":"examples/commands_examples/#create-a-role-with-sia-show-tile-admin-right","title":"Create a role with SIA show tile admin right","text":"<pre><code>ark exec identity roles create-role --role-name RoleName --admin-rights \"ServiceRight/dpaShowTile\"\n</code></pre>"},{"location":"examples/commands_examples/#delete-a-role-by-name","title":"Delete a role by name","text":"<pre><code>ark exec identity roles delete-role --role-name RoleName\n</code></pre>"},{"location":"examples/commands_examples/#create-a-new-user","title":"Create a new user","text":"<pre><code>ark exec identity users create-user --username myname --email email@email.com --password MyPassword\n</code></pre>"},{"location":"examples/commands_examples/#delete-a-user-by-name","title":"Delete a user by name","text":"<pre><code>ark exec identity users delete-user --username myname\n</code></pre>"},{"location":"examples/commands_examples/#add-an-authentication-profile","title":"Add an authentication profile","text":"<pre><code>ark exec identity policies add-authentication-profile --auth-profile-name myprofile --first-challenges UP --second-challenges EMAIL\n</code></pre>"},{"location":"examples/commands_examples/#add-a-policy","title":"Add a policy","text":"<pre><code>ark exec identity policies add-policy --policy-name mypolicy --role-names RoleName --auth-profile-name myprofile\n</code></pre>"},{"location":"examples/commands_examples/#create-a-pcloud-safe","title":"Create a PCloud Safe","text":"<pre><code>ark exec pcloud safes add-safe --safe-name=safe\n</code></pre>"},{"location":"examples/commands_examples/#create-a-pcloud-account","title":"Create a PCloud Account","text":"<pre><code>ark exec pcloud accounts add-account --name account --safe-name safe --platform-id='UnixSSH' --username root --address 1.2.3.4 --secret-type=password --secret mypass\n</code></pre>"},{"location":"examples/commands_examples/#list-available-platforms","title":"List available platforms","text":"<pre><code>ark exec pcloud platforms list-platforms\n</code></pre>"},{"location":"examples/commands_examples/#list-cmgr-connector-pools","title":"List CMGR connector pools","text":"<pre><code>ark exec exec cmgr list-pools\n</code></pre>"},{"location":"examples/sdk_examples/","title":"SDK examples","text":"<p>This page lists some useful SDK examples.</p>"},{"location":"examples/sdk_examples/#authenticate-and-read-tenant-db-policies","title":"Authenticate and read tenant DB policies","text":"<pre><code>from ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.auth import ArkSecret, ArkAuthMethod, ArkAuthProfile, IdentityArkAuthMethodSettings\nfrom ark_sdk_python.services.sia.policies.db import ArkSIADBPoliciesService\n\nif __name__ == \"__main__\":\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='tina@cyberark.cloud.12345', auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n    db_policies_service = ArkSIADBPoliciesService(isp_auth)\n    policies = db_policies_service.list_policies()\n</code></pre>"},{"location":"examples/sdk_examples/#authenticate-and-provision-sia-databases-and-policy-and-connector","title":"Authenticate and provision SIA databases and policy and connector","text":"<pre><code>if __name__ == '__main__':\n    ArkSystemConfig.disable_verbose_logging()\n    # Authenticate to the tenant with an auth profile to configure SIA\n    username = 'user@cyberark.cloud.12345'\n    print(f'Authenticating to the created tenant with user [{username}]')\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n\n    # Create SIA DB Secret, Database, Connector and DB Policy\n    sia_service = ArkSIAAPI(isp_auth)\n    print('Adding SIA DB User Secret')\n    secret = sia_service.secrets_db.add_secret(\n        ArkSIADBAddSecret(secret_type=ArkSIADBSecretType.UsernamePassword, username='Administrator', password='CoolPassword')\n    )\n    print('Adding SIA Database')\n    sia_service.workspace_db.add_database(\n        ArkSIADBAddDatabase(\n            name='mydomain.com',\n            provider_engine=ArkSIADBDatabaseEngineType.PostgresSH,\n            secret_id=secret.secret_id,\n            read_write_endpoint=\"myendpoint.mydomain.com\",\n        )\n    )\n    print('Installing SIA Connector')\n    sia_service.access.install_connector(\n        ArkSIAInstallConnector(\n            connector_os=ArkOsType.LINUX,\n            connector_type=ArkWorkspaceType.ONPREM,\n            connector_pool_id='pool_id',\n            target_machine='1.2.3.4',\n            username='root',\n            private_key_path='/path/to/private.pem',\n        )\n    )\n    print('Adding SIA DB Policy')\n    sia_service.policies_db.add_policy(\n        ArkSIADBAddPolicy(\n            policy_name='IT Policy',\n            status=ArkSIARuleStatus.Enabled,\n            description='IT Policy',\n            providers_data=ArkSIADBProvidersData(\n                postgres=ArkSIADBPostgres(\n                    resources=['postgres-onboarded-asset'],\n                ),\n            ),\n            user_access_rules=[\n                ArkSIADBAuthorizationRule(\n                    rule_name='IT Rule',\n                    user_data=ArkSIAUserData(roles=['DpaAdmin'], groups=[], users=[]),\n                    connection_information=ArkSIADBConnectionInformation(\n                        grant_access=2,\n                        idle_time=10,\n                        full_days=True,\n                        hours_from='07:00',\n                        hours_to='17:00',\n                        time_zone='Asia/Jerusalem',\n                        connect_as=ArkSIADBConnectAs(\n                            db_auth=[\n                                ArkSIADBLocalDBAuth(\n                                    roles=['rds_superuser'],\n                                    applied_to=[\n                                        ArkSIADBAppliedTo(\n                                            name='postgres-onboarded-asset',\n                                            type=ArkSIADBResourceIdentifierType.RESOURCE,\n                                        )\n                                    ],\n                                ),\n                            ],\n                        ),\n                    ),\n                )\n            ],\n        )\n    )\n</code></pre>"},{"location":"examples/sdk_examples/#authenticate-and-provision-sia-vm-policies","title":"Authenticate and provision SIA VM policies","text":"<pre><code>if __name__ == '__main__':\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n    print('Adding SIA Policy')\n    sia_service.policies.add_policy(\n        ArkSIAVMAddPolicy(\n            policy_name='IT Policy',\n            description='IT Policy',\n            status=ArkSIARuleStatus.Enabled,\n            providers_data={\n                ArkWorkspaceType.AWS: ArkSIAVMAWSProviderData(\n                    account_ids=['965428623928'], tags=[{'key': 'team', 'value': 'IT'}], regions=[], vpc_ids=[]\n                )\n            },\n            user_access_rules=[\n                ArkSIAVMAuthorizationRule(\n                    rule_name='IT Rule',\n                    user_data=ArkSIAUserData(roles=['IT']),\n                    connection_information=ArkSIAVMConnectionInformation(\n                        full_days=True,\n                        days_of_week=[],\n                        time_zone='Asia/Jerusalem',\n                        connect_as={\n                            ArkWorkspaceType.AWS: {\n                                ArkProtocolType.SSH: 'root',\n                                ArkProtocolType.RDP: ArkSIAVMRDPLocalEphemeralUserConnectionData(\n                                    local_ephemeral_user=ArkSIAVMLocalEphemeralUserConnectionMethodData(assign_groups={'Administrators'})\n                                ),\n                            }\n                        },\n                    ),\n                )\n            ],\n        )\n    )\n</code></pre>"},{"location":"examples/sdk_examples/#authenticate-and-provision-sia-vm-rdp-target-set-secret-policy-connector","title":"Authenticate and provision SIA VM RDP Target Set / Secret / Policy / Connector","text":"<pre><code>if __name__ == '__main__':\n    ArkSystemConfig.disable_verbose_logging()\n    # Authenticate to the tenant with an auth profile to configure SIA\n    username = 'user@cyberark.cloud.12345'\n    print(f'Authenticating to the created tenant with user [{username}]')\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n\n    # Create SIA VM Secret, Target Set and VM Policy\n    sia_service = ArkSIAAPI(isp_auth)\n    print('Adding SIA VM User Secret')\n    secret = sia_service.secrets_vm.add_secret(\n        ArkSIAVMAddSecret(\n            secret_type=ArkSIAVMSecretType.ProvisionerUser, \n            provisioner_username='Administrator', \n            provisioner_password='CoolPassword',\n        ),\n    )\n    print('Installing SIA Connector')\n    sia_service.access.install_connector(\n        ArkSIAInstallConnector(\n            connector_os=ArkOsType.LINUX,\n            connector_type=ArkWorkspaceType.ONPREM,\n            connector_pool_id='pool_id',\n            target_machine='1.2.3.4',\n            username='root',\n            private_key_path='/path/to/private.pem',\n        )\n    )\n    print('Adding SIA Target Set')\n    sia_service.workspace_target_sets.add_target_set(\n        ArkSIAAddTargetSet(\n            name='mydomain.com',\n            secret_type=ArkSIAVMSecretType.ProvisionerUser,\n            secret_id=secret.secret_id,\n        )\n    )\n    print('Adding SIA VM Policy')\n    sia_service.policies_vm.add_policy(\n        ArkSIAVMAddPolicy(\n            policy_name='IT Policy',\n            status=ArkSIARuleStatus.Enabled,\n            description='IT Policy',\n            providers_data={\n                ArkWorkspaceType.ONPREM: ArkSIAVMOnPremProviderData(\n                    fqdn_rules=[\n                        ArkSIAVMFQDNRule(\n                            operator=ArkSIAVMFQDNOperator.WILDCARD,\n                            computername_pattern='*',\n                            domain='mydomain.com',\n                        ),\n                    ],\n                ),\n            },\n            user_access_rules=[\n                ArkSIAVMAuthorizationRule(\n                    rule_name='IT Rule',\n                    user_data=ArkSIAUserData(roles=['DpaAdmin'], groups=[], users=[]),\n                    connection_information=ArkSIAVMConnectionInformation(\n                        grant_access=2,\n                        idle_time=10,\n                        full_days=True,\n                        hours_from='07:00',\n                        hours_to='17:00',\n                        time_zone='Asia/Jerusalem',\n                        connect_as={\n                            ArkWorkspaceType.ONPREM: {\n                                ArkProtocolType.RDP: ArkSIAVMRDPLocalEphemeralUserConnectionData(\n                                    local_ephemeral_user=ArkSIAVMLocalEphemeralUserConnectionMethodData(\n                                        assign_groups=[\n                                            'Administrators'\n                                        ],\n                                    ),\n                                ),\n                            },\n                        },\n                    ),\n                )\n            ],\n        )\n    )\n    print('Finished Successfully')\n</code></pre>"},{"location":"examples/sdk_examples/#view-session-monitoring-sessions-and-activities-per-session","title":"View Session Monitoring Sessions And Activities Per Session","text":"<pre><code>from ark_sdk_python.services.sm import ArkSMService\nfrom ark_sdk_python.models.services.sm import ArkSMSessionsFilter, ArkSMGetSession, ArkSMGetSessionActivities\nfrom ark_sdk_python.models.ark_profile import ArkProfileLoader\nfrom ark_sdk_python.models.common import ArkProtocolType\nfrom ark_sdk_python.auth import ArkISPAuth\nfrom datetime import datetime, timedelta\n\nif __name__ == \"__main__\":\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        profile=ArkProfileLoader().load_default_profile()\n    )\n    sm: ArkSMService = ArkSMService(isp_auth)\n    search_by = 'startTime ge {start_time_from} AND sessionDuration GE {min_duration} AND protocol IN {protocols}'\n    search_by = search_by.format(\n        start_time_from=(datetime.utcnow() - timedelta(days=30)).isoformat(timespec='seconds'),\n        min_duration='00:00:01',\n        protocols=','.join([ArkProtocolType.DB[0], ArkProtocolType.SSH[0], ArkProtocolType.RDP[0]]),\n    )\n    sessions_filter = ArkSMSessionsFilter(\n        search=search_by,\n    )\n    print(f'session_count = {sm.count_sessions_by(sessions_filter)}')\n    for s_page in sm.list_sessions_by(sessions_filter):\n        for session in s_page.items:\n            session = sm.session(ArkSMGetSession(session_id=session.session_id))\n            get_session_activities = ArkSMGetSessionActivities(session_id=session.session_id)\n            print(f'session = {session}, activities_count = {sm.count_session_activities(get_session_activities)}')\n            session_activities = [activity for page in sm.list_session_activities(get_session_activities) for activity in page.items]\n            print(session_activities)\n</code></pre>"},{"location":"examples/sdk_examples/#get-current-tenant-default-suffix","title":"Get current tenant default suffix","text":"<pre><code>from ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.ark_profile import ArkProfileLoader\nfrom ark_sdk_python.models.services.identity.directories import ArkIdentityListDirectoriesEntities\nfrom ark_sdk_python.services.identity import ArkIdentityAPI\n\nif __name__ == \"__main__\":\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(ArkProfileLoader().load_default_profile())\n    identity_api = ArkIdentityAPI(isp_auth)\n    print(identity_api.identity_directories.tenant_default_suffix())\n    for page in identity_api.identity_directories.list_directories_entities(ArkIdentityListDirectoriesEntities()):\n        print([i.name for i in page.items])\n</code></pre>"},{"location":"examples/sdk_examples/#add-identity-role-and-user","title":"Add identity role and user","text":"<pre><code>from ark_sdk_python.models.auth import (\n    ArkAuthMethod,\n    ArkAuthProfile,\n    ArkSecret,\n    IdentityArkAuthMethodSettings,\n)\nfrom ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.services.identity import ArkIdentityAPI\nfrom ark_sdk_python.models.services.identity.roles import ArkIdentityCreateRole\nfrom ark_sdk_python.models.services.identity.users import ArkIdentityCreateUser\n\nif __name__ == \"__main__\":\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='CoolUser', auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n\n    # Create an identity service to create some users and roles\n    print('Creating identity roles and users')\n    identity_api = ArkIdentityAPI(isp_auth)\n    identity_api.identity_roles.create_role(ArkIdentityCreateRole(role_name='IT'))\n    identity_api.identity_users.create_user(ArkIdentityCreateUser(username='it_user', password='CoolPassword', roles=['IT']))\n</code></pre>"},{"location":"examples/sdk_examples/#list-pcloud-accounts","title":"List PCloud Accounts","text":"<pre><code>import pprint\n\nfrom ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.auth import ArkAuthMethod, ArkAuthProfile, ArkSecret, IdentityArkAuthMethodSettings\nfrom ark_sdk_python.services.pcloud.accounts import ArkPCloudAccountsService\n\nif __name__ == '__main__':\n    isp_auth = ArkISPAuth(cache_authentication=False)\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='smarom@cyberark.cloud.84573',\n            auth_method=ArkAuthMethod.Identity,\n            auth_method_settings=IdentityArkAuthMethodSettings(),\n        ),\n        secret=ArkSecret(secret=\"CoolPassword\"),\n    )\n    accounts_service = ArkPCloudAccountsService(isp_auth=isp_auth)\n    for page in accounts_service.list_accounts():\n        for item in page:\n            pprint.pprint(item.model_dump())\n</code></pre>"},{"location":"howto/enduser_databases_workflow/","title":"End-user database Workflow","text":"<p>Here is an example workflow for connecting to a database:</p> <ol> <li>Install Ark SDK: <code>pip3 install ark-sdk-python</code></li> <li>Create a profile:  <ul> <li>Interactively:     <pre><code>ark configure\n</code></pre></li> <li>Silently:     <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></li> </ul> </li> <li>Log in to Ark:     <pre><code>ark login --silent --isp-secret &lt;my-ark-secret&gt;\n</code></pre></li> <li>Get a short-lived SSO password for a database from the SIA service:     <pre><code>ark exec sia sso short-lived-password\n</code></pre></li> <li>One of these:<ul> <li>Log in directly to the database:     <pre><code>psql \"host=mytenant.postgres.cyberark.cloud user=user@cyberark.cloud.12345@postgres@mypostgres.fqdn.com\"\n</code></pre></li> <li>Log in to the database from Ark:     <pre><code>ark exec sia db psql --target-username postgres --target-address mypostgres.fqdn.com\n</code></pre></li> </ul> </li> </ol>"},{"location":"howto/enduser_kubernetes_workflow/","title":"End-user Kubernetes workflow","text":"<p>To securely access a Kubernetes cluster, do the following:</p> <ol> <li>If required, install the Ark SDK (<code>pip3 install ark-sdk-python</code>).</li> <li>Configure a profile:<ul> <li>Interactively:     <pre><code>ark configure\n</code></pre></li> <li>Silently:     <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></li> </ul> </li> <li>Log in to Ark:     <pre><code>ark login --silent --isp-secret &lt;my-ark-secret&gt;\n</code></pre></li> <li>To generate a kubectl kubeconfig file, which defines the user's permissions and accessible clusters, do one of the following:<ul> <li>Run this command:     <pre><code>ark exec sia k8s generate-kubeconfig\n</code></pre></li> <li>Use the <code>-f</code> flag to generate the config file in the specified path (this option overrides existing files with the same name):     <pre><code>ark exec sia k8s generate-kubeconfig -f ~/.kube\n</code></pre></li> </ul> </li> </ol>"},{"location":"howto/enduser_kubernetes_workflow/#refresh-sso-certificate-workflow","title":"Refresh SSO certificate workflow","text":"<p>When you refresh the certificate, you can keep using its associated kubeconfig file and only need to refresh the MFA authentication data. To refresh the certificate, run one of the following:</p> <ul> <li>To generate two files (certificate and private key files), where the required <code>-f</code> flag defines the generated files' location:     <pre><code>ark exec sia sso short-lived-client-certificate -of file -f ~/home\n</code></pre></li> <li>To print the certificate and private key to the console as plaintext:     <pre><code>ark exec sia sso short-lived-client-certificate -of raw\n</code></pre></li> <li>To print the certificate and private key to the console as base64-encoded strings:     <pre><code>ark ark exec sia sso short-lived-client-certificate -of base64\n</code></pre></li> </ul>"},{"location":"howto/refreshing_authentication/","title":"Refresh authentication","text":"<p>When you want to continue working with an existing authenticator, you can refresh the authentications. You can refresh authentications for the following:</p> <ul> <li>The login command</li> <li>The exec command</li> <li>Polling operations</li> <li>Via the SDK code</li> </ul>"},{"location":"howto/refreshing_authentication/#login-command","title":"Login command","text":"<p>To try to authenticate with an existing authenticator, use the <code>-ra</code>or <code>--refresh-auth</code> CLI flag: <pre><code>ark login -ra\n</code></pre> The <code>-ra</code> flag indicates that the user's profile authenticator should be refreshed and used for authentication. The user is only prompted for additional authentication values when the refresh fails.</p>"},{"location":"howto/refreshing_authentication/#exec-command","title":"Exec command","text":"<p>To try to run any command with an existing authenticator, use the <code>-ra</code>or -<code>-refresh-auth</code> CLI flag: <pre><code>ark exec -ra sia policies list-policies\n</code></pre></p> <p>The <code>-ra</code> flag indicates that the user's profile authenticator should be refreshed and used before executing the command. When the refresh fails, an error is returned and you must log in again.</p>"},{"location":"howto/refreshing_authentication/#polling-operations","title":"Polling operations","text":"<p>When polling any async command, a timeout can occur before the polling operation finishes. To try and overcome these timeouts, you can enable automatic authentication refreshes for polling operations.</p> <p>When refreshed are configured, if an unauthorized (<code>401</code>) response is returned, Ark refreshes the authenticator before the next poll. When the refresh fails, a timeout error is reported in the CLI. </p> <p>To enable refreshes, use the <code>-parc</code> or <code>--poll-allow-refresh-connection</code> CLI flag.</p>"},{"location":"howto/refreshing_authentication/#sdk","title":"SDK","text":"<p>When using the SDK, use the <code>load_authentication</code> method to attempt using a cached authenticator (with a refresh if required): <pre><code>isp_auth = ArkISPAuth()\nisp_auth.authenticate(\n    auth_profile=ArkAuthProfile(\n        username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n    ),\n    secret=ArkSecret(secret='CoolPassword'),\n)\n...\nisp_auth.load_authentication(refresh_auth=True)\n</code></pre></p>"},{"location":"howto/simple_commands_workflow/","title":"Simple commands workflow","text":"<p>Here's an example of how to:</p> <ol> <li>Configure a profile for logging in to a tenant</li> <li>Log in to the tenant</li> <li>Run a SIA action to configure a database secret and policy</li> </ol>"},{"location":"howto/simple_commands_workflow/#configure-profile-and-log-in","title":"Configure profile and log in","text":"<pre><code>ark configure --work-with-isp --isp-username=username\nark login -s --isp-secret=secret\n</code></pre>"},{"location":"howto/simple_commands_workflow/#configure-a-database-secret-and-policy","title":"Configure a database secret and policy","text":"<pre><code>ark exec sia secrets db add-secret -sn name -st username_password -u user -pa coolpassword\nark exec sia workspaces db add-database -n somedb -pe postgres-sh -rwe myendpoint.domain.com\nark exec sia policies db editor generate-policy\n</code></pre>"},{"location":"howto/simple_sdk_workflow/","title":"Simple SDK workflow","text":"<p>This example shows how to create, with a Python script, a demo environment that contains the required SIA DB assets:</p> <pre><code>ArkSystemConfig.disable_verbose_logging()\n# Authenticate to the tenant with an auth profile to configure SIA\nprint(f'Authenticating to the created tenant with user [{username}]')\nisp_auth = ArkISPAuth()\nisp_auth.authenticate(auth_profile=ArkAuthProfile(\n    username='user@cyberark.cloud.12345',\n    auth_method=ArkAuthMethod.Identity,\n    auth_method_settings=IdentityArkAuthMethodSettings()\n), secret=ArkSecret(secret='CoolPassword'))\n\n# Create SIA DB secret, database, connector, and DB policy\nsia_service = ArkSIAAPI(isp_auth)\nprint('Adding SIA DB User Secret')\nsecret = sia_service.secrets_db.add_secret(ArkSIADBAddSecret(\n    secret_type=ArkSIADBSecretType.UsernamePassword,\n    username='Administrator',\n    password='CoolPassword'\n))\nprint('Adding SIA Database')\nsia_service.workspace_db.add_database(ArkSIADBAddDatabase(\n    name='mydomain.com',\n    provider_engine=ArkSIADBDatabaseEngineType.PosgresSH,\n    secret_id=secret.secret_id,\n    read_write_endpoint=\"myendpoint.mydomain.com\"\n))\nprint('Adding SIA DB Policy')\nsia_service.policies_db.add_policy(\n    ArkSIADBAddPolicy(\n        policy_name='IT Policy',\n        status=ArkSIARuleStatus.Enabled,\n        description='IT Policy',\n        providers_data=ArkSIADBProvidersData(\n            postgres=ArkSIADBPostgres(\n                resources=['postgres-onboarded-asset'],\n            ),\n        ),\n        user_access_rules=[\n            ArkSIADBAuthorizationRule(\n                rule_name='IT Rule',\n                user_data=ArkSIAUserData(roles=['DpaAdmin'], groups=[], users=[]),\n                connection_information=ArkSIADBConnectionInformation(\n                    grant_access=2,\n                    idle_time=10,\n                    full_days=True,\n                    hours_from='07:00',\n                    hours_to='17:00',\n                    time_zone='Asia/Jerusalem',\n                    connect_as=ArkSIADBConnectAs(\n                        db_auth=[\n                            ArkSIADBLocalDBAuth(\n                                roles=['rds_superuser'],\n                                applied_to=[\n                                    ArkSIADBAppliedTo(\n                                        name='postgres-onboarded-asset',\n                                        type=ArkSIADBResourceIdentifierType.RESOURCE,\n                                    )\n                                ],\n                            ),\n                        ],\n                    ),\n                ),\n            )\n        ],\n    )\n)\nprint('Finished Successfully')\n</code></pre> <p>In the script above, the following actions are defined:</p> <ul> <li>The admin user is logged in to perform actions on the tenant (lines 4-9)</li> <li>The SIA's secret, database, and policy are configured (lines 12-65)</li> </ul>"},{"location":"howto/working_with_ark_cache/","title":"Work with Ark cache","text":"<p>Both the CLI and SDK cache login information in the local machine's keystore or, when a keystore does not exist, in an encrypted folder (located in <code>$HOME/.ark_cache</code>). The cached information is used to run commands until the authentication tokens expire or are otherwise invalided.</p> <p>You can set the cache folder with the <code>ARK_KEYRING_FOLDER</code> env variable. To force Ark SDK to work only with the filesystem cache, use the <code>ARK_BASIC_KEYRING</code> environment variable</p> <p>If you want to ignore the cache when logging in, use the <code>-f</code> flag: <pre><code>ark login -f\n</code></pre></p> <p>Also, you can disable caching in the SDK: <pre><code>isp_auth = ArkISPAuth(cache_authentication=False)\n</code></pre></p> <p>To clear the cache, run <code>ark cache clear</code> or, when using an encrypted folder, remove the files from the <code>$HOME/.ark_cache</code> folder.</p>"},{"location":"howto/working_with_profiles/","title":"Work with profiles","text":"<p>Profiles define authentication methods for users. They are used with the CLI and, to a lesser extent, the SDK. Different profiles can be created and configured via the Ark <code>configure</code> command.</p> <p>You can specify which profile a command uses with the <code>--profile-name</code> flag or setting the <code>ARK_PROFILE</code> environment variable.</p> <p>Profiles are stored as JSON files in the <code>$HOME/.ark_profiles</code> folder.</p> <p>Note</p> <p>When There are multiple profiles configured, if profile is not specified explicitly in the command via --profile-name or ARK_PROFILE environment variable not set, the default profile called \"ark\" will be used.</p> <p>Here is an example profile file:</p> <pre><code>{\n    \"profile_name\": \"ark\",\n    \"profile_description\": \"Default Ark Profile\",\n    \"auth_profiles\": {\n        \"isp\": {\n            \"username\": \"tina@cyberark.cloud.1234567\",\n            \"auth_method\": \"identity\",\n            \"auth_method_settings\": {\n                \"identity_mfa_method\": \"email\",\n                \"identity_mfa_interactive\": true,\n                \"identity_application\": null,\n                \"identity_url\": null\n            }\n        }\n    }\n}\n</code></pre> <p>As well as using the CLI to manage profiles, you can create, modify, and delete profiles directly in the <code>$HOME/.ark_profiles</code> folder.</p>"},{"location":"reference/","title":".","text":""},{"location":"reference/#ark_sdk_python.ArkAPI","title":"<code>ArkAPI</code>","text":"Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>class ArkAPI:\n    def __init__(self, authenticators: List[ArkAuth], profile: Optional[ArkProfile] = None) -&gt; None:\n        self.__authenticators = authenticators\n        self.__lazy_loaded_services: Dict[str, ArkService] = {}\n        self.__profile = profile or ArkProfileLoader.load_default_profile()\n\n    def __lazy_load_service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        service_name = service_type.service_config().service_name\n        required_auth_names = service_type.service_config().required_authenticator_names\n        required_autheneticators = [auth for auth in self.__authenticators if auth.authenticator_name() in required_auth_names]\n        optional_authenticators = [\n            auth\n            for auth in self.__authenticators\n            if auth.authenticator_name() in service_type.service_config().optional_authenticator_names\n        ]\n        if len(required_autheneticators) == len(required_auth_names):\n            authenticators = {f'{a.authenticator_name()}_auth': a for a in required_autheneticators + optional_authenticators}\n            self.__lazy_loaded_services[service_name] = service_type(**authenticators)\n        else:\n            raise ArkServiceException(\n                f'{service_name.title()} is not supported or missing fitting authenticators, please make sure you are logged in'\n            )\n        return self.__lazy_loaded_services[service_name]\n\n    def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Returns the specified authenticator.\n\n        Args:\n            authenticator_name (str): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.__authenticators:\n            if auth.authenticator_name() == authenticator_name:\n                return auth\n        raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n\n    def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        \"\"\"\n        Returns the specified service when the appropriate authenticators were provided.\n\n        Args:\n            service_type (Type[ArkService]): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkService: _description_\n        \"\"\"\n        if not issubclass(service_type, ArkService):\n            raise ArkServiceException(f\"Type {service_type} is invalid\")\n        service_name = service_type.service_config().service_name\n        if service_name in self.__lazy_loaded_services:\n            return self.__lazy_loaded_services[service_name]\n        return self.__lazy_load_service(service_type)\n\n    @property\n    def profile(self) -&gt; ArkProfile:\n        \"\"\"\n        Gets the API profile\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        return self.__profile\n\n    @property\n    def identity_connectors(self) -&gt; \"ArkIdentityConnectorsService\":\n        \"\"\"\n        Returns the Identity Connectors Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityConnectorsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.connectors import ArkIdentityConnectorsService\n\n        return cast(ArkIdentityConnectorsService, self.service(ArkIdentityConnectorsService))\n\n    @property\n    def identity_directories(self) -&gt; \"ArkIdentityDirectoriesService\":\n        \"\"\"\n        Returns the Identity Directories Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityDirectoriesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.directories import ArkIdentityDirectoriesService\n\n        return cast(ArkIdentityDirectoriesService, self.service(ArkIdentityDirectoriesService))\n\n    @property\n    def identity_policies(self) -&gt; \"ArkIdentityPoliciesService\":\n        \"\"\"\n        Returns the Identity Policies Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.policies import ArkIdentityPoliciesService\n\n        return cast(ArkIdentityPoliciesService, self.service(ArkIdentityPoliciesService))\n\n    @property\n    def identity_roles(self) -&gt; \"ArkIdentityRolesService\":\n        \"\"\"\n        Returns the Identity Roles Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityRolesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.roles import ArkIdentityRolesService\n\n        return cast(ArkIdentityRolesService, self.service(ArkIdentityRolesService))\n\n    @property\n    def identity_users(self) -&gt; \"ArkIdentityUsersService\":\n        \"\"\"\n        Returns the Identity Users Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityUsersService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.users import ArkIdentityUsersService\n\n        return cast(ArkIdentityUsersService, self.service(ArkIdentityUsersService))\n\n    @property\n    def sia_access(self) -&gt; \"ArkSIAAccessService\":\n        \"\"\"\n        Returns the SIA Access service if the appropriate authenticators were given\n\n        Returns:\n            ArkSIAAccessService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.access import ArkSIAAccessService\n\n        return cast(ArkSIAAccessService, self.service(ArkSIAAccessService))\n\n    @property\n    def sia_workspaces_db(self) -&gt; \"ArkSIADBWorkspaceService\":\n        \"\"\"\n        Returns the SIA DB Workspace service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.workspaces.db import ArkSIADBWorkspaceService\n\n        return cast(ArkSIADBWorkspaceService, self.service(ArkSIADBWorkspaceService))\n\n    @property\n    def sia_workspaces_target_sets(self) -&gt; \"ArkSIATargetSetsWorkspaceService\":\n        \"\"\"\n        Returns the SIA Target Sets Workspace service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIATargetSetsWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.workspaces.targetsets import ArkSIATargetSetsWorkspaceService\n\n        return cast(ArkSIATargetSetsWorkspaceService, self.service(ArkSIATargetSetsWorkspaceService))\n\n    @property\n    def sia_policies_vm(self) -&gt; \"ArkSIAVMPoliciesService\":\n        \"\"\"\n        Returns the SIA VM Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIAVMPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.policies.vm import ArkSIAVMPoliciesService\n\n        return cast(ArkSIAVMPoliciesService, self.service(ArkSIAVMPoliciesService))\n\n    @property\n    def sia_policies_db(self) -&gt; \"ArkSIADBPoliciesService\":\n        \"\"\"\n        Returns the SIA DB Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.policies.db import ArkSIADBPoliciesService\n\n        return cast(ArkSIADBPoliciesService, self.service(ArkSIADBPoliciesService))\n\n    @property\n    def sia_secrets_db(self) -&gt; \"ArkSIADBSecretsService\":\n        \"\"\"\n        Returns the SIA DB Secrets service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.secrets.db import ArkSIADBSecretsService\n\n        return cast(ArkSIADBSecretsService, self.service(ArkSIADBSecretsService))\n\n    @property\n    def sia_secrets_vm(self) -&gt; \"ArkSIAVMSecretsService\":\n        \"\"\"\n        Returns the SIA VM Secrets service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIAVMSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.secrets.vm import ArkSIAVMSecretsService\n\n        return cast(ArkSIAVMSecretsService, self.service(ArkSIAVMSecretsService))\n\n    @property\n    def sia_sso(self) -&gt; \"ArkSIASSOService\":\n        \"\"\"\n        Returns the SIA sso service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIASSOService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.sso import ArkSIASSOService\n\n        return cast(ArkSIASSOService, self.service(ArkSIASSOService))\n\n    @property\n    def sia_db(self) -&gt; \"ArkSIADBService\":\n        \"\"\"\n        Returns the SIA DB service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.db import ArkSIADBService\n\n        return cast(ArkSIADBService, self.service(ArkSIADBService))\n\n    @property\n    def sia_certificates(self) -&gt; \"ArkSIACertificatesService\":\n        \"\"\"\n        Returns SIA certificates service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIACertificatesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.certificates import ArkSIACertificatesService\n\n        return cast(ArkSIACertificatesService, self.service(ArkSIACertificatesService))\n\n    @property\n    def sia_k8s(self) -&gt; \"ArkSIAK8SService\":\n        \"\"\"\n        Returns the SIA Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIAK8SService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.k8s import ArkSIAK8SService\n\n        return cast(ArkSIAK8SService, self.service(ArkSIAK8SService))\n\n    @property\n    def sm(self) -&gt; \"ArkSMService\":\n        \"\"\"\n        Returns the SM service if the appropriate authenticators were given\n\n        Returns:\n            ArkSMService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sm import ArkSMService\n\n        return cast(ArkSMService, self.service(ArkSMService))\n\n    @property\n    def pcloud_accounts(self) -&gt; \"ArkPCloudAccountsService\":\n        \"\"\"\n        Returns the PCloud Accounts service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudAccountsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.accounts import ArkPCloudAccountsService\n\n        return cast(ArkPCloudAccountsService, self.service(ArkPCloudAccountsService))\n\n    @property\n    def pcloud_safes(self) -&gt; \"ArkPCloudSafesService\":\n        \"\"\"\n        Returns the PCloud Safes service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudSafesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.safes import ArkPCloudSafesService\n\n        return cast(ArkPCloudSafesService, self.service(ArkPCloudSafesService))\n\n    @property\n    def pcloud_platforms(self) -&gt; \"ArkPCloudPlatformsService\":\n        \"\"\"\n        Returns the PCloud Platforms service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudPlatformsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.platforms import ArkPCloudPlatformsService\n\n        return cast(ArkPCloudPlatformsService, self.service(ArkPCloudPlatformsService))\n\n    @property\n    def pcloud_applications(self) -&gt; \"ArkPCloudApplicationsService\":\n        \"\"\"\n        Returns the PCloud Applications service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudApplicationsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.applications import ArkPCloudApplicationsService\n\n        return cast(ArkPCloudApplicationsService, self.service(ArkPCloudApplicationsService))\n\n    @property\n    def cmgr(self) -&gt; \"ArkCmgrService\":\n        \"\"\"\n        Returns the Connector Management service if the appropriate authenticators were given\n\n        Returns:\n            ArkCmgrService: _description_\n        \"\"\"\n        from ark_sdk_python.services.cmgr import ArkCmgrService\n\n        return cast(ArkCmgrService, self.service(ArkCmgrService))\n</code></pre>"},{"location":"reference/#ark_sdk_python.ArkAPI.cmgr","title":"<code>cmgr</code>  <code>property</code>","text":"<p>Returns the Connector Management service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkCmgrService</code> <code>'ArkCmgrService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.identity_connectors","title":"<code>identity_connectors</code>  <code>property</code>","text":"<p>Returns the Identity Connectors Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityConnectorsService</code> <code>'ArkIdentityConnectorsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.identity_directories","title":"<code>identity_directories</code>  <code>property</code>","text":"<p>Returns the Identity Directories Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityDirectoriesService</code> <code>'ArkIdentityDirectoriesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.identity_policies","title":"<code>identity_policies</code>  <code>property</code>","text":"<p>Returns the Identity Policies Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityPoliciesService</code> <code>'ArkIdentityPoliciesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.identity_roles","title":"<code>identity_roles</code>  <code>property</code>","text":"<p>Returns the Identity Roles Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityRolesService</code> <code>'ArkIdentityRolesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.identity_users","title":"<code>identity_users</code>  <code>property</code>","text":"<p>Returns the Identity Users Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUsersService</code> <code>'ArkIdentityUsersService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.pcloud_accounts","title":"<code>pcloud_accounts</code>  <code>property</code>","text":"<p>Returns the PCloud Accounts service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountsService</code> <code>'ArkPCloudAccountsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.pcloud_applications","title":"<code>pcloud_applications</code>  <code>property</code>","text":"<p>Returns the PCloud Applications service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudApplicationsService</code> <code>'ArkPCloudApplicationsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.pcloud_platforms","title":"<code>pcloud_platforms</code>  <code>property</code>","text":"<p>Returns the PCloud Platforms service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatformsService</code> <code>'ArkPCloudPlatformsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.pcloud_safes","title":"<code>pcloud_safes</code>  <code>property</code>","text":"<p>Returns the PCloud Safes service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafesService</code> <code>'ArkPCloudSafesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.profile","title":"<code>profile</code>  <code>property</code>","text":"<p>Gets the API profile</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_access","title":"<code>sia_access</code>  <code>property</code>","text":"<p>Returns the SIA Access service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkSIAAccessService</code> <code>'ArkSIAAccessService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_certificates","title":"<code>sia_certificates</code>  <code>property</code>","text":"<p>Returns SIA certificates service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificatesService</code> <code>'ArkSIACertificatesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_db","title":"<code>sia_db</code>  <code>property</code>","text":"<p>Returns the SIA DB service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBService</code> <code>'ArkSIADBService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_k8s","title":"<code>sia_k8s</code>  <code>property</code>","text":"<p>Returns the SIA Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIAK8SService</code> <code>'ArkSIAK8SService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_policies_db","title":"<code>sia_policies_db</code>  <code>property</code>","text":"<p>Returns the SIA DB Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesService</code> <code>'ArkSIADBPoliciesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_policies_vm","title":"<code>sia_policies_vm</code>  <code>property</code>","text":"<p>Returns the SIA VM Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesService</code> <code>'ArkSIAVMPoliciesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_secrets_db","title":"<code>sia_secrets_db</code>  <code>property</code>","text":"<p>Returns the SIA DB Secrets service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretsService</code> <code>'ArkSIADBSecretsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_secrets_vm","title":"<code>sia_secrets_vm</code>  <code>property</code>","text":"<p>Returns the SIA VM Secrets service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecretsService</code> <code>'ArkSIAVMSecretsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_sso","title":"<code>sia_sso</code>  <code>property</code>","text":"<p>Returns the SIA sso service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOService</code> <code>'ArkSIASSOService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_workspaces_db","title":"<code>sia_workspaces_db</code>  <code>property</code>","text":"<p>Returns the SIA DB Workspace service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBWorkspaceService</code> <code>'ArkSIADBWorkspaceService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sia_workspaces_target_sets","title":"<code>sia_workspaces_target_sets</code>  <code>property</code>","text":"<p>Returns the SIA Target Sets Workspace service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSetsWorkspaceService</code> <code>'ArkSIATargetSetsWorkspaceService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sm","title":"<code>sm</code>  <code>property</code>","text":"<p>Returns the SM service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkSMService</code> <code>'ArkSMService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.authenticator","title":"<code>authenticator(authenticator_name)</code>","text":"<p>Returns the specified authenticator.</p> <p>Parameters:</p> Name Type Description Default <code>authenticator_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Returns the specified authenticator.\n\n    Args:\n        authenticator_name (str): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.__authenticators:\n        if auth.authenticator_name() == authenticator_name:\n            return auth\n    raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n</code></pre>"},{"location":"reference/#ark_sdk_python.ArkAPI.service","title":"<code>service(service_type)</code>","text":"<p>Returns the specified service when the appropriate authenticators were provided.</p> <p>Parameters:</p> Name Type Description Default <code>service_type</code> <code>Type[ArkService]</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkService</code> <code>ArkService</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n    \"\"\"\n    Returns the specified service when the appropriate authenticators were provided.\n\n    Args:\n        service_type (Type[ArkService]): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkService: _description_\n    \"\"\"\n    if not issubclass(service_type, ArkService):\n        raise ArkServiceException(f\"Type {service_type} is invalid\")\n    service_name = service_type.service_config().service_name\n    if service_name in self.__lazy_loaded_services:\n        return self.__lazy_loaded_services[service_name]\n    return self.__lazy_load_service(service_type)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>.</li> <li>actions<ul> <li>ark_action</li> <li>ark_cache_action</li> <li>ark_configure_action</li> <li>ark_exec_action</li> <li>ark_login_action</li> <li>ark_profiles_action</li> <li>ark_service_exec_action</li> </ul> </li> <li>args<ul> <li>ark_args_formatter</li> <li>ark_pydantic_argparse</li> </ul> </li> <li>ark</li> <li>ark_api</li> <li>auth<ul> <li>ark_auth</li> <li>ark_isp_auth</li> <li>identity<ul> <li>ark_identity</li> <li>ark_identity_fqdn_resolver</li> <li>ark_identity_service_user</li> </ul> </li> </ul> </li> <li>cli_services<ul> <li>ark_cli_api</li> <li>sia<ul> <li>common<ul> <li>ark_sia_base_policies_editor_service</li> </ul> </li> <li>db<ul> <li>ark_sia_db_policies_editor_service</li> </ul> </li> <li>vm<ul> <li>ark_sia_vm_policies_editor_service</li> </ul> </li> </ul> </li> </ul> </li> <li>common<ul> <li>ark_async_client</li> <li>ark_async_request</li> <li>ark_client</li> <li>ark_jwt_utils</li> <li>ark_keyring</li> <li>ark_logger</li> <li>ark_page</li> <li>ark_pollers</li> <li>ark_random_utils</li> <li>ark_retry</li> <li>ark_system_config</li> <li>connections<ul> <li>ark_connection</li> <li>ssh<ul> <li>ark_ssh_connection</li> </ul> </li> <li>winrm<ul> <li>ark_winrm_connection</li> </ul> </li> </ul> </li> <li>env<ul> <li>ark_env_mapping</li> </ul> </li> <li>isp<ul> <li>ark_isp_service_client</li> </ul> </li> </ul> </li> <li>models<ul> <li>actions<ul> <li>ark_configure_action_consts</li> <li>ark_service_action_definition</li> <li>services<ul> <li>ark_cmgr_exec_action_consts</li> <li>ark_identity_exec_action_consts</li> <li>ark_pcloud_exec_action_consts</li> <li>ark_sia_exec_action_consts</li> <li>ark_sm_exec_action_consts</li> </ul> </li> </ul> </li> <li>ark_exceptions</li> <li>ark_model</li> <li>ark_profile</li> <li>auth<ul> <li>ark_auth_method</li> <li>ark_auth_profile</li> <li>ark_secret</li> <li>ark_token</li> </ul> </li> <li>cli_services<ul> <li>sia<ul> <li>policies_editor<ul> <li>common<ul> <li>ark_sia_base_generate_policy</li> <li>ark_sia_commit_policies</li> <li>ark_sia_edit_policies</li> <li>ark_sia_get_policies_status</li> <li>ark_sia_load_policies</li> <li>ark_sia_loaded_policies</li> <li>ark_sia_policies_diff</li> <li>ark_sia_policies_status</li> <li>ark_sia_remove_policies</li> <li>ark_sia_reset_policies</li> <li>ark_sia_view_policies</li> </ul> </li> <li>db<ul> <li>ark_sia_db_generate_policy</li> </ul> </li> <li>vm<ul> <li>ark_sia_vm_generate_policy</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>common<ul> <li>ark_access_method</li> <li>ark_application_code</li> <li>ark_async_request_settings</li> <li>ark_async_status</li> <li>ark_async_task</li> <li>ark_connection_method</li> <li>ark_connector_type</li> <li>ark_counted_values</li> <li>ark_network_entity_type</li> <li>ark_os_type</li> <li>ark_protocol_type</li> <li>ark_region</li> <li>ark_status</li> <li>ark_status_stats</li> <li>ark_validations</li> <li>ark_workspace_type</li> <li>aws<ul> <li>ark_cfn_async_task</li> </ul> </li> <li>connections<ul> <li>ark_connection_command</li> <li>ark_connection_credentials</li> <li>ark_connection_details</li> <li>ark_connection_result</li> <li>connection_data<ul> <li>ark_ssh_connection_data</li> <li>ark_winrm_connection_data</li> </ul> </li> </ul> </li> <li>identity<ul> <li>ark_identity_auth_schemas</li> <li>ark_identity_common_schemas</li> <li>ark_identity_directory_schemas</li> </ul> </li> <li>isp<ul> <li>ark_platform_discovery_schemas</li> </ul> </li> </ul> </li> <li>services<ul> <li>ark_service_config</li> <li>cmgr<ul> <li>ark_cmgr_add_network</li> <li>ark_cmgr_add_pool</li> <li>ark_cmgr_add_pool_identifiers</li> <li>ark_cmgr_bulk_response</li> <li>ark_cmgr_delete_network</li> <li>ark_cmgr_delete_pool</li> <li>ark_cmgr_delete_pool_identifiers</li> <li>ark_cmgr_get_network</li> <li>ark_cmgr_get_pool</li> <li>ark_cmgr_get_pool_component</li> <li>ark_cmgr_list_pool_identifiers</li> <li>ark_cmgr_network</li> <li>ark_cmgr_networks_filter</li> <li>ark_cmgr_networks_stats</li> <li>ark_cmgr_pool</li> <li>ark_cmgr_pool_component</li> <li>ark_cmgr_pool_components_filter</li> <li>ark_cmgr_pool_identifiers</li> <li>ark_cmgr_pool_identifiers_filter</li> <li>ark_cmgr_pools_common_filter</li> <li>ark_cmgr_pools_filter</li> <li>ark_cmgr_pools_stats</li> <li>ark_cmgr_update_network</li> <li>ark_cmgr_update_pool</li> </ul> </li> <li>identity<ul> <li>connectors<ul> <li>ark_identity_connector_info</li> <li>ark_identity_connectors_filter</li> <li>ark_identity_get_connector</li> </ul> </li> <li>directories<ul> <li>ark_identity_directory</li> <li>ark_identity_entity</li> <li>ark_identity_list_directories</li> <li>ark_identity_list_directories_entities</li> </ul> </li> <li>policies<ul> <li>ark_identity_add_authentication_profile</li> <li>ark_identity_add_policy</li> <li>ark_identity_authentication_profile</li> <li>ark_identity_disable_policy</li> <li>ark_identity_enable_policy</li> <li>ark_identity_get_authentication_profile</li> <li>ark_identity_get_policy</li> <li>ark_identity_policy</li> <li>ark_identity_policy_info</li> <li>ark_identity_policy_operation</li> <li>ark_identity_policy_operation_type</li> <li>ark_identity_remove_authentication_profile</li> <li>ark_identity_remove_policy</li> </ul> </li> <li>roles<ul> <li>ark_identity_add_admin_right_to_role</li> <li>ark_identity_add_group_to_role</li> <li>ark_identity_add_role_to_role</li> <li>ark_identity_add_user_to_role</li> <li>ark_identity_admin_right</li> <li>ark_identity_create_role</li> <li>ark_identity_delete_role</li> <li>ark_identity_list_role_members</li> <li>ark_identity_remove_group_from_role</li> <li>ark_identity_remove_role_from_role</li> <li>ark_identity_remove_user_from_role</li> <li>ark_identity_role</li> <li>ark_identity_role_id_by_name</li> <li>ark_identity_role_member</li> <li>ark_identity_update_role</li> </ul> </li> <li>users<ul> <li>ark_identity_create_user</li> <li>ark_identity_delete_user</li> <li>ark_identity_delete_users</li> <li>ark_identity_reset_user_password</li> <li>ark_identity_update_user</li> <li>ark_identity_user</li> <li>ark_identity_user_by_id</li> <li>ark_identity_user_by_name</li> <li>ark_identity_user_id_by_name</li> <li>ark_identity_user_info</li> </ul> </li> </ul> </li> <li>pcloud<ul> <li>accounts<ul> <li>ark_pcloud_account</li> <li>ark_pcloud_account_credentials</li> <li>ark_pcloud_account_secret_version</li> <li>ark_pcloud_accounts_filter</li> <li>ark_pcloud_accounts_stats</li> <li>ark_pcloud_add_account</li> <li>ark_pcloud_change_account_credentials</li> <li>ark_pcloud_delete_account</li> <li>ark_pcloud_generate_account_credentials</li> <li>ark_pcloud_get_account</li> <li>ark_pcloud_get_account_credentials</li> <li>ark_pcloud_link_account</li> <li>ark_pcloud_list_account_secret_versions</li> <li>ark_pcloud_reconcile_account_credentials</li> <li>ark_pcloud_set_account_next_credentials</li> <li>ark_pcloud_unlink_account</li> <li>ark_pcloud_update_account</li> <li>ark_pcloud_update_account_credentials_in_vault</li> <li>ark_pcloud_verify_account_credentias</li> </ul> </li> <li>applications<ul> <li>ark_pcloud_add_application</li> <li>ark_pcloud_add_application_auth_method</li> <li>ark_pcloud_application</li> <li>ark_pcloud_application_auth_method</li> <li>ark_pcloud_application_auth_methods_filter</li> <li>ark_pcloud_applications_filter</li> <li>ark_pcloud_applications_stats</li> <li>ark_pcloud_delete_application</li> <li>ark_pcloud_delete_application_auth_method</li> <li>ark_pcloud_get_application</li> <li>ark_pcloud_get_application_auth_method</li> <li>ark_pcloud_list_application_auth_methods</li> </ul> </li> <li>platforms<ul> <li>ark_pcloud_activate_target_platform</li> <li>ark_pcloud_deactivate_target_platform</li> <li>ark_pcloud_delete_target_platform</li> <li>ark_pcloud_duplicate_target_platform</li> <li>ark_pcloud_duplicated_target_platform_info</li> <li>ark_pcloud_export_platform</li> <li>ark_pcloud_export_target_platform</li> <li>ark_pcloud_get_platform</li> <li>ark_pcloud_get_target_platform</li> <li>ark_pcloud_import_platform</li> <li>ark_pcloud_import_target_platform</li> <li>ark_pcloud_platform</li> <li>ark_pcloud_platforms_filter</li> <li>ark_pcloud_platforms_stats</li> <li>ark_pcloud_target_platform</li> <li>ark_pcloud_target_platforms_filter</li> <li>ark_pcloud_target_platforms_stats</li> </ul> </li> <li>safes<ul> <li>ark_pcloud_add_safe</li> <li>ark_pcloud_add_safe_member</li> <li>ark_pcloud_delete_safe</li> <li>ark_pcloud_delete_safe_member</li> <li>ark_pcloud_get_safe</li> <li>ark_pcloud_get_safe_member</li> <li>ark_pcloud_get_safe_members_stats</li> <li>ark_pcloud_list_safe_members</li> <li>ark_pcloud_safe</li> <li>ark_pcloud_safe_member</li> <li>ark_pcloud_safe_members_filter</li> <li>ark_pcloud_safes_filters</li> <li>ark_pcloud_safes_members_stats</li> <li>ark_pcloud_safes_stats</li> <li>ark_pcloud_update_safe</li> <li>ark_pcloud_update_safe_member</li> </ul> </li> </ul> </li> <li>sia<ul> <li>access<ul> <li>ark_sia_access_workspace_type_serializer</li> <li>ark_sia_connector_setup_script</li> <li>ark_sia_get_connector_setup_script</li> <li>ark_sia_install_connector</li> <li>ark_sia_uninstall_connector</li> </ul> </li> <li>certificates<ul> <li>ark_sia_certificates_certificate</li> <li>ark_sia_certificates_delete_certificate</li> <li>ark_sia_certificates_filter</li> <li>ark_sia_certificates_get_certificate</li> <li>ark_sia_certificates_update_certificate</li> </ul> </li> <li>db<ul> <li>ark_sia_db_assets_type</li> <li>ark_sia_db_base_execution</li> <li>ark_sia_db_base_generate_assets</li> <li>ark_sia_db_generated_assets</li> <li>ark_sia_db_mysql_execution</li> <li>ark_sia_db_oracle_generate_assets</li> <li>ark_sia_db_proxy_fullchain_generate_assets</li> <li>ark_sia_db_psql_execution</li> </ul> </li> <li>k8s<ul> <li>ark_sia_k8s_generate_kubeconfig</li> </ul> </li> <li>policies<ul> <li>common<ul> <li>ark_sia_base_add_policy</li> <li>ark_sia_base_authorization_rule</li> <li>ark_sia_base_authorization_rule_extended</li> <li>ark_sia_base_connection_information</li> <li>ark_sia_base_policies_filter</li> <li>ark_sia_base_policies_stats</li> <li>ark_sia_base_policy</li> <li>ark_sia_base_policy_list_item</li> <li>ark_sia_base_policy_list_item_extanded</li> <li>ark_sia_base_update_policy</li> <li>ark_sia_delete_policy</li> <li>ark_sia_get_policy</li> <li>ark_sia_rule_status</li> <li>ark_sia_update_policy_status</li> <li>ark_sia_user_data</li> </ul> </li> <li>db<ul> <li>ark_sia_db_add_policy</li> <li>ark_sia_db_authorization_rule</li> <li>ark_sia_db_connection_data</li> <li>ark_sia_db_enums</li> <li>ark_sia_db_policies_filter</li> <li>ark_sia_db_policies_stats</li> <li>ark_sia_db_policies_workspace_type_serializer</li> <li>ark_sia_db_policy</li> <li>ark_sia_db_policy_list_item</li> <li>ark_sia_db_providers</li> <li>ark_sia_db_update_policy</li> </ul> </li> <li>vm<ul> <li>ark_sia_vm_add_policy</li> <li>ark_sia_vm_authorization_rule</li> <li>ark_sia_vm_connection_data</li> <li>ark_sia_vm_policies_filter</li> <li>ark_sia_vm_policies_filter_by_query</li> <li>ark_sia_vm_policies_protocol_type_serializer</li> <li>ark_sia_vm_policies_stats</li> <li>ark_sia_vm_policies_workspace_type_serializer</li> <li>ark_sia_vm_policy</li> <li>ark_sia_vm_policy_list_item</li> <li>ark_sia_vm_providers</li> <li>ark_sia_vm_update_policy</li> </ul> </li> </ul> </li> <li>secrets<ul> <li>db<ul> <li>ark_sia_db_add_secret</li> <li>ark_sia_db_delete_secret</li> <li>ark_sia_db_disable_secret</li> <li>ark_sia_db_enable_secret</li> <li>ark_sia_db_get_secret</li> <li>ark_sia_db_secret_metadata</li> <li>ark_sia_db_secret_type</li> <li>ark_sia_db_secrets_filter</li> <li>ark_sia_db_secrets_stats</li> <li>ark_sia_db_store_descriptor</li> <li>ark_sia_db_store_type</li> <li>ark_sia_db_update_secret</li> <li>secret_links<ul> <li>ark_sia_db_pam_account_secret_link</li> </ul> </li> <li>secrets_data<ul> <li>ark_sia_db_atlas_access_keys_secret_data</li> <li>ark_sia_db_iam_user_secret_data</li> <li>ark_sia_db_user_password_secret_data</li> </ul> </li> </ul> </li> <li>vm<ul> <li>ark_sia_vm_add_secret</li> <li>ark_sia_vm_change_secret</li> <li>ark_sia_vm_delete_secret</li> <li>ark_sia_vm_get_secret</li> <li>ark_sia_vm_secret</li> <li>ark_sia_vm_secret_error</li> <li>ark_sia_vm_secret_info</li> <li>ark_sia_vm_secret_type</li> <li>ark_sia_vm_secrets_filter</li> <li>ark_sia_vm_secrets_stats</li> </ul> </li> </ul> </li> <li>sso<ul> <li>ark_sia_sso_acquire_token_response</li> <li>ark_sia_sso_get_short_lived_client_certificate</li> <li>ark_sia_sso_get_short_lived_oracle_wallet</li> <li>ark_sia_sso_get_short_lived_password</li> <li>ark_sia_sso_get_short_lived_rdp_file</li> <li>ark_sia_sso_get_ssh_key</li> <li>ark_sia_sso_get_token_info</li> <li>ark_sia_sso_token_info</li> <li>ark_sia_sso_token_type</li> </ul> </li> <li>workspaces<ul> <li>db<ul> <li>ark_sia_db_add_database</li> <li>ark_sia_db_auth_method</li> <li>ark_sia_db_database</li> <li>ark_sia_db_database_info</li> <li>ark_sia_db_database_target_service</li> <li>ark_sia_db_databases_filter</li> <li>ark_sia_db_databases_stats</li> <li>ark_sia_db_delete_database</li> <li>ark_sia_db_get_database</li> <li>ark_sia_db_platform_type_serializer</li> <li>ark_sia_db_provider</li> <li>ark_sia_db_tag</li> <li>ark_sia_db_update_database</li> <li>ark_sia_db_warning</li> </ul> </li> <li>targetsets<ul> <li>ark_sia_add_target_set</li> <li>ark_sia_bulk_add_target_sets</li> <li>ark_sia_bulk_delete_target_sets</li> <li>ark_sia_bulk_target_set_response</li> <li>ark_sia_delete_target_set</li> <li>ark_sia_get_target_set</li> <li>ark_sia_target_set</li> <li>ark_sia_target_set_type</li> <li>ark_sia_target_sets_filter</li> <li>ark_sia_target_sets_stats</li> <li>ark_sia_update_target_set</li> </ul> </li> </ul> </li> </ul> </li> <li>sm<ul> <li>ark_sm_get_session</li> <li>ark_sm_get_session_activities</li> <li>ark_sm_protocol_type_serializer</li> <li>ark_sm_session</li> <li>ark_sm_session_activity</li> <li>ark_sm_session_activity_filter</li> <li>ark_sm_sessions_filter</li> <li>ark_sm_sessions_stats</li> <li>ark_sm_workspace_type_serializer</li> </ul> </li> </ul> </li> </ul> </li> <li>services<ul> <li>ark_service</li> <li>cmgr<ul> <li>ark_cmgr_service</li> </ul> </li> <li>identity<ul> <li>ark_identity_api</li> <li>common<ul> <li>ark_identity_base_service</li> </ul> </li> <li>connectors<ul> <li>ark_identity_connectors_service</li> </ul> </li> <li>directories<ul> <li>ark_identity_directories_service</li> </ul> </li> <li>policies<ul> <li>ark_identity_policies_service</li> </ul> </li> <li>roles<ul> <li>ark_identity_roles_service</li> </ul> </li> <li>users<ul> <li>ark_identity_users_service</li> </ul> </li> </ul> </li> <li>pcloud<ul> <li>accounts<ul> <li>ark_pcloud_accounts_service</li> </ul> </li> <li>applications<ul> <li>ark_pcloud_applications_service</li> </ul> </li> <li>ark_pcloud_api</li> <li>common<ul> <li>ark_pcloud_base_service</li> </ul> </li> <li>platforms<ul> <li>ark_pcloud_platforms_service</li> </ul> </li> <li>safes<ul> <li>ark_pcloud_safes_service</li> </ul> </li> </ul> </li> <li>sia<ul> <li>access<ul> <li>ark_sia_access_service</li> </ul> </li> <li>ark_sia_api</li> <li>certificates<ul> <li>ark_sia_certificates_service</li> </ul> </li> <li>db<ul> <li>ark_sia_db_service</li> </ul> </li> <li>k8s<ul> <li>ark_sia_k8s_service</li> </ul> </li> <li>policies<ul> <li>db<ul> <li>ark_sia_db_policies_service</li> </ul> </li> <li>vm<ul> <li>ark_sia_vm_policies_service</li> </ul> </li> </ul> </li> <li>secrets<ul> <li>db<ul> <li>ark_sia_db_secrets_service</li> </ul> </li> <li>vm<ul> <li>ark_sia_vm_secrets_service</li> </ul> </li> </ul> </li> <li>sso<ul> <li>ark_sia_sso_service</li> </ul> </li> <li>workspaces<ul> <li>db<ul> <li>ark_sia_db_workspace_service</li> </ul> </li> <li>targetsets<ul> <li>ark_sia_target_sets_workspace_service</li> </ul> </li> </ul> </li> </ul> </li> <li>sm<ul> <li>ark_sm_service</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/ark/","title":"ark","text":""},{"location":"reference/ark_api/","title":"ark_api","text":""},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI","title":"<code>ArkAPI</code>","text":"Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>class ArkAPI:\n    def __init__(self, authenticators: List[ArkAuth], profile: Optional[ArkProfile] = None) -&gt; None:\n        self.__authenticators = authenticators\n        self.__lazy_loaded_services: Dict[str, ArkService] = {}\n        self.__profile = profile or ArkProfileLoader.load_default_profile()\n\n    def __lazy_load_service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        service_name = service_type.service_config().service_name\n        required_auth_names = service_type.service_config().required_authenticator_names\n        required_autheneticators = [auth for auth in self.__authenticators if auth.authenticator_name() in required_auth_names]\n        optional_authenticators = [\n            auth\n            for auth in self.__authenticators\n            if auth.authenticator_name() in service_type.service_config().optional_authenticator_names\n        ]\n        if len(required_autheneticators) == len(required_auth_names):\n            authenticators = {f'{a.authenticator_name()}_auth': a for a in required_autheneticators + optional_authenticators}\n            self.__lazy_loaded_services[service_name] = service_type(**authenticators)\n        else:\n            raise ArkServiceException(\n                f'{service_name.title()} is not supported or missing fitting authenticators, please make sure you are logged in'\n            )\n        return self.__lazy_loaded_services[service_name]\n\n    def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Returns the specified authenticator.\n\n        Args:\n            authenticator_name (str): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.__authenticators:\n            if auth.authenticator_name() == authenticator_name:\n                return auth\n        raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n\n    def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        \"\"\"\n        Returns the specified service when the appropriate authenticators were provided.\n\n        Args:\n            service_type (Type[ArkService]): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkService: _description_\n        \"\"\"\n        if not issubclass(service_type, ArkService):\n            raise ArkServiceException(f\"Type {service_type} is invalid\")\n        service_name = service_type.service_config().service_name\n        if service_name in self.__lazy_loaded_services:\n            return self.__lazy_loaded_services[service_name]\n        return self.__lazy_load_service(service_type)\n\n    @property\n    def profile(self) -&gt; ArkProfile:\n        \"\"\"\n        Gets the API profile\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        return self.__profile\n\n    @property\n    def identity_connectors(self) -&gt; \"ArkIdentityConnectorsService\":\n        \"\"\"\n        Returns the Identity Connectors Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityConnectorsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.connectors import ArkIdentityConnectorsService\n\n        return cast(ArkIdentityConnectorsService, self.service(ArkIdentityConnectorsService))\n\n    @property\n    def identity_directories(self) -&gt; \"ArkIdentityDirectoriesService\":\n        \"\"\"\n        Returns the Identity Directories Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityDirectoriesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.directories import ArkIdentityDirectoriesService\n\n        return cast(ArkIdentityDirectoriesService, self.service(ArkIdentityDirectoriesService))\n\n    @property\n    def identity_policies(self) -&gt; \"ArkIdentityPoliciesService\":\n        \"\"\"\n        Returns the Identity Policies Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.policies import ArkIdentityPoliciesService\n\n        return cast(ArkIdentityPoliciesService, self.service(ArkIdentityPoliciesService))\n\n    @property\n    def identity_roles(self) -&gt; \"ArkIdentityRolesService\":\n        \"\"\"\n        Returns the Identity Roles Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityRolesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.roles import ArkIdentityRolesService\n\n        return cast(ArkIdentityRolesService, self.service(ArkIdentityRolesService))\n\n    @property\n    def identity_users(self) -&gt; \"ArkIdentityUsersService\":\n        \"\"\"\n        Returns the Identity Users Service if the appropriate authenticators were given\n\n        Returns:\n            ArkIdentityUsersService: _description_\n        \"\"\"\n        from ark_sdk_python.services.identity.users import ArkIdentityUsersService\n\n        return cast(ArkIdentityUsersService, self.service(ArkIdentityUsersService))\n\n    @property\n    def sia_access(self) -&gt; \"ArkSIAAccessService\":\n        \"\"\"\n        Returns the SIA Access service if the appropriate authenticators were given\n\n        Returns:\n            ArkSIAAccessService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.access import ArkSIAAccessService\n\n        return cast(ArkSIAAccessService, self.service(ArkSIAAccessService))\n\n    @property\n    def sia_workspaces_db(self) -&gt; \"ArkSIADBWorkspaceService\":\n        \"\"\"\n        Returns the SIA DB Workspace service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.workspaces.db import ArkSIADBWorkspaceService\n\n        return cast(ArkSIADBWorkspaceService, self.service(ArkSIADBWorkspaceService))\n\n    @property\n    def sia_workspaces_target_sets(self) -&gt; \"ArkSIATargetSetsWorkspaceService\":\n        \"\"\"\n        Returns the SIA Target Sets Workspace service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIATargetSetsWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.workspaces.targetsets import ArkSIATargetSetsWorkspaceService\n\n        return cast(ArkSIATargetSetsWorkspaceService, self.service(ArkSIATargetSetsWorkspaceService))\n\n    @property\n    def sia_policies_vm(self) -&gt; \"ArkSIAVMPoliciesService\":\n        \"\"\"\n        Returns the SIA VM Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIAVMPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.policies.vm import ArkSIAVMPoliciesService\n\n        return cast(ArkSIAVMPoliciesService, self.service(ArkSIAVMPoliciesService))\n\n    @property\n    def sia_policies_db(self) -&gt; \"ArkSIADBPoliciesService\":\n        \"\"\"\n        Returns the SIA DB Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.policies.db import ArkSIADBPoliciesService\n\n        return cast(ArkSIADBPoliciesService, self.service(ArkSIADBPoliciesService))\n\n    @property\n    def sia_secrets_db(self) -&gt; \"ArkSIADBSecretsService\":\n        \"\"\"\n        Returns the SIA DB Secrets service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.secrets.db import ArkSIADBSecretsService\n\n        return cast(ArkSIADBSecretsService, self.service(ArkSIADBSecretsService))\n\n    @property\n    def sia_secrets_vm(self) -&gt; \"ArkSIAVMSecretsService\":\n        \"\"\"\n        Returns the SIA VM Secrets service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIAVMSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.secrets.vm import ArkSIAVMSecretsService\n\n        return cast(ArkSIAVMSecretsService, self.service(ArkSIAVMSecretsService))\n\n    @property\n    def sia_sso(self) -&gt; \"ArkSIASSOService\":\n        \"\"\"\n        Returns the SIA sso service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIASSOService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.sso import ArkSIASSOService\n\n        return cast(ArkSIASSOService, self.service(ArkSIASSOService))\n\n    @property\n    def sia_db(self) -&gt; \"ArkSIADBService\":\n        \"\"\"\n        Returns the SIA DB service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIADBService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.db import ArkSIADBService\n\n        return cast(ArkSIADBService, self.service(ArkSIADBService))\n\n    @property\n    def sia_certificates(self) -&gt; \"ArkSIACertificatesService\":\n        \"\"\"\n        Returns SIA certificates service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIACertificatesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.certificates import ArkSIACertificatesService\n\n        return cast(ArkSIACertificatesService, self.service(ArkSIACertificatesService))\n\n    @property\n    def sia_k8s(self) -&gt; \"ArkSIAK8SService\":\n        \"\"\"\n        Returns the SIA Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkSIAK8SService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sia.k8s import ArkSIAK8SService\n\n        return cast(ArkSIAK8SService, self.service(ArkSIAK8SService))\n\n    @property\n    def sm(self) -&gt; \"ArkSMService\":\n        \"\"\"\n        Returns the SM service if the appropriate authenticators were given\n\n        Returns:\n            ArkSMService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sm import ArkSMService\n\n        return cast(ArkSMService, self.service(ArkSMService))\n\n    @property\n    def pcloud_accounts(self) -&gt; \"ArkPCloudAccountsService\":\n        \"\"\"\n        Returns the PCloud Accounts service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudAccountsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.accounts import ArkPCloudAccountsService\n\n        return cast(ArkPCloudAccountsService, self.service(ArkPCloudAccountsService))\n\n    @property\n    def pcloud_safes(self) -&gt; \"ArkPCloudSafesService\":\n        \"\"\"\n        Returns the PCloud Safes service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudSafesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.safes import ArkPCloudSafesService\n\n        return cast(ArkPCloudSafesService, self.service(ArkPCloudSafesService))\n\n    @property\n    def pcloud_platforms(self) -&gt; \"ArkPCloudPlatformsService\":\n        \"\"\"\n        Returns the PCloud Platforms service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudPlatformsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.platforms import ArkPCloudPlatformsService\n\n        return cast(ArkPCloudPlatformsService, self.service(ArkPCloudPlatformsService))\n\n    @property\n    def pcloud_applications(self) -&gt; \"ArkPCloudApplicationsService\":\n        \"\"\"\n        Returns the PCloud Applications service if the appropriate authenticators were given\n\n        Returns:\n            ArkPCloudApplicationsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.pcloud.applications import ArkPCloudApplicationsService\n\n        return cast(ArkPCloudApplicationsService, self.service(ArkPCloudApplicationsService))\n\n    @property\n    def cmgr(self) -&gt; \"ArkCmgrService\":\n        \"\"\"\n        Returns the Connector Management service if the appropriate authenticators were given\n\n        Returns:\n            ArkCmgrService: _description_\n        \"\"\"\n        from ark_sdk_python.services.cmgr import ArkCmgrService\n\n        return cast(ArkCmgrService, self.service(ArkCmgrService))\n</code></pre>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.cmgr","title":"<code>cmgr</code>  <code>property</code>","text":"<p>Returns the Connector Management service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkCmgrService</code> <code>'ArkCmgrService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.identity_connectors","title":"<code>identity_connectors</code>  <code>property</code>","text":"<p>Returns the Identity Connectors Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityConnectorsService</code> <code>'ArkIdentityConnectorsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.identity_directories","title":"<code>identity_directories</code>  <code>property</code>","text":"<p>Returns the Identity Directories Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityDirectoriesService</code> <code>'ArkIdentityDirectoriesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.identity_policies","title":"<code>identity_policies</code>  <code>property</code>","text":"<p>Returns the Identity Policies Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityPoliciesService</code> <code>'ArkIdentityPoliciesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.identity_roles","title":"<code>identity_roles</code>  <code>property</code>","text":"<p>Returns the Identity Roles Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityRolesService</code> <code>'ArkIdentityRolesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.identity_users","title":"<code>identity_users</code>  <code>property</code>","text":"<p>Returns the Identity Users Service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUsersService</code> <code>'ArkIdentityUsersService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.pcloud_accounts","title":"<code>pcloud_accounts</code>  <code>property</code>","text":"<p>Returns the PCloud Accounts service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountsService</code> <code>'ArkPCloudAccountsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.pcloud_applications","title":"<code>pcloud_applications</code>  <code>property</code>","text":"<p>Returns the PCloud Applications service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudApplicationsService</code> <code>'ArkPCloudApplicationsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.pcloud_platforms","title":"<code>pcloud_platforms</code>  <code>property</code>","text":"<p>Returns the PCloud Platforms service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatformsService</code> <code>'ArkPCloudPlatformsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.pcloud_safes","title":"<code>pcloud_safes</code>  <code>property</code>","text":"<p>Returns the PCloud Safes service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafesService</code> <code>'ArkPCloudSafesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.profile","title":"<code>profile</code>  <code>property</code>","text":"<p>Gets the API profile</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_access","title":"<code>sia_access</code>  <code>property</code>","text":"<p>Returns the SIA Access service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkSIAAccessService</code> <code>'ArkSIAAccessService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_certificates","title":"<code>sia_certificates</code>  <code>property</code>","text":"<p>Returns SIA certificates service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificatesService</code> <code>'ArkSIACertificatesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_db","title":"<code>sia_db</code>  <code>property</code>","text":"<p>Returns the SIA DB service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBService</code> <code>'ArkSIADBService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_k8s","title":"<code>sia_k8s</code>  <code>property</code>","text":"<p>Returns the SIA Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIAK8SService</code> <code>'ArkSIAK8SService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_policies_db","title":"<code>sia_policies_db</code>  <code>property</code>","text":"<p>Returns the SIA DB Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesService</code> <code>'ArkSIADBPoliciesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_policies_vm","title":"<code>sia_policies_vm</code>  <code>property</code>","text":"<p>Returns the SIA VM Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesService</code> <code>'ArkSIAVMPoliciesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_secrets_db","title":"<code>sia_secrets_db</code>  <code>property</code>","text":"<p>Returns the SIA DB Secrets service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretsService</code> <code>'ArkSIADBSecretsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_secrets_vm","title":"<code>sia_secrets_vm</code>  <code>property</code>","text":"<p>Returns the SIA VM Secrets service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecretsService</code> <code>'ArkSIAVMSecretsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_sso","title":"<code>sia_sso</code>  <code>property</code>","text":"<p>Returns the SIA sso service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOService</code> <code>'ArkSIASSOService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_workspaces_db","title":"<code>sia_workspaces_db</code>  <code>property</code>","text":"<p>Returns the SIA DB Workspace service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBWorkspaceService</code> <code>'ArkSIADBWorkspaceService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sia_workspaces_target_sets","title":"<code>sia_workspaces_target_sets</code>  <code>property</code>","text":"<p>Returns the SIA Target Sets Workspace service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSetsWorkspaceService</code> <code>'ArkSIATargetSetsWorkspaceService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sm","title":"<code>sm</code>  <code>property</code>","text":"<p>Returns the SM service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkSMService</code> <code>'ArkSMService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.authenticator","title":"<code>authenticator(authenticator_name)</code>","text":"<p>Returns the specified authenticator.</p> <p>Parameters:</p> Name Type Description Default <code>authenticator_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Returns the specified authenticator.\n\n    Args:\n        authenticator_name (str): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.__authenticators:\n        if auth.authenticator_name() == authenticator_name:\n            return auth\n    raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n</code></pre>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.service","title":"<code>service(service_type)</code>","text":"<p>Returns the specified service when the appropriate authenticators were provided.</p> <p>Parameters:</p> Name Type Description Default <code>service_type</code> <code>Type[ArkService]</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkService</code> <code>ArkService</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n    \"\"\"\n    Returns the specified service when the appropriate authenticators were provided.\n\n    Args:\n        service_type (Type[ArkService]): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkService: _description_\n    \"\"\"\n    if not issubclass(service_type, ArkService):\n        raise ArkServiceException(f\"Type {service_type} is invalid\")\n    service_name = service_type.service_config().service_name\n    if service_name in self.__lazy_loaded_services:\n        return self.__lazy_loaded_services[service_name]\n    return self.__lazy_load_service(service_type)\n</code></pre>"},{"location":"reference/actions/","title":"actions","text":""},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction","title":"<code>ArkAction</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>class ArkAction(ABC):\n    def __init__(self):\n        self._logger = get_logger(app=self.__class__.__name__)\n\n    def _common_actions_configuration(self, parser: argparse.ArgumentParser) -&gt; None:\n        parser.add_argument('-r', '--raw', action='store_true', help='Whether to raw output')\n        parser.add_argument('-s', '--silent', action='store_true', help='Silent execution, no interactiveness')\n        parser.add_argument('-ao', '--allow-output', action='store_true', help='Allow stdout / stderr even when silent and not interactive')\n        parser.add_argument('-v', '--verbose', action='store_true', help='Whether to verbose log')\n        parser.add_argument('-ls', '--logger-style', choices=['default'], help='Which verbose logger style to use', default='default')\n        parser.add_argument(\n            '-ll',\n            '--log-level',\n            help='Log level to use while verbose',\n            choices=['DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL'],\n            default='INFO',\n        )\n        parser.add_argument(\n            '-dcv', '--disable-cert-verification', action='store_true', help='Disables certificate verification on HTTPS calls, unsafe!'\n        )\n        parser.add_argument('-tc', '--trusted-cert', help='Certificate to use for HTTPS calls')\n\n    def _common_actions_execution(self, args: argparse.Namespace) -&gt; None:\n        ArkSystemConfig.enable_color()\n        ArkSystemConfig.enable_interactive()\n        ArkSystemConfig.disable_verbose_logging()\n        ArkSystemConfig.disallow_output()\n        ArkSystemConfig.set_logger_style(args.logger_style)\n        ArkSystemConfig.enable_certificate_verification()\n        if args.raw:\n            ArkSystemConfig.disable_color()\n        if args.silent:\n            ArkSystemConfig.disable_interactive()\n        if args.verbose:\n            ArkSystemConfig.enable_verbose_logging(args.log_level)\n        if args.allow_output:\n            ArkSystemConfig.allow_output()\n        if args.disable_cert_verification:\n            ArkSystemConfig.disable_certificate_verification()\n        elif args.trusted_cert is not None:\n            ArkSystemConfig.set_trusted_certificate(args.trusted_cert)\n        self._logger = get_logger(app=self.__class__.__name__)\n        if 'profile-name' in args:\n            args.profile_name = ArkProfileLoader.deduce_profile_name(args.profile_name)\n        if 'DEPLOY_ENV' not in os.environ:\n            # Last fallback on deploy env\n            os.environ['DEPLOY_ENV'] = 'prod'\n\n    @abstractmethod\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the action as part of the specified subparsers group.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the actual action with the given arguments.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the given action can be run with the specified arguments.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the given action can be run with the specified arguments.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the given action can be run with the specified arguments.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.define_action","title":"<code>define_action(subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines the action as part of the specified subparsers group.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the action as part of the specified subparsers group.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.run_action","title":"<code>run_action(args)</code>  <code>abstractmethod</code>","text":"<p>Runs the actual action with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the actual action with the given arguments.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction","title":"<code>ArkCacheAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>class ArkCacheAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `cache` action, and adds the clear cache function.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n        self._common_actions_configuration(cache_parser)\n        cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n        cache_cmd_subparsers.required = True\n        cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n\n    def __run_clear_cache_action(self) -&gt; None:\n        if isinstance(ArkKeyring.get_keyring(), BasicKeyring):\n            cache_folder_path = os.path.join(os.path.expanduser('~'), DEFAULT_BASIC_KEYRING_FOLDER)\n            if ARK_BASIC_KEYRING_FOLDER_ENV_VAR in os.environ:\n                cache_folder_path = os.environ[ARK_BASIC_KEYRING_FOLDER_ENV_VAR]\n            os.unlink(f'{cache_folder_path}{os.sep}keyring')\n            os.unlink(f'{cache_folder_path}{os.sep}mac')\n        else:\n            ArkArgsFormatter.print_normal('Cache clear is only valid for basic keyring implementation at the moment')\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the cache action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        if args.cache_cmd == 'clear':\n            self.__run_clear_cache_action()\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `cache`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>cache</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `cache`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>cache</code> action, and adds the clear cache function.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `cache` action, and adds the clear cache function.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n    self._common_actions_configuration(cache_parser)\n    cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n    cache_cmd_subparsers.required = True\n    cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the cache action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the cache action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    if args.cache_cmd == 'clear':\n        self.__run_clear_cache_action()\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction","title":"<code>ArkConfigureAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>class ArkConfigureAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `configure` action.\n        For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n        self._common_actions_configuration(conf_parser)\n\n        # Add the profile settings to the arguments\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkProfile.model_json_schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n        )\n\n        # Add the supported authenticator settings and whether to work with them or not\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            conf_parser.add_argument(\n                f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n                f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n                action='store_true',\n                help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                conf_parser.add_argument(\n                    f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                    f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                    choices=[am.value for am in authenticator.supported_auth_methods()],\n                    default=ArkAuthMethod.Default.value,\n                )\n            # Add the rest of the ark auth profile params\n            ArkPydanticArgparse.schema_to_argparse(\n                ArkAuthProfile.model_json_schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n            )\n\n            # Add the supported authentication methods settings of the authenticators\n            for auth_method in authenticator.supported_auth_methods():\n                auth_settings = ArkAuthMethodSettingsMap[auth_method]\n                ArkPydanticArgparse.schema_to_argparse(\n                    auth_settings.model_json_schema(by_alias=False),\n                    conf_parser,\n                    key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                    ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n                )\n\n    def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Performs an interactive configuration.\n        The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n        Selected authenticators are also configured with the user's auth methods and settings.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile first with the given profile name from the user\n        profile_name = ArkArgsFormatter.get_arg(\n            args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n        )\n        profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n        # Fill the rest of the profile settings\n        profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n            ArkProfile.model_json_schema(by_alias=False),\n            args,\n            ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS,\n            existing_values=profile.model_dump(),\n        )\n        profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n        if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n            work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n        else:\n            work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n                args,\n                [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n                'Which authenticators would you like to connect to',\n                [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n                {\n                    f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                    for a in SUPPORTED_AUTHENTICATORS_LIST\n                    if a.authenticator_name() in profile.auth_profiles\n                },\n                True,\n            )\n        for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n            # Find out if we are working with the authenticator\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n                # Get the authenticator auth method\n                ArkArgsFormatter.print_success_bright(\n                    ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n                )\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    auth_method = ArkArgsFormatter.get_switch_arg(\n                        args,\n                        f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                        'Authentication Method',\n                        [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                        (\n                            ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                            if authenticator.authenticator_name() in profile.auth_profiles\n                            else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]]\n                        ),\n                        prioritize_existing_val=True,\n                    )\n                    auth_method = next(\n                        # pylint: disable-next=cell-var-from-loop\n                        filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                    )\n                    # If the default is chosen, override it by the authenticator's default\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n                ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                    authenticator.authenticator_name(), []\n                )\n                # Get the auth profile general settings\n                auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    ArkAuthProfile.model_json_schema(by_alias=False),\n                    args,\n                    ignored_keys=ignored_keys,\n                    existing_values=auth_profile.model_dump(),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    auth_profile_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignore_keys=['auth_method_settings'],\n                )\n\n                # Get the auth method settings and fill them\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(auth_profile.auth_method_settings)\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    method_settings.model_json_schema(by_alias=False),\n                    args,\n                    existing_values=method_settings.model_dump(),\n                    override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                    empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                    default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n                )\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Runs the CLI configure action silently, without user interaction.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile based on the cli params and merge the rest of the params\n        profile = ArkPydanticArgparse.merge_by_model(\n            ArkProfile,\n            ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n            ArkPydanticArgparse.argparse_to_schema(ArkProfile.model_json_schema(by_alias=False), args),\n        )\n\n        # Load the authenticators\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    # Load the auth method\n                    auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                    # If default, fallback to default auth method of the authenticator\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n\n                # Load the rest of the auth profile\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    ArkPydanticArgparse.argparse_to_schema(\n                        ArkAuthProfile.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                    ),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n\n                # Make sure if the type requires credentials, a username was supplied\n                if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                    raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n                # Load the method settings\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(method_settings)\n\n                # Parse and merge the method settings from the cli\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                    method_settings.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                )\n\n                # Remove the postfix\n                method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    defaults={\n                        k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                        for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                        if k.startswith(f'{authenticator.authenticator_name()}_')\n                    },\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the configure action.\n        Prompts the user when interactive mode is run, based on the associated authenticators,\n        and saves the configured profile when completed.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n        # Parse the profile\n        self._common_actions_execution(args)\n        profile: Optional[ArkProfile] = None\n        if ArkSystemConfig.is_interactive():\n            profile = self.__run_interactive_action(args)\n        else:\n            profile = self.__run_silent_action(args)\n\n        # Store it\n        ArkProfileLoader.save_profile(profile)\n\n        # Print out results\n        ArkArgsFormatter.print_success(profile.model_dump_json(indent=4))\n        ArkArgsFormatter.print_success_bright(\n            f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `configure`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.__run_interactive_action","title":"<code>__run_interactive_action(args)</code>","text":"<p>Performs an interactive configuration. The user is prompted for each Ark profile setting, with the default/defined CLI arguments. Selected authenticators are also configured with the user's auth methods and settings.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Performs an interactive configuration.\n    The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n    Selected authenticators are also configured with the user's auth methods and settings.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile first with the given profile name from the user\n    profile_name = ArkArgsFormatter.get_arg(\n        args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n    )\n    profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n    # Fill the rest of the profile settings\n    profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n        ArkProfile.model_json_schema(by_alias=False),\n        args,\n        ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS,\n        existing_values=profile.model_dump(),\n    )\n    profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n    if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n        work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n    else:\n        work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n            args,\n            [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n            'Which authenticators would you like to connect to',\n            [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n            {\n                f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                for a in SUPPORTED_AUTHENTICATORS_LIST\n                if a.authenticator_name() in profile.auth_profiles\n            },\n            True,\n        )\n    for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n        # Find out if we are working with the authenticator\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n            # Get the authenticator auth method\n            ArkArgsFormatter.print_success_bright(\n                ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                auth_method = ArkArgsFormatter.get_switch_arg(\n                    args,\n                    f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                    'Authentication Method',\n                    [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                    (\n                        ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                        if authenticator.authenticator_name() in profile.auth_profiles\n                        else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]]\n                    ),\n                    prioritize_existing_val=True,\n                )\n                auth_method = next(\n                    # pylint: disable-next=cell-var-from-loop\n                    filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                )\n                # If the default is chosen, override it by the authenticator's default\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n            ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                authenticator.authenticator_name(), []\n            )\n            # Get the auth profile general settings\n            auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                ArkAuthProfile.model_json_schema(by_alias=False),\n                args,\n                ignored_keys=ignored_keys,\n                existing_values=auth_profile.model_dump(),\n                key_prefix=authenticator.authenticator_name(),\n            )\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                auth_profile_vals,\n                key_prefix=authenticator.authenticator_name(),\n                ignore_keys=['auth_method_settings'],\n            )\n\n            # Get the auth method settings and fill them\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(auth_profile.auth_method_settings)\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                method_settings.model_json_schema(by_alias=False),\n                args,\n                existing_values=method_settings.model_dump(),\n                override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                key_prefix=authenticator.authenticator_name(),\n                ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n            )\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.__run_silent_action","title":"<code>__run_silent_action(args)</code>","text":"<p>Runs the CLI configure action silently, without user interaction.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Runs the CLI configure action silently, without user interaction.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile based on the cli params and merge the rest of the params\n    profile = ArkPydanticArgparse.merge_by_model(\n        ArkProfile,\n        ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n        ArkPydanticArgparse.argparse_to_schema(ArkProfile.model_json_schema(by_alias=False), args),\n    )\n\n    # Load the authenticators\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                # Load the auth method\n                auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                # If default, fallback to default auth method of the authenticator\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n\n            # Load the rest of the auth profile\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                ArkPydanticArgparse.argparse_to_schema(\n                    ArkAuthProfile.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                ),\n                key_prefix=authenticator.authenticator_name(),\n            )\n\n            # Make sure if the type requires credentials, a username was supplied\n            if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n            # Load the method settings\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(method_settings)\n\n            # Parse and merge the method settings from the cli\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                method_settings.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n            )\n\n            # Remove the postfix\n            method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n                defaults={\n                    k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                    for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                    if k.startswith(f'{authenticator.authenticator_name()}_')\n                },\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>configure</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `configure`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>configure</code> action. For each supported authenticator, sets whether it is used and adds the appropriate parameters.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `configure` action.\n    For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n    self._common_actions_configuration(conf_parser)\n\n    # Add the profile settings to the arguments\n    ArkPydanticArgparse.schema_to_argparse(\n        ArkProfile.model_json_schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n    )\n\n    # Add the supported authenticator settings and whether to work with them or not\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        conf_parser.add_argument(\n            f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n            f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n            action='store_true',\n            help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n        )\n        if len(authenticator.supported_auth_methods()) &gt; 1:\n            conf_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                choices=[am.value for am in authenticator.supported_auth_methods()],\n                default=ArkAuthMethod.Default.value,\n            )\n        # Add the rest of the ark auth profile params\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkAuthProfile.model_json_schema(by_alias=False),\n            conf_parser,\n            key_prefix=authenticator.authenticator_name().replace('_', '-'),\n            ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n        )\n\n        # Add the supported authentication methods settings of the authenticators\n        for auth_method in authenticator.supported_auth_methods():\n            auth_settings = ArkAuthMethodSettingsMap[auth_method]\n            ArkPydanticArgparse.schema_to_argparse(\n                auth_settings.model_json_schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n            )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the configure action. Prompts the user when interactive mode is run, based on the associated authenticators, and saves the configured profile when completed.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the configure action.\n    Prompts the user when interactive mode is run, based on the associated authenticators,\n    and saves the configured profile when completed.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n    # Parse the profile\n    self._common_actions_execution(args)\n    profile: Optional[ArkProfile] = None\n    if ArkSystemConfig.is_interactive():\n        profile = self.__run_interactive_action(args)\n    else:\n        profile = self.__run_silent_action(args)\n\n    # Store it\n    ArkProfileLoader.save_profile(profile)\n\n    # Print out results\n    ArkArgsFormatter.print_success(profile.model_dump_json(indent=4))\n    ArkArgsFormatter.print_success_bright(\n        f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction","title":"<code>ArkExecAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>class ArkExecAction(ArkAction):\n    def _serialize_output(self, output: Optional[Union[List, Dict, ArkModel, Generator, Tuple, Any]]) -&gt; str:\n        if output is None:\n            return ''\n        if isinstance(output, Generator):\n            return self._serialize_output(list(itertools.chain.from_iterable([p.items for p in output])))\n        if isinstance(output, list):\n            return json.dumps(\n                [\n                    (\n                        json.loads(a.model_dump_json(by_alias=False, exclude={'poll_progress_callback'}))\n                        if issubclass(type(a), ArkModel)\n                        else a\n                    )\n                    for a in output\n                    if a is not None\n                ],\n                indent=4,\n            )\n        elif isinstance(output, tuple):\n            return json.dumps(\n                [\n                    (\n                        json.loads(a.model_dump_json(by_alias=False, exclude={'poll_progress_callback'}))\n                        if issubclass(type(a), ArkModel)\n                        else a\n                    )\n                    for a in output\n                    if a is not None\n                ],\n                indent=4,\n            )\n        elif isinstance(output, dict):\n            return json.dumps(\n                {\n                    k: (\n                        json.loads(v.model_dump_json(indent=4, by_alias=False, exclude={'poll_progress_callback'}))\n                        if issubclass(type(v), ArkModel)\n                        else v\n                    )\n                    for k, v in output.items()\n                    if k is not None and v is not None\n                },\n                indent=4,\n            )\n        elif issubclass(type(output), ArkModel):\n            return output.model_dump_json(indent=4, by_alias=False, exclude={'poll_progress_callback'})\n        elif issubclass(type(output), ArkAsyncRequest):\n            return output.async_task.model_dump_json(indent=4, by_alias=False)\n        return str(output)\n\n    def _write_output_to_file(self, output_path: str, serialized_output: str) -&gt; None:\n        output_path = os.path.abspath(output_path)\n        if not os.path.exists(os.path.dirname(output_path)):\n            os.makedirs(os.path.dirname(output_path), exist_ok=True)\n        with open(output_path, 'w', encoding='utf-8') as f:\n            f.write(serialized_output)\n\n    def _run_async_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            model: ArkPollableModel = model_type.model_validate(\n                ArkPydanticArgparse.argparse_to_schema(model_type.model_json_schema(), args)\n            )\n            model.poll_progress_callback = ArkPollers.default_poller()\n            output = getattr(service, action.replace('-', '_'))(model)\n            async_req = None\n            if issubclass(type(output), ArkAsyncRequest):\n                async_req = output\n            elif isinstance(output, tuple):\n                for a in output:\n                    if issubclass(type(a), ArkAsyncRequest):\n                        async_req = a\n                        break\n            if async_req is not None:\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path, async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})\n                    )\n                if async_req.task_failed():\n                    if async_req.task_timeout():\n                        ArkArgsFormatter.print_warning(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                    else:\n                        ArkArgsFormatter.print_failure(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                else:\n                    ArkArgsFormatter.print_success(self._serialize_output(output))\n            elif isinstance(output, list) and all(issubclass(type(ar), ArkAsyncRequest) for ar in output):\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path,\n                        json.dumps(\n                            [ar.async_task.model_dump(indent=4, by_alias=False, exclude={\"poll_progress_callback\"}) for ar in output]\n                        ),\n                    )\n                for ar in output:\n                    if ar.task_failed():\n                        if ar.task_timeout():\n                            ArkArgsFormatter.print_warning(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                        else:\n                            ArkArgsFormatter.print_failure(\n                                f'Failed to execute async command, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                    else:\n                        ArkArgsFormatter.print_success(self._serialize_output(ar))\n            elif output is not None:\n                ArkArgsFormatter.print_success(self._serialize_output(output))\n        except Exception as ex:\n            self._logger.exception(f'Failed running async command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute async command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _run_sync_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            if model_type:\n                model: ArkModel = model_type.model_validate(ArkPydanticArgparse.argparse_to_schema(model_type.model_json_schema(), args))\n                output = getattr(service, action.replace('-', '_'))(model)\n            else:\n                output = getattr(service, action.replace('-', '_'))()\n            if output is not None:\n                serialized_output: str = self._serialize_output(output)\n                if args.output_path:\n                    self._write_output_to_file(args.output_path, serialized_output)\n                ArkArgsFormatter.print_success(serialized_output)\n            else:\n                ArkArgsFormatter.print_success(f'{action.replace(\"-\", \" \").title()} finished successfully')\n        except Exception as ex:\n            self._logger.exception(f'Failed running command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _define_actions_by_schemas(\n        self,\n        subparsers: argparse._SubParsersAction,\n        schemas_map: Dict[str, Optional[Type[ArkModel]]],\n        defaults_map: Optional[Dict[str, Dict[str, Any]]] = None,\n    ):\n        for action, schema in schemas_map.items():\n            parser = subparsers.add_parser(action)\n            if schema:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema.model_json_schema(), parser, defaults=defaults_map.get(action, None) if defaults_map else None\n                )\n\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        exec_parser = None\n        exec_subparsers = None\n        # Check if the exec subparser already exists from previous definitions of a service\n        if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n            # Retrieve the existing exec parser\n            exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n            exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n        else:\n            # Create a new exec parser\n            exec_parser = subparsers.add_parser('exec')\n            self._common_actions_configuration(exec_parser)\n            exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n            exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n            exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n            exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n            exec_parser.add_argument(\n                '-ra',\n                '--refresh-auth',\n                action='store_true',\n                help='If possible, will try to refresh the active authentication before running the actual command',\n            )\n            exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n            exec_subparsers.required = True\n        self.define_exec_action(exec_subparsers)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action.\n        Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n        Each service is created from the API, based on the given authenticators, and then\n        runs the exec action using the API.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile and login before trying to exec')\n\n        # Load token from cache for each auth profile\n        authenticators: List[ArkAuth] = []\n        for authenticator_name in profile.auth_profiles.keys():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n            if not authenticator.load_authentication(profile, args.refresh_auth):\n                continue\n            authenticators.append(authenticator)\n\n        if len(authenticators) == 0:\n            raise ArkException(\n                'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n            )\n        if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n            ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n        # Create the CLI API with the authenticators\n        api = ArkCLIAPI(authenticators, profile)\n\n        # Run the actual exec fitting action with the api\n        # Run it with retries as per defined by user\n        ArkRetry.retry_call(\n            self.run_exec_action,\n            fargs=[api, args],\n            tries=args.retry_count,\n            delay=1,\n            logger=namedtuple(\"logger\", (\"warning\"))(\n                warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n            ),\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `exec`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n\n    @abstractmethod\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines an exec action, and its specified configurations and args, for a service.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action for a service with the specified arguments and API.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the specified exec service action can be run.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>exec</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `exec`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the specified exec service action can be run.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the specified exec service action can be run.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>exec</code> action, with its subparsers (args) for the service.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    exec_parser = None\n    exec_subparsers = None\n    # Check if the exec subparser already exists from previous definitions of a service\n    if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n        # Retrieve the existing exec parser\n        exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n        exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n    else:\n        # Create a new exec parser\n        exec_parser = subparsers.add_parser('exec')\n        self._common_actions_configuration(exec_parser)\n        exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n        exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n        exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n        exec_parser.add_argument(\n            '-ra',\n            '--refresh-auth',\n            action='store_true',\n            help='If possible, will try to refresh the active authentication before running the actual command',\n        )\n        exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n        exec_subparsers.required = True\n    self.define_exec_action(exec_subparsers)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines an exec action, and its specified configurations and args, for a service.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines an exec action, and its specified configurations and args, for a service.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the exec action. Loads the authenticators from the cache and connects to the API using the loaded authenticators. Each service is created from the API, based on the given authenticators, and then runs the exec action using the API.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action.\n    Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n    Each service is created from the API, based on the given authenticators, and then\n    runs the exec action using the API.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile and login before trying to exec')\n\n    # Load token from cache for each auth profile\n    authenticators: List[ArkAuth] = []\n    for authenticator_name in profile.auth_profiles.keys():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n        if not authenticator.load_authentication(profile, args.refresh_auth):\n            continue\n        authenticators.append(authenticator)\n\n    if len(authenticators) == 0:\n        raise ArkException(\n            'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n        )\n    if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n        ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n    # Create the CLI API with the authenticators\n    api = ArkCLIAPI(authenticators, profile)\n\n    # Run the actual exec fitting action with the api\n    # Run it with retries as per defined by user\n    ArkRetry.retry_call(\n        self.run_exec_action,\n        fargs=[api, args],\n        tries=args.retry_count,\n        delay=1,\n        logger=namedtuple(\"logger\", (\"warning\"))(\n            warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n        ),\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>  <code>abstractmethod</code>","text":"<p>Runs the exec action for a service with the specified arguments and API.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action for a service with the specified arguments and API.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction","title":"<code>ArkLoginAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>class ArkLoginAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `login` action.\n        For each supported authenticator, adds the username/secret params for logging in.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n        self._common_actions_configuration(login_parser)\n        login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n        login_parser.add_argument(\n            '-nss',\n            '--no-shared-secrets',\n            action='store_true',\n            help='Do not share secrets between different authenticators with the same username',\n        )\n        login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n        login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n        # Add username and secret for each authenticator for logging in\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n                help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n                help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the login action for each authenticator.\n        After a login completes, credentials are stored in the keyring for future use.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        # Load up the profile\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile before trying to login')\n\n        # Login for each auth profile\n        # Share secrets between authenticators for allowed auth methods\n        shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n        # Save tokens for finalization output\n        tokens_map: Dict[str, ArkToken] = dict()\n        for authenticator_name, auth_profile in profile.auth_profiles.items():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n            # Only perform the authentication if not already authenticated and not forced\n            if authenticator.is_authenticated(profile) and not args.force:\n                try:\n                    if args.refresh_auth:\n                        token = authenticator.load_authentication(profile, True)\n                        if token:\n                            ArkArgsFormatter.print_success(\n                                f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                            )\n                        else:\n                            raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                    else:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                        )\n                    continue\n                except Exception as ex:\n                    self._logger.info(\n                        f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                    )\n            secret = (\n                ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n            )\n            auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n            # Ask the user for the user and secret if interactive\n            if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n                auth_profile.username = ArkArgsFormatter.get_arg(\n                    args,\n                    f'{authenticator_name}_username',\n                    f'{authenticator.authenticator_human_readable_name()} Username',\n                    auth_profile.username,\n                )\n                # Check if there is an existing secret who is sharable\n                if (\n                    auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                    and auth_profile.auth_method in shared_secrets_map\n                    and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                    and not args.__dict__[f'{authenticator_name}_secret']\n                    and not args.no_shared_secrets\n                ):\n                    # pylint: disable-next=cell-var-from-loop\n                    secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n                else:\n                    if not args.force and (\n                        (\n                            auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                        )\n                    ):\n                        # Check if there is a secret already cached, if there is, no need to ask for password\n                        secret = ArkSecret(secret='')\n                    else:\n                        # Check if we really need to ask for a password in specific use cases\n                        if (\n                            authenticator_name == 'isp'\n                            and auth_profile.auth_method == ArkAuthMethod.Identity\n                            and not ArkIdentity.is_password_required(\n                                auth_profile.username,\n                                (\n                                    auth_profile.auth_method_settings.identity_url\n                                    if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                    else None\n                                ),\n                                (\n                                    auth_profile.auth_method_settings.identity_tenant_subdomain\n                                    if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                    else None\n                                ),\n                            )\n                        ):\n                            secret = ArkSecret(secret='')\n                        else:\n                            secret = ArkSecret(\n                                secret=ArkArgsFormatter.get_arg(\n                                    args,\n                                    f'{authenticator_name}_secret',\n                                    f'{authenticator.authenticator_human_readable_name()} Secret',\n                                    hidden=True,\n                                )\n                            )\n            elif (\n                not ArkSystemConfig.is_interactive()\n                and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n                and not args.__dict__[f'{authenticator_name}_secret']\n            ):\n                raise ArkException(\n                    f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n                )\n            # Perform the authentication, will also cache the token\n            token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n            if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n                shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n            tokens_map[authenticator.authenticator_human_readable_name()] = token\n        if not args.show_tokens and tokens_map:\n            ArkArgsFormatter.print_success('Login tokens are hidden')\n        for k, v in tokens_map.items():\n            if 'cookies' in v.metadata:\n                del v.metadata['cookies']\n            ArkArgsFormatter.print_success(\n                f'{k} Token\\n{v.model_dump_json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n            )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `login`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>login</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `login`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>login</code> action. For each supported authenticator, adds the username/secret params for logging in.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `login` action.\n    For each supported authenticator, adds the username/secret params for logging in.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n    self._common_actions_configuration(login_parser)\n    login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n    login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n    login_parser.add_argument(\n        '-nss',\n        '--no-shared-secrets',\n        action='store_true',\n        help='Do not share secrets between different authenticators with the same username',\n    )\n    login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n    login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n    # Add username and secret for each authenticator for logging in\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n            help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n            help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the login action for each authenticator. After a login completes, credentials are stored in the keyring for future use.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the login action for each authenticator.\n    After a login completes, credentials are stored in the keyring for future use.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    # Load up the profile\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile before trying to login')\n\n    # Login for each auth profile\n    # Share secrets between authenticators for allowed auth methods\n    shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n    # Save tokens for finalization output\n    tokens_map: Dict[str, ArkToken] = dict()\n    for authenticator_name, auth_profile in profile.auth_profiles.items():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n        # Only perform the authentication if not already authenticated and not forced\n        if authenticator.is_authenticated(profile) and not args.force:\n            try:\n                if args.refresh_auth:\n                    token = authenticator.load_authentication(profile, True)\n                    if token:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                        )\n                    else:\n                        raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                else:\n                    ArkArgsFormatter.print_success(\n                        f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                    )\n                continue\n            except Exception as ex:\n                self._logger.info(\n                    f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                )\n        secret = (\n            ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n        )\n        auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n        # Ask the user for the user and secret if interactive\n        if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n            auth_profile.username = ArkArgsFormatter.get_arg(\n                args,\n                f'{authenticator_name}_username',\n                f'{authenticator.authenticator_human_readable_name()} Username',\n                auth_profile.username,\n            )\n            # Check if there is an existing secret who is sharable\n            if (\n                auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                and auth_profile.auth_method in shared_secrets_map\n                and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                and not args.__dict__[f'{authenticator_name}_secret']\n                and not args.no_shared_secrets\n            ):\n                # pylint: disable-next=cell-var-from-loop\n                secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n            else:\n                if not args.force and (\n                    (\n                        auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                    )\n                ):\n                    # Check if there is a secret already cached, if there is, no need to ask for password\n                    secret = ArkSecret(secret='')\n                else:\n                    # Check if we really need to ask for a password in specific use cases\n                    if (\n                        authenticator_name == 'isp'\n                        and auth_profile.auth_method == ArkAuthMethod.Identity\n                        and not ArkIdentity.is_password_required(\n                            auth_profile.username,\n                            (\n                                auth_profile.auth_method_settings.identity_url\n                                if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                else None\n                            ),\n                            (\n                                auth_profile.auth_method_settings.identity_tenant_subdomain\n                                if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                else None\n                            ),\n                        )\n                    ):\n                        secret = ArkSecret(secret='')\n                    else:\n                        secret = ArkSecret(\n                            secret=ArkArgsFormatter.get_arg(\n                                args,\n                                f'{authenticator_name}_secret',\n                                f'{authenticator.authenticator_human_readable_name()} Secret',\n                                hidden=True,\n                            )\n                        )\n        elif (\n            not ArkSystemConfig.is_interactive()\n            and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n            and not args.__dict__[f'{authenticator_name}_secret']\n        ):\n            raise ArkException(\n                f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n            )\n        # Perform the authentication, will also cache the token\n        token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n        if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n            shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n        tokens_map[authenticator.authenticator_human_readable_name()] = token\n    if not args.show_tokens and tokens_map:\n        ArkArgsFormatter.print_success('Login tokens are hidden')\n    for k, v in tokens_map.items():\n        if 'cookies' in v.metadata:\n            del v.metadata['cookies']\n        ArkArgsFormatter.print_success(\n            f'{k} Token\\n{v.model_dump_json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n        )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction","title":"<code>ArkProfilesAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>class ArkProfilesAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n        self._common_actions_configuration(profile_parser)\n        profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n        profile_cmd_subparsers.required = True\n        list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n        list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n        list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n        list_profiles_parser.add_argument(\n            '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n        )\n        show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n        show_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n        )\n        delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n        delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n        delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n        clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n        clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n        clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n        clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n        clone_profile_parser.add_argument(\n            '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n        )\n        clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n        add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n        add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n        edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n        edit_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n        )\n\n    def __run_list_action(self, args: argparse.Namespace) -&gt; None:\n        # Start by loading all the profiles\n        profiles: Optional[List[ArkProfile]] = ArkProfileLoader.load_all_profiles()\n        if not profiles:\n            ArkArgsFormatter.print_warning(\n                'No profiles were found',\n            )\n            return\n        # Filter profiles\n        if args.name:\n            profiles = [p for p in profiles if fnmatch(p.profile_name, args.name)]\n        if args.auth_profile:\n            profiles = [p for p in profiles if args.auth_profile in list(p.auth_profiles.keys())]\n        # Print them based on request\n        if args.all:\n            ArkArgsFormatter.print_success(json.dumps([p.model_dump() for p in profiles], indent=4))\n        else:\n            ArkArgsFormatter.print_success(json.dumps([p.profile_name for p in profiles], indent=4))\n\n    def __run_show_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        ArkArgsFormatter.print_success(profile.model_dump_json(indent=4))\n\n    def __run_delete_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message=f'Are you sure you want to delete profile {args.profile_name}')],\n                render=ArkInquirerRender(),\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.delete_profile(args.profile_name)\n\n    def __run_clear_action(self, args: argparse.Namespace) -&gt; None:\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message='Are you sure you want to clear all profiles')], render=ArkInquirerRender()\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.clear_all_profiles()\n\n    def __run_clone_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        cloned_profile: ArkProfile = profile.copy(update={'profile_name': args.new_profile_name or f'{profile.profile_name}_clone'})\n        if ArkProfileLoader.profile_exists(cloned_profile.profile_name):\n            if not args.yes:\n                answer = inquirer.prompt(\n                    [\n                        inquirer.Confirm(\n                            'answer', message=f'Are you sure you want to override existing profile {cloned_profile.profile_name}'\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answer or not answer['answer']:\n                    return\n        ArkProfileLoader.save_profile(cloned_profile)\n\n    def __run_add_action(self, args: argparse.Namespace) -&gt; None:\n        if not os.path.exists(args.profile_path):\n            ArkArgsFormatter.print_warning(\n                f'Profile path [{args.profile_path}] does not exist, ignoring',\n            )\n            return\n        try:\n            with open(args.profile_path, 'r', encoding='utf-8') as fh:\n                profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n            ArkProfileLoader.save_profile(profile)\n        except Exception as ex:\n            self._logger.exception(f'Failed to parser profile [{str(ex)}]')\n            ArkArgsFormatter.print_failure(\n                f'Profile path [{args.profile_path}] failed to be parsed, aborting',\n            )\n            return\n\n    def __run_edit_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        answer = inquirer.prompt(\n            [inquirer.Editor('profile_edit', message=f'Chosen profile [{profile_name}] is about to be edited')],\n            render=ArkInquirerRender(),\n            answers={'profile_edit': profile.model_dump_json(indent=4)},\n        )\n        edited_profile = ArkProfile.model_validate_json(answer['profile_edit'])\n        ArkProfileLoader.save_profile(edited_profile)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the profile action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.profile_cmd == 'list':\n            self.__run_list_action(args)\n        elif args.profile_cmd == 'show':\n            self.__run_show_action(args)\n        elif args.profile_cmd == 'delete':\n            self.__run_delete_action(args)\n        elif args.profile_cmd == 'clear':\n            self.__run_clear_action(args)\n        elif args.profile_cmd == 'clone':\n            self.__run_clone_action(args)\n        elif args.profile_cmd == 'add':\n            self.__run_add_action(args)\n        elif args.profile_cmd == 'edit':\n            self.__run_edit_action(args)\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `profile`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>profile</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `profile`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>profile</code> action, and adds actions for managing multiple profiles.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n    self._common_actions_configuration(profile_parser)\n    profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n    profile_cmd_subparsers.required = True\n    list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n    list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n    list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n    list_profiles_parser.add_argument(\n        '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n    )\n    show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n    show_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n    )\n    delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n    delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n    delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n    clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n    clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n    clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n    clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n    clone_profile_parser.add_argument(\n        '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n    )\n    clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n    add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n    add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n    edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n    edit_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the profile action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the profile action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.profile_cmd == 'list':\n        self.__run_list_action(args)\n    elif args.profile_cmd == 'show':\n        self.__run_show_action(args)\n    elif args.profile_cmd == 'delete':\n        self.__run_delete_action(args)\n    elif args.profile_cmd == 'clear':\n        self.__run_clear_action(args)\n    elif args.profile_cmd == 'clone':\n        self.__run_clone_action(args)\n    elif args.profile_cmd == 'add':\n        self.__run_add_action(args)\n    elif args.profile_cmd == 'edit':\n        self.__run_edit_action(args)\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction","title":"<code>ArkServiceExecAction</code>","text":"<p>               Bases: <code>ArkExecAction</code></p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>class ArkServiceExecAction(ArkExecAction):\n    def __define_service_exec_action(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; argparse._SubParsersAction:\n        action_parser = subparsers.add_parser(action_def.action_name)\n        action_dest = action_def.action_name\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}'\n        action_subparsers = action_parser.add_subparsers(dest=f\"{action_dest}_action\")\n        action_subparsers.required = True\n        if action_def.schemas:\n            self._define_actions_by_schemas(action_subparsers, action_def.schemas, action_def.defaults)\n        return action_subparsers\n\n    def __define_service_exec_actions(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; None:\n        action_subparsers = self.__define_service_exec_action(action_def, subparsers, parent_actions_def)\n        if action_def.subactions:\n            for subaction in action_def.subactions:\n                self.__define_service_exec_actions(\n                    subaction, action_subparsers, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                )\n\n    def __deduce_action_def(\n        self,\n        args: argparse.Namespace,\n        action_def: ArkServiceActionDefinition,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        action_dest = f'{action_def.action_name}_action'\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}_action'\n        if action_dest in args.__dict__:\n            action_value = args.__dict__[action_dest]\n            if action_def.subactions:\n                for subaction in action_def.subactions:\n                    if subaction.action_name == action_value:\n                        return self.__deduce_action_def(\n                            args, subaction, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                        )\n            return action_def, action_dest\n\n    def __deduce_action_command_def(self, command_name: str, args: argparse.Namespace) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        for action_def in SUPPORTED_SERVICE_ACTIONS:\n            if action_def.action_name == command_name:\n                # Find the fitting action\n                return self.__deduce_action_def(args, action_def)\n\n    @overrides\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        for actions in SUPPORTED_SERVICE_ACTIONS:\n            self.__define_service_exec_actions(actions, exec_subparsers)\n\n    @overrides\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Deduces from the arguments the appropriate service definition and action.\n        Finds the appropriate service using the definition and executes the sync or async service action.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n        action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n        action_value = args.__dict__[action_dest]\n        api_name = action_dest.replace('_action', '').replace('-', '_')\n        while '_' in api_name and not hasattr(api, api_name):\n            api_name = api_name.rsplit('_', 1)[0]\n        service = getattr(api, api_name)\n        if action_def.async_actions and action_value in action_def.async_actions:\n            self._run_async_action(service, action_def.schemas, action_value, args)\n        else:\n            self._run_sync_action(service, action_def.schemas, action_value, args)\n\n    @overrides\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether there is a service definition for the command and its actions.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>","text":"<p>Checks whether there is a service definition for the command and its actions.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether there is a service definition for the command and its actions.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>","text":"<p>Defines all the supported service actions as CLI actions, with its associated arguments and schemas.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    for actions in SUPPORTED_SERVICE_ACTIONS:\n        self.__define_service_exec_actions(actions, exec_subparsers)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>","text":"<p>Deduces from the arguments the appropriate service definition and action. Finds the appropriate service using the definition and executes the sync or async service action.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Deduces from the arguments the appropriate service definition and action.\n    Finds the appropriate service using the definition and executes the sync or async service action.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n    action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n    action_value = args.__dict__[action_dest]\n    api_name = action_dest.replace('_action', '').replace('-', '_')\n    while '_' in api_name and not hasattr(api, api_name):\n        api_name = api_name.rsplit('_', 1)[0]\n    service = getattr(api, api_name)\n    if action_def.async_actions and action_value in action_def.async_actions:\n        self._run_async_action(service, action_def.schemas, action_value, args)\n    else:\n        self._run_sync_action(service, action_def.schemas, action_value, args)\n</code></pre>"},{"location":"reference/actions/ark_action/","title":"ark_action","text":""},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction","title":"<code>ArkAction</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>class ArkAction(ABC):\n    def __init__(self):\n        self._logger = get_logger(app=self.__class__.__name__)\n\n    def _common_actions_configuration(self, parser: argparse.ArgumentParser) -&gt; None:\n        parser.add_argument('-r', '--raw', action='store_true', help='Whether to raw output')\n        parser.add_argument('-s', '--silent', action='store_true', help='Silent execution, no interactiveness')\n        parser.add_argument('-ao', '--allow-output', action='store_true', help='Allow stdout / stderr even when silent and not interactive')\n        parser.add_argument('-v', '--verbose', action='store_true', help='Whether to verbose log')\n        parser.add_argument('-ls', '--logger-style', choices=['default'], help='Which verbose logger style to use', default='default')\n        parser.add_argument(\n            '-ll',\n            '--log-level',\n            help='Log level to use while verbose',\n            choices=['DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL'],\n            default='INFO',\n        )\n        parser.add_argument(\n            '-dcv', '--disable-cert-verification', action='store_true', help='Disables certificate verification on HTTPS calls, unsafe!'\n        )\n        parser.add_argument('-tc', '--trusted-cert', help='Certificate to use for HTTPS calls')\n\n    def _common_actions_execution(self, args: argparse.Namespace) -&gt; None:\n        ArkSystemConfig.enable_color()\n        ArkSystemConfig.enable_interactive()\n        ArkSystemConfig.disable_verbose_logging()\n        ArkSystemConfig.disallow_output()\n        ArkSystemConfig.set_logger_style(args.logger_style)\n        ArkSystemConfig.enable_certificate_verification()\n        if args.raw:\n            ArkSystemConfig.disable_color()\n        if args.silent:\n            ArkSystemConfig.disable_interactive()\n        if args.verbose:\n            ArkSystemConfig.enable_verbose_logging(args.log_level)\n        if args.allow_output:\n            ArkSystemConfig.allow_output()\n        if args.disable_cert_verification:\n            ArkSystemConfig.disable_certificate_verification()\n        elif args.trusted_cert is not None:\n            ArkSystemConfig.set_trusted_certificate(args.trusted_cert)\n        self._logger = get_logger(app=self.__class__.__name__)\n        if 'profile-name' in args:\n            args.profile_name = ArkProfileLoader.deduce_profile_name(args.profile_name)\n        if 'DEPLOY_ENV' not in os.environ:\n            # Last fallback on deploy env\n            os.environ['DEPLOY_ENV'] = 'prod'\n\n    @abstractmethod\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the action as part of the specified subparsers group.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the actual action with the given arguments.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the given action can be run with the specified arguments.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the given action can be run with the specified arguments.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the given action can be run with the specified arguments.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.define_action","title":"<code>define_action(subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines the action as part of the specified subparsers group.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the action as part of the specified subparsers group.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.run_action","title":"<code>run_action(args)</code>  <code>abstractmethod</code>","text":"<p>Runs the actual action with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the actual action with the given arguments.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_cache_action/","title":"ark_cache_action","text":""},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction","title":"<code>ArkCacheAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>class ArkCacheAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `cache` action, and adds the clear cache function.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n        self._common_actions_configuration(cache_parser)\n        cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n        cache_cmd_subparsers.required = True\n        cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n\n    def __run_clear_cache_action(self) -&gt; None:\n        if isinstance(ArkKeyring.get_keyring(), BasicKeyring):\n            cache_folder_path = os.path.join(os.path.expanduser('~'), DEFAULT_BASIC_KEYRING_FOLDER)\n            if ARK_BASIC_KEYRING_FOLDER_ENV_VAR in os.environ:\n                cache_folder_path = os.environ[ARK_BASIC_KEYRING_FOLDER_ENV_VAR]\n            os.unlink(f'{cache_folder_path}{os.sep}keyring')\n            os.unlink(f'{cache_folder_path}{os.sep}mac')\n        else:\n            ArkArgsFormatter.print_normal('Cache clear is only valid for basic keyring implementation at the moment')\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the cache action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        if args.cache_cmd == 'clear':\n            self.__run_clear_cache_action()\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `cache`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>cache</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `cache`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>cache</code> action, and adds the clear cache function.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `cache` action, and adds the clear cache function.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n    self._common_actions_configuration(cache_parser)\n    cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n    cache_cmd_subparsers.required = True\n    cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the cache action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the cache action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    if args.cache_cmd == 'clear':\n        self.__run_clear_cache_action()\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/ark_configure_action/","title":"ark_configure_action","text":""},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction","title":"<code>ArkConfigureAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>class ArkConfigureAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `configure` action.\n        For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n        self._common_actions_configuration(conf_parser)\n\n        # Add the profile settings to the arguments\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkProfile.model_json_schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n        )\n\n        # Add the supported authenticator settings and whether to work with them or not\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            conf_parser.add_argument(\n                f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n                f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n                action='store_true',\n                help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                conf_parser.add_argument(\n                    f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                    f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                    choices=[am.value for am in authenticator.supported_auth_methods()],\n                    default=ArkAuthMethod.Default.value,\n                )\n            # Add the rest of the ark auth profile params\n            ArkPydanticArgparse.schema_to_argparse(\n                ArkAuthProfile.model_json_schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n            )\n\n            # Add the supported authentication methods settings of the authenticators\n            for auth_method in authenticator.supported_auth_methods():\n                auth_settings = ArkAuthMethodSettingsMap[auth_method]\n                ArkPydanticArgparse.schema_to_argparse(\n                    auth_settings.model_json_schema(by_alias=False),\n                    conf_parser,\n                    key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                    ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n                )\n\n    def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Performs an interactive configuration.\n        The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n        Selected authenticators are also configured with the user's auth methods and settings.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile first with the given profile name from the user\n        profile_name = ArkArgsFormatter.get_arg(\n            args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n        )\n        profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n        # Fill the rest of the profile settings\n        profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n            ArkProfile.model_json_schema(by_alias=False),\n            args,\n            ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS,\n            existing_values=profile.model_dump(),\n        )\n        profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n        if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n            work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n        else:\n            work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n                args,\n                [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n                'Which authenticators would you like to connect to',\n                [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n                {\n                    f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                    for a in SUPPORTED_AUTHENTICATORS_LIST\n                    if a.authenticator_name() in profile.auth_profiles\n                },\n                True,\n            )\n        for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n            # Find out if we are working with the authenticator\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n                # Get the authenticator auth method\n                ArkArgsFormatter.print_success_bright(\n                    ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n                )\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    auth_method = ArkArgsFormatter.get_switch_arg(\n                        args,\n                        f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                        'Authentication Method',\n                        [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                        (\n                            ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                            if authenticator.authenticator_name() in profile.auth_profiles\n                            else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]]\n                        ),\n                        prioritize_existing_val=True,\n                    )\n                    auth_method = next(\n                        # pylint: disable-next=cell-var-from-loop\n                        filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                    )\n                    # If the default is chosen, override it by the authenticator's default\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n                ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                    authenticator.authenticator_name(), []\n                )\n                # Get the auth profile general settings\n                auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    ArkAuthProfile.model_json_schema(by_alias=False),\n                    args,\n                    ignored_keys=ignored_keys,\n                    existing_values=auth_profile.model_dump(),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    auth_profile_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignore_keys=['auth_method_settings'],\n                )\n\n                # Get the auth method settings and fill them\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(auth_profile.auth_method_settings)\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    method_settings.model_json_schema(by_alias=False),\n                    args,\n                    existing_values=method_settings.model_dump(),\n                    override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                    empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                    default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n                )\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Runs the CLI configure action silently, without user interaction.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile based on the cli params and merge the rest of the params\n        profile = ArkPydanticArgparse.merge_by_model(\n            ArkProfile,\n            ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n            ArkPydanticArgparse.argparse_to_schema(ArkProfile.model_json_schema(by_alias=False), args),\n        )\n\n        # Load the authenticators\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    # Load the auth method\n                    auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                    # If default, fallback to default auth method of the authenticator\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n\n                # Load the rest of the auth profile\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    ArkPydanticArgparse.argparse_to_schema(\n                        ArkAuthProfile.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                    ),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n\n                # Make sure if the type requires credentials, a username was supplied\n                if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                    raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n                # Load the method settings\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(method_settings)\n\n                # Parse and merge the method settings from the cli\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                    method_settings.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                )\n\n                # Remove the postfix\n                method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    defaults={\n                        k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                        for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                        if k.startswith(f'{authenticator.authenticator_name()}_')\n                    },\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the configure action.\n        Prompts the user when interactive mode is run, based on the associated authenticators,\n        and saves the configured profile when completed.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n        # Parse the profile\n        self._common_actions_execution(args)\n        profile: Optional[ArkProfile] = None\n        if ArkSystemConfig.is_interactive():\n            profile = self.__run_interactive_action(args)\n        else:\n            profile = self.__run_silent_action(args)\n\n        # Store it\n        ArkProfileLoader.save_profile(profile)\n\n        # Print out results\n        ArkArgsFormatter.print_success(profile.model_dump_json(indent=4))\n        ArkArgsFormatter.print_success_bright(\n            f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `configure`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.__run_interactive_action","title":"<code>__run_interactive_action(args)</code>","text":"<p>Performs an interactive configuration. The user is prompted for each Ark profile setting, with the default/defined CLI arguments. Selected authenticators are also configured with the user's auth methods and settings.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Performs an interactive configuration.\n    The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n    Selected authenticators are also configured with the user's auth methods and settings.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile first with the given profile name from the user\n    profile_name = ArkArgsFormatter.get_arg(\n        args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n    )\n    profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n    # Fill the rest of the profile settings\n    profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n        ArkProfile.model_json_schema(by_alias=False),\n        args,\n        ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS,\n        existing_values=profile.model_dump(),\n    )\n    profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n    if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n        work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n    else:\n        work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n            args,\n            [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n            'Which authenticators would you like to connect to',\n            [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n            {\n                f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                for a in SUPPORTED_AUTHENTICATORS_LIST\n                if a.authenticator_name() in profile.auth_profiles\n            },\n            True,\n        )\n    for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n        # Find out if we are working with the authenticator\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n            # Get the authenticator auth method\n            ArkArgsFormatter.print_success_bright(\n                ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                auth_method = ArkArgsFormatter.get_switch_arg(\n                    args,\n                    f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                    'Authentication Method',\n                    [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                    (\n                        ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                        if authenticator.authenticator_name() in profile.auth_profiles\n                        else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]]\n                    ),\n                    prioritize_existing_val=True,\n                )\n                auth_method = next(\n                    # pylint: disable-next=cell-var-from-loop\n                    filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                )\n                # If the default is chosen, override it by the authenticator's default\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n            ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                authenticator.authenticator_name(), []\n            )\n            # Get the auth profile general settings\n            auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                ArkAuthProfile.model_json_schema(by_alias=False),\n                args,\n                ignored_keys=ignored_keys,\n                existing_values=auth_profile.model_dump(),\n                key_prefix=authenticator.authenticator_name(),\n            )\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                auth_profile_vals,\n                key_prefix=authenticator.authenticator_name(),\n                ignore_keys=['auth_method_settings'],\n            )\n\n            # Get the auth method settings and fill them\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(auth_profile.auth_method_settings)\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                method_settings.model_json_schema(by_alias=False),\n                args,\n                existing_values=method_settings.model_dump(),\n                override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                key_prefix=authenticator.authenticator_name(),\n                ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n            )\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.__run_silent_action","title":"<code>__run_silent_action(args)</code>","text":"<p>Runs the CLI configure action silently, without user interaction.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Runs the CLI configure action silently, without user interaction.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile based on the cli params and merge the rest of the params\n    profile = ArkPydanticArgparse.merge_by_model(\n        ArkProfile,\n        ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n        ArkPydanticArgparse.argparse_to_schema(ArkProfile.model_json_schema(by_alias=False), args),\n    )\n\n    # Load the authenticators\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                # Load the auth method\n                auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                # If default, fallback to default auth method of the authenticator\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n\n            # Load the rest of the auth profile\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                ArkPydanticArgparse.argparse_to_schema(\n                    ArkAuthProfile.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                ),\n                key_prefix=authenticator.authenticator_name(),\n            )\n\n            # Make sure if the type requires credentials, a username was supplied\n            if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n            # Load the method settings\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].model_validate(method_settings)\n\n            # Parse and merge the method settings from the cli\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                method_settings.model_json_schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n            )\n\n            # Remove the postfix\n            method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n                defaults={\n                    k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                    for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                    if k.startswith(f'{authenticator.authenticator_name()}_')\n                },\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>configure</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `configure`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>configure</code> action. For each supported authenticator, sets whether it is used and adds the appropriate parameters.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `configure` action.\n    For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n    self._common_actions_configuration(conf_parser)\n\n    # Add the profile settings to the arguments\n    ArkPydanticArgparse.schema_to_argparse(\n        ArkProfile.model_json_schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n    )\n\n    # Add the supported authenticator settings and whether to work with them or not\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        conf_parser.add_argument(\n            f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n            f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n            action='store_true',\n            help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n        )\n        if len(authenticator.supported_auth_methods()) &gt; 1:\n            conf_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                choices=[am.value for am in authenticator.supported_auth_methods()],\n                default=ArkAuthMethod.Default.value,\n            )\n        # Add the rest of the ark auth profile params\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkAuthProfile.model_json_schema(by_alias=False),\n            conf_parser,\n            key_prefix=authenticator.authenticator_name().replace('_', '-'),\n            ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n        )\n\n        # Add the supported authentication methods settings of the authenticators\n        for auth_method in authenticator.supported_auth_methods():\n            auth_settings = ArkAuthMethodSettingsMap[auth_method]\n            ArkPydanticArgparse.schema_to_argparse(\n                auth_settings.model_json_schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n            )\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the configure action. Prompts the user when interactive mode is run, based on the associated authenticators, and saves the configured profile when completed.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the configure action.\n    Prompts the user when interactive mode is run, based on the associated authenticators,\n    and saves the configured profile when completed.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n    # Parse the profile\n    self._common_actions_execution(args)\n    profile: Optional[ArkProfile] = None\n    if ArkSystemConfig.is_interactive():\n        profile = self.__run_interactive_action(args)\n    else:\n        profile = self.__run_silent_action(args)\n\n    # Store it\n    ArkProfileLoader.save_profile(profile)\n\n    # Print out results\n    ArkArgsFormatter.print_success(profile.model_dump_json(indent=4))\n    ArkArgsFormatter.print_success_bright(\n        f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n    )\n</code></pre>"},{"location":"reference/actions/ark_exec_action/","title":"ark_exec_action","text":""},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction","title":"<code>ArkExecAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>class ArkExecAction(ArkAction):\n    def _serialize_output(self, output: Optional[Union[List, Dict, ArkModel, Generator, Tuple, Any]]) -&gt; str:\n        if output is None:\n            return ''\n        if isinstance(output, Generator):\n            return self._serialize_output(list(itertools.chain.from_iterable([p.items for p in output])))\n        if isinstance(output, list):\n            return json.dumps(\n                [\n                    (\n                        json.loads(a.model_dump_json(by_alias=False, exclude={'poll_progress_callback'}))\n                        if issubclass(type(a), ArkModel)\n                        else a\n                    )\n                    for a in output\n                    if a is not None\n                ],\n                indent=4,\n            )\n        elif isinstance(output, tuple):\n            return json.dumps(\n                [\n                    (\n                        json.loads(a.model_dump_json(by_alias=False, exclude={'poll_progress_callback'}))\n                        if issubclass(type(a), ArkModel)\n                        else a\n                    )\n                    for a in output\n                    if a is not None\n                ],\n                indent=4,\n            )\n        elif isinstance(output, dict):\n            return json.dumps(\n                {\n                    k: (\n                        json.loads(v.model_dump_json(indent=4, by_alias=False, exclude={'poll_progress_callback'}))\n                        if issubclass(type(v), ArkModel)\n                        else v\n                    )\n                    for k, v in output.items()\n                    if k is not None and v is not None\n                },\n                indent=4,\n            )\n        elif issubclass(type(output), ArkModel):\n            return output.model_dump_json(indent=4, by_alias=False, exclude={'poll_progress_callback'})\n        elif issubclass(type(output), ArkAsyncRequest):\n            return output.async_task.model_dump_json(indent=4, by_alias=False)\n        return str(output)\n\n    def _write_output_to_file(self, output_path: str, serialized_output: str) -&gt; None:\n        output_path = os.path.abspath(output_path)\n        if not os.path.exists(os.path.dirname(output_path)):\n            os.makedirs(os.path.dirname(output_path), exist_ok=True)\n        with open(output_path, 'w', encoding='utf-8') as f:\n            f.write(serialized_output)\n\n    def _run_async_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            model: ArkPollableModel = model_type.model_validate(\n                ArkPydanticArgparse.argparse_to_schema(model_type.model_json_schema(), args)\n            )\n            model.poll_progress_callback = ArkPollers.default_poller()\n            output = getattr(service, action.replace('-', '_'))(model)\n            async_req = None\n            if issubclass(type(output), ArkAsyncRequest):\n                async_req = output\n            elif isinstance(output, tuple):\n                for a in output:\n                    if issubclass(type(a), ArkAsyncRequest):\n                        async_req = a\n                        break\n            if async_req is not None:\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path, async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})\n                    )\n                if async_req.task_failed():\n                    if async_req.task_timeout():\n                        ArkArgsFormatter.print_warning(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                    else:\n                        ArkArgsFormatter.print_failure(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                else:\n                    ArkArgsFormatter.print_success(self._serialize_output(output))\n            elif isinstance(output, list) and all(issubclass(type(ar), ArkAsyncRequest) for ar in output):\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path,\n                        json.dumps(\n                            [ar.async_task.model_dump(indent=4, by_alias=False, exclude={\"poll_progress_callback\"}) for ar in output]\n                        ),\n                    )\n                for ar in output:\n                    if ar.task_failed():\n                        if ar.task_timeout():\n                            ArkArgsFormatter.print_warning(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                        else:\n                            ArkArgsFormatter.print_failure(\n                                f'Failed to execute async command, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command, error:\\n{ar.async_task.model_dump_json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                    else:\n                        ArkArgsFormatter.print_success(self._serialize_output(ar))\n            elif output is not None:\n                ArkArgsFormatter.print_success(self._serialize_output(output))\n        except Exception as ex:\n            self._logger.exception(f'Failed running async command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute async command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _run_sync_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            if model_type:\n                model: ArkModel = model_type.model_validate(ArkPydanticArgparse.argparse_to_schema(model_type.model_json_schema(), args))\n                output = getattr(service, action.replace('-', '_'))(model)\n            else:\n                output = getattr(service, action.replace('-', '_'))()\n            if output is not None:\n                serialized_output: str = self._serialize_output(output)\n                if args.output_path:\n                    self._write_output_to_file(args.output_path, serialized_output)\n                ArkArgsFormatter.print_success(serialized_output)\n            else:\n                ArkArgsFormatter.print_success(f'{action.replace(\"-\", \" \").title()} finished successfully')\n        except Exception as ex:\n            self._logger.exception(f'Failed running command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _define_actions_by_schemas(\n        self,\n        subparsers: argparse._SubParsersAction,\n        schemas_map: Dict[str, Optional[Type[ArkModel]]],\n        defaults_map: Optional[Dict[str, Dict[str, Any]]] = None,\n    ):\n        for action, schema in schemas_map.items():\n            parser = subparsers.add_parser(action)\n            if schema:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema.model_json_schema(), parser, defaults=defaults_map.get(action, None) if defaults_map else None\n                )\n\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        exec_parser = None\n        exec_subparsers = None\n        # Check if the exec subparser already exists from previous definitions of a service\n        if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n            # Retrieve the existing exec parser\n            exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n            exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n        else:\n            # Create a new exec parser\n            exec_parser = subparsers.add_parser('exec')\n            self._common_actions_configuration(exec_parser)\n            exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n            exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n            exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n            exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n            exec_parser.add_argument(\n                '-ra',\n                '--refresh-auth',\n                action='store_true',\n                help='If possible, will try to refresh the active authentication before running the actual command',\n            )\n            exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n            exec_subparsers.required = True\n        self.define_exec_action(exec_subparsers)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action.\n        Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n        Each service is created from the API, based on the given authenticators, and then\n        runs the exec action using the API.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile and login before trying to exec')\n\n        # Load token from cache for each auth profile\n        authenticators: List[ArkAuth] = []\n        for authenticator_name in profile.auth_profiles.keys():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n            if not authenticator.load_authentication(profile, args.refresh_auth):\n                continue\n            authenticators.append(authenticator)\n\n        if len(authenticators) == 0:\n            raise ArkException(\n                'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n            )\n        if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n            ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n        # Create the CLI API with the authenticators\n        api = ArkCLIAPI(authenticators, profile)\n\n        # Run the actual exec fitting action with the api\n        # Run it with retries as per defined by user\n        ArkRetry.retry_call(\n            self.run_exec_action,\n            fargs=[api, args],\n            tries=args.retry_count,\n            delay=1,\n            logger=namedtuple(\"logger\", (\"warning\"))(\n                warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n            ),\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `exec`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n\n    @abstractmethod\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines an exec action, and its specified configurations and args, for a service.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action for a service with the specified arguments and API.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the specified exec service action can be run.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>exec</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `exec`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the specified exec service action can be run.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the specified exec service action can be run.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>exec</code> action, with its subparsers (args) for the service.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    exec_parser = None\n    exec_subparsers = None\n    # Check if the exec subparser already exists from previous definitions of a service\n    if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n        # Retrieve the existing exec parser\n        exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n        exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n    else:\n        # Create a new exec parser\n        exec_parser = subparsers.add_parser('exec')\n        self._common_actions_configuration(exec_parser)\n        exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n        exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n        exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n        exec_parser.add_argument(\n            '-ra',\n            '--refresh-auth',\n            action='store_true',\n            help='If possible, will try to refresh the active authentication before running the actual command',\n        )\n        exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n        exec_subparsers.required = True\n    self.define_exec_action(exec_subparsers)\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines an exec action, and its specified configurations and args, for a service.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines an exec action, and its specified configurations and args, for a service.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the exec action. Loads the authenticators from the cache and connects to the API using the loaded authenticators. Each service is created from the API, based on the given authenticators, and then runs the exec action using the API.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action.\n    Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n    Each service is created from the API, based on the given authenticators, and then\n    runs the exec action using the API.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile and login before trying to exec')\n\n    # Load token from cache for each auth profile\n    authenticators: List[ArkAuth] = []\n    for authenticator_name in profile.auth_profiles.keys():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n        if not authenticator.load_authentication(profile, args.refresh_auth):\n            continue\n        authenticators.append(authenticator)\n\n    if len(authenticators) == 0:\n        raise ArkException(\n            'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n        )\n    if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n        ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n    # Create the CLI API with the authenticators\n    api = ArkCLIAPI(authenticators, profile)\n\n    # Run the actual exec fitting action with the api\n    # Run it with retries as per defined by user\n    ArkRetry.retry_call(\n        self.run_exec_action,\n        fargs=[api, args],\n        tries=args.retry_count,\n        delay=1,\n        logger=namedtuple(\"logger\", (\"warning\"))(\n            warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n        ),\n    )\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>  <code>abstractmethod</code>","text":"<p>Runs the exec action for a service with the specified arguments and API.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action for a service with the specified arguments and API.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_login_action/","title":"ark_login_action","text":""},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction","title":"<code>ArkLoginAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>class ArkLoginAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `login` action.\n        For each supported authenticator, adds the username/secret params for logging in.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n        self._common_actions_configuration(login_parser)\n        login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n        login_parser.add_argument(\n            '-nss',\n            '--no-shared-secrets',\n            action='store_true',\n            help='Do not share secrets between different authenticators with the same username',\n        )\n        login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n        login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n        # Add username and secret for each authenticator for logging in\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n                help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n                help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the login action for each authenticator.\n        After a login completes, credentials are stored in the keyring for future use.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        # Load up the profile\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile before trying to login')\n\n        # Login for each auth profile\n        # Share secrets between authenticators for allowed auth methods\n        shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n        # Save tokens for finalization output\n        tokens_map: Dict[str, ArkToken] = dict()\n        for authenticator_name, auth_profile in profile.auth_profiles.items():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n            # Only perform the authentication if not already authenticated and not forced\n            if authenticator.is_authenticated(profile) and not args.force:\n                try:\n                    if args.refresh_auth:\n                        token = authenticator.load_authentication(profile, True)\n                        if token:\n                            ArkArgsFormatter.print_success(\n                                f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                            )\n                        else:\n                            raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                    else:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                        )\n                    continue\n                except Exception as ex:\n                    self._logger.info(\n                        f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                    )\n            secret = (\n                ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n            )\n            auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n            # Ask the user for the user and secret if interactive\n            if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n                auth_profile.username = ArkArgsFormatter.get_arg(\n                    args,\n                    f'{authenticator_name}_username',\n                    f'{authenticator.authenticator_human_readable_name()} Username',\n                    auth_profile.username,\n                )\n                # Check if there is an existing secret who is sharable\n                if (\n                    auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                    and auth_profile.auth_method in shared_secrets_map\n                    and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                    and not args.__dict__[f'{authenticator_name}_secret']\n                    and not args.no_shared_secrets\n                ):\n                    # pylint: disable-next=cell-var-from-loop\n                    secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n                else:\n                    if not args.force and (\n                        (\n                            auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                        )\n                    ):\n                        # Check if there is a secret already cached, if there is, no need to ask for password\n                        secret = ArkSecret(secret='')\n                    else:\n                        # Check if we really need to ask for a password in specific use cases\n                        if (\n                            authenticator_name == 'isp'\n                            and auth_profile.auth_method == ArkAuthMethod.Identity\n                            and not ArkIdentity.is_password_required(\n                                auth_profile.username,\n                                (\n                                    auth_profile.auth_method_settings.identity_url\n                                    if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                    else None\n                                ),\n                                (\n                                    auth_profile.auth_method_settings.identity_tenant_subdomain\n                                    if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                    else None\n                                ),\n                            )\n                        ):\n                            secret = ArkSecret(secret='')\n                        else:\n                            secret = ArkSecret(\n                                secret=ArkArgsFormatter.get_arg(\n                                    args,\n                                    f'{authenticator_name}_secret',\n                                    f'{authenticator.authenticator_human_readable_name()} Secret',\n                                    hidden=True,\n                                )\n                            )\n            elif (\n                not ArkSystemConfig.is_interactive()\n                and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n                and not args.__dict__[f'{authenticator_name}_secret']\n            ):\n                raise ArkException(\n                    f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n                )\n            # Perform the authentication, will also cache the token\n            token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n            if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n                shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n            tokens_map[authenticator.authenticator_human_readable_name()] = token\n        if not args.show_tokens and tokens_map:\n            ArkArgsFormatter.print_success('Login tokens are hidden')\n        for k, v in tokens_map.items():\n            if 'cookies' in v.metadata:\n                del v.metadata['cookies']\n            ArkArgsFormatter.print_success(\n                f'{k} Token\\n{v.model_dump_json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n            )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `login`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>login</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `login`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>login</code> action. For each supported authenticator, adds the username/secret params for logging in.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `login` action.\n    For each supported authenticator, adds the username/secret params for logging in.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n    self._common_actions_configuration(login_parser)\n    login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n    login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n    login_parser.add_argument(\n        '-nss',\n        '--no-shared-secrets',\n        action='store_true',\n        help='Do not share secrets between different authenticators with the same username',\n    )\n    login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n    login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n    # Add username and secret for each authenticator for logging in\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n            help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n            help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the login action for each authenticator. After a login completes, credentials are stored in the keyring for future use.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the login action for each authenticator.\n    After a login completes, credentials are stored in the keyring for future use.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    # Load up the profile\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile before trying to login')\n\n    # Login for each auth profile\n    # Share secrets between authenticators for allowed auth methods\n    shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n    # Save tokens for finalization output\n    tokens_map: Dict[str, ArkToken] = dict()\n    for authenticator_name, auth_profile in profile.auth_profiles.items():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n        # Only perform the authentication if not already authenticated and not forced\n        if authenticator.is_authenticated(profile) and not args.force:\n            try:\n                if args.refresh_auth:\n                    token = authenticator.load_authentication(profile, True)\n                    if token:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                        )\n                    else:\n                        raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                else:\n                    ArkArgsFormatter.print_success(\n                        f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                    )\n                continue\n            except Exception as ex:\n                self._logger.info(\n                    f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                )\n        secret = (\n            ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n        )\n        auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n        # Ask the user for the user and secret if interactive\n        if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n            auth_profile.username = ArkArgsFormatter.get_arg(\n                args,\n                f'{authenticator_name}_username',\n                f'{authenticator.authenticator_human_readable_name()} Username',\n                auth_profile.username,\n            )\n            # Check if there is an existing secret who is sharable\n            if (\n                auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                and auth_profile.auth_method in shared_secrets_map\n                and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                and not args.__dict__[f'{authenticator_name}_secret']\n                and not args.no_shared_secrets\n            ):\n                # pylint: disable-next=cell-var-from-loop\n                secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n            else:\n                if not args.force and (\n                    (\n                        auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                    )\n                ):\n                    # Check if there is a secret already cached, if there is, no need to ask for password\n                    secret = ArkSecret(secret='')\n                else:\n                    # Check if we really need to ask for a password in specific use cases\n                    if (\n                        authenticator_name == 'isp'\n                        and auth_profile.auth_method == ArkAuthMethod.Identity\n                        and not ArkIdentity.is_password_required(\n                            auth_profile.username,\n                            (\n                                auth_profile.auth_method_settings.identity_url\n                                if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                else None\n                            ),\n                            (\n                                auth_profile.auth_method_settings.identity_tenant_subdomain\n                                if isinstance(auth_profile.auth_method_settings, IdentityArkAuthMethodSettings)\n                                else None\n                            ),\n                        )\n                    ):\n                        secret = ArkSecret(secret='')\n                    else:\n                        secret = ArkSecret(\n                            secret=ArkArgsFormatter.get_arg(\n                                args,\n                                f'{authenticator_name}_secret',\n                                f'{authenticator.authenticator_human_readable_name()} Secret',\n                                hidden=True,\n                            )\n                        )\n        elif (\n            not ArkSystemConfig.is_interactive()\n            and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n            and not args.__dict__[f'{authenticator_name}_secret']\n        ):\n            raise ArkException(\n                f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n            )\n        # Perform the authentication, will also cache the token\n        token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n        if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n            shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n        tokens_map[authenticator.authenticator_human_readable_name()] = token\n    if not args.show_tokens and tokens_map:\n        ArkArgsFormatter.print_success('Login tokens are hidden')\n    for k, v in tokens_map.items():\n        if 'cookies' in v.metadata:\n            del v.metadata['cookies']\n        ArkArgsFormatter.print_success(\n            f'{k} Token\\n{v.model_dump_json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n        )\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/","title":"ark_profiles_action","text":""},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction","title":"<code>ArkProfilesAction</code>","text":"<p>               Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>class ArkProfilesAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n        self._common_actions_configuration(profile_parser)\n        profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n        profile_cmd_subparsers.required = True\n        list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n        list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n        list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n        list_profiles_parser.add_argument(\n            '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n        )\n        show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n        show_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n        )\n        delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n        delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n        delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n        clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n        clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n        clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n        clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n        clone_profile_parser.add_argument(\n            '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n        )\n        clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n        add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n        add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n        edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n        edit_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n        )\n\n    def __run_list_action(self, args: argparse.Namespace) -&gt; None:\n        # Start by loading all the profiles\n        profiles: Optional[List[ArkProfile]] = ArkProfileLoader.load_all_profiles()\n        if not profiles:\n            ArkArgsFormatter.print_warning(\n                'No profiles were found',\n            )\n            return\n        # Filter profiles\n        if args.name:\n            profiles = [p for p in profiles if fnmatch(p.profile_name, args.name)]\n        if args.auth_profile:\n            profiles = [p for p in profiles if args.auth_profile in list(p.auth_profiles.keys())]\n        # Print them based on request\n        if args.all:\n            ArkArgsFormatter.print_success(json.dumps([p.model_dump() for p in profiles], indent=4))\n        else:\n            ArkArgsFormatter.print_success(json.dumps([p.profile_name for p in profiles], indent=4))\n\n    def __run_show_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        ArkArgsFormatter.print_success(profile.model_dump_json(indent=4))\n\n    def __run_delete_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message=f'Are you sure you want to delete profile {args.profile_name}')],\n                render=ArkInquirerRender(),\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.delete_profile(args.profile_name)\n\n    def __run_clear_action(self, args: argparse.Namespace) -&gt; None:\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message='Are you sure you want to clear all profiles')], render=ArkInquirerRender()\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.clear_all_profiles()\n\n    def __run_clone_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        cloned_profile: ArkProfile = profile.copy(update={'profile_name': args.new_profile_name or f'{profile.profile_name}_clone'})\n        if ArkProfileLoader.profile_exists(cloned_profile.profile_name):\n            if not args.yes:\n                answer = inquirer.prompt(\n                    [\n                        inquirer.Confirm(\n                            'answer', message=f'Are you sure you want to override existing profile {cloned_profile.profile_name}'\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answer or not answer['answer']:\n                    return\n        ArkProfileLoader.save_profile(cloned_profile)\n\n    def __run_add_action(self, args: argparse.Namespace) -&gt; None:\n        if not os.path.exists(args.profile_path):\n            ArkArgsFormatter.print_warning(\n                f'Profile path [{args.profile_path}] does not exist, ignoring',\n            )\n            return\n        try:\n            with open(args.profile_path, 'r', encoding='utf-8') as fh:\n                profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n            ArkProfileLoader.save_profile(profile)\n        except Exception as ex:\n            self._logger.exception(f'Failed to parser profile [{str(ex)}]')\n            ArkArgsFormatter.print_failure(\n                f'Profile path [{args.profile_path}] failed to be parsed, aborting',\n            )\n            return\n\n    def __run_edit_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        answer = inquirer.prompt(\n            [inquirer.Editor('profile_edit', message=f'Chosen profile [{profile_name}] is about to be edited')],\n            render=ArkInquirerRender(),\n            answers={'profile_edit': profile.model_dump_json(indent=4)},\n        )\n        edited_profile = ArkProfile.model_validate_json(answer['profile_edit'])\n        ArkProfileLoader.save_profile(edited_profile)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the profile action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.profile_cmd == 'list':\n            self.__run_list_action(args)\n        elif args.profile_cmd == 'show':\n            self.__run_show_action(args)\n        elif args.profile_cmd == 'delete':\n            self.__run_delete_action(args)\n        elif args.profile_cmd == 'clear':\n            self.__run_clear_action(args)\n        elif args.profile_cmd == 'clone':\n            self.__run_clone_action(args)\n        elif args.profile_cmd == 'add':\n            self.__run_add_action(args)\n        elif args.profile_cmd == 'edit':\n            self.__run_edit_action(args)\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `profile`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>profile</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `profile`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>profile</code> action, and adds actions for managing multiple profiles.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n    self._common_actions_configuration(profile_parser)\n    profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n    profile_cmd_subparsers.required = True\n    list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n    list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n    list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n    list_profiles_parser.add_argument(\n        '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n    )\n    show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n    show_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n    )\n    delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n    delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n    delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n    clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n    clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n    clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n    clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n    clone_profile_parser.add_argument(\n        '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n    )\n    clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n    add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n    add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n    edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n    edit_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n    )\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the profile action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the profile action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.profile_cmd == 'list':\n        self.__run_list_action(args)\n    elif args.profile_cmd == 'show':\n        self.__run_show_action(args)\n    elif args.profile_cmd == 'delete':\n        self.__run_delete_action(args)\n    elif args.profile_cmd == 'clear':\n        self.__run_clear_action(args)\n    elif args.profile_cmd == 'clone':\n        self.__run_clone_action(args)\n    elif args.profile_cmd == 'add':\n        self.__run_add_action(args)\n    elif args.profile_cmd == 'edit':\n        self.__run_edit_action(args)\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/","title":"ark_service_exec_action","text":""},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction","title":"<code>ArkServiceExecAction</code>","text":"<p>               Bases: <code>ArkExecAction</code></p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>class ArkServiceExecAction(ArkExecAction):\n    def __define_service_exec_action(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; argparse._SubParsersAction:\n        action_parser = subparsers.add_parser(action_def.action_name)\n        action_dest = action_def.action_name\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}'\n        action_subparsers = action_parser.add_subparsers(dest=f\"{action_dest}_action\")\n        action_subparsers.required = True\n        if action_def.schemas:\n            self._define_actions_by_schemas(action_subparsers, action_def.schemas, action_def.defaults)\n        return action_subparsers\n\n    def __define_service_exec_actions(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; None:\n        action_subparsers = self.__define_service_exec_action(action_def, subparsers, parent_actions_def)\n        if action_def.subactions:\n            for subaction in action_def.subactions:\n                self.__define_service_exec_actions(\n                    subaction, action_subparsers, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                )\n\n    def __deduce_action_def(\n        self,\n        args: argparse.Namespace,\n        action_def: ArkServiceActionDefinition,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        action_dest = f'{action_def.action_name}_action'\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}_action'\n        if action_dest in args.__dict__:\n            action_value = args.__dict__[action_dest]\n            if action_def.subactions:\n                for subaction in action_def.subactions:\n                    if subaction.action_name == action_value:\n                        return self.__deduce_action_def(\n                            args, subaction, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                        )\n            return action_def, action_dest\n\n    def __deduce_action_command_def(self, command_name: str, args: argparse.Namespace) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        for action_def in SUPPORTED_SERVICE_ACTIONS:\n            if action_def.action_name == command_name:\n                # Find the fitting action\n                return self.__deduce_action_def(args, action_def)\n\n    @overrides\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        for actions in SUPPORTED_SERVICE_ACTIONS:\n            self.__define_service_exec_actions(actions, exec_subparsers)\n\n    @overrides\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Deduces from the arguments the appropriate service definition and action.\n        Finds the appropriate service using the definition and executes the sync or async service action.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n        action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n        action_value = args.__dict__[action_dest]\n        api_name = action_dest.replace('_action', '').replace('-', '_')\n        while '_' in api_name and not hasattr(api, api_name):\n            api_name = api_name.rsplit('_', 1)[0]\n        service = getattr(api, api_name)\n        if action_def.async_actions and action_value in action_def.async_actions:\n            self._run_async_action(service, action_def.schemas, action_value, args)\n        else:\n            self._run_sync_action(service, action_def.schemas, action_value, args)\n\n    @overrides\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether there is a service definition for the command and its actions.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>","text":"<p>Checks whether there is a service definition for the command and its actions.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether there is a service definition for the command and its actions.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>","text":"<p>Defines all the supported service actions as CLI actions, with its associated arguments and schemas.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    for actions in SUPPORTED_SERVICE_ACTIONS:\n        self.__define_service_exec_actions(actions, exec_subparsers)\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>","text":"<p>Deduces from the arguments the appropriate service definition and action. Finds the appropriate service using the definition and executes the sync or async service action.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Deduces from the arguments the appropriate service definition and action.\n    Finds the appropriate service using the definition and executes the sync or async service action.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n    action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n    action_value = args.__dict__[action_dest]\n    api_name = action_dest.replace('_action', '').replace('-', '_')\n    while '_' in api_name and not hasattr(api, api_name):\n        api_name = api_name.rsplit('_', 1)[0]\n    service = getattr(api, api_name)\n    if action_def.async_actions and action_value in action_def.async_actions:\n        self._run_async_action(service, action_def.schemas, action_value, args)\n    else:\n        self._run_sync_action(service, action_def.schemas, action_value, args)\n</code></pre>"},{"location":"reference/args/","title":"args","text":""},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse","title":"<code>ArkPydanticArgparse</code>","text":"Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>class ArkPydanticArgparse:\n    @staticmethod\n    def __populate_type(\n        prop_type: str,\n        snake_prop_name: str,\n        default: Optional[str],\n        required: bool,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        description: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        enum: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '-'\n        if ignore_keys != None and snake_prop_name in ignore_keys:\n            return\n        if default != None:\n            required = False\n        if isinstance(default, Enum):\n            default = default.value\n        arg_type = None\n        if prop_type == 'string':\n            arg_type = str\n        elif prop_type == 'integer':\n            arg_type = int\n        elif prop_type == 'boolean':\n            arg_type = bool\n        elif prop_type == 'object':\n            arg_type = object\n        else:\n            arg_type = str\n        long_name = key_prefix + prefix + snake_prop_name\n        shorted_name = ''.join([s[0] for s in long_name.replace('.', '-').split('-')])\n        for i in range(5):\n            for action in parser._actions:  # pylint: disable=protected-access\n                if f'-{shorted_name}' in action.option_strings:\n                    shorted_name = ''.join([s[: i + 1] for s in long_name.split('-')])\n                    break\n        if arg_type == bool:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                action='store_true',\n                help=description,\n            )\n            if long_name != 'poll':\n                parser.add_argument(\n                    '-n' + shorted_name,\n                    '--no-' + long_name,\n                    dest=long_name.replace('-', '_'),\n                    required='--request-file' not in ' '.join(sys.argv) and required,\n                    action='store_false',\n                    help=description,\n                )\n            parser.set_defaults(**{f\"{long_name.replace('-', '_')}\": default})\n        elif arg_type == object:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                metavar=\"KEY=VALUE\",\n                nargs='+',\n                default=default,\n                help=description,\n            )\n        else:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                type=arg_type,\n                default=default,\n                help=description,\n                choices=enum,\n            )\n\n    @staticmethod\n    def __schema_definition_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if not definitions:\n            return\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n        def_prop = definitions[def_prop_name]\n        if 'type' not in def_prop.keys():\n            return\n        prop_type = def_prop['type']\n        desc = ''\n        if 'description' in def_prop.keys():\n            desc = def_prop['description']\n        default: Optional[str] = None\n        if 'default' in def_prop.keys():\n            default = def_prop['default']\n        elif defaults and prefix + snake_prop_name in defaults:\n            default = defaults[snake_prop_name]\n        if prop_type == 'object':\n            ArkPydanticArgparse.schema_to_argparse(\n                def_prop, parser, defaults, f'{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n            )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in def_prop:\n                enum = def_prop['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n\n    @staticmethod\n    def __schema_allof_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        desc = ''\n        default: Optional[str] = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        for item in schema['properties'][prop_name]['allOf']:\n            if '$ref' in item.keys() and definitions:\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                if 'type' not in item.keys():\n                    continue\n                prop_type = item['type']\n                if 'default' in item.keys():\n                    default = item['default']\n                elif defaults and prefix + snake_prop_name in defaults:\n                    default = defaults[snake_prop_name]\n                if 'description' in item.keys():\n                    desc = item['description']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        item, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in item:\n                        enum = item['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n\n    @staticmethod\n    def __arg_in_schema(arg_key: str, schema: Dict[str, Any], definitions: Optional[Dict[str, Any]], prefix: str = '') -&gt; Optional[str]:\n        if 'properties' not in schema:\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if prefix + snake_prop_name == arg_key:\n                return schema['type']\n            else:\n                return None\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if '$ref' in schema['properties'][prop_name].keys():\n                def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        return 'string'\n                    continue\n                if def_prop['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    return def_prop['type']\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                for item in schema['properties'][prop_name]['allOf']:\n                    if '$ref' in item.keys():\n                        def_prop_name = item['$ref'].split('/')[2]\n                        def_prop = definitions[def_prop_name]\n                        if 'type' not in def_prop.keys():\n                            if 'enum' in def_prop.keys():\n                                return 'string'\n                            continue\n                        if def_prop['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                                return def_prop['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return def_prop['type']\n                    if 'type' in item.keys():\n                        if item['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, item, definitions, f'{prefix}{snake_prop_name}.'):\n                                return item['type']\n                        if item['type'] == 'null':\n                            continue\n                        if prefix + snake_prop_name == arg_key:\n                            return item['type']\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t or '$ref' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                if any('$ref' in t for t in schema['properties'][prop_name]['anyOf']):\n                    item = [t for t in schema['properties'][prop_name]['anyOf'] if '$ref' in t][0]\n                    def_prop_name = item['$ref'].split('/')[2]\n                    def_prop = definitions[def_prop_name]\n                    if 'type' not in def_prop.keys():\n                        if 'enum' in def_prop.keys():\n                            return 'string'\n                        continue\n                    if def_prop['type'] == 'object':\n                        if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                            return def_prop['type']\n                    if prefix + snake_prop_name == arg_key:\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    if any(t['type'] != 'null' for t in schema['properties'][prop_name]['anyOf']):\n                        return [t['type'] for t in schema['properties'][prop_name]['anyOf'] if t['type'] != 'null'][0]\n                    return 'string'\n            elif 'type' in schema['properties'][prop_name].keys():\n                if prefix + snake_prop_name == arg_key:\n                    return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(\n                        arg_key, schema['properties'][prop_name], definitions, f'{prefix}{snake_prop_name}.'\n                    ):\n                        return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'null':\n                    return None\n        return None\n\n    @staticmethod\n    def __parse_types(args: Dict[str, str]) -&gt; Dict[str, Any]:\n        parsed_args = {}\n        for k, v in args.items():\n            if not isinstance(v, str):\n                parsed_args[k] = v\n                continue\n            if v.lower() == 'true':\n                parsed_args[k] = True\n                continue\n            if v.lower() == 'false':\n                parsed_args[k] = False\n                continue\n            try:\n                parsed_args[k] = int(v)\n                continue\n            except:  # pylint: disable=bare-except\n                pass\n            try:\n                parsed_args[k] = float(v)\n                continue\n            except:  # pylint: disable=bare-except\n                pass\n            try:\n                parsed_args[k] = json.loads(v)\n                continue\n            except:  # pylint: disable=bare-except\n                pass\n            parsed_args[k] = v\n        return parsed_args\n\n    @staticmethod\n    def __arg_to_schema(\n        arg_key: str, arg_val: Any, args_map: Dict[str, Any], arg_type: str, keep_empty_values: bool = False, key_prefix: str = ''\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if '.' in arg_key:\n            args = arg_key.split('.')\n            key = args[0]\n            if key not in args_map.keys() or args_map[key] == None:\n                args_map[key] = {}\n            ArkPydanticArgparse.__arg_to_schema('.'.join(args[1:]), arg_val, args_map[key], arg_type, key_prefix)\n        elif arg_val != None or keep_empty_values:\n            if arg_type == 'array':\n                if isinstance(arg_val, list):\n                    args_map[key_prefix + arg_key] = arg_val\n                elif re.match('({.*},?)+', arg_val) != None:\n                    objs = []\n                    for m in re.finditer('{.*?}', arg_val):\n                        objs.append(json.loads(m.group(0)))\n                    args_map[key_prefix + arg_key] = objs\n                else:\n                    args_map[key_prefix + arg_key] = arg_val.split(',')\n            elif arg_type == 'object' and not isinstance(arg_val, (int, bool, float)):\n                if isinstance(arg_val, list):\n                    arg_val = ','.join(arg_val)\n                if '=' not in arg_val:\n                    args_map[key_prefix + arg_key] = arg_val\n                else:\n                    args_dict = dict(\n                        next(csv.reader([item], delimiter='=', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                        for item in next(csv.reader([arg_val], delimiter=',', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                    )\n                    if len(args_dict) &gt; 0:\n                        args_dict = ArkPydanticArgparse.__parse_types(args_dict)\n                        args_map[key_prefix + arg_key] = args_dict\n                    elif arg_key != 'extrafields':\n                        args_map[key_prefix + arg_key] = arg_val\n            else:\n                args_map[key_prefix + arg_key] = arg_val\n\n    @staticmethod\n    def schema_to_argparse(\n        schema: Dict[str, Any],\n        parser: argparse.ArgumentParser,\n        defaults: Optional[Dict[str, str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        required: Optional[List[str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        \"\"\"\n        Converts the given schema to argparse parameters.\n        Recursively iterates over the JSON schema and adds parameters to the parser.\n        The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n        This function does not return anything, but updates the parser itself.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            parser (argparse.ArgumentParser): _description_\n            defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            required (Optional[List[str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n        \"\"\"\n        if not definitions and '$defs' in schema.keys():\n            definitions = schema['$defs']\n        elif not definitions:\n            definitions = {}\n        if not required and 'required' in schema.keys():\n            required = schema['required']\n        elif not required:\n            required = []\n        if 'properties' not in schema.keys():\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema.keys():\n                default = schema['default']\n            desc = ''\n            if 'description' in schema.keys():\n                desc = schema['description']\n            enum = None\n            if 'enum' in schema:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            return\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if '$ref' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_definition_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_allof_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t or '$ref' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                if any('$ref' in t for t in schema['properties'][prop_name]['anyOf']):\n                    item = [t for t in schema['properties'][prop_name]['anyOf'] if '$ref' in t][0]\n                    def_prop_name = item['$ref'].split('/')[2]\n                    def_prop = definitions[def_prop_name]\n                    if 'type' not in def_prop.keys():\n                        if 'enum' in def_prop.keys():\n                            is_required = False\n                            if required and prop_name in required:\n                                is_required = True\n                            enum = def_prop['enum']\n                            ArkPydanticArgparse.__populate_type(\n                                'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                            )\n                        continue\n                    prop_type = def_prop['type']\n                    if prop_type == 'object':\n                        ArkPydanticArgparse.schema_to_argparse(\n                            def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                        )\n                    else:\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        default = None\n                        if 'default' in schema['properties'][prop_name].keys():\n                            default = schema['properties'][prop_name]['default']\n                        desc = ''\n                        if 'description' in schema['properties'][prop_name].keys():\n                            desc = schema['properties'][prop_name]['description']\n                        enum = None\n                        if 'enum' in def_prop:\n                            enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                else:\n                    is_required = False\n                    if prop_name in required:\n                        is_required = True\n                    default = None\n                    if 'default' in schema['properties'][prop_name].keys():\n                        default = schema['properties'][prop_name]['default']\n                    desc = ''\n                    if 'description' in schema['properties'][prop_name].keys():\n                        desc = schema['properties'][prop_name]['description']\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['enum']\n                    prop_type = 'string'\n                    if any(t['type'] != 'null' for t in schema['properties'][prop_name]['anyOf']) and all(\n                        t['type'] != 'string' for t in schema['properties'][prop_name]['anyOf']\n                    ):\n                        prop_type = [t['type'] for t in schema['properties'][prop_name]['anyOf'] if t['type'] != 'null'][0]\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                    continue\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            elif defaults and prefix + snake_prop_name in defaults.keys():\n                default = defaults[snake_prop_name]\n            if 'type' not in schema['properties'][prop_name].keys():\n                if 'enum' in schema['properties'][prop_name].keys():\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                continue\n            prop_type = schema['properties'][prop_name]['type']\n            if prop_type == 'object':\n                if (\n                    'properties' not in schema['properties'][prop_name]\n                    and (\n                        'additionalProperties' in schema['properties'][prop_name]\n                        and 'type' in schema['properties'][prop_name]['additionalProperties']\n                        and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                    )\n                    or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n                ):\n                    # Special use case for dicitionary\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                else:\n                    local_schema = schema['properties'][prop_name]\n                    if 'properties' not in local_schema.keys():\n                        prop_name = local_schema['title']\n                        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                        is_required = False\n                        if prop_name in required:\n                            is_required = True\n                        default = None\n                        if 'default' in schema.keys():\n                            default = local_schema['default']\n                        desc = ''\n                        if 'description' in schema.keys():\n                            desc = local_schema['description']\n                        enum = None\n                        if 'enum' in local_schema:\n                            enum = local_schema['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            local_schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                        continue\n                    ArkPydanticArgparse.schema_to_argparse(\n                        schema['properties'][prop_name],\n                        parser,\n                        defaults,\n                        f'{prefix}{snake_prop_name}.',\n                        definitions,\n                        required,\n                        ignore_keys,\n                        key_prefix,\n                    )\n            else:\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n\n    @staticmethod\n    def schema_to_aliases(\n        schema: Dict[str, Any],\n        override_aliases: Optional[Dict[str, str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        key_prefix: str = '',\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n        Converts a schema to only a dictionary containing its aliases (title).\n        Returns a string to string dictionary with the aliases.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n\n        Returns:\n            Dict[str, str]: _description_\n        \"\"\"\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if 'properties' not in schema:\n            return {}\n        if not definitions and '$defs' in schema.keys():\n            definitions = schema['$defs']\n        elif not definitions:\n            definitions = {}\n        if not override_aliases:\n            override_aliases = {}\n        aliases_map: Dict[str, Any] = {}\n        for prop_name in schema['properties']:\n            snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n                continue\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if snake_prop_name in override_aliases:\n                aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n            else:\n                aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n            if 'type' in schema['properties'][prop_name]:\n                if schema['properties'][prop_name]['type'] == 'object':\n                    aliases_map.update(\n                        ArkPydanticArgparse.schema_to_aliases(\n                            schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                        )\n                    )\n        return aliases_map\n\n    @staticmethod\n    def argparse_to_schema(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        keep_empty_values: bool = False,\n        key_prefix: str = '',\n        ignored_keys: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given JSON schema and argparse args into a finalized dictionary.\n        The conversion is recursive and converts keys according to snake case.\n\n        Returns a finalized args dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            keep_empty_values (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        file_args_map: Dict = {}\n        args_map: Dict = {}\n        definitions: Optional[Dict] = None\n        if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n            request_file = args.__dict__['request_file']\n            with open(request_file, 'r', encoding='utf-8') as f:\n                loaded_args_map = json.load(f)\n                for key, value in loaded_args_map.items():\n                    first, *others = key.split('_')\n                    file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n                    # Also add the snake case for models which are not camel based\n                    file_args_map[key] = value\n        if '$defs' in schema.keys():\n            definitions = schema['$defs']\n        for arg_key, arg_val in args.__dict__.items():\n            if ignored_keys and arg_key in ignored_keys:\n                continue\n            if key_prefix:\n                arg_key = arg_key.replace(f'{key_prefix}_', '')\n            arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n            if not arg_type:\n                continue\n            ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n        args_map.update(file_args_map)\n        return args_map\n\n    @staticmethod\n    def argparse_to_schema_interactive(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        ignored_keys: Optional[List[str]] = None,\n        existing_values: Optional[Dict[str, Any]] = None,\n        hidden_keys: Optional[List[str]] = None,\n        override_aliases: Optional[Dict[str, str]] = None,\n        key_prefix: str = '',\n        empty_allowed_keys: Optional[List[str]] = None,\n        default_values: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given schema and args into a finalized dictionary.\n        The function interacts with the user and requests args that were not provided in the CLI.\n        Returns a dict that combines the schema with the user inputs.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        if key_prefix:\n            existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n        args_map = {\n            k: (\n                existing_values[k]\n                if existing_values and k in existing_values and existing_values[k] != None\n                else v if v else default_values[k] if default_values and k in default_values else None\n            )\n            for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n        }\n        aliases_map = {\n            k: v\n            for k, v in ArkPydanticArgparse.schema_to_aliases(\n                schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n            ).items()\n            if k in args_map\n        }\n        for k, v in aliases_map.items():\n            if ignored_keys and k in ignored_keys:\n                continue\n            args_map[k] = ArkArgsFormatter.get_arg(\n                args=args,\n                key=k,\n                prompt=v,\n                existing_val=args_map[k],\n                hidden=k in hidden_keys if hidden_keys else False,\n                prioritize_existing_val=True,\n                empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n            )\n        if key_prefix:\n            return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n        return args_map\n\n    @staticmethod\n    def merge_by_model(\n        model: Type[BaseModel],\n        existing_model: BaseModel,\n        new_vals: Union[BaseModel, Dict[str, Any]],\n        by_alias: bool = False,\n        key_prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        defaults: Optional[Dict[str, Any]] = None,\n    ) -&gt; BaseModel:\n        \"\"\"\n        Merges the given existing model with new values.\n        The new values can be either a base model or dictionary of values.\n        When provided, the merging is based on the specified key prefix.\n\n        Args:\n            model (Type[BaseModel]): _description_\n            existing_model (BaseModel): _description_\n            new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n            by_alias (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            BaseModel: _description_\n        \"\"\"\n        if key_prefix:\n            new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n        if isinstance(new_vals, BaseModel):\n            new_vals = new_vals.model_dump(by_alias=by_alias)\n        new_vals = {k: v for k, v in new_vals.items() if v is not None}\n        vals_dict = existing_model.model_dump(by_alias=by_alias)\n        if ignore_keys:\n            new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n        vals_dict.update(new_vals)\n        if defaults:\n            vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n        return model.model_validate(vals_dict)\n\n    @staticmethod\n    def schema_to_simple_arguments(\n        schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Exports model's schema as task's input parameters dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        Returns:\n            Dict[str, TaskInputParameter]: _description_\n        \"\"\"\n        definitions: dict = None\n        if '$defs' in schema.keys():\n            definitions = schema['$defs']\n        parser = argparse.ArgumentParser()\n        ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n        input_args = {}\n        if extra_params:\n            input_args.update(extra_params)\n        for action in parser._actions:  # pylint: disable=protected-access\n            if '_HelpAction' not in str(type(action)):\n                arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n                action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n                if 'strtobool' in str(action_type):\n                    action_type = bool\n                if 'format' in arg_info and arg_info['format'] == 'password':\n                    action_type = 'secret'\n                default = action.default\n                name = action.dest\n                input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n                if default is not None:\n                    input_args[name]['default'] = default\n                if action.choices:\n                    input_args[name]['choices'] = action.choices\n        for _, val in input_args.items():\n            if val['type'] == bool:\n                val['type'] = 'boolean'\n            elif 'choices' in val:\n                val['type'] = 'choice'\n                val['choices'] = [str(v) for v in val['choices']]\n            elif val['type'] != 'secret':\n                val['type'] = 'string'\n            if 'default' not in val:\n                val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n            if val['type'] == 'string':\n                val['default'] = str(val['default'])\n        return input_args\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.argparse_to_schema","title":"<code>argparse_to_schema(schema, args, keep_empty_values=False, key_prefix='', ignored_keys=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given JSON schema and argparse args into a finalized dictionary. The conversion is recursive and converts keys according to snake case.</p> <p>Returns a finalized args dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>keep_empty_values</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    keep_empty_values: bool = False,\n    key_prefix: str = '',\n    ignored_keys: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given JSON schema and argparse args into a finalized dictionary.\n    The conversion is recursive and converts keys according to snake case.\n\n    Returns a finalized args dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        keep_empty_values (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    file_args_map: Dict = {}\n    args_map: Dict = {}\n    definitions: Optional[Dict] = None\n    if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n        request_file = args.__dict__['request_file']\n        with open(request_file, 'r', encoding='utf-8') as f:\n            loaded_args_map = json.load(f)\n            for key, value in loaded_args_map.items():\n                first, *others = key.split('_')\n                file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n                # Also add the snake case for models which are not camel based\n                file_args_map[key] = value\n    if '$defs' in schema.keys():\n        definitions = schema['$defs']\n    for arg_key, arg_val in args.__dict__.items():\n        if ignored_keys and arg_key in ignored_keys:\n            continue\n        if key_prefix:\n            arg_key = arg_key.replace(f'{key_prefix}_', '')\n        arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n        if not arg_type:\n            continue\n        ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n    args_map.update(file_args_map)\n    return args_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.argparse_to_schema_interactive","title":"<code>argparse_to_schema_interactive(schema, args, ignored_keys=None, existing_values=None, hidden_keys=None, override_aliases=None, key_prefix='', empty_allowed_keys=None, default_values=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given schema and args into a finalized dictionary. The function interacts with the user and requests args that were not provided in the CLI. Returns a dict that combines the schema with the user inputs.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>existing_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>hidden_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>empty_allowed_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>default_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema_interactive(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    ignored_keys: Optional[List[str]] = None,\n    existing_values: Optional[Dict[str, Any]] = None,\n    hidden_keys: Optional[List[str]] = None,\n    override_aliases: Optional[Dict[str, str]] = None,\n    key_prefix: str = '',\n    empty_allowed_keys: Optional[List[str]] = None,\n    default_values: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given schema and args into a finalized dictionary.\n    The function interacts with the user and requests args that were not provided in the CLI.\n    Returns a dict that combines the schema with the user inputs.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    if key_prefix:\n        existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n    args_map = {\n        k: (\n            existing_values[k]\n            if existing_values and k in existing_values and existing_values[k] != None\n            else v if v else default_values[k] if default_values and k in default_values else None\n        )\n        for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n    }\n    aliases_map = {\n        k: v\n        for k, v in ArkPydanticArgparse.schema_to_aliases(\n            schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n        ).items()\n        if k in args_map\n    }\n    for k, v in aliases_map.items():\n        if ignored_keys and k in ignored_keys:\n            continue\n        args_map[k] = ArkArgsFormatter.get_arg(\n            args=args,\n            key=k,\n            prompt=v,\n            existing_val=args_map[k],\n            hidden=k in hidden_keys if hidden_keys else False,\n            prioritize_existing_val=True,\n            empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n        )\n    if key_prefix:\n        return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n    return args_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.merge_by_model","title":"<code>merge_by_model(model, existing_model, new_vals, by_alias=False, key_prefix='', ignore_keys=None, defaults=None)</code>  <code>staticmethod</code>","text":"<p>Merges the given existing model with new values. The new values can be either a base model or dictionary of values. When provided, the merging is based on the specified key prefix.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>description</p> required <code>existing_model</code> <code>BaseModel</code> <p>description</p> required <code>new_vals</code> <code>Union[BaseModel, Dict[str, Any]]</code> <p>description</p> required <code>by_alias</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>defaults</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef merge_by_model(\n    model: Type[BaseModel],\n    existing_model: BaseModel,\n    new_vals: Union[BaseModel, Dict[str, Any]],\n    by_alias: bool = False,\n    key_prefix: str = '',\n    ignore_keys: Optional[List[str]] = None,\n    defaults: Optional[Dict[str, Any]] = None,\n) -&gt; BaseModel:\n    \"\"\"\n    Merges the given existing model with new values.\n    The new values can be either a base model or dictionary of values.\n    When provided, the merging is based on the specified key prefix.\n\n    Args:\n        model (Type[BaseModel]): _description_\n        existing_model (BaseModel): _description_\n        new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n        by_alias (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        BaseModel: _description_\n    \"\"\"\n    if key_prefix:\n        new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n    if isinstance(new_vals, BaseModel):\n        new_vals = new_vals.model_dump(by_alias=by_alias)\n    new_vals = {k: v for k, v in new_vals.items() if v is not None}\n    vals_dict = existing_model.model_dump(by_alias=by_alias)\n    if ignore_keys:\n        new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n    vals_dict.update(new_vals)\n    if defaults:\n        vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n    return model.model_validate(vals_dict)\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_aliases","title":"<code>schema_to_aliases(schema, override_aliases=None, ignore_keys=None, prefix='', definitions=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a schema to only a dictionary containing its aliases (title). Returns a string to string dictionary with the aliases.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_aliases(\n    schema: Dict[str, Any],\n    override_aliases: Optional[Dict[str, str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    key_prefix: str = '',\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Converts a schema to only a dictionary containing its aliases (title).\n    Returns a string to string dictionary with the aliases.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n\n    Returns:\n        Dict[str, str]: _description_\n    \"\"\"\n    if key_prefix:\n        key_prefix = key_prefix + '_'\n    if 'properties' not in schema:\n        return {}\n    if not definitions and '$defs' in schema.keys():\n        definitions = schema['$defs']\n    elif not definitions:\n        definitions = {}\n    if not override_aliases:\n        override_aliases = {}\n    aliases_map: Dict[str, Any] = {}\n    for prop_name in schema['properties']:\n        snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n        if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n            continue\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if snake_prop_name in override_aliases:\n            aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n        else:\n            aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n        if 'type' in schema['properties'][prop_name]:\n            if schema['properties'][prop_name]['type'] == 'object':\n                aliases_map.update(\n                    ArkPydanticArgparse.schema_to_aliases(\n                        schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                    )\n                )\n    return aliases_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_argparse","title":"<code>schema_to_argparse(schema, parser, defaults=None, prefix='', definitions=None, required=None, ignore_keys=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts the given schema to argparse parameters. Recursively iterates over the JSON schema and adds parameters to the parser. The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function. This function does not return anything, but updates the parser itself.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>parser</code> <code>ArgumentParser</code> <p>description</p> required <code>defaults</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>required</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_argparse(\n    schema: Dict[str, Any],\n    parser: argparse.ArgumentParser,\n    defaults: Optional[Dict[str, str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    required: Optional[List[str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    key_prefix: str = '',\n) -&gt; None:\n    \"\"\"\n    Converts the given schema to argparse parameters.\n    Recursively iterates over the JSON schema and adds parameters to the parser.\n    The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n    This function does not return anything, but updates the parser itself.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        parser (argparse.ArgumentParser): _description_\n        defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        required (Optional[List[str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n    \"\"\"\n    if not definitions and '$defs' in schema.keys():\n        definitions = schema['$defs']\n    elif not definitions:\n        definitions = {}\n    if not required and 'required' in schema.keys():\n        required = schema['required']\n    elif not required:\n        required = []\n    if 'properties' not in schema.keys():\n        prop_name = schema['title']\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        is_required = False\n        if prop_name in required:\n            is_required = True\n        default = None\n        if 'default' in schema.keys():\n            default = schema['default']\n        desc = ''\n        if 'description' in schema.keys():\n            desc = schema['description']\n        enum = None\n        if 'enum' in schema:\n            enum = schema['enum']\n        ArkPydanticArgparse.__populate_type(\n            schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n        )\n        return\n    for prop_name in schema['properties'].keys():\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if '$ref' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_definition_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif 'allOf' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_allof_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif (\n            'anyOf' in schema['properties'][prop_name].keys()\n            and isinstance(schema['properties'][prop_name]['anyOf'], list)\n            and all('type' in t or '$ref' in t for t in schema['properties'][prop_name]['anyOf'])\n        ):\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if any('$ref' in t for t in schema['properties'][prop_name]['anyOf']):\n                item = [t for t in schema['properties'][prop_name]['anyOf'] if '$ref' in t][0]\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    default = None\n                    if 'default' in schema['properties'][prop_name].keys():\n                        default = schema['properties'][prop_name]['default']\n                    desc = ''\n                    if 'description' in schema['properties'][prop_name].keys():\n                        desc = schema['properties'][prop_name]['description']\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                is_required = False\n                if prop_name in required:\n                    is_required = True\n                default = None\n                if 'default' in schema['properties'][prop_name].keys():\n                    default = schema['properties'][prop_name]['default']\n                desc = ''\n                if 'description' in schema['properties'][prop_name].keys():\n                    desc = schema['properties'][prop_name]['description']\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['enum']\n                prop_type = 'string'\n                if any(t['type'] != 'null' for t in schema['properties'][prop_name]['anyOf']) and all(\n                    t['type'] != 'string' for t in schema['properties'][prop_name]['anyOf']\n                ):\n                    prop_type = [t['type'] for t in schema['properties'][prop_name]['anyOf'] if t['type'] != 'null'][0]\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n                continue\n        desc = ''\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        default = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'type' not in schema['properties'][prop_name].keys():\n            if 'enum' in schema['properties'][prop_name].keys():\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            continue\n        prop_type = schema['properties'][prop_name]['type']\n        if prop_type == 'object':\n            if (\n                'properties' not in schema['properties'][prop_name]\n                and (\n                    'additionalProperties' in schema['properties'][prop_name]\n                    and 'type' in schema['properties'][prop_name]['additionalProperties']\n                    and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                )\n                or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n            ):\n                # Special use case for dicitionary\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            else:\n                local_schema = schema['properties'][prop_name]\n                if 'properties' not in local_schema.keys():\n                    prop_name = local_schema['title']\n                    snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                    is_required = False\n                    if prop_name in required:\n                        is_required = True\n                    default = None\n                    if 'default' in schema.keys():\n                        default = local_schema['default']\n                    desc = ''\n                    if 'description' in schema.keys():\n                        desc = local_schema['description']\n                    enum = None\n                    if 'enum' in local_schema:\n                        enum = local_schema['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        local_schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                    continue\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema['properties'][prop_name],\n                    parser,\n                    defaults,\n                    f'{prefix}{snake_prop_name}.',\n                    definitions,\n                    required,\n                    ignore_keys,\n                    key_prefix,\n                )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['properties'][prop_name]['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_simple_arguments","title":"<code>schema_to_simple_arguments(schema, ignore_keys=None, extra_params=None)</code>  <code>staticmethod</code>","text":"<p>Exports model's schema as task's input parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_simple_arguments(\n    schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Exports model's schema as task's input parameters dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n    Returns:\n        Dict[str, TaskInputParameter]: _description_\n    \"\"\"\n    definitions: dict = None\n    if '$defs' in schema.keys():\n        definitions = schema['$defs']\n    parser = argparse.ArgumentParser()\n    ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n    input_args = {}\n    if extra_params:\n        input_args.update(extra_params)\n    for action in parser._actions:  # pylint: disable=protected-access\n        if '_HelpAction' not in str(type(action)):\n            arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n            action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n            if 'strtobool' in str(action_type):\n                action_type = bool\n            if 'format' in arg_info and arg_info['format'] == 'password':\n                action_type = 'secret'\n            default = action.default\n            name = action.dest\n            input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n            if default is not None:\n                input_args[name]['default'] = default\n            if action.choices:\n                input_args[name]['choices'] = action.choices\n    for _, val in input_args.items():\n        if val['type'] == bool:\n            val['type'] = 'boolean'\n        elif 'choices' in val:\n            val['type'] = 'choice'\n            val['choices'] = [str(v) for v in val['choices']]\n        elif val['type'] != 'secret':\n            val['type'] = 'string'\n        if 'default' not in val:\n            val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n        if val['type'] == 'string':\n            val['default'] = str(val['default'])\n    return input_args\n</code></pre>"},{"location":"reference/args/ark_args_formatter/","title":"ark_args_formatter","text":""},{"location":"reference/args/ark_pydantic_argparse/","title":"ark_pydantic_argparse","text":""},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse","title":"<code>ArkPydanticArgparse</code>","text":"Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>class ArkPydanticArgparse:\n    @staticmethod\n    def __populate_type(\n        prop_type: str,\n        snake_prop_name: str,\n        default: Optional[str],\n        required: bool,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        description: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        enum: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '-'\n        if ignore_keys != None and snake_prop_name in ignore_keys:\n            return\n        if default != None:\n            required = False\n        if isinstance(default, Enum):\n            default = default.value\n        arg_type = None\n        if prop_type == 'string':\n            arg_type = str\n        elif prop_type == 'integer':\n            arg_type = int\n        elif prop_type == 'boolean':\n            arg_type = bool\n        elif prop_type == 'object':\n            arg_type = object\n        else:\n            arg_type = str\n        long_name = key_prefix + prefix + snake_prop_name\n        shorted_name = ''.join([s[0] for s in long_name.replace('.', '-').split('-')])\n        for i in range(5):\n            for action in parser._actions:  # pylint: disable=protected-access\n                if f'-{shorted_name}' in action.option_strings:\n                    shorted_name = ''.join([s[: i + 1] for s in long_name.split('-')])\n                    break\n        if arg_type == bool:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                action='store_true',\n                help=description,\n            )\n            if long_name != 'poll':\n                parser.add_argument(\n                    '-n' + shorted_name,\n                    '--no-' + long_name,\n                    dest=long_name.replace('-', '_'),\n                    required='--request-file' not in ' '.join(sys.argv) and required,\n                    action='store_false',\n                    help=description,\n                )\n            parser.set_defaults(**{f\"{long_name.replace('-', '_')}\": default})\n        elif arg_type == object:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                metavar=\"KEY=VALUE\",\n                nargs='+',\n                default=default,\n                help=description,\n            )\n        else:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                type=arg_type,\n                default=default,\n                help=description,\n                choices=enum,\n            )\n\n    @staticmethod\n    def __schema_definition_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if not definitions:\n            return\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n        def_prop = definitions[def_prop_name]\n        if 'type' not in def_prop.keys():\n            return\n        prop_type = def_prop['type']\n        desc = ''\n        if 'description' in def_prop.keys():\n            desc = def_prop['description']\n        default: Optional[str] = None\n        if 'default' in def_prop.keys():\n            default = def_prop['default']\n        elif defaults and prefix + snake_prop_name in defaults:\n            default = defaults[snake_prop_name]\n        if prop_type == 'object':\n            ArkPydanticArgparse.schema_to_argparse(\n                def_prop, parser, defaults, f'{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n            )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in def_prop:\n                enum = def_prop['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n\n    @staticmethod\n    def __schema_allof_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        desc = ''\n        default: Optional[str] = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        for item in schema['properties'][prop_name]['allOf']:\n            if '$ref' in item.keys() and definitions:\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                if 'type' not in item.keys():\n                    continue\n                prop_type = item['type']\n                if 'default' in item.keys():\n                    default = item['default']\n                elif defaults and prefix + snake_prop_name in defaults:\n                    default = defaults[snake_prop_name]\n                if 'description' in item.keys():\n                    desc = item['description']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        item, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in item:\n                        enum = item['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n\n    @staticmethod\n    def __arg_in_schema(arg_key: str, schema: Dict[str, Any], definitions: Optional[Dict[str, Any]], prefix: str = '') -&gt; Optional[str]:\n        if 'properties' not in schema:\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if prefix + snake_prop_name == arg_key:\n                return schema['type']\n            else:\n                return None\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if '$ref' in schema['properties'][prop_name].keys():\n                def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        return 'string'\n                    continue\n                if def_prop['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    return def_prop['type']\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                for item in schema['properties'][prop_name]['allOf']:\n                    if '$ref' in item.keys():\n                        def_prop_name = item['$ref'].split('/')[2]\n                        def_prop = definitions[def_prop_name]\n                        if 'type' not in def_prop.keys():\n                            if 'enum' in def_prop.keys():\n                                return 'string'\n                            continue\n                        if def_prop['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                                return def_prop['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return def_prop['type']\n                    if 'type' in item.keys():\n                        if item['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, item, definitions, f'{prefix}{snake_prop_name}.'):\n                                return item['type']\n                        if item['type'] == 'null':\n                            continue\n                        if prefix + snake_prop_name == arg_key:\n                            return item['type']\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t or '$ref' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                if any('$ref' in t for t in schema['properties'][prop_name]['anyOf']):\n                    item = [t for t in schema['properties'][prop_name]['anyOf'] if '$ref' in t][0]\n                    def_prop_name = item['$ref'].split('/')[2]\n                    def_prop = definitions[def_prop_name]\n                    if 'type' not in def_prop.keys():\n                        if 'enum' in def_prop.keys():\n                            return 'string'\n                        continue\n                    if def_prop['type'] == 'object':\n                        if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                            return def_prop['type']\n                    if prefix + snake_prop_name == arg_key:\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    if any(t['type'] != 'null' for t in schema['properties'][prop_name]['anyOf']):\n                        return [t['type'] for t in schema['properties'][prop_name]['anyOf'] if t['type'] != 'null'][0]\n                    return 'string'\n            elif 'type' in schema['properties'][prop_name].keys():\n                if prefix + snake_prop_name == arg_key:\n                    return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(\n                        arg_key, schema['properties'][prop_name], definitions, f'{prefix}{snake_prop_name}.'\n                    ):\n                        return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'null':\n                    return None\n        return None\n\n    @staticmethod\n    def __parse_types(args: Dict[str, str]) -&gt; Dict[str, Any]:\n        parsed_args = {}\n        for k, v in args.items():\n            if not isinstance(v, str):\n                parsed_args[k] = v\n                continue\n            if v.lower() == 'true':\n                parsed_args[k] = True\n                continue\n            if v.lower() == 'false':\n                parsed_args[k] = False\n                continue\n            try:\n                parsed_args[k] = int(v)\n                continue\n            except:  # pylint: disable=bare-except\n                pass\n            try:\n                parsed_args[k] = float(v)\n                continue\n            except:  # pylint: disable=bare-except\n                pass\n            try:\n                parsed_args[k] = json.loads(v)\n                continue\n            except:  # pylint: disable=bare-except\n                pass\n            parsed_args[k] = v\n        return parsed_args\n\n    @staticmethod\n    def __arg_to_schema(\n        arg_key: str, arg_val: Any, args_map: Dict[str, Any], arg_type: str, keep_empty_values: bool = False, key_prefix: str = ''\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if '.' in arg_key:\n            args = arg_key.split('.')\n            key = args[0]\n            if key not in args_map.keys() or args_map[key] == None:\n                args_map[key] = {}\n            ArkPydanticArgparse.__arg_to_schema('.'.join(args[1:]), arg_val, args_map[key], arg_type, key_prefix)\n        elif arg_val != None or keep_empty_values:\n            if arg_type == 'array':\n                if isinstance(arg_val, list):\n                    args_map[key_prefix + arg_key] = arg_val\n                elif re.match('({.*},?)+', arg_val) != None:\n                    objs = []\n                    for m in re.finditer('{.*?}', arg_val):\n                        objs.append(json.loads(m.group(0)))\n                    args_map[key_prefix + arg_key] = objs\n                else:\n                    args_map[key_prefix + arg_key] = arg_val.split(',')\n            elif arg_type == 'object' and not isinstance(arg_val, (int, bool, float)):\n                if isinstance(arg_val, list):\n                    arg_val = ','.join(arg_val)\n                if '=' not in arg_val:\n                    args_map[key_prefix + arg_key] = arg_val\n                else:\n                    args_dict = dict(\n                        next(csv.reader([item], delimiter='=', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                        for item in next(csv.reader([arg_val], delimiter=',', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                    )\n                    if len(args_dict) &gt; 0:\n                        args_dict = ArkPydanticArgparse.__parse_types(args_dict)\n                        args_map[key_prefix + arg_key] = args_dict\n                    elif arg_key != 'extrafields':\n                        args_map[key_prefix + arg_key] = arg_val\n            else:\n                args_map[key_prefix + arg_key] = arg_val\n\n    @staticmethod\n    def schema_to_argparse(\n        schema: Dict[str, Any],\n        parser: argparse.ArgumentParser,\n        defaults: Optional[Dict[str, str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        required: Optional[List[str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        \"\"\"\n        Converts the given schema to argparse parameters.\n        Recursively iterates over the JSON schema and adds parameters to the parser.\n        The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n        This function does not return anything, but updates the parser itself.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            parser (argparse.ArgumentParser): _description_\n            defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            required (Optional[List[str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n        \"\"\"\n        if not definitions and '$defs' in schema.keys():\n            definitions = schema['$defs']\n        elif not definitions:\n            definitions = {}\n        if not required and 'required' in schema.keys():\n            required = schema['required']\n        elif not required:\n            required = []\n        if 'properties' not in schema.keys():\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema.keys():\n                default = schema['default']\n            desc = ''\n            if 'description' in schema.keys():\n                desc = schema['description']\n            enum = None\n            if 'enum' in schema:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            return\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if '$ref' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_definition_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_allof_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t or '$ref' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                if any('$ref' in t for t in schema['properties'][prop_name]['anyOf']):\n                    item = [t for t in schema['properties'][prop_name]['anyOf'] if '$ref' in t][0]\n                    def_prop_name = item['$ref'].split('/')[2]\n                    def_prop = definitions[def_prop_name]\n                    if 'type' not in def_prop.keys():\n                        if 'enum' in def_prop.keys():\n                            is_required = False\n                            if required and prop_name in required:\n                                is_required = True\n                            enum = def_prop['enum']\n                            ArkPydanticArgparse.__populate_type(\n                                'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                            )\n                        continue\n                    prop_type = def_prop['type']\n                    if prop_type == 'object':\n                        ArkPydanticArgparse.schema_to_argparse(\n                            def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                        )\n                    else:\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        default = None\n                        if 'default' in schema['properties'][prop_name].keys():\n                            default = schema['properties'][prop_name]['default']\n                        desc = ''\n                        if 'description' in schema['properties'][prop_name].keys():\n                            desc = schema['properties'][prop_name]['description']\n                        enum = None\n                        if 'enum' in def_prop:\n                            enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                else:\n                    is_required = False\n                    if prop_name in required:\n                        is_required = True\n                    default = None\n                    if 'default' in schema['properties'][prop_name].keys():\n                        default = schema['properties'][prop_name]['default']\n                    desc = ''\n                    if 'description' in schema['properties'][prop_name].keys():\n                        desc = schema['properties'][prop_name]['description']\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['enum']\n                    prop_type = 'string'\n                    if any(t['type'] != 'null' for t in schema['properties'][prop_name]['anyOf']) and all(\n                        t['type'] != 'string' for t in schema['properties'][prop_name]['anyOf']\n                    ):\n                        prop_type = [t['type'] for t in schema['properties'][prop_name]['anyOf'] if t['type'] != 'null'][0]\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                    continue\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            elif defaults and prefix + snake_prop_name in defaults.keys():\n                default = defaults[snake_prop_name]\n            if 'type' not in schema['properties'][prop_name].keys():\n                if 'enum' in schema['properties'][prop_name].keys():\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                continue\n            prop_type = schema['properties'][prop_name]['type']\n            if prop_type == 'object':\n                if (\n                    'properties' not in schema['properties'][prop_name]\n                    and (\n                        'additionalProperties' in schema['properties'][prop_name]\n                        and 'type' in schema['properties'][prop_name]['additionalProperties']\n                        and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                    )\n                    or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n                ):\n                    # Special use case for dicitionary\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                else:\n                    local_schema = schema['properties'][prop_name]\n                    if 'properties' not in local_schema.keys():\n                        prop_name = local_schema['title']\n                        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                        is_required = False\n                        if prop_name in required:\n                            is_required = True\n                        default = None\n                        if 'default' in schema.keys():\n                            default = local_schema['default']\n                        desc = ''\n                        if 'description' in schema.keys():\n                            desc = local_schema['description']\n                        enum = None\n                        if 'enum' in local_schema:\n                            enum = local_schema['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            local_schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                        continue\n                    ArkPydanticArgparse.schema_to_argparse(\n                        schema['properties'][prop_name],\n                        parser,\n                        defaults,\n                        f'{prefix}{snake_prop_name}.',\n                        definitions,\n                        required,\n                        ignore_keys,\n                        key_prefix,\n                    )\n            else:\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n\n    @staticmethod\n    def schema_to_aliases(\n        schema: Dict[str, Any],\n        override_aliases: Optional[Dict[str, str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        key_prefix: str = '',\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n        Converts a schema to only a dictionary containing its aliases (title).\n        Returns a string to string dictionary with the aliases.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n\n        Returns:\n            Dict[str, str]: _description_\n        \"\"\"\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if 'properties' not in schema:\n            return {}\n        if not definitions and '$defs' in schema.keys():\n            definitions = schema['$defs']\n        elif not definitions:\n            definitions = {}\n        if not override_aliases:\n            override_aliases = {}\n        aliases_map: Dict[str, Any] = {}\n        for prop_name in schema['properties']:\n            snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n                continue\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if snake_prop_name in override_aliases:\n                aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n            else:\n                aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n            if 'type' in schema['properties'][prop_name]:\n                if schema['properties'][prop_name]['type'] == 'object':\n                    aliases_map.update(\n                        ArkPydanticArgparse.schema_to_aliases(\n                            schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                        )\n                    )\n        return aliases_map\n\n    @staticmethod\n    def argparse_to_schema(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        keep_empty_values: bool = False,\n        key_prefix: str = '',\n        ignored_keys: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given JSON schema and argparse args into a finalized dictionary.\n        The conversion is recursive and converts keys according to snake case.\n\n        Returns a finalized args dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            keep_empty_values (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        file_args_map: Dict = {}\n        args_map: Dict = {}\n        definitions: Optional[Dict] = None\n        if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n            request_file = args.__dict__['request_file']\n            with open(request_file, 'r', encoding='utf-8') as f:\n                loaded_args_map = json.load(f)\n                for key, value in loaded_args_map.items():\n                    first, *others = key.split('_')\n                    file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n                    # Also add the snake case for models which are not camel based\n                    file_args_map[key] = value\n        if '$defs' in schema.keys():\n            definitions = schema['$defs']\n        for arg_key, arg_val in args.__dict__.items():\n            if ignored_keys and arg_key in ignored_keys:\n                continue\n            if key_prefix:\n                arg_key = arg_key.replace(f'{key_prefix}_', '')\n            arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n            if not arg_type:\n                continue\n            ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n        args_map.update(file_args_map)\n        return args_map\n\n    @staticmethod\n    def argparse_to_schema_interactive(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        ignored_keys: Optional[List[str]] = None,\n        existing_values: Optional[Dict[str, Any]] = None,\n        hidden_keys: Optional[List[str]] = None,\n        override_aliases: Optional[Dict[str, str]] = None,\n        key_prefix: str = '',\n        empty_allowed_keys: Optional[List[str]] = None,\n        default_values: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given schema and args into a finalized dictionary.\n        The function interacts with the user and requests args that were not provided in the CLI.\n        Returns a dict that combines the schema with the user inputs.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        if key_prefix:\n            existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n        args_map = {\n            k: (\n                existing_values[k]\n                if existing_values and k in existing_values and existing_values[k] != None\n                else v if v else default_values[k] if default_values and k in default_values else None\n            )\n            for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n        }\n        aliases_map = {\n            k: v\n            for k, v in ArkPydanticArgparse.schema_to_aliases(\n                schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n            ).items()\n            if k in args_map\n        }\n        for k, v in aliases_map.items():\n            if ignored_keys and k in ignored_keys:\n                continue\n            args_map[k] = ArkArgsFormatter.get_arg(\n                args=args,\n                key=k,\n                prompt=v,\n                existing_val=args_map[k],\n                hidden=k in hidden_keys if hidden_keys else False,\n                prioritize_existing_val=True,\n                empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n            )\n        if key_prefix:\n            return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n        return args_map\n\n    @staticmethod\n    def merge_by_model(\n        model: Type[BaseModel],\n        existing_model: BaseModel,\n        new_vals: Union[BaseModel, Dict[str, Any]],\n        by_alias: bool = False,\n        key_prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        defaults: Optional[Dict[str, Any]] = None,\n    ) -&gt; BaseModel:\n        \"\"\"\n        Merges the given existing model with new values.\n        The new values can be either a base model or dictionary of values.\n        When provided, the merging is based on the specified key prefix.\n\n        Args:\n            model (Type[BaseModel]): _description_\n            existing_model (BaseModel): _description_\n            new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n            by_alias (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            BaseModel: _description_\n        \"\"\"\n        if key_prefix:\n            new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n        if isinstance(new_vals, BaseModel):\n            new_vals = new_vals.model_dump(by_alias=by_alias)\n        new_vals = {k: v for k, v in new_vals.items() if v is not None}\n        vals_dict = existing_model.model_dump(by_alias=by_alias)\n        if ignore_keys:\n            new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n        vals_dict.update(new_vals)\n        if defaults:\n            vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n        return model.model_validate(vals_dict)\n\n    @staticmethod\n    def schema_to_simple_arguments(\n        schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Exports model's schema as task's input parameters dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        Returns:\n            Dict[str, TaskInputParameter]: _description_\n        \"\"\"\n        definitions: dict = None\n        if '$defs' in schema.keys():\n            definitions = schema['$defs']\n        parser = argparse.ArgumentParser()\n        ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n        input_args = {}\n        if extra_params:\n            input_args.update(extra_params)\n        for action in parser._actions:  # pylint: disable=protected-access\n            if '_HelpAction' not in str(type(action)):\n                arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n                action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n                if 'strtobool' in str(action_type):\n                    action_type = bool\n                if 'format' in arg_info and arg_info['format'] == 'password':\n                    action_type = 'secret'\n                default = action.default\n                name = action.dest\n                input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n                if default is not None:\n                    input_args[name]['default'] = default\n                if action.choices:\n                    input_args[name]['choices'] = action.choices\n        for _, val in input_args.items():\n            if val['type'] == bool:\n                val['type'] = 'boolean'\n            elif 'choices' in val:\n                val['type'] = 'choice'\n                val['choices'] = [str(v) for v in val['choices']]\n            elif val['type'] != 'secret':\n                val['type'] = 'string'\n            if 'default' not in val:\n                val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n            if val['type'] == 'string':\n                val['default'] = str(val['default'])\n        return input_args\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.argparse_to_schema","title":"<code>argparse_to_schema(schema, args, keep_empty_values=False, key_prefix='', ignored_keys=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given JSON schema and argparse args into a finalized dictionary. The conversion is recursive and converts keys according to snake case.</p> <p>Returns a finalized args dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>keep_empty_values</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    keep_empty_values: bool = False,\n    key_prefix: str = '',\n    ignored_keys: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given JSON schema and argparse args into a finalized dictionary.\n    The conversion is recursive and converts keys according to snake case.\n\n    Returns a finalized args dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        keep_empty_values (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    file_args_map: Dict = {}\n    args_map: Dict = {}\n    definitions: Optional[Dict] = None\n    if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n        request_file = args.__dict__['request_file']\n        with open(request_file, 'r', encoding='utf-8') as f:\n            loaded_args_map = json.load(f)\n            for key, value in loaded_args_map.items():\n                first, *others = key.split('_')\n                file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n                # Also add the snake case for models which are not camel based\n                file_args_map[key] = value\n    if '$defs' in schema.keys():\n        definitions = schema['$defs']\n    for arg_key, arg_val in args.__dict__.items():\n        if ignored_keys and arg_key in ignored_keys:\n            continue\n        if key_prefix:\n            arg_key = arg_key.replace(f'{key_prefix}_', '')\n        arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n        if not arg_type:\n            continue\n        ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n    args_map.update(file_args_map)\n    return args_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.argparse_to_schema_interactive","title":"<code>argparse_to_schema_interactive(schema, args, ignored_keys=None, existing_values=None, hidden_keys=None, override_aliases=None, key_prefix='', empty_allowed_keys=None, default_values=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given schema and args into a finalized dictionary. The function interacts with the user and requests args that were not provided in the CLI. Returns a dict that combines the schema with the user inputs.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>existing_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>hidden_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>empty_allowed_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>default_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema_interactive(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    ignored_keys: Optional[List[str]] = None,\n    existing_values: Optional[Dict[str, Any]] = None,\n    hidden_keys: Optional[List[str]] = None,\n    override_aliases: Optional[Dict[str, str]] = None,\n    key_prefix: str = '',\n    empty_allowed_keys: Optional[List[str]] = None,\n    default_values: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given schema and args into a finalized dictionary.\n    The function interacts with the user and requests args that were not provided in the CLI.\n    Returns a dict that combines the schema with the user inputs.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    if key_prefix:\n        existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n    args_map = {\n        k: (\n            existing_values[k]\n            if existing_values and k in existing_values and existing_values[k] != None\n            else v if v else default_values[k] if default_values and k in default_values else None\n        )\n        for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n    }\n    aliases_map = {\n        k: v\n        for k, v in ArkPydanticArgparse.schema_to_aliases(\n            schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n        ).items()\n        if k in args_map\n    }\n    for k, v in aliases_map.items():\n        if ignored_keys and k in ignored_keys:\n            continue\n        args_map[k] = ArkArgsFormatter.get_arg(\n            args=args,\n            key=k,\n            prompt=v,\n            existing_val=args_map[k],\n            hidden=k in hidden_keys if hidden_keys else False,\n            prioritize_existing_val=True,\n            empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n        )\n    if key_prefix:\n        return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n    return args_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.merge_by_model","title":"<code>merge_by_model(model, existing_model, new_vals, by_alias=False, key_prefix='', ignore_keys=None, defaults=None)</code>  <code>staticmethod</code>","text":"<p>Merges the given existing model with new values. The new values can be either a base model or dictionary of values. When provided, the merging is based on the specified key prefix.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>description</p> required <code>existing_model</code> <code>BaseModel</code> <p>description</p> required <code>new_vals</code> <code>Union[BaseModel, Dict[str, Any]]</code> <p>description</p> required <code>by_alias</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>defaults</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef merge_by_model(\n    model: Type[BaseModel],\n    existing_model: BaseModel,\n    new_vals: Union[BaseModel, Dict[str, Any]],\n    by_alias: bool = False,\n    key_prefix: str = '',\n    ignore_keys: Optional[List[str]] = None,\n    defaults: Optional[Dict[str, Any]] = None,\n) -&gt; BaseModel:\n    \"\"\"\n    Merges the given existing model with new values.\n    The new values can be either a base model or dictionary of values.\n    When provided, the merging is based on the specified key prefix.\n\n    Args:\n        model (Type[BaseModel]): _description_\n        existing_model (BaseModel): _description_\n        new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n        by_alias (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        BaseModel: _description_\n    \"\"\"\n    if key_prefix:\n        new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n    if isinstance(new_vals, BaseModel):\n        new_vals = new_vals.model_dump(by_alias=by_alias)\n    new_vals = {k: v for k, v in new_vals.items() if v is not None}\n    vals_dict = existing_model.model_dump(by_alias=by_alias)\n    if ignore_keys:\n        new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n    vals_dict.update(new_vals)\n    if defaults:\n        vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n    return model.model_validate(vals_dict)\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_aliases","title":"<code>schema_to_aliases(schema, override_aliases=None, ignore_keys=None, prefix='', definitions=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a schema to only a dictionary containing its aliases (title). Returns a string to string dictionary with the aliases.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_aliases(\n    schema: Dict[str, Any],\n    override_aliases: Optional[Dict[str, str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    key_prefix: str = '',\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Converts a schema to only a dictionary containing its aliases (title).\n    Returns a string to string dictionary with the aliases.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n\n    Returns:\n        Dict[str, str]: _description_\n    \"\"\"\n    if key_prefix:\n        key_prefix = key_prefix + '_'\n    if 'properties' not in schema:\n        return {}\n    if not definitions and '$defs' in schema.keys():\n        definitions = schema['$defs']\n    elif not definitions:\n        definitions = {}\n    if not override_aliases:\n        override_aliases = {}\n    aliases_map: Dict[str, Any] = {}\n    for prop_name in schema['properties']:\n        snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n        if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n            continue\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if snake_prop_name in override_aliases:\n            aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n        else:\n            aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n        if 'type' in schema['properties'][prop_name]:\n            if schema['properties'][prop_name]['type'] == 'object':\n                aliases_map.update(\n                    ArkPydanticArgparse.schema_to_aliases(\n                        schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                    )\n                )\n    return aliases_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_argparse","title":"<code>schema_to_argparse(schema, parser, defaults=None, prefix='', definitions=None, required=None, ignore_keys=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts the given schema to argparse parameters. Recursively iterates over the JSON schema and adds parameters to the parser. The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function. This function does not return anything, but updates the parser itself.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>parser</code> <code>ArgumentParser</code> <p>description</p> required <code>defaults</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>required</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_argparse(\n    schema: Dict[str, Any],\n    parser: argparse.ArgumentParser,\n    defaults: Optional[Dict[str, str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    required: Optional[List[str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    key_prefix: str = '',\n) -&gt; None:\n    \"\"\"\n    Converts the given schema to argparse parameters.\n    Recursively iterates over the JSON schema and adds parameters to the parser.\n    The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n    This function does not return anything, but updates the parser itself.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        parser (argparse.ArgumentParser): _description_\n        defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        required (Optional[List[str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n    \"\"\"\n    if not definitions and '$defs' in schema.keys():\n        definitions = schema['$defs']\n    elif not definitions:\n        definitions = {}\n    if not required and 'required' in schema.keys():\n        required = schema['required']\n    elif not required:\n        required = []\n    if 'properties' not in schema.keys():\n        prop_name = schema['title']\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        is_required = False\n        if prop_name in required:\n            is_required = True\n        default = None\n        if 'default' in schema.keys():\n            default = schema['default']\n        desc = ''\n        if 'description' in schema.keys():\n            desc = schema['description']\n        enum = None\n        if 'enum' in schema:\n            enum = schema['enum']\n        ArkPydanticArgparse.__populate_type(\n            schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n        )\n        return\n    for prop_name in schema['properties'].keys():\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if '$ref' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_definition_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif 'allOf' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_allof_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif (\n            'anyOf' in schema['properties'][prop_name].keys()\n            and isinstance(schema['properties'][prop_name]['anyOf'], list)\n            and all('type' in t or '$ref' in t for t in schema['properties'][prop_name]['anyOf'])\n        ):\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if any('$ref' in t for t in schema['properties'][prop_name]['anyOf']):\n                item = [t for t in schema['properties'][prop_name]['anyOf'] if '$ref' in t][0]\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    default = None\n                    if 'default' in schema['properties'][prop_name].keys():\n                        default = schema['properties'][prop_name]['default']\n                    desc = ''\n                    if 'description' in schema['properties'][prop_name].keys():\n                        desc = schema['properties'][prop_name]['description']\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                is_required = False\n                if prop_name in required:\n                    is_required = True\n                default = None\n                if 'default' in schema['properties'][prop_name].keys():\n                    default = schema['properties'][prop_name]['default']\n                desc = ''\n                if 'description' in schema['properties'][prop_name].keys():\n                    desc = schema['properties'][prop_name]['description']\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['enum']\n                prop_type = 'string'\n                if any(t['type'] != 'null' for t in schema['properties'][prop_name]['anyOf']) and all(\n                    t['type'] != 'string' for t in schema['properties'][prop_name]['anyOf']\n                ):\n                    prop_type = [t['type'] for t in schema['properties'][prop_name]['anyOf'] if t['type'] != 'null'][0]\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n                continue\n        desc = ''\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        default = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'type' not in schema['properties'][prop_name].keys():\n            if 'enum' in schema['properties'][prop_name].keys():\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            continue\n        prop_type = schema['properties'][prop_name]['type']\n        if prop_type == 'object':\n            if (\n                'properties' not in schema['properties'][prop_name]\n                and (\n                    'additionalProperties' in schema['properties'][prop_name]\n                    and 'type' in schema['properties'][prop_name]['additionalProperties']\n                    and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                )\n                or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n            ):\n                # Special use case for dicitionary\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            else:\n                local_schema = schema['properties'][prop_name]\n                if 'properties' not in local_schema.keys():\n                    prop_name = local_schema['title']\n                    snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                    is_required = False\n                    if prop_name in required:\n                        is_required = True\n                    default = None\n                    if 'default' in schema.keys():\n                        default = local_schema['default']\n                    desc = ''\n                    if 'description' in schema.keys():\n                        desc = local_schema['description']\n                    enum = None\n                    if 'enum' in local_schema:\n                        enum = local_schema['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        local_schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                    continue\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema['properties'][prop_name],\n                    parser,\n                    defaults,\n                    f'{prefix}{snake_prop_name}.',\n                    definitions,\n                    required,\n                    ignore_keys,\n                    key_prefix,\n                )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['properties'][prop_name]['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_simple_arguments","title":"<code>schema_to_simple_arguments(schema, ignore_keys=None, extra_params=None)</code>  <code>staticmethod</code>","text":"<p>Exports model's schema as task's input parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_simple_arguments(\n    schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Exports model's schema as task's input parameters dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n    Returns:\n        Dict[str, TaskInputParameter]: _description_\n    \"\"\"\n    definitions: dict = None\n    if '$defs' in schema.keys():\n        definitions = schema['$defs']\n    parser = argparse.ArgumentParser()\n    ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n    input_args = {}\n    if extra_params:\n        input_args.update(extra_params)\n    for action in parser._actions:  # pylint: disable=protected-access\n        if '_HelpAction' not in str(type(action)):\n            arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n            action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n            if 'strtobool' in str(action_type):\n                action_type = bool\n            if 'format' in arg_info and arg_info['format'] == 'password':\n                action_type = 'secret'\n            default = action.default\n            name = action.dest\n            input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n            if default is not None:\n                input_args[name]['default'] = default\n            if action.choices:\n                input_args[name]['choices'] = action.choices\n    for _, val in input_args.items():\n        if val['type'] == bool:\n            val['type'] = 'boolean'\n        elif 'choices' in val:\n            val['type'] = 'choice'\n            val['choices'] = [str(v) for v in val['choices']]\n        elif val['type'] != 'secret':\n            val['type'] = 'string'\n        if 'default' not in val:\n            val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n        if val['type'] == 'string':\n            val['default'] = str(val['default'])\n    return input_args\n</code></pre>"},{"location":"reference/auth/","title":"auth","text":""},{"location":"reference/auth/ark_auth/","title":"ark_auth","text":""},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth","title":"<code>ArkAuth</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>class ArkAuth(ABC):\n    def __init__(self, cache_authentication: bool = True, token: Optional[ArkToken] = None) -&gt; None:\n        self._logger = get_logger(app=self.__class__.__name__)\n        self._cache_authentication = cache_authentication\n        self._cache_keyring = None\n        if cache_authentication:\n            self._cache_keyring = ArkKeyring(self.authenticator_name())\n        self.__token = token\n        self._active_profile = None\n        self._active_auth_profile = None\n\n    def _resolve_cache_postfix(self, auth_profile: ArkAuthProfile) -&gt; str:\n        \"\"\"\n        Resolves the postfix used to get the token based on the auth method\n\n        Args:\n            auth_profile (ArkAuthProfile): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        postfix = auth_profile.username\n        if auth_profile.auth_method == ArkAuthMethod.Direct and auth_profile.auth_method_settings:\n            direct_method_settings = cast(DirectArkAuthMethodSettings, auth_profile.auth_method_settings)\n            if direct_method_settings.endpoint:\n                postfix = f'{postfix}_{urlparse(direct_method_settings.endpoint).netloc}'\n        return postfix\n\n    @abstractmethod\n    def _perform_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n    ) -&gt; ArkToken:\n        \"\"\"\n        Performs the actual authentication, based on the implementation\n\n        Args:\n            profile (ArkProfile): Profile to authenticate on\n            auth_profile (ArkAuthProfile): Specific auth profile for the authentication\n            secret (Optional[ArkSecret]): Secret used for authentication. Defaults to None\n            force (bool): Force authenticate and ignore caching\n\n        Returns:\n            Optional[ArkToken]: Token of the authentication to be used\n        \"\"\"\n\n    @abstractmethod\n    def _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        \"\"\"\n        Tries to perform refresh authentication on the existing token\n        This is not promised for all authenticators\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            token (ArkToken): _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n\n    def authenticate(\n        self,\n        profile: Optional[ArkProfile] = None,\n        auth_profile: Optional[ArkAuthProfile] = None,\n        secret: Optional[ArkSecret] = None,\n        force: bool = False,\n        refresh_auth: bool = False,\n    ) -&gt; ArkToken:\n        \"\"\"\n        Authenticates with the specified authenticator implementation.\n        The implementation is based on the `_perform_authentication` method.\n        When caching is allowed, authorization credentials are loaded from the cache.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile containing information about the environment and authentication methods\n            auth_profile (Optional[ArkAuthProfile]): Specific auth profile to use instead of the profile, when provided\n            secret (Optional[ArkSecret]): Secret used for authentication\n            force (bool): Determines whether to force authentication without cached credentials\n            refresh_auth (bool): Attempts to refresh an existing cached auth when it is available\n\n        Raises:\n            ArkAuthException: _description_\n\n        Returns:\n            ArkToken: The authentication token to use. The token is also saved in the object.\n        \"\"\"\n        if not auth_profile and not profile:\n            raise ArkAuthException('Either a profile or a specific auth profile must be supplied')\n        if not auth_profile and profile:\n            if self.authenticator_name() in profile.auth_profiles:\n                auth_profile = profile.auth_profiles[self.authenticator_name()]\n            else:\n                raise ArkAuthException(\n                    f'{self.authenticator_human_readable_name()} [{self.authenticator_name()}] is not defined within the authentication profiles'\n                )\n        if not profile:\n            profile = ArkProfileLoader.load_default_profile()\n        if auth_profile.auth_method not in self.supported_auth_methods() and auth_profile.auth_method != ArkAuthMethod.Default:\n            raise ArkAuthException(\n                f'{self.authenticator_human_readable_name()} does not support authentication method {auth_profile.auth_method.value}'\n            )\n        if auth_profile.auth_method == ArkAuthMethod.Default:\n            auth_profile.auth_method, auth_profile.auth_method_settings = self.default_auth_method()\n        if auth_profile.auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n            raise ArkAuthException(f'{self.authenticator_human_readable_name()} requires a username and optionally a secret')\n        ark_token = None\n        token_refreshed = False\n        if self._cache_authentication and self._cache_keyring and not force:\n            # Load the postfix of the token based on the auth profile and method type\n            ark_token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n            if ark_token and ark_token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                # Expired, try to refresh\n                if refresh_auth and ark_token.refresh_token:\n                    ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                    if ark_token:\n                        token_refreshed = True\n                else:\n                    ark_token = None\n        if not ark_token:\n            ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        elif refresh_auth and not token_refreshed:\n            try:\n                ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                if self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n            except Exception as ex:  # Fallback to normal authentication\n                self._logger.info(\n                    f'Refresh auth for [{self.authenticator_human_readable_name()}] failed, falling back to normal authentication [{str(ex)}]'\n                )\n                ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n                if self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        self.__token = ark_token\n        self._active_profile = profile\n        self._active_auth_profile = auth_profile\n        return ark_token\n\n    def is_authenticated(self, profile: ArkProfile) -&gt; bool:\n        \"\"\"\n        Checks whether the specified profile is authenticated (has a valid token), either from the keyring or in memory.\n        If the valid token originated from the keyring, it is loaded into memory.\n\n        Args:\n            profile (ArkProfile): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        self._logger.info(f'Checking if [{self.authenticator_name()}] is authenticated')\n        if self.__token:\n            self._logger.info('Token is already loaded')\n            return True\n        if self.authenticator_name() in profile.auth_profiles and self._cache_keyring:\n            self.__token = self._cache_keyring.load_token(profile, profile.auth_profiles[self.authenticator_name()].username)\n            if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                self.__token = None\n            else:\n                self._logger.info('Loaded token from cache successfully')\n            return self.__token != None\n        return False\n\n    def load_authentication(\n        self, profile: Optional[ArkProfile] = None, refresh_auth: bool = False, grace_seconds: Optional[int] = None\n    ) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads and returns the authentication token from the cache, if it exists.\n        If specified, the method also attempts to refresh the token as needed.\n\n        Args:\n            profile (Optional[ArkProfile], optional): _description_. Defaults to None.\n            refresh_auth (bool, optional): _description_. Defaults to False.\n            grace_seconds (Optional[int], optional): try to refresh in case there is less than grace_seconds until expired. Defaults to None.\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        self._logger.info(f'Trying to load [{self.authenticator_name()}] authentication')\n        if not profile:\n            if self._active_profile:\n                profile = self._active_profile\n            else:\n                profile = ArkProfileLoader.load_default_profile()\n        auth_profile = self._active_auth_profile\n        if not auth_profile and self.authenticator_name() in profile.auth_profiles:\n            auth_profile = profile.auth_profiles[self.authenticator_name()]\n        if auth_profile:\n            self._logger.info(\n                f'Loading authentication for profile [{profile.profile_name}] and auth profile [{self.authenticator_name()}] of type [{auth_profile.auth_method.value}]'\n            )\n            if self._cache_keyring:\n                self.__token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n            if refresh_auth:\n                grace_seconds = grace_seconds if grace_seconds is not None else DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS\n                if self.__token and self.__token.expires_in.replace(tzinfo=None) - timedelta(seconds=grace_seconds) &gt; datetime.now():\n                    self._logger.info('Token did not pass grace expiration, no need to refresh')\n                else:\n                    self._logger.info('Trying to refresh token authentication')\n                    self.__token = self._perform_refresh_authentication(profile, auth_profile, self.__token)\n                    if self.__token and self.__token.expires_in.replace(tzinfo=None) &gt; datetime.now():\n                        self._logger.info('Token refreshed')\n                    if self.__token and self._cache_authentication and self._cache_keyring:\n                        self._cache_keyring.save_token(profile, self.__token, self._resolve_cache_postfix(auth_profile))\n            if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                self.__token = None\n            if self.__token:\n                self._active_profile = profile\n                self._active_auth_profile = auth_profile\n            return self.__token\n        return None\n\n    @property\n    def token(self) -&gt; Optional[ArkToken]:\n        return self.__token\n\n    @property\n    def active_profile(self) -&gt; Optional[ArkProfile]:\n        return self._active_profile\n\n    @property\n    def active_auth_profile(self) -&gt; Optional[ArkAuthProfile]:\n        return self._active_auth_profile\n\n    @staticmethod\n    @abstractmethod\n    def authenticator_name() -&gt; str:\n        \"\"\"\n        Returns the name of the authenticator used for the auth profile and services.\n\n        Returns:\n            str: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def authenticator_human_readable_name() -&gt; str:\n        \"\"\"\n        Returns the human-readable name of the authenticator.\n\n        Returns:\n            str: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def supported_auth_methods() -&gt; List[ArkAuthMethod]:\n        \"\"\"\n        Returns the authenticator's supported authentication methods.\n\n        Returns:\n            List[ArkAuthMethod]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n        \"\"\"\n        Returns the default authentication method and settings.\n\n        Returns:\n            Tuple[ArkAuthMethod, ArkAuthMethodSettings]: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth._perform_authentication","title":"<code>_perform_authentication(profile, auth_profile, secret=None, force=False)</code>  <code>abstractmethod</code>","text":"<p>Performs the actual authentication, based on the implementation</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>Profile to authenticate on</p> required <code>auth_profile</code> <code>ArkAuthProfile</code> <p>Specific auth profile for the authentication</p> required <code>secret</code> <code>Optional[ArkSecret]</code> <p>Secret used for authentication. Defaults to None</p> <code>None</code> <code>force</code> <code>bool</code> <p>Force authenticate and ignore caching</p> <code>False</code> <p>Returns:</p> Type Description <code>ArkToken</code> <p>Optional[ArkToken]: Token of the authentication to be used</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@abstractmethod\ndef _perform_authentication(\n    self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n) -&gt; ArkToken:\n    \"\"\"\n    Performs the actual authentication, based on the implementation\n\n    Args:\n        profile (ArkProfile): Profile to authenticate on\n        auth_profile (ArkAuthProfile): Specific auth profile for the authentication\n        secret (Optional[ArkSecret]): Secret used for authentication. Defaults to None\n        force (bool): Force authenticate and ignore caching\n\n    Returns:\n        Optional[ArkToken]: Token of the authentication to be used\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth._perform_refresh_authentication","title":"<code>_perform_refresh_authentication(profile, auth_profile, token)</code>  <code>abstractmethod</code>","text":"<p>Tries to perform refresh authentication on the existing token This is not promised for all authenticators</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>auth_profile</code> <code>ArkAuthProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkToken</code> <code>ArkToken</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@abstractmethod\ndef _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n    \"\"\"\n    Tries to perform refresh authentication on the existing token\n    This is not promised for all authenticators\n\n    Args:\n        profile (ArkProfile): _description_\n        auth_profile (ArkAuthProfile): _description_\n        token (ArkToken): _description_\n\n    Returns:\n        ArkToken: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth._resolve_cache_postfix","title":"<code>_resolve_cache_postfix(auth_profile)</code>","text":"<p>Resolves the postfix used to get the token based on the auth method</p> <p>Parameters:</p> Name Type Description Default <code>auth_profile</code> <code>ArkAuthProfile</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def _resolve_cache_postfix(self, auth_profile: ArkAuthProfile) -&gt; str:\n    \"\"\"\n    Resolves the postfix used to get the token based on the auth method\n\n    Args:\n        auth_profile (ArkAuthProfile): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    postfix = auth_profile.username\n    if auth_profile.auth_method == ArkAuthMethod.Direct and auth_profile.auth_method_settings:\n        direct_method_settings = cast(DirectArkAuthMethodSettings, auth_profile.auth_method_settings)\n        if direct_method_settings.endpoint:\n            postfix = f'{postfix}_{urlparse(direct_method_settings.endpoint).netloc}'\n    return postfix\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticate","title":"<code>authenticate(profile=None, auth_profile=None, secret=None, force=False, refresh_auth=False)</code>","text":"<p>Authenticates with the specified authenticator implementation. The implementation is based on the <code>_perform_authentication</code> method. When caching is allowed, authorization credentials are loaded from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile containing information about the environment and authentication methods</p> <code>None</code> <code>auth_profile</code> <code>Optional[ArkAuthProfile]</code> <p>Specific auth profile to use instead of the profile, when provided</p> <code>None</code> <code>secret</code> <code>Optional[ArkSecret]</code> <p>Secret used for authentication</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to force authentication without cached credentials</p> <code>False</code> <code>refresh_auth</code> <code>bool</code> <p>Attempts to refresh an existing cached auth when it is available</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkToken</code> <code>ArkToken</code> <p>The authentication token to use. The token is also saved in the object.</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def authenticate(\n    self,\n    profile: Optional[ArkProfile] = None,\n    auth_profile: Optional[ArkAuthProfile] = None,\n    secret: Optional[ArkSecret] = None,\n    force: bool = False,\n    refresh_auth: bool = False,\n) -&gt; ArkToken:\n    \"\"\"\n    Authenticates with the specified authenticator implementation.\n    The implementation is based on the `_perform_authentication` method.\n    When caching is allowed, authorization credentials are loaded from the cache.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile containing information about the environment and authentication methods\n        auth_profile (Optional[ArkAuthProfile]): Specific auth profile to use instead of the profile, when provided\n        secret (Optional[ArkSecret]): Secret used for authentication\n        force (bool): Determines whether to force authentication without cached credentials\n        refresh_auth (bool): Attempts to refresh an existing cached auth when it is available\n\n    Raises:\n        ArkAuthException: _description_\n\n    Returns:\n        ArkToken: The authentication token to use. The token is also saved in the object.\n    \"\"\"\n    if not auth_profile and not profile:\n        raise ArkAuthException('Either a profile or a specific auth profile must be supplied')\n    if not auth_profile and profile:\n        if self.authenticator_name() in profile.auth_profiles:\n            auth_profile = profile.auth_profiles[self.authenticator_name()]\n        else:\n            raise ArkAuthException(\n                f'{self.authenticator_human_readable_name()} [{self.authenticator_name()}] is not defined within the authentication profiles'\n            )\n    if not profile:\n        profile = ArkProfileLoader.load_default_profile()\n    if auth_profile.auth_method not in self.supported_auth_methods() and auth_profile.auth_method != ArkAuthMethod.Default:\n        raise ArkAuthException(\n            f'{self.authenticator_human_readable_name()} does not support authentication method {auth_profile.auth_method.value}'\n        )\n    if auth_profile.auth_method == ArkAuthMethod.Default:\n        auth_profile.auth_method, auth_profile.auth_method_settings = self.default_auth_method()\n    if auth_profile.auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n        raise ArkAuthException(f'{self.authenticator_human_readable_name()} requires a username and optionally a secret')\n    ark_token = None\n    token_refreshed = False\n    if self._cache_authentication and self._cache_keyring and not force:\n        # Load the postfix of the token based on the auth profile and method type\n        ark_token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n        if ark_token and ark_token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            # Expired, try to refresh\n            if refresh_auth and ark_token.refresh_token:\n                ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                if ark_token:\n                    token_refreshed = True\n            else:\n                ark_token = None\n    if not ark_token:\n        ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n        if self._cache_authentication and self._cache_keyring:\n            self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n    elif refresh_auth and not token_refreshed:\n        try:\n            ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        except Exception as ex:  # Fallback to normal authentication\n            self._logger.info(\n                f'Refresh auth for [{self.authenticator_human_readable_name()}] failed, falling back to normal authentication [{str(ex)}]'\n            )\n            ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n    self.__token = ark_token\n    self._active_profile = profile\n    self._active_auth_profile = auth_profile\n    return ark_token\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticator_human_readable_name","title":"<code>authenticator_human_readable_name()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the human-readable name of the authenticator.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef authenticator_human_readable_name() -&gt; str:\n    \"\"\"\n    Returns the human-readable name of the authenticator.\n\n    Returns:\n        str: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticator_name","title":"<code>authenticator_name()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the name of the authenticator used for the auth profile and services.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef authenticator_name() -&gt; str:\n    \"\"\"\n    Returns the name of the authenticator used for the auth profile and services.\n\n    Returns:\n        str: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.default_auth_method","title":"<code>default_auth_method()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the default authentication method and settings.</p> <p>Returns:</p> Type Description <code>Tuple[ArkAuthMethod, ArkAuthMethodSettings]</code> <p>Tuple[ArkAuthMethod, ArkAuthMethodSettings]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n    \"\"\"\n    Returns the default authentication method and settings.\n\n    Returns:\n        Tuple[ArkAuthMethod, ArkAuthMethodSettings]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.is_authenticated","title":"<code>is_authenticated(profile)</code>","text":"<p>Checks whether the specified profile is authenticated (has a valid token), either from the keyring or in memory. If the valid token originated from the keyring, it is loaded into memory.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def is_authenticated(self, profile: ArkProfile) -&gt; bool:\n    \"\"\"\n    Checks whether the specified profile is authenticated (has a valid token), either from the keyring or in memory.\n    If the valid token originated from the keyring, it is loaded into memory.\n\n    Args:\n        profile (ArkProfile): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    self._logger.info(f'Checking if [{self.authenticator_name()}] is authenticated')\n    if self.__token:\n        self._logger.info('Token is already loaded')\n        return True\n    if self.authenticator_name() in profile.auth_profiles and self._cache_keyring:\n        self.__token = self._cache_keyring.load_token(profile, profile.auth_profiles[self.authenticator_name()].username)\n        if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            self.__token = None\n        else:\n            self._logger.info('Loaded token from cache successfully')\n        return self.__token != None\n    return False\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.load_authentication","title":"<code>load_authentication(profile=None, refresh_auth=False, grace_seconds=None)</code>","text":"<p>Loads and returns the authentication token from the cache, if it exists. If specified, the method also attempts to refresh the token as needed.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>description. Defaults to None.</p> <code>None</code> <code>refresh_auth</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>grace_seconds</code> <code>Optional[int]</code> <p>try to refresh in case there is less than grace_seconds until expired. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def load_authentication(\n    self, profile: Optional[ArkProfile] = None, refresh_auth: bool = False, grace_seconds: Optional[int] = None\n) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads and returns the authentication token from the cache, if it exists.\n    If specified, the method also attempts to refresh the token as needed.\n\n    Args:\n        profile (Optional[ArkProfile], optional): _description_. Defaults to None.\n        refresh_auth (bool, optional): _description_. Defaults to False.\n        grace_seconds (Optional[int], optional): try to refresh in case there is less than grace_seconds until expired. Defaults to None.\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    self._logger.info(f'Trying to load [{self.authenticator_name()}] authentication')\n    if not profile:\n        if self._active_profile:\n            profile = self._active_profile\n        else:\n            profile = ArkProfileLoader.load_default_profile()\n    auth_profile = self._active_auth_profile\n    if not auth_profile and self.authenticator_name() in profile.auth_profiles:\n        auth_profile = profile.auth_profiles[self.authenticator_name()]\n    if auth_profile:\n        self._logger.info(\n            f'Loading authentication for profile [{profile.profile_name}] and auth profile [{self.authenticator_name()}] of type [{auth_profile.auth_method.value}]'\n        )\n        if self._cache_keyring:\n            self.__token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n        if refresh_auth:\n            grace_seconds = grace_seconds if grace_seconds is not None else DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS\n            if self.__token and self.__token.expires_in.replace(tzinfo=None) - timedelta(seconds=grace_seconds) &gt; datetime.now():\n                self._logger.info('Token did not pass grace expiration, no need to refresh')\n            else:\n                self._logger.info('Trying to refresh token authentication')\n                self.__token = self._perform_refresh_authentication(profile, auth_profile, self.__token)\n                if self.__token and self.__token.expires_in.replace(tzinfo=None) &gt; datetime.now():\n                    self._logger.info('Token refreshed')\n                if self.__token and self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, self.__token, self._resolve_cache_postfix(auth_profile))\n        if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            self.__token = None\n        if self.__token:\n            self._active_profile = profile\n            self._active_auth_profile = auth_profile\n        return self.__token\n    return None\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.supported_auth_methods","title":"<code>supported_auth_methods()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the authenticator's supported authentication methods.</p> <p>Returns:</p> Type Description <code>List[ArkAuthMethod]</code> <p>List[ArkAuthMethod]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef supported_auth_methods() -&gt; List[ArkAuthMethod]:\n    \"\"\"\n    Returns the authenticator's supported authentication methods.\n\n    Returns:\n        List[ArkAuthMethod]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_isp_auth/","title":"ark_isp_auth","text":""},{"location":"reference/auth/ark_isp_auth/#ark_sdk_python.auth.ark_isp_auth.ArkISPAuth","title":"<code>ArkISPAuth</code>","text":"<p>               Bases: <code>ArkAuth</code></p> Source code in <code>ark_sdk_python/auth/ark_isp_auth.py</code> <pre><code>class ArkISPAuth(ArkAuth):\n    def __perform_identity_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret], force: bool\n    ) -&gt; ArkToken:\n        try:\n            method_settings = cast(IdentityArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentity(\n                username=auth_profile.username,\n                password=secret.secret.get_secret_value() if secret else None,\n                identity_url=method_settings.identity_url,\n                identity_tenant_subdomain=method_settings.identity_tenant_subdomain,\n                mfa_type=method_settings.identity_mfa_method,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n            )\n            identity.auth_identity(profile, ArkSystemConfig.is_interactive() and method_settings.identity_mfa_interactive, force)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            token_lifetime = identity.session_details.token_lifetime\n            if not token_lifetime:\n                token_lifetime = DEFAULT_TOKEN_LIFETIME\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.Identity,\n                expires_in=datetime.now() + timedelta(seconds=token_lifetime),\n                refresh_token=identity.session_details.refresh_token,\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            self._logger.exception(f'Failed to authenticate to identity security platform [{str(ex)}]')\n            raise ArkAuthException from ex\n\n    def __perform_identity_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        try:\n            method_settings = cast(IdentityArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentity(\n                username=auth_profile.username,\n                password=None,\n                identity_url=method_settings.identity_url,\n                mfa_type=method_settings.identity_mfa_method,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n                load_cache=True,\n                cache_profile=profile,\n            )\n            identity.refresh_auth_identity(profile, method_settings.identity_mfa_interactive, False)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            token_lifetime = identity.session_details.token_lifetime\n            if not token_lifetime:\n                token_lifetime = DEFAULT_TOKEN_LIFETIME\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.Identity,\n                expires_in=datetime.now() + timedelta(seconds=token_lifetime),\n                refresh_token=identity.session_details.refresh_token,\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            raise ArkAuthException('Failed to authenticate to isp via identity') from ex\n\n    def __perform_identity_service_user_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret], force: bool\n    ) -&gt; ArkToken:\n        try:\n            if not secret:\n                raise ArkException('Token secret is required for identity service user auth')\n            method_settings = cast(IdentityServiceUserArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentityServiceUser(\n                username=auth_profile.username,\n                token=secret.secret.get_secret_value(),\n                app_name=method_settings.identity_authorization_application,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n            )\n            identity.auth_identity(profile, force)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.IdentityServiceUser,\n                expires_in=datetime.now() + timedelta(hours=4),\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            self._logger.exception(f'Failed to authenticate to identity security platform with service user [{str(ex)}]')\n            raise ArkAuthException from ex\n\n    @overrides\n    def _perform_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n    ) -&gt; ArkToken:\n        \"\"\"\n        Performs authentication to the identity security platform identity tenant\n        Authentication can be done with either a service user or a normal user\n        Authentication Methods:\n        - Identity, Default\n        - IdentityServiceUser\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            secret (Optional[ArkSecret], optional): _description_. Defaults to None.\n            force (bool, optional): _description_. Defaults to False.\n\n        Raises:\n            ArkAuthException: _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n        self._logger.info('Performing authentication to ISP')\n        if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n            return self.__perform_identity_authentication(profile, auth_profile, secret, force)\n        if auth_profile.auth_method == ArkAuthMethod.IdentityServiceUser:\n            return self.__perform_identity_service_user_authentication(profile, auth_profile, secret, force)\n        raise ArkAuthException('Given auth method is not supported')\n\n    @overrides\n    def _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        \"\"\"\n        Refresh for isp tenant is supported only for identity\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            token (ArkToken): _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n        self._logger.info('Performing refresh authentication to ISP')\n        if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n            return self.__perform_identity_refresh_authentication(profile, auth_profile, token)\n        return token\n\n    @staticmethod\n    @overrides\n    def authenticator_name() -&gt; str:\n        return AUTH_NAME\n\n    @staticmethod\n    @overrides\n    def authenticator_human_readable_name() -&gt; str:\n        return AUTH_HUMAN_READABLE_NAME\n\n    @staticmethod\n    @overrides\n    def supported_auth_methods() -&gt; List[ArkAuthMethod]:\n        return AUTH_METHODS\n\n    @staticmethod\n    @overrides\n    def default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n        return DEFAULT_AUTH_METHOD, DEFAULT_AUTH_METHOD_SETTINGS\n</code></pre>"},{"location":"reference/auth/ark_isp_auth/#ark_sdk_python.auth.ark_isp_auth.ArkISPAuth._perform_authentication","title":"<code>_perform_authentication(profile, auth_profile, secret=None, force=False)</code>","text":"<p>Performs authentication to the identity security platform identity tenant Authentication can be done with either a service user or a normal user Authentication Methods: - Identity, Default - IdentityServiceUser</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>auth_profile</code> <code>ArkAuthProfile</code> <p>description</p> required <code>secret</code> <code>Optional[ArkSecret]</code> <p>description. Defaults to None.</p> <code>None</code> <code>force</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkToken</code> <code>ArkToken</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_isp_auth.py</code> <pre><code>@overrides\ndef _perform_authentication(\n    self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n) -&gt; ArkToken:\n    \"\"\"\n    Performs authentication to the identity security platform identity tenant\n    Authentication can be done with either a service user or a normal user\n    Authentication Methods:\n    - Identity, Default\n    - IdentityServiceUser\n\n    Args:\n        profile (ArkProfile): _description_\n        auth_profile (ArkAuthProfile): _description_\n        secret (Optional[ArkSecret], optional): _description_. Defaults to None.\n        force (bool, optional): _description_. Defaults to False.\n\n    Raises:\n        ArkAuthException: _description_\n\n    Returns:\n        ArkToken: _description_\n    \"\"\"\n    self._logger.info('Performing authentication to ISP')\n    if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n        return self.__perform_identity_authentication(profile, auth_profile, secret, force)\n    if auth_profile.auth_method == ArkAuthMethod.IdentityServiceUser:\n        return self.__perform_identity_service_user_authentication(profile, auth_profile, secret, force)\n    raise ArkAuthException('Given auth method is not supported')\n</code></pre>"},{"location":"reference/auth/ark_isp_auth/#ark_sdk_python.auth.ark_isp_auth.ArkISPAuth._perform_refresh_authentication","title":"<code>_perform_refresh_authentication(profile, auth_profile, token)</code>","text":"<p>Refresh for isp tenant is supported only for identity</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>auth_profile</code> <code>ArkAuthProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkToken</code> <code>ArkToken</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_isp_auth.py</code> <pre><code>@overrides\ndef _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n    \"\"\"\n    Refresh for isp tenant is supported only for identity\n\n    Args:\n        profile (ArkProfile): _description_\n        auth_profile (ArkAuthProfile): _description_\n        token (ArkToken): _description_\n\n    Returns:\n        ArkToken: _description_\n    \"\"\"\n    self._logger.info('Performing refresh authentication to ISP')\n    if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n        return self.__perform_identity_refresh_authentication(profile, auth_profile, token)\n    return token\n</code></pre>"},{"location":"reference/auth/identity/","title":"identity","text":""},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity","title":"<code>ArkIdentity</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>class ArkIdentity:\n    __LAST_START_AUTH_RESP: Dict[str, Tuple[StartAuthResponse, datetime]] = {}\n    __LAST_START_AUTH_RESP_DELTA_SECONDS: Final[int] = 30\n\n    def __init__(\n        self,\n        username: str,\n        password: Optional[str],\n        identity_url: Optional[str] = None,\n        identity_tenant_subdomain: Optional[str] = None,\n        mfa_type: Optional[str] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__password = password\n        self.__identity_url = self.__resolve_fqdn_from_username_or_subdomain(identity_url, identity_tenant_subdomain)\n        if not self.__identity_url.startswith('https://'):\n            self.__identity_url = f'https://{self.__identity_url}'\n        self.__mfa_type = mfa_type\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__interaction_process: Optional[Process] = None\n        self.__is_polling: bool = False\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_details = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__verify = verify\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity')\n            session = self.__keyring.load_token(profile, f'{self.__username}_identity_session')\n            if token and session:\n                import dill as pickle\n\n                try:\n                    self.__session_details = AdvanceAuthResult.model_validate_json(token.token.get_secret_value())\n                except ValidationError:\n                    self.__session_details = IdpAuthStatusResult.model_validate_json(token.token.get_secret_value())\n                self.__session_exp = token.expires_in\n                self.__session = pickle.loads(codecs.decode(session.token.get_secret_value().encode(), \"base64\"))\n                self.__session.verify = self.__verify\n                self.__identity_url = token.endpoint\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_details:\n            import dill as pickle\n\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_details.model_dump_json(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                    refresh_token=self.__session_details.refresh_token,\n                ),\n                f'{self.__username}_identity',\n            )\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=codecs.encode(pickle.dumps(self.__session), 'base64').decode(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_session',\n            )\n\n    def __resolve_fqdn_from_username_or_subdomain(self, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; str:\n        if identity_tenant_subdomain and not identity_url:\n            try:\n                identity_url = ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain(\n                    identity_tenant_subdomain, AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n                )\n            except Exception as ex:\n                self.__logger.warning(f'Failed to resolve url from tenant subdomain, falling back to user [{str(ex)}]')\n        if identity_url:\n            return identity_url\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix=tenant_suffix)\n\n    def __start_authentication(self) -&gt; StartAuthResponse:\n        self.__logger.info(f'Starting authentication with user {self.__username} and fqdn {self.__identity_url}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/StartAuthentication',\n            json={'User': self.__username, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        )\n        try:\n            parsed_res: StartAuthResponse = StartAuthResponse.model_validate_json(response.text)\n            if not parsed_res.result.challenges and not parsed_res.result.idp_redirect_url:\n                raise ValidationError('No challenges or idp redirect url on start auth')\n        except (ValidationError, TypeError) as ex:\n            try:\n                if 'PodFqdn' in response.text:\n                    fqdn = TenantFqdnResponse.model_validate_json(response.text)\n                    self.__identity_url = f'https://{fqdn.result.pod_fqdn}'\n                    self.__session = Session()\n                    self.__session.verify = self.__verify\n                    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n                    return self.__start_authentication()\n            except Exception:\n                pass\n            raise ArkException('Identity start authentication failed to be parsed / validated') from ex\n        return parsed_res\n\n    def __advance_authentication(\n        self, mechanism_id: str, session_id: str, answer: str, action: str\n    ) -&gt; Union[AdvanceAuthMidResponse, AdvanceAuthResponse]:\n        self.__logger.info(f'Advancing authentication with user {self.__username} and fqdn {self.__identity_url} and action {action}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/AdvanceAuthentication',\n            json={'SessionId': session_id, 'MechanismId': mechanism_id, 'Action': action, 'Answer': answer},\n        )\n        try:\n            parsed_res: AdvanceAuthMidResponse = AdvanceAuthMidResponse.model_validate_json(response.text)\n            if parsed_res.result.summary == 'LoginSuccess':\n                parsed_res: AdvanceAuthResponse = AdvanceAuthResponse.model_validate_json(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity advance authentication failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __identity_idp_auth_status(self, session_id: str) -&gt; IdpAuthStatusResponse:\n        self.__logger.info(f'Calling idp auth status for fqdn {self.__identity_url} and session id {session_id}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/OobAuthStatus',\n            json={'SessionId': session_id},\n        )\n        try:\n            parsed_res: IdpAuthStatusResponse = IdpAuthStatusResponse.model_validate_json(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity idp auth status failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __start_input_process(\n        self, pipe_write: Connection, pipe_read: Connection, mechanism: Mechanism, oob_advance_resp: AdvanceAuthMidResponse\n    ) -&gt; None:\n        if self.__interaction_process:\n            raise ArkException('Interaction thread is already in progress')\n        if sys.platform not in ['win32', 'cygwin']:\n            ctx = get_context('fork')\n        else:\n            ctx = get_context('spawn')\n        self.__interaction_process = ctx.Process(\n            target=input_process,\n            args=(\n                pipe_write,\n                pipe_read,\n                mechanism,\n                oob_advance_resp,\n            ),\n        )\n        self.__interaction_process.start()\n\n    def __stop_input_process(self) -&gt; None:\n        if self.__interaction_process:\n            self.__interaction_process.kill()\n            self.__interaction_process.join()\n            self.__interaction_process = None\n\n    def __poll_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        start_auth_response: StartAuthResponse,\n        oob_advance_resp: AdvanceAuthMidResponse,\n        is_interactive: bool,\n    ) -&gt; None:\n        try:\n            if self.__is_polling:\n                raise ArkException('MFA Polling is already in progress')\n            self.__is_polling = True\n            input_conn, output_conn = Pipe(duplex=True)\n            if is_interactive:\n                self.__start_input_process(input_conn, output_conn, mechanism, oob_advance_resp)\n            start_time = datetime.now()\n            while self.__is_polling:\n                current_time = datetime.now()\n                if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                    self.__is_polling = False\n                    raise ArkException('Timeout reached while polling for user answer')\n                if output_conn.poll():\n                    mfa_code = output_conn.recv()\n                    advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, mfa_code, 'Answer'\n                    )\n                    if isinstance(advance_resp, AdvanceAuthResponse):\n                        input_conn.send('DONE')\n                    else:\n                        input_conn.send('CONTINUE')\n                else:\n                    advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'Poll')\n                if isinstance(advance_resp, AdvanceAuthResponse):\n                    # Done here, save the token\n                    self.__is_polling = False\n                    if is_interactive:\n                        self.__stop_input_process()\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                time.sleep(POLL_INTERVAL_MS)\n        except Exception as ex:\n            if is_interactive:\n                self.__stop_input_process()\n            if not self.__session_details:\n                raise ex\n        finally:\n            if is_interactive:\n                self.__stop_input_process()\n\n    def __pick_mechanism(self, challenge: Challenge) -&gt; Mechanism:\n        factors = {'otp': '\ud83d\udcf2 Push / Code', 'sms': '\ud83d\udcdf SMS', 'email': '\ud83d\udce7 Email', 'pf': '\ud83d\udcde Phone call', 'up': '\ud83d\udd11 User Password'}\n        supported_mechanisms = [m for m in challenge.mechanisms if m.name.lower() in SUPPORTED_MECHANISMS]\n        answers = inquirer.prompt(\n            [\n                inquirer.List(\n                    'mfa',\n                    'Please pick one of the following MFA methods',\n                    choices=[factors[m.name.lower()] for m in supported_mechanisms],\n                    default=factors[self.__mfa_type] if self.__mfa_type and self.__mfa_type in factors else None,\n                    carousel=True,\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            raise ArkException('Failed to get answer for which MFA method to use')\n        self.__mfa_type = next(filter(lambda f: factors[f] == answers['mfa'], factors.keys()))\n        return next(filter(lambda m: factors[m.name.lower()] == answers['mfa'], supported_mechanisms))\n\n    def __perform_idp_authentication(\n        self, start_auth_response: StartAuthResponse, profile: Optional[ArkProfile] = None, interactive: bool = False\n    ) -&gt; None:\n        if self.__is_polling:\n            raise ArkException('MFA / IDP Polling is already in progress')\n        # Print the user some info if we are interactive\n        if interactive:\n            ArkArgsFormatter.print_normal_bright(\n                \"\\nYou are now being redirected from your browser to your external identity provider for authentication\\n\"\n                \"If the browser did not open, you may also click the following URL to access your identity provider authentication\\n\\n\"\n                f\"{start_auth_response.result.idp_redirect_short_url}\\n\"\n            )\n\n        # Error can be ignored\n        webbrowser.open(start_auth_response.result.idp_redirect_short_url, new=0, autoraise=True)\n\n        # Start polling for idp auth\n        self.__is_polling = True\n        start_time = datetime.now()\n        while self.__is_polling:\n            current_time = datetime.now()\n            if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                self.__is_polling = False\n                raise ArkException('Timeout reached while polling for idp auth')\n            idp_auth_status = self.__identity_idp_auth_status(start_auth_response.result.idp_login_session_id)\n            if idp_auth_status.result.state == 'Success' and idp_auth_status.result.token:\n                # We managed to successfully authenticate\n                # Done here, save the token\n                self.__session_details = idp_auth_status.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {idp_auth_status.result.token}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                break\n            time.sleep(POLL_INTERVAL_MS)\n\n    def __perform_up_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        interactive: bool,\n        start_auth_response: StartAuthResponse,\n        current_challenge_idx: int,\n    ) -&gt; Tuple[str, int]:\n        current_challenge_idx += 1\n        # Password, answer it\n        if not self.__password:\n            if not interactive:\n                raise ArkAuthException('No password and not interactive, cannot continue')\n            answers = inquirer.prompt(\n                [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                raise ArkAuthException('Canceled by user')\n            self.__password = answers['answer']\n        advance_resp = self.__advance_authentication(\n            mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n        )\n        if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n            # Done here, save the token\n            self.__session_details = advance_resp.result\n            self.__session.headers.update(\n                {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n            )\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            if self.__cache_authentication:\n                self.__save_cache(profile)\n            return 'DONE', current_challenge_idx\n        elif isinstance(advance_resp, AdvanceAuthMidResponse) and advance_resp.result.challenges:\n            start_auth_response.result.challenges = advance_resp.result.challenges\n            current_challenge_idx = 0\n        return 'CONTINUE', current_challenge_idx\n\n    @classmethod\n    def has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n        \"\"\"\n        Checks if a cache record exists for the specified profile and username.\n\n        Args:\n            profile (ArkProfile): _description_\n            username (str): _description_\n            refresh_auth_allowed (bool): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        keyring = ArkKeyring(cls.__name__.lower())\n        token = keyring.load_token(profile, f'{username}_identity')\n        session = keyring.load_token(profile, f'{username}_identity_session')\n        if token is not None and session is not None:\n            if token.expires_in and token.expires_in &lt; datetime.now():\n                if token.refresh_token and refresh_auth_allowed:\n                    return True\n                return False\n            return True\n        return False\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_idp_user(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n        \"\"\"\n        Checks whether or not the specified username is from an external IDP.\n\n        Args:\n            username (str): _description_\n            identity_url (Optional[str]): _description_\n            identity_tenant_subdomain (Optional[str]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n            return False\n        identity = ArkIdentity(\n            username=username,\n            password='',\n            identity_url=identity_url,\n            identity_tenant_subdomain=identity_tenant_subdomain,\n        )\n        resp = identity.__start_authentication()\n        return resp.result.idp_redirect_url != None\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_password_required(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n        \"\"\"\n        Checks whether or not the specified username is from an external IDP.\n        Args:\n            username (str): _description_\n            identity_url (Optional[str]): _description_\n            identity_tenant_subdomain (Optional[str]): _description_\n        Returns:\n            bool: _description_\n        \"\"\"\n        identity = ArkIdentity(\n            username=username,\n            password='',\n            identity_url=identity_url,\n            identity_tenant_subdomain=identity_tenant_subdomain,\n        )\n        resp = identity.__start_authentication()\n        ArkIdentity.__LAST_START_AUTH_RESP[f'{identity.identity_url}_{username}'] = (resp, datetime.now())\n        return (\n            resp.result.idp_redirect_url == None\n            and resp.result.challenges\n            and all(c.name == 'UP' for c in resp.result.challenges[0].mechanisms)\n        )\n\n    def get_apps(self) -&gt; Dict:\n        \"\"\"\n        Returns the applications to which the user is logged in.\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            Dict: _description_\n        \"\"\"\n        if not self.__session_details:\n            raise ArkException('Identity authentication is required first')\n        cookies = self.__session.cookies.copy()\n        response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n        self.__session.cookies = cookies\n        return json.loads(response.text)\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with the information specified in the constructor.\n        If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n        The auth token and other details are stored in the object for future use.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n            interactive (bool): Determines whether interactive user prompts are allowed\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        self.__logger.debug('Attempting to authenticate to Identity')\n        self.__session_details = None\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity details from cache')\n                return\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n        # Start the authentication\n        start_auth_response: Optional[StartAuthResponse] = None\n        if f'{self.__identity_url}_{self.__username}' in ArkIdentity.__LAST_START_AUTH_RESP:\n            start_auth_response_time = ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n            if (datetime.now() - start_auth_response_time[1]).total_seconds() &lt; ArkIdentity.__LAST_START_AUTH_RESP_DELTA_SECONDS:\n                start_auth_response = start_auth_response_time[0]\n            del ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n        if not start_auth_response:\n            start_auth_response = self.__start_authentication()\n        if start_auth_response.result.idp_redirect_url:\n            # External IDP Flow, ignore the mechanisms and just open a browser\n            self.__perform_idp_authentication(start_auth_response, profile, interactive)\n            return\n\n        # Check if password is part of the first challenges list and if so, answer it directly\n        current_challenge_idx = 0\n        if len(start_auth_response.result.challenges[current_challenge_idx].mechanisms) &gt; 1 and interactive:\n            mechanism = self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n            if mechanism.name.lower() == 'up':\n                result, current_challenge_idx = self.__perform_up_authentication(\n                    profile, mechanism, interactive, start_auth_response, current_challenge_idx\n                )\n                if result == 'DONE':\n                    return\n            else:\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                if self.__session_details:\n                    return\n        else:\n            mechanism = start_auth_response.result.challenges[current_challenge_idx].mechanisms[0]\n            if mechanism.name.lower() == 'up':\n                result, current_challenge_idx = self.__perform_up_authentication(\n                    profile, mechanism, interactive, start_auth_response, current_challenge_idx\n                )\n                if result == 'DONE':\n                    return\n\n        # Pick MFA for the user\n        if interactive:\n            self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n        # Handle a case where MFA type was supplied\n        if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS:\n            for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n                if mechanism.name.lower() == self.__mfa_type.lower():\n                    oob_advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                    )\n                    self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                    return\n\n        if not interactive:\n            raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n        # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n        for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n            mechanism = self.__pick_mechanism(challenge)\n            oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n\n    # pylint: disable=unused-argument\n    def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Performs a token refresh with the object's existing details.\n\n        Args:\n            profile (Optional[ArkProfile]): The profile to load from the cache, if available\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        if not self.__session_details.token:\n            # We only refresh platform token at the moment, call the normal authentication instead\n            return self.auth_identity(profile, interactive, force)\n\n        self.__logger.debug('Attempting to refresh authenticate to Identity')\n        saved_cookies = None\n        if self.__session:\n            saved_cookies = self.__session.cookies.copy()\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        decoded_token = ArkJWTUtils.get_unverified_claims(self.__session_details.token)\n        platform_tenant_id = decoded_token['tenant_id']\n        refresh_cookies = {\n            f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n            f'idToken-{platform_tenant_id}': self.__session_details.token,\n        }\n        response = self.__session.post(\n            url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n            cookies=refresh_cookies,\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed to refresh token')\n        new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n        new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n        if not new_token or not new_refresh_token:\n            raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n        if saved_cookies:\n            self.__session.cookies = saved_cookies\n        self.__session_details.token = new_token\n        self.__session_details.refresh_token = new_refresh_token\n        self.__session_details.token_lifetime = (\n            datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['exp'])\n            - datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['iat'])\n        ).seconds\n        delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n        self.__session_exp = datetime.now() + timedelta(seconds=delta)\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        if self.__session_details:\n            if self.__session_details.token:\n                return self.__session_details.token\n            if 'auth' in self.__session_details.__dict__ and self.__session_details.auth:\n                return self.__session_details.auth\n        return None\n\n    @property\n    def session_details(self) -&gt; Optional[AdvanceAuthResult]:\n        return self.__session_details\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.auth_identity","title":"<code>auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Authenticates to Identity with the information specified in the constructor. If MFA is configured and <code>interactive</code> is enabled, the user is prompted for the MFA secret. The auth token and other details are stored in the object for future use.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to use (loaded from cache, if available)</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Determines whether interactive user prompts are allowed</p> <code>False</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with the information specified in the constructor.\n    If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n    The auth token and other details are stored in the object for future use.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n        interactive (bool): Determines whether interactive user prompts are allowed\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    self.__logger.debug('Attempting to authenticate to Identity')\n    self.__session_details = None\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity details from cache')\n            return\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n    # Start the authentication\n    start_auth_response: Optional[StartAuthResponse] = None\n    if f'{self.__identity_url}_{self.__username}' in ArkIdentity.__LAST_START_AUTH_RESP:\n        start_auth_response_time = ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n        if (datetime.now() - start_auth_response_time[1]).total_seconds() &lt; ArkIdentity.__LAST_START_AUTH_RESP_DELTA_SECONDS:\n            start_auth_response = start_auth_response_time[0]\n        del ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n    if not start_auth_response:\n        start_auth_response = self.__start_authentication()\n    if start_auth_response.result.idp_redirect_url:\n        # External IDP Flow, ignore the mechanisms and just open a browser\n        self.__perform_idp_authentication(start_auth_response, profile, interactive)\n        return\n\n    # Check if password is part of the first challenges list and if so, answer it directly\n    current_challenge_idx = 0\n    if len(start_auth_response.result.challenges[current_challenge_idx].mechanisms) &gt; 1 and interactive:\n        mechanism = self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n        if mechanism.name.lower() == 'up':\n            result, current_challenge_idx = self.__perform_up_authentication(\n                profile, mechanism, interactive, start_auth_response, current_challenge_idx\n            )\n            if result == 'DONE':\n                return\n        else:\n            oob_advance_resp = self.__advance_authentication(\n                mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n            )\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n            if self.__session_details:\n                return\n    else:\n        mechanism = start_auth_response.result.challenges[current_challenge_idx].mechanisms[0]\n        if mechanism.name.lower() == 'up':\n            result, current_challenge_idx = self.__perform_up_authentication(\n                profile, mechanism, interactive, start_auth_response, current_challenge_idx\n            )\n            if result == 'DONE':\n                return\n\n    # Pick MFA for the user\n    if interactive:\n        self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n    # Handle a case where MFA type was supplied\n    if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS:\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == self.__mfa_type.lower():\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                return\n\n    if not interactive:\n        raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n    # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n    for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n        mechanism = self.__pick_mechanism(challenge)\n        oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n        self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.get_apps","title":"<code>get_apps()</code>","text":"<p>Returns the applications to which the user is logged in.</p> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def get_apps(self) -&gt; Dict:\n    \"\"\"\n    Returns the applications to which the user is logged in.\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        Dict: _description_\n    \"\"\"\n    if not self.__session_details:\n        raise ArkException('Identity authentication is required first')\n    cookies = self.__session.cookies.copy()\n    response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n    self.__session.cookies = cookies\n    return json.loads(response.text)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.has_cache_record","title":"<code>has_cache_record(profile, username, refresh_auth_allowed)</code>  <code>classmethod</code>","text":"<p>Checks if a cache record exists for the specified profile and username.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>username</code> <code>str</code> <p>description</p> required <code>refresh_auth_allowed</code> <code>bool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\ndef has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n    \"\"\"\n    Checks if a cache record exists for the specified profile and username.\n\n    Args:\n        profile (ArkProfile): _description_\n        username (str): _description_\n        refresh_auth_allowed (bool): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    keyring = ArkKeyring(cls.__name__.lower())\n    token = keyring.load_token(profile, f'{username}_identity')\n    session = keyring.load_token(profile, f'{username}_identity_session')\n    if token is not None and session is not None:\n        if token.expires_in and token.expires_in &lt; datetime.now():\n            if token.refresh_token and refresh_auth_allowed:\n                return True\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.is_idp_user","title":"<code>is_idp_user(username, identity_url, identity_tenant_subdomain)</code>  <code>classmethod</code>","text":"<p>Checks whether or not the specified username is from an external IDP.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>description</p> required <code>identity_url</code> <code>Optional[str]</code> <p>description</p> required <code>identity_tenant_subdomain</code> <code>Optional[str]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_idp_user(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n    \"\"\"\n    Checks whether or not the specified username is from an external IDP.\n\n    Args:\n        username (str): _description_\n        identity_url (Optional[str]): _description_\n        identity_tenant_subdomain (Optional[str]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n        return False\n    identity = ArkIdentity(\n        username=username,\n        password='',\n        identity_url=identity_url,\n        identity_tenant_subdomain=identity_tenant_subdomain,\n    )\n    resp = identity.__start_authentication()\n    return resp.result.idp_redirect_url != None\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.is_password_required","title":"<code>is_password_required(username, identity_url, identity_tenant_subdomain)</code>  <code>classmethod</code>","text":"<p>Checks whether or not the specified username is from an external IDP. Args:     username (str): description     identity_url (Optional[str]): description     identity_tenant_subdomain (Optional[str]): description Returns:     bool: description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_password_required(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n    \"\"\"\n    Checks whether or not the specified username is from an external IDP.\n    Args:\n        username (str): _description_\n        identity_url (Optional[str]): _description_\n        identity_tenant_subdomain (Optional[str]): _description_\n    Returns:\n        bool: _description_\n    \"\"\"\n    identity = ArkIdentity(\n        username=username,\n        password='',\n        identity_url=identity_url,\n        identity_tenant_subdomain=identity_tenant_subdomain,\n    )\n    resp = identity.__start_authentication()\n    ArkIdentity.__LAST_START_AUTH_RESP[f'{identity.identity_url}_{username}'] = (resp, datetime.now())\n    return (\n        resp.result.idp_redirect_url == None\n        and resp.result.challenges\n        and all(c.name == 'UP' for c in resp.result.challenges[0].mechanisms)\n    )\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.refresh_auth_identity","title":"<code>refresh_auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Performs a token refresh with the object's existing details.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>The profile to load from the cache, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Performs a token refresh with the object's existing details.\n\n    Args:\n        profile (Optional[ArkProfile]): The profile to load from the cache, if available\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    if not self.__session_details.token:\n        # We only refresh platform token at the moment, call the normal authentication instead\n        return self.auth_identity(profile, interactive, force)\n\n    self.__logger.debug('Attempting to refresh authenticate to Identity')\n    saved_cookies = None\n    if self.__session:\n        saved_cookies = self.__session.cookies.copy()\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n    decoded_token = ArkJWTUtils.get_unverified_claims(self.__session_details.token)\n    platform_tenant_id = decoded_token['tenant_id']\n    refresh_cookies = {\n        f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n        f'idToken-{platform_tenant_id}': self.__session_details.token,\n    }\n    response = self.__session.post(\n        url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n        cookies=refresh_cookies,\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed to refresh token')\n    new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n    new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n    if not new_token or not new_refresh_token:\n        raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n    if saved_cookies:\n        self.__session.cookies = saved_cookies\n    self.__session_details.token = new_token\n    self.__session_details.refresh_token = new_refresh_token\n    self.__session_details.token_lifetime = (\n        datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['exp'])\n        - datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['iat'])\n    ).seconds\n    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver","title":"<code>ArkIdentityFQDNResolver</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>class ArkIdentityFQDNResolver:\n    __DISCOVERY_SERVICE_DOMAIN_NAME: Final[str] = 'platform-discovery'\n    __DISCOVERY_TIMEOUT: Final[int] = 30\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {\n            'Content-Type': 'application/json',\n            'X-IDAP-NATIVE-CLIENT': 'true',\n            'User-Agent': UserAgent(browsers=['chrome']).chrome,\n            'OobIdPAuth': 'true',\n        }\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_system_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {'X-IDAP-NATIVE-CLIENT': 'true', 'User-Agent': UserAgent(browsers=['chrome']).chrome}\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL from its subdomain.\n        The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n        Args:\n            tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n            env (AwsEnv): The environment for which the the tenant URL is resolved\n\n        Raises:\n            ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n        Returns:\n            str: The tenant's resolved FQDN\n        \"\"\"\n        platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n        session = Session()\n        response = session.get(\n            f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n            headers={'Content-Type': 'application/json'},\n            timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n        )\n        try:\n            if response.status_code == HTTPStatus.OK:\n                parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.model_validate_json(response.text)\n                return str(parsed_response.endpoint)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n        raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL in Identity.\n        By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n        Args:\n            tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n            identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: The tenant's FQDN\n        \"\"\"\n        identity_env_url = identity_env_url or (\n            IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n        )\n        session = Session()\n        response = session.post(\n            f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n            json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n            headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n        )\n        try:\n            parsed_res: TenantFqdnResponse = TenantFqdnResponse.model_validate_json(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n        if not parsed_res.result.pod_fqdn.startswith('https://'):\n            parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n        return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain","title":"<code>resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain, env)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL from its subdomain. The resolved URL is based on the current working environment, which is provided in the <code>tenant_subdomain</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_subdomain</code> <code>str</code> <p>The tenant subdomain, for example: <code>mytenant</code></p> required <code>env</code> <code>AwsEnv</code> <p>The environment for which the the tenant URL is resolved</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>When an error occurs or the tenant username prefix was not found in the Identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's resolved FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL from its subdomain.\n    The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n    Args:\n        tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n        env (AwsEnv): The environment for which the the tenant URL is resolved\n\n    Raises:\n        ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n    Returns:\n        str: The tenant's resolved FQDN\n    \"\"\"\n    platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n    session = Session()\n    response = session.get(\n        f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n        headers={'Content-Type': 'application/json'},\n        timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n    )\n    try:\n        if response.status_code == HTTPStatus.OK:\n            parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.model_validate_json(response.text)\n            return str(parsed_response.endpoint)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n    raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix","title":"<code>resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix, identity_env_url=None)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL in Identity. By default, the Identity address is resolved from the current environment mapping (see <code>get_identity_env_url()</code>), but it can be optionally be resolved from the <code>identity_env_url</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_suffix</code> <code>str</code> <p>The tenant's URL suffix, for example: <code>@tenant-a-527.shell.cyberark.cloud</code></p> required <code>identity_env_url</code> <code>str</code> <p>If specified, used as the Identity pod0 URL; otherwise, defaults to <code>None</code> (use environment mapping)</p> <code>None</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL in Identity.\n    By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n    Args:\n        tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n        identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: The tenant's FQDN\n    \"\"\"\n    identity_env_url = identity_env_url or (\n        IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n    )\n    session = Session()\n    response = session.post(\n        f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n        json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n    )\n    try:\n        parsed_res: TenantFqdnResponse = TenantFqdnResponse.model_validate_json(response.text)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n    if not parsed_res.result.pod_fqdn.startswith('https://'):\n        parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n    return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityServiceUser","title":"<code>ArkIdentityServiceUser</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>class ArkIdentityServiceUser:\n    def __init__(\n        self,\n        username: str,\n        token: str,\n        app_name: str,\n        identity_url: Optional[str] = None,\n        env: Optional[AwsEnv] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__token = token\n        self.__app_name = app_name\n        self.__env = env or AwsEnv(os.getenv(DEPLOY_ENV, AwsEnv.PROD.value))\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_token = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_system_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity_service_user')\n            if token and token.username == self.__username:\n                self.__session_token = token.token.get_secret_value()\n                self.__session_exp = token.expires_in\n                self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}'})\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_token:\n            self.__session_exp = datetime.now() + timedelta(hours=4)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_token,\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_service_user',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(\n            tenant_suffix=tenant_suffix, identity_env_url=IDENTITY_ENV_URLS[self.__env]\n        )\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with a service user.\n        This method creates an auth token and authorizes to the service.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n            force (bool): Determines whether to discard existing cache, defaults to `False`\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        # Login to identity with the service service user\n        self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity service user details from cache')\n                return\n\n        token_response: Response = self.__session.post(\n            url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n            auth=HTTPBasicAuth(self.__username, self.__token),\n            verify=True,\n            data={'grant_type': 'client_credentials', 'scope': 'api'},\n        )\n        if token_response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed logging in to identity service user')\n        auth_result = json.loads(token_response.text)\n        if 'access_token' not in auth_result.keys():\n            raise ArkAuthException('Failed logging in to identity service user, access token not found')\n        access_token = auth_result['access_token']\n\n        # Authorize to the application with the service user\n        params = {\n            'client_id': self.__app_name,\n            'response_type': 'id_token',\n            'scope': 'openid profile api',\n            'redirect_uri': 'https://cyberark.cloud/redirect',\n        }\n        self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n        authorize_response = self.__session.get(\n            url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n            headers={'Authorization': f'Bearer {access_token}'},\n            params=params,\n            allow_redirects=False,\n        )\n        if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n            raise ArkAuthException('Failed to authorize to application')\n        # Parse the authorized token and return the session with it\n        location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n        if len(location_header_splitted) != 2:\n            raise ArkAuthException('Failed to parse location header to retrieve token from')\n        parsed_query = parse_qs(location_header_splitted[1])\n        if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n            raise ArkAuthException('Failed to parse id token from location header')\n        self.__session_token = parsed_query['id_token'][0]\n        self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n        self.__session_exp = datetime.now() + timedelta(hours=4)\n        self.__logger.info(\n            f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n        )\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__session_token\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityServiceUser.auth_identity","title":"<code>auth_identity(profile=None, force=False)</code>","text":"<p>Authenticates to Identity with a service user. This method creates an auth token and authorizes to the service.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to discard existing cache, defaults to <code>False</code></p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with a service user.\n    This method creates an auth token and authorizes to the service.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n        force (bool): Determines whether to discard existing cache, defaults to `False`\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    # Login to identity with the service service user\n    self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity service user details from cache')\n            return\n\n    token_response: Response = self.__session.post(\n        url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n        auth=HTTPBasicAuth(self.__username, self.__token),\n        verify=True,\n        data={'grant_type': 'client_credentials', 'scope': 'api'},\n    )\n    if token_response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed logging in to identity service user')\n    auth_result = json.loads(token_response.text)\n    if 'access_token' not in auth_result.keys():\n        raise ArkAuthException('Failed logging in to identity service user, access token not found')\n    access_token = auth_result['access_token']\n\n    # Authorize to the application with the service user\n    params = {\n        'client_id': self.__app_name,\n        'response_type': 'id_token',\n        'scope': 'openid profile api',\n        'redirect_uri': 'https://cyberark.cloud/redirect',\n    }\n    self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n    authorize_response = self.__session.get(\n        url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n        headers={'Authorization': f'Bearer {access_token}'},\n        params=params,\n        allow_redirects=False,\n    )\n    if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n        raise ArkAuthException('Failed to authorize to application')\n    # Parse the authorized token and return the session with it\n    location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n    if len(location_header_splitted) != 2:\n        raise ArkAuthException('Failed to parse location header to retrieve token from')\n    parsed_query = parse_qs(location_header_splitted[1])\n    if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n        raise ArkAuthException('Failed to parse id token from location header')\n    self.__session_token = parsed_query['id_token'][0]\n    self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n    self.__session_exp = datetime.now() + timedelta(hours=4)\n    self.__logger.info(\n        f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n    )\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/","title":"ark_identity","text":""},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity","title":"<code>ArkIdentity</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>class ArkIdentity:\n    __LAST_START_AUTH_RESP: Dict[str, Tuple[StartAuthResponse, datetime]] = {}\n    __LAST_START_AUTH_RESP_DELTA_SECONDS: Final[int] = 30\n\n    def __init__(\n        self,\n        username: str,\n        password: Optional[str],\n        identity_url: Optional[str] = None,\n        identity_tenant_subdomain: Optional[str] = None,\n        mfa_type: Optional[str] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__password = password\n        self.__identity_url = self.__resolve_fqdn_from_username_or_subdomain(identity_url, identity_tenant_subdomain)\n        if not self.__identity_url.startswith('https://'):\n            self.__identity_url = f'https://{self.__identity_url}'\n        self.__mfa_type = mfa_type\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__interaction_process: Optional[Process] = None\n        self.__is_polling: bool = False\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_details = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__verify = verify\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity')\n            session = self.__keyring.load_token(profile, f'{self.__username}_identity_session')\n            if token and session:\n                import dill as pickle\n\n                try:\n                    self.__session_details = AdvanceAuthResult.model_validate_json(token.token.get_secret_value())\n                except ValidationError:\n                    self.__session_details = IdpAuthStatusResult.model_validate_json(token.token.get_secret_value())\n                self.__session_exp = token.expires_in\n                self.__session = pickle.loads(codecs.decode(session.token.get_secret_value().encode(), \"base64\"))\n                self.__session.verify = self.__verify\n                self.__identity_url = token.endpoint\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_details:\n            import dill as pickle\n\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_details.model_dump_json(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                    refresh_token=self.__session_details.refresh_token,\n                ),\n                f'{self.__username}_identity',\n            )\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=codecs.encode(pickle.dumps(self.__session), 'base64').decode(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_session',\n            )\n\n    def __resolve_fqdn_from_username_or_subdomain(self, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; str:\n        if identity_tenant_subdomain and not identity_url:\n            try:\n                identity_url = ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain(\n                    identity_tenant_subdomain, AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n                )\n            except Exception as ex:\n                self.__logger.warning(f'Failed to resolve url from tenant subdomain, falling back to user [{str(ex)}]')\n        if identity_url:\n            return identity_url\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix=tenant_suffix)\n\n    def __start_authentication(self) -&gt; StartAuthResponse:\n        self.__logger.info(f'Starting authentication with user {self.__username} and fqdn {self.__identity_url}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/StartAuthentication',\n            json={'User': self.__username, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        )\n        try:\n            parsed_res: StartAuthResponse = StartAuthResponse.model_validate_json(response.text)\n            if not parsed_res.result.challenges and not parsed_res.result.idp_redirect_url:\n                raise ValidationError('No challenges or idp redirect url on start auth')\n        except (ValidationError, TypeError) as ex:\n            try:\n                if 'PodFqdn' in response.text:\n                    fqdn = TenantFqdnResponse.model_validate_json(response.text)\n                    self.__identity_url = f'https://{fqdn.result.pod_fqdn}'\n                    self.__session = Session()\n                    self.__session.verify = self.__verify\n                    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n                    return self.__start_authentication()\n            except Exception:\n                pass\n            raise ArkException('Identity start authentication failed to be parsed / validated') from ex\n        return parsed_res\n\n    def __advance_authentication(\n        self, mechanism_id: str, session_id: str, answer: str, action: str\n    ) -&gt; Union[AdvanceAuthMidResponse, AdvanceAuthResponse]:\n        self.__logger.info(f'Advancing authentication with user {self.__username} and fqdn {self.__identity_url} and action {action}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/AdvanceAuthentication',\n            json={'SessionId': session_id, 'MechanismId': mechanism_id, 'Action': action, 'Answer': answer},\n        )\n        try:\n            parsed_res: AdvanceAuthMidResponse = AdvanceAuthMidResponse.model_validate_json(response.text)\n            if parsed_res.result.summary == 'LoginSuccess':\n                parsed_res: AdvanceAuthResponse = AdvanceAuthResponse.model_validate_json(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity advance authentication failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __identity_idp_auth_status(self, session_id: str) -&gt; IdpAuthStatusResponse:\n        self.__logger.info(f'Calling idp auth status for fqdn {self.__identity_url} and session id {session_id}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/OobAuthStatus',\n            json={'SessionId': session_id},\n        )\n        try:\n            parsed_res: IdpAuthStatusResponse = IdpAuthStatusResponse.model_validate_json(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity idp auth status failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __start_input_process(\n        self, pipe_write: Connection, pipe_read: Connection, mechanism: Mechanism, oob_advance_resp: AdvanceAuthMidResponse\n    ) -&gt; None:\n        if self.__interaction_process:\n            raise ArkException('Interaction thread is already in progress')\n        if sys.platform not in ['win32', 'cygwin']:\n            ctx = get_context('fork')\n        else:\n            ctx = get_context('spawn')\n        self.__interaction_process = ctx.Process(\n            target=input_process,\n            args=(\n                pipe_write,\n                pipe_read,\n                mechanism,\n                oob_advance_resp,\n            ),\n        )\n        self.__interaction_process.start()\n\n    def __stop_input_process(self) -&gt; None:\n        if self.__interaction_process:\n            self.__interaction_process.kill()\n            self.__interaction_process.join()\n            self.__interaction_process = None\n\n    def __poll_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        start_auth_response: StartAuthResponse,\n        oob_advance_resp: AdvanceAuthMidResponse,\n        is_interactive: bool,\n    ) -&gt; None:\n        try:\n            if self.__is_polling:\n                raise ArkException('MFA Polling is already in progress')\n            self.__is_polling = True\n            input_conn, output_conn = Pipe(duplex=True)\n            if is_interactive:\n                self.__start_input_process(input_conn, output_conn, mechanism, oob_advance_resp)\n            start_time = datetime.now()\n            while self.__is_polling:\n                current_time = datetime.now()\n                if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                    self.__is_polling = False\n                    raise ArkException('Timeout reached while polling for user answer')\n                if output_conn.poll():\n                    mfa_code = output_conn.recv()\n                    advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, mfa_code, 'Answer'\n                    )\n                    if isinstance(advance_resp, AdvanceAuthResponse):\n                        input_conn.send('DONE')\n                    else:\n                        input_conn.send('CONTINUE')\n                else:\n                    advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'Poll')\n                if isinstance(advance_resp, AdvanceAuthResponse):\n                    # Done here, save the token\n                    self.__is_polling = False\n                    if is_interactive:\n                        self.__stop_input_process()\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                time.sleep(POLL_INTERVAL_MS)\n        except Exception as ex:\n            if is_interactive:\n                self.__stop_input_process()\n            if not self.__session_details:\n                raise ex\n        finally:\n            if is_interactive:\n                self.__stop_input_process()\n\n    def __pick_mechanism(self, challenge: Challenge) -&gt; Mechanism:\n        factors = {'otp': '\ud83d\udcf2 Push / Code', 'sms': '\ud83d\udcdf SMS', 'email': '\ud83d\udce7 Email', 'pf': '\ud83d\udcde Phone call', 'up': '\ud83d\udd11 User Password'}\n        supported_mechanisms = [m for m in challenge.mechanisms if m.name.lower() in SUPPORTED_MECHANISMS]\n        answers = inquirer.prompt(\n            [\n                inquirer.List(\n                    'mfa',\n                    'Please pick one of the following MFA methods',\n                    choices=[factors[m.name.lower()] for m in supported_mechanisms],\n                    default=factors[self.__mfa_type] if self.__mfa_type and self.__mfa_type in factors else None,\n                    carousel=True,\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            raise ArkException('Failed to get answer for which MFA method to use')\n        self.__mfa_type = next(filter(lambda f: factors[f] == answers['mfa'], factors.keys()))\n        return next(filter(lambda m: factors[m.name.lower()] == answers['mfa'], supported_mechanisms))\n\n    def __perform_idp_authentication(\n        self, start_auth_response: StartAuthResponse, profile: Optional[ArkProfile] = None, interactive: bool = False\n    ) -&gt; None:\n        if self.__is_polling:\n            raise ArkException('MFA / IDP Polling is already in progress')\n        # Print the user some info if we are interactive\n        if interactive:\n            ArkArgsFormatter.print_normal_bright(\n                \"\\nYou are now being redirected from your browser to your external identity provider for authentication\\n\"\n                \"If the browser did not open, you may also click the following URL to access your identity provider authentication\\n\\n\"\n                f\"{start_auth_response.result.idp_redirect_short_url}\\n\"\n            )\n\n        # Error can be ignored\n        webbrowser.open(start_auth_response.result.idp_redirect_short_url, new=0, autoraise=True)\n\n        # Start polling for idp auth\n        self.__is_polling = True\n        start_time = datetime.now()\n        while self.__is_polling:\n            current_time = datetime.now()\n            if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                self.__is_polling = False\n                raise ArkException('Timeout reached while polling for idp auth')\n            idp_auth_status = self.__identity_idp_auth_status(start_auth_response.result.idp_login_session_id)\n            if idp_auth_status.result.state == 'Success' and idp_auth_status.result.token:\n                # We managed to successfully authenticate\n                # Done here, save the token\n                self.__session_details = idp_auth_status.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {idp_auth_status.result.token}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                break\n            time.sleep(POLL_INTERVAL_MS)\n\n    def __perform_up_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        interactive: bool,\n        start_auth_response: StartAuthResponse,\n        current_challenge_idx: int,\n    ) -&gt; Tuple[str, int]:\n        current_challenge_idx += 1\n        # Password, answer it\n        if not self.__password:\n            if not interactive:\n                raise ArkAuthException('No password and not interactive, cannot continue')\n            answers = inquirer.prompt(\n                [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                raise ArkAuthException('Canceled by user')\n            self.__password = answers['answer']\n        advance_resp = self.__advance_authentication(\n            mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n        )\n        if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n            # Done here, save the token\n            self.__session_details = advance_resp.result\n            self.__session.headers.update(\n                {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n            )\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            if self.__cache_authentication:\n                self.__save_cache(profile)\n            return 'DONE', current_challenge_idx\n        elif isinstance(advance_resp, AdvanceAuthMidResponse) and advance_resp.result.challenges:\n            start_auth_response.result.challenges = advance_resp.result.challenges\n            current_challenge_idx = 0\n        return 'CONTINUE', current_challenge_idx\n\n    @classmethod\n    def has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n        \"\"\"\n        Checks if a cache record exists for the specified profile and username.\n\n        Args:\n            profile (ArkProfile): _description_\n            username (str): _description_\n            refresh_auth_allowed (bool): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        keyring = ArkKeyring(cls.__name__.lower())\n        token = keyring.load_token(profile, f'{username}_identity')\n        session = keyring.load_token(profile, f'{username}_identity_session')\n        if token is not None and session is not None:\n            if token.expires_in and token.expires_in &lt; datetime.now():\n                if token.refresh_token and refresh_auth_allowed:\n                    return True\n                return False\n            return True\n        return False\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_idp_user(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n        \"\"\"\n        Checks whether or not the specified username is from an external IDP.\n\n        Args:\n            username (str): _description_\n            identity_url (Optional[str]): _description_\n            identity_tenant_subdomain (Optional[str]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n            return False\n        identity = ArkIdentity(\n            username=username,\n            password='',\n            identity_url=identity_url,\n            identity_tenant_subdomain=identity_tenant_subdomain,\n        )\n        resp = identity.__start_authentication()\n        return resp.result.idp_redirect_url != None\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_password_required(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n        \"\"\"\n        Checks whether or not the specified username is from an external IDP.\n        Args:\n            username (str): _description_\n            identity_url (Optional[str]): _description_\n            identity_tenant_subdomain (Optional[str]): _description_\n        Returns:\n            bool: _description_\n        \"\"\"\n        identity = ArkIdentity(\n            username=username,\n            password='',\n            identity_url=identity_url,\n            identity_tenant_subdomain=identity_tenant_subdomain,\n        )\n        resp = identity.__start_authentication()\n        ArkIdentity.__LAST_START_AUTH_RESP[f'{identity.identity_url}_{username}'] = (resp, datetime.now())\n        return (\n            resp.result.idp_redirect_url == None\n            and resp.result.challenges\n            and all(c.name == 'UP' for c in resp.result.challenges[0].mechanisms)\n        )\n\n    def get_apps(self) -&gt; Dict:\n        \"\"\"\n        Returns the applications to which the user is logged in.\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            Dict: _description_\n        \"\"\"\n        if not self.__session_details:\n            raise ArkException('Identity authentication is required first')\n        cookies = self.__session.cookies.copy()\n        response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n        self.__session.cookies = cookies\n        return json.loads(response.text)\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with the information specified in the constructor.\n        If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n        The auth token and other details are stored in the object for future use.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n            interactive (bool): Determines whether interactive user prompts are allowed\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        self.__logger.debug('Attempting to authenticate to Identity')\n        self.__session_details = None\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity details from cache')\n                return\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n        # Start the authentication\n        start_auth_response: Optional[StartAuthResponse] = None\n        if f'{self.__identity_url}_{self.__username}' in ArkIdentity.__LAST_START_AUTH_RESP:\n            start_auth_response_time = ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n            if (datetime.now() - start_auth_response_time[1]).total_seconds() &lt; ArkIdentity.__LAST_START_AUTH_RESP_DELTA_SECONDS:\n                start_auth_response = start_auth_response_time[0]\n            del ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n        if not start_auth_response:\n            start_auth_response = self.__start_authentication()\n        if start_auth_response.result.idp_redirect_url:\n            # External IDP Flow, ignore the mechanisms and just open a browser\n            self.__perform_idp_authentication(start_auth_response, profile, interactive)\n            return\n\n        # Check if password is part of the first challenges list and if so, answer it directly\n        current_challenge_idx = 0\n        if len(start_auth_response.result.challenges[current_challenge_idx].mechanisms) &gt; 1 and interactive:\n            mechanism = self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n            if mechanism.name.lower() == 'up':\n                result, current_challenge_idx = self.__perform_up_authentication(\n                    profile, mechanism, interactive, start_auth_response, current_challenge_idx\n                )\n                if result == 'DONE':\n                    return\n            else:\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                if self.__session_details:\n                    return\n        else:\n            mechanism = start_auth_response.result.challenges[current_challenge_idx].mechanisms[0]\n            if mechanism.name.lower() == 'up':\n                result, current_challenge_idx = self.__perform_up_authentication(\n                    profile, mechanism, interactive, start_auth_response, current_challenge_idx\n                )\n                if result == 'DONE':\n                    return\n\n        # Pick MFA for the user\n        if interactive:\n            self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n        # Handle a case where MFA type was supplied\n        if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS:\n            for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n                if mechanism.name.lower() == self.__mfa_type.lower():\n                    oob_advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                    )\n                    self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                    return\n\n        if not interactive:\n            raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n        # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n        for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n            mechanism = self.__pick_mechanism(challenge)\n            oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n\n    # pylint: disable=unused-argument\n    def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Performs a token refresh with the object's existing details.\n\n        Args:\n            profile (Optional[ArkProfile]): The profile to load from the cache, if available\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        if not self.__session_details.token:\n            # We only refresh platform token at the moment, call the normal authentication instead\n            return self.auth_identity(profile, interactive, force)\n\n        self.__logger.debug('Attempting to refresh authenticate to Identity')\n        saved_cookies = None\n        if self.__session:\n            saved_cookies = self.__session.cookies.copy()\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        decoded_token = ArkJWTUtils.get_unverified_claims(self.__session_details.token)\n        platform_tenant_id = decoded_token['tenant_id']\n        refresh_cookies = {\n            f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n            f'idToken-{platform_tenant_id}': self.__session_details.token,\n        }\n        response = self.__session.post(\n            url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n            cookies=refresh_cookies,\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed to refresh token')\n        new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n        new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n        if not new_token or not new_refresh_token:\n            raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n        if saved_cookies:\n            self.__session.cookies = saved_cookies\n        self.__session_details.token = new_token\n        self.__session_details.refresh_token = new_refresh_token\n        self.__session_details.token_lifetime = (\n            datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['exp'])\n            - datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['iat'])\n        ).seconds\n        delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n        self.__session_exp = datetime.now() + timedelta(seconds=delta)\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        if self.__session_details:\n            if self.__session_details.token:\n                return self.__session_details.token\n            if 'auth' in self.__session_details.__dict__ and self.__session_details.auth:\n                return self.__session_details.auth\n        return None\n\n    @property\n    def session_details(self) -&gt; Optional[AdvanceAuthResult]:\n        return self.__session_details\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.auth_identity","title":"<code>auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Authenticates to Identity with the information specified in the constructor. If MFA is configured and <code>interactive</code> is enabled, the user is prompted for the MFA secret. The auth token and other details are stored in the object for future use.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to use (loaded from cache, if available)</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Determines whether interactive user prompts are allowed</p> <code>False</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with the information specified in the constructor.\n    If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n    The auth token and other details are stored in the object for future use.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n        interactive (bool): Determines whether interactive user prompts are allowed\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    self.__logger.debug('Attempting to authenticate to Identity')\n    self.__session_details = None\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity details from cache')\n            return\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n    # Start the authentication\n    start_auth_response: Optional[StartAuthResponse] = None\n    if f'{self.__identity_url}_{self.__username}' in ArkIdentity.__LAST_START_AUTH_RESP:\n        start_auth_response_time = ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n        if (datetime.now() - start_auth_response_time[1]).total_seconds() &lt; ArkIdentity.__LAST_START_AUTH_RESP_DELTA_SECONDS:\n            start_auth_response = start_auth_response_time[0]\n        del ArkIdentity.__LAST_START_AUTH_RESP[f'{self.__identity_url}_{self.__username}']\n    if not start_auth_response:\n        start_auth_response = self.__start_authentication()\n    if start_auth_response.result.idp_redirect_url:\n        # External IDP Flow, ignore the mechanisms and just open a browser\n        self.__perform_idp_authentication(start_auth_response, profile, interactive)\n        return\n\n    # Check if password is part of the first challenges list and if so, answer it directly\n    current_challenge_idx = 0\n    if len(start_auth_response.result.challenges[current_challenge_idx].mechanisms) &gt; 1 and interactive:\n        mechanism = self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n        if mechanism.name.lower() == 'up':\n            result, current_challenge_idx = self.__perform_up_authentication(\n                profile, mechanism, interactive, start_auth_response, current_challenge_idx\n            )\n            if result == 'DONE':\n                return\n        else:\n            oob_advance_resp = self.__advance_authentication(\n                mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n            )\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n            if self.__session_details:\n                return\n    else:\n        mechanism = start_auth_response.result.challenges[current_challenge_idx].mechanisms[0]\n        if mechanism.name.lower() == 'up':\n            result, current_challenge_idx = self.__perform_up_authentication(\n                profile, mechanism, interactive, start_auth_response, current_challenge_idx\n            )\n            if result == 'DONE':\n                return\n\n    # Pick MFA for the user\n    if interactive:\n        self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n    # Handle a case where MFA type was supplied\n    if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS:\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == self.__mfa_type.lower():\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                return\n\n    if not interactive:\n        raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n    # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n    for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n        mechanism = self.__pick_mechanism(challenge)\n        oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n        self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.get_apps","title":"<code>get_apps()</code>","text":"<p>Returns the applications to which the user is logged in.</p> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def get_apps(self) -&gt; Dict:\n    \"\"\"\n    Returns the applications to which the user is logged in.\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        Dict: _description_\n    \"\"\"\n    if not self.__session_details:\n        raise ArkException('Identity authentication is required first')\n    cookies = self.__session.cookies.copy()\n    response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n    self.__session.cookies = cookies\n    return json.loads(response.text)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.has_cache_record","title":"<code>has_cache_record(profile, username, refresh_auth_allowed)</code>  <code>classmethod</code>","text":"<p>Checks if a cache record exists for the specified profile and username.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>username</code> <code>str</code> <p>description</p> required <code>refresh_auth_allowed</code> <code>bool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\ndef has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n    \"\"\"\n    Checks if a cache record exists for the specified profile and username.\n\n    Args:\n        profile (ArkProfile): _description_\n        username (str): _description_\n        refresh_auth_allowed (bool): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    keyring = ArkKeyring(cls.__name__.lower())\n    token = keyring.load_token(profile, f'{username}_identity')\n    session = keyring.load_token(profile, f'{username}_identity_session')\n    if token is not None and session is not None:\n        if token.expires_in and token.expires_in &lt; datetime.now():\n            if token.refresh_token and refresh_auth_allowed:\n                return True\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.is_idp_user","title":"<code>is_idp_user(username, identity_url, identity_tenant_subdomain)</code>  <code>classmethod</code>","text":"<p>Checks whether or not the specified username is from an external IDP.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>description</p> required <code>identity_url</code> <code>Optional[str]</code> <p>description</p> required <code>identity_tenant_subdomain</code> <code>Optional[str]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_idp_user(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n    \"\"\"\n    Checks whether or not the specified username is from an external IDP.\n\n    Args:\n        username (str): _description_\n        identity_url (Optional[str]): _description_\n        identity_tenant_subdomain (Optional[str]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n        return False\n    identity = ArkIdentity(\n        username=username,\n        password='',\n        identity_url=identity_url,\n        identity_tenant_subdomain=identity_tenant_subdomain,\n    )\n    resp = identity.__start_authentication()\n    return resp.result.idp_redirect_url != None\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.is_password_required","title":"<code>is_password_required(username, identity_url, identity_tenant_subdomain)</code>  <code>classmethod</code>","text":"<p>Checks whether or not the specified username is from an external IDP. Args:     username (str): description     identity_url (Optional[str]): description     identity_tenant_subdomain (Optional[str]): description Returns:     bool: description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_password_required(cls, username: str, identity_url: Optional[str], identity_tenant_subdomain: Optional[str]) -&gt; bool:\n    \"\"\"\n    Checks whether or not the specified username is from an external IDP.\n    Args:\n        username (str): _description_\n        identity_url (Optional[str]): _description_\n        identity_tenant_subdomain (Optional[str]): _description_\n    Returns:\n        bool: _description_\n    \"\"\"\n    identity = ArkIdentity(\n        username=username,\n        password='',\n        identity_url=identity_url,\n        identity_tenant_subdomain=identity_tenant_subdomain,\n    )\n    resp = identity.__start_authentication()\n    ArkIdentity.__LAST_START_AUTH_RESP[f'{identity.identity_url}_{username}'] = (resp, datetime.now())\n    return (\n        resp.result.idp_redirect_url == None\n        and resp.result.challenges\n        and all(c.name == 'UP' for c in resp.result.challenges[0].mechanisms)\n    )\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.refresh_auth_identity","title":"<code>refresh_auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Performs a token refresh with the object's existing details.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>The profile to load from the cache, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Performs a token refresh with the object's existing details.\n\n    Args:\n        profile (Optional[ArkProfile]): The profile to load from the cache, if available\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    if not self.__session_details.token:\n        # We only refresh platform token at the moment, call the normal authentication instead\n        return self.auth_identity(profile, interactive, force)\n\n    self.__logger.debug('Attempting to refresh authenticate to Identity')\n    saved_cookies = None\n    if self.__session:\n        saved_cookies = self.__session.cookies.copy()\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n    decoded_token = ArkJWTUtils.get_unverified_claims(self.__session_details.token)\n    platform_tenant_id = decoded_token['tenant_id']\n    refresh_cookies = {\n        f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n        f'idToken-{platform_tenant_id}': self.__session_details.token,\n    }\n    response = self.__session.post(\n        url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n        cookies=refresh_cookies,\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed to refresh token')\n    new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n    new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n    if not new_token or not new_refresh_token:\n        raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n    if saved_cookies:\n        self.__session.cookies = saved_cookies\n    self.__session_details.token = new_token\n    self.__session_details.refresh_token = new_refresh_token\n    self.__session_details.token_lifetime = (\n        datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['exp'])\n        - datetime.fromtimestamp(ArkJWTUtils.get_unverified_claims(new_token)['iat'])\n    ).seconds\n    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/","title":"ark_identity_fqdn_resolver","text":""},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver","title":"<code>ArkIdentityFQDNResolver</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>class ArkIdentityFQDNResolver:\n    __DISCOVERY_SERVICE_DOMAIN_NAME: Final[str] = 'platform-discovery'\n    __DISCOVERY_TIMEOUT: Final[int] = 30\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {\n            'Content-Type': 'application/json',\n            'X-IDAP-NATIVE-CLIENT': 'true',\n            'User-Agent': UserAgent(browsers=['chrome']).chrome,\n            'OobIdPAuth': 'true',\n        }\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_system_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {'X-IDAP-NATIVE-CLIENT': 'true', 'User-Agent': UserAgent(browsers=['chrome']).chrome}\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL from its subdomain.\n        The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n        Args:\n            tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n            env (AwsEnv): The environment for which the the tenant URL is resolved\n\n        Raises:\n            ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n        Returns:\n            str: The tenant's resolved FQDN\n        \"\"\"\n        platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n        session = Session()\n        response = session.get(\n            f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n            headers={'Content-Type': 'application/json'},\n            timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n        )\n        try:\n            if response.status_code == HTTPStatus.OK:\n                parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.model_validate_json(response.text)\n                return str(parsed_response.endpoint)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n        raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL in Identity.\n        By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n        Args:\n            tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n            identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: The tenant's FQDN\n        \"\"\"\n        identity_env_url = identity_env_url or (\n            IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n        )\n        session = Session()\n        response = session.post(\n            f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n            json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n            headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n        )\n        try:\n            parsed_res: TenantFqdnResponse = TenantFqdnResponse.model_validate_json(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n        if not parsed_res.result.pod_fqdn.startswith('https://'):\n            parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n        return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain","title":"<code>resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain, env)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL from its subdomain. The resolved URL is based on the current working environment, which is provided in the <code>tenant_subdomain</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_subdomain</code> <code>str</code> <p>The tenant subdomain, for example: <code>mytenant</code></p> required <code>env</code> <code>AwsEnv</code> <p>The environment for which the the tenant URL is resolved</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>When an error occurs or the tenant username prefix was not found in the Identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's resolved FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL from its subdomain.\n    The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n    Args:\n        tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n        env (AwsEnv): The environment for which the the tenant URL is resolved\n\n    Raises:\n        ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n    Returns:\n        str: The tenant's resolved FQDN\n    \"\"\"\n    platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n    session = Session()\n    response = session.get(\n        f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n        headers={'Content-Type': 'application/json'},\n        timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n    )\n    try:\n        if response.status_code == HTTPStatus.OK:\n            parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.model_validate_json(response.text)\n            return str(parsed_response.endpoint)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n    raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix","title":"<code>resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix, identity_env_url=None)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL in Identity. By default, the Identity address is resolved from the current environment mapping (see <code>get_identity_env_url()</code>), but it can be optionally be resolved from the <code>identity_env_url</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_suffix</code> <code>str</code> <p>The tenant's URL suffix, for example: <code>@tenant-a-527.shell.cyberark.cloud</code></p> required <code>identity_env_url</code> <code>str</code> <p>If specified, used as the Identity pod0 URL; otherwise, defaults to <code>None</code> (use environment mapping)</p> <code>None</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL in Identity.\n    By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n    Args:\n        tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n        identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: The tenant's FQDN\n    \"\"\"\n    identity_env_url = identity_env_url or (\n        IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n    )\n    session = Session()\n    response = session.post(\n        f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n        json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n    )\n    try:\n        parsed_res: TenantFqdnResponse = TenantFqdnResponse.model_validate_json(response.text)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n    if not parsed_res.result.pod_fqdn.startswith('https://'):\n        parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n    return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_service_user/","title":"ark_identity_service_user","text":""},{"location":"reference/auth/identity/ark_identity_service_user/#ark_sdk_python.auth.identity.ark_identity_service_user.ArkIdentityServiceUser","title":"<code>ArkIdentityServiceUser</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>class ArkIdentityServiceUser:\n    def __init__(\n        self,\n        username: str,\n        token: str,\n        app_name: str,\n        identity_url: Optional[str] = None,\n        env: Optional[AwsEnv] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__token = token\n        self.__app_name = app_name\n        self.__env = env or AwsEnv(os.getenv(DEPLOY_ENV, AwsEnv.PROD.value))\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_token = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_system_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity_service_user')\n            if token and token.username == self.__username:\n                self.__session_token = token.token.get_secret_value()\n                self.__session_exp = token.expires_in\n                self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}'})\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_token:\n            self.__session_exp = datetime.now() + timedelta(hours=4)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_token,\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_service_user',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(\n            tenant_suffix=tenant_suffix, identity_env_url=IDENTITY_ENV_URLS[self.__env]\n        )\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with a service user.\n        This method creates an auth token and authorizes to the service.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n            force (bool): Determines whether to discard existing cache, defaults to `False`\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        # Login to identity with the service service user\n        self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity service user details from cache')\n                return\n\n        token_response: Response = self.__session.post(\n            url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n            auth=HTTPBasicAuth(self.__username, self.__token),\n            verify=True,\n            data={'grant_type': 'client_credentials', 'scope': 'api'},\n        )\n        if token_response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed logging in to identity service user')\n        auth_result = json.loads(token_response.text)\n        if 'access_token' not in auth_result.keys():\n            raise ArkAuthException('Failed logging in to identity service user, access token not found')\n        access_token = auth_result['access_token']\n\n        # Authorize to the application with the service user\n        params = {\n            'client_id': self.__app_name,\n            'response_type': 'id_token',\n            'scope': 'openid profile api',\n            'redirect_uri': 'https://cyberark.cloud/redirect',\n        }\n        self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n        authorize_response = self.__session.get(\n            url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n            headers={'Authorization': f'Bearer {access_token}'},\n            params=params,\n            allow_redirects=False,\n        )\n        if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n            raise ArkAuthException('Failed to authorize to application')\n        # Parse the authorized token and return the session with it\n        location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n        if len(location_header_splitted) != 2:\n            raise ArkAuthException('Failed to parse location header to retrieve token from')\n        parsed_query = parse_qs(location_header_splitted[1])\n        if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n            raise ArkAuthException('Failed to parse id token from location header')\n        self.__session_token = parsed_query['id_token'][0]\n        self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n        self.__session_exp = datetime.now() + timedelta(hours=4)\n        self.__logger.info(\n            f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n        )\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__session_token\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_service_user/#ark_sdk_python.auth.identity.ark_identity_service_user.ArkIdentityServiceUser.auth_identity","title":"<code>auth_identity(profile=None, force=False)</code>","text":"<p>Authenticates to Identity with a service user. This method creates an auth token and authorizes to the service.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to discard existing cache, defaults to <code>False</code></p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with a service user.\n    This method creates an auth token and authorizes to the service.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n        force (bool): Determines whether to discard existing cache, defaults to `False`\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    # Login to identity with the service service user\n    self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity service user details from cache')\n            return\n\n    token_response: Response = self.__session.post(\n        url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n        auth=HTTPBasicAuth(self.__username, self.__token),\n        verify=True,\n        data={'grant_type': 'client_credentials', 'scope': 'api'},\n    )\n    if token_response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed logging in to identity service user')\n    auth_result = json.loads(token_response.text)\n    if 'access_token' not in auth_result.keys():\n        raise ArkAuthException('Failed logging in to identity service user, access token not found')\n    access_token = auth_result['access_token']\n\n    # Authorize to the application with the service user\n    params = {\n        'client_id': self.__app_name,\n        'response_type': 'id_token',\n        'scope': 'openid profile api',\n        'redirect_uri': 'https://cyberark.cloud/redirect',\n    }\n    self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n    authorize_response = self.__session.get(\n        url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n        headers={'Authorization': f'Bearer {access_token}'},\n        params=params,\n        allow_redirects=False,\n    )\n    if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n        raise ArkAuthException('Failed to authorize to application')\n    # Parse the authorized token and return the session with it\n    location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n    if len(location_header_splitted) != 2:\n        raise ArkAuthException('Failed to parse location header to retrieve token from')\n    parsed_query = parse_qs(location_header_splitted[1])\n    if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n        raise ArkAuthException('Failed to parse id token from location header')\n    self.__session_token = parsed_query['id_token'][0]\n    self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n    self.__session_exp = datetime.now() + timedelta(hours=4)\n    self.__logger.info(\n        f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n    )\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/cli_services/","title":"cli_services","text":""},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI","title":"<code>ArkCLIAPI</code>","text":"<p>               Bases: <code>ArkAPI</code></p> Source code in <code>ark_sdk_python/cli_services/ark_cli_api.py</code> <pre><code>class ArkCLIAPI(ArkAPI):\n    @property\n    def sia_policies_vm_editor(self) -&gt; \"ArkSIAVMPoliciesEditorService\":\n        \"\"\"\n        VM policy editor CLI service\n\n        Returns:\n            ArkSIAVMPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.sia.vm import ArkSIAVMPoliciesEditorService\n\n        return ArkSIAVMPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n\n    @property\n    def sia_policies_db_editor(self) -&gt; \"ArkSIADBPoliciesEditorService\":\n        \"\"\"\n        DB policy editor CLI service\n\n        Returns:\n            ArkSIADBPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.sia.db import ArkSIADBPoliciesEditorService\n\n        return ArkSIADBPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n</code></pre>"},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI.sia_policies_db_editor","title":"<code>sia_policies_db_editor</code>  <code>property</code>","text":"<p>DB policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesEditorService</code> <code>'ArkSIADBPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI.sia_policies_vm_editor","title":"<code>sia_policies_vm_editor</code>  <code>property</code>","text":"<p>VM policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesEditorService</code> <code>'ArkSIAVMPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/ark_cli_api/","title":"ark_cli_api","text":""},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI","title":"<code>ArkCLIAPI</code>","text":"<p>               Bases: <code>ArkAPI</code></p> Source code in <code>ark_sdk_python/cli_services/ark_cli_api.py</code> <pre><code>class ArkCLIAPI(ArkAPI):\n    @property\n    def sia_policies_vm_editor(self) -&gt; \"ArkSIAVMPoliciesEditorService\":\n        \"\"\"\n        VM policy editor CLI service\n\n        Returns:\n            ArkSIAVMPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.sia.vm import ArkSIAVMPoliciesEditorService\n\n        return ArkSIAVMPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n\n    @property\n    def sia_policies_db_editor(self) -&gt; \"ArkSIADBPoliciesEditorService\":\n        \"\"\"\n        DB policy editor CLI service\n\n        Returns:\n            ArkSIADBPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.sia.db import ArkSIADBPoliciesEditorService\n\n        return ArkSIADBPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n</code></pre>"},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI.sia_policies_db_editor","title":"<code>sia_policies_db_editor</code>  <code>property</code>","text":"<p>DB policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesEditorService</code> <code>'ArkSIADBPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI.sia_policies_vm_editor","title":"<code>sia_policies_vm_editor</code>  <code>property</code>","text":"<p>VM policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesEditorService</code> <code>'ArkSIAVMPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/sia/","title":"sia","text":""},{"location":"reference/cli_services/sia/common/","title":"common","text":""},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/","title":"ark_sia_base_policies_editor_service","text":""},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService","title":"<code>ArkSIABasePoliciesEditorService</code>","text":"<p>               Bases: <code>ArkService</code>, <code>ABC</code>, <code>Generic[PolicyType, PolicyListItemType, AddPolicyType, UpdatePolicyType, GeneratePolicyType]</code></p> Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>class ArkSIABasePoliciesEditorService(\n    ArkService, ABC, Generic[PolicyType, PolicyListItemType, AddPolicyType, UpdatePolicyType, GeneratePolicyType]\n):\n    def __init__(\n        self,\n        policy_type: PolicyType,\n        add_policy_type: AddPolicyType,\n        update_policy_type: UpdatePolicyType,\n        isp_auth: ArkISPAuth,\n        policies_family: str,\n        tenant_id: str,\n        policies_cache_dir: Optional[str] = None,\n        profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        super().__init__(isp_auth)\n        profile = profile or ArkProfileLoader.load_default_profile()\n        self._policies_family = policies_family\n        self.__policies_cache_dir = Path(policies_cache_dir or Path.home() / '.ark_cache' / 'profiles' / profile.profile_name / tenant_id)\n        if not policies_cache_dir and 'ARK_SIA_POLICIES_EDITOR_FOLDER' in os.environ:\n            self.__policies_cache_dir = Path(os.environ['ARK_SIA_POLICIES_EDITOR_FOLDER'])\n        self.__policies_cache_dir = self.__policies_cache_dir / policies_family\n        self.__policies_cache_dir.mkdir(exist_ok=True, parents=True)\n        self.__policy_type = policy_type\n        self.__add_policy_type = add_policy_type\n        self.__update_policy_type = update_policy_type\n\n    @abstractmethod\n    def _policy(self, get_policy: ArkSIAGetPolicy) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _list_policies(self) -&gt; List[PolicyListItemType]:\n        pass\n\n    @abstractmethod\n    def _add_policy(self, add_policy: AddPolicyType) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _update_policy(self, update_policy: UpdatePolicyType) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n        pass\n\n    @abstractmethod\n    def _generate_policy(self, generate_policy: GeneratePolicyType, workspace_policies: List[PolicyType]) -&gt; PolicyType:\n        pass\n\n    def __load_policy_diff(self, workspace_policy: PolicyType) -&gt; Optional[Tuple[PolicyType, PolicyType]]:\n        remote_policy = self._policy(ArkSIAGetPolicy(policy_id=str(workspace_policy.policy_id)))\n        if remote_policy != workspace_policy:\n            return (workspace_policy, remote_policy)\n        return None\n\n    def __load_policies_diff(self) -&gt; Dict[str, Tuple[PolicyType, PolicyType]]:\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        with ThreadPoolExecutor() as executor:\n            remote_policies = {\n                p[0].policy_name: p for p in executor.map(self.__load_policy_diff, workspace_policies.values()) if p is not None\n            }\n            return remote_policies\n\n    def __load_policies_from_workspace_by_suffix(self, suffix: str = '') -&gt; Dict[str, PolicyType]:\n        p = Path(self.__policies_cache_dir).glob(f'*.json{suffix}')\n        policies_files = [x for x in p if x.is_file() and x.suffix == suffix or '.json']\n        policies = {}\n        for f in policies_files:\n            with open(f, 'r', encoding='utf-8') as fh:\n                policy = self.__policy_type.model_validate_json(fh.read())\n            policies[policy.policy_name] = policy\n        return policies\n\n    def __load_removed_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix('.removed')\n\n    def __load_generated_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix('.generated')\n\n    def __load_existing_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix()\n\n    def __load_policy_to_workspace(self, policy: PolicyListItemType, override: bool) -&gt; Optional[PolicyType]:\n        policy_data = self._policy(ArkSIAGetPolicy(policy_id=policy.policy_id))\n        policy_path = Path(self.__policies_cache_dir) / (policy_data.policy_name + '.json')\n        if policy_path.exists():\n            existing_data = self.__policy_type.model_validate_json(policy_path.read_text())\n            if existing_data != policy_data:\n                if not override:\n                    return policy_data\n        if not policy_data.policy_id:\n            policy_data.policy_id = policy.policy_id\n        policy_path.write_text(policy_data.model_dump_json(indent=4))\n        (Path(self.__policies_cache_dir) / (policy_data.policy_name + '.json.removed')).unlink(missing_ok=True)\n\n    def load_policies(self, load_policies: ArkSIALoadPolicies) -&gt; ArkSIALoadedPolicies:\n        \"\"\"\n        Loads all remote policies into the local workspace.\n        The user is asked whether to overwrite existing policies that were edited either locally or remotely.\n        When default overwrite is enabled, existing policies are overwritten without prompts.\n\n        Args:\n            load_policies (ArkSIALoadPolicies): _description_\n\n        Returns:\n            ArkSIALoadedPolicies: _description_\n        \"\"\"\n        policies = self._list_policies()\n        policies_to_query: Dict[str, PolicyType] = []\n        with ThreadPoolExecutor() as executor:\n            policies_to_query = {\n                p.policy_name: p\n                for p in executor.map(lambda p: self.__load_policy_to_workspace(p, load_policies.override), policies)\n                if p is not None\n            }\n        # Build the query editor to ask the user\n        policies_to_override = []\n        if policies_to_query:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'override',\n                        message=f'Conflicts detected, please choose if you wish to override local {self._policies_family} policies or leave them as is',\n                        choices=[p.policy_name for p in policies_to_query.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policies_to_override = answers['override']\n            for policy_name in policies_to_override:\n                policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n                if policy_path.exists() and policy_name in policies_to_query:\n                    policy_path.write_text(policies_to_query[policy_name].model_dump_json(indent=4))\n        return ArkSIALoadedPolicies(\n            loaded_path=str(self.__policies_cache_dir),\n            overall_policies_count=len(policies),\n            loaded_policies_count=len(policies) - len(policies_to_query),\n            overriden_policies_count=len(policies_to_override),\n            untouched_policies_count=len(policies_to_query) - len(policies_to_override),\n        )\n\n    def edit_policies(self, edit_policies: ArkSIAEditPolicies) -&gt; None:\n        \"\"\"\n        Edits the set of specified policies one at a time, either via the CLI or the default OS editor.\n        Edited policies are only saved locally until they are committed.\n\n        Args:\n            edit_policies (ArkSIAEditPolicies): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        if not workspace_policies:\n            raise ArkServiceException(\n                f'No {self._policies_family} policies to edit in the workspace, please load the policies or generate a new one'\n            )\n        policy_names = edit_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to edit?, press space to select',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        try:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Editor(f'{name}_edit', message=f'Chosen {self._policies_family} policy [{name}] is about to be edited')\n                    for name in policy_names\n                ],\n                render=ArkInquirerRender(),\n                answers={f'{name}_edit': workspace_policies[name].model_dump_json(indent=4) for name in policy_names},\n            )\n            for name in policy_names:\n                policy = self.__policy_type.model_validate_json(answers[f'{name}_edit'])\n                for path in [\n                    Path(self.__policies_cache_dir) / (name + '.json'),\n                    Path(self.__policies_cache_dir) / (name + '.json.generated'),\n                ]:\n                    if path.exists():\n                        path.write_text(policy.model_dump_json(indent=4))\n                        break\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to edit {self._policies_family} policies, '\n                f'you can edit the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def remove_policies(self, remove_policies: ArkSIARemovePolicies) -&gt; None:\n        \"\"\"\n        Removes one or more policies from the local workspace.\n        Until changes are committed, removing a remote policy only appends the `.deleted` indication to its name.\n        After committing the changes, the policies are deleted both locally and remotely.\n        New, uncommitted policies are deleted locally after the user consents.\n\n        Args:\n            remove_policies (ArkSIARemovePolicies): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        if not workspace_policies:\n            raise ArkServiceException(\n                f'No {self._policies_family} policies to remove in the workspace, please load the policies or generate a new one'\n            )\n        policy_names = remove_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to remove?, press space to select',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        for policy_name in policy_names:\n            for path in [\n                Path(self.__policies_cache_dir) / (policy_name + '.json'),\n                Path(self.__policies_cache_dir) / (policy_name + '.json.generated'),\n            ]:\n                if path.exists():\n                    if path.suffix == '.json':\n                        path.rename(Path(self.__policies_cache_dir) / (policy_name + '.json.removed'))\n                    else:\n                        answers = inquirer.prompt(\n                            [\n                                inquirer.Confirm(\n                                    'remove',\n                                    message=f'Are you sure you want to remove local {self._policies_family} policy [{policy_name}]?, removing an uncommitted local policy cannot be reverted',\n                                )\n                            ],\n                            render=ArkInquirerRender(),\n                        )\n                        if not answers:\n                            return\n                        if answers['remove']:\n                            path.unlink(missing_ok=True)\n\n    def view_policies(self, view_policies: ArkSIAViewPolicies) -&gt; None:\n        \"\"\"\n        Allows the user to view one or more policies either together or individually, as defined in the CLI user prompt.\n        Policies are viewed in the machine's default editor (both existing policies and newly generated policies).\n\n        Args:\n            view_policies (ArkSIAViewPolicies): _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        policy_names = view_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to view?',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        if not policy_names:\n            return\n        try:\n            if view_policies.unified:\n                inquirer.prompt(\n                    [inquirer.Editor('views', f'Show all selected {self._policies_family} policies')],\n                    answers={\n                        'views': '\\n\\n\\n'.join(\n                            [\n                                f'# Policy [{policy_name}]\\n{workspace_policies[policy_name].model_dump_json(indent=4)}'\n                                for policy_name in policy_names\n                            ]\n                        )\n                    },\n                    render=ArkInquirerRender(),\n                )\n            else:\n                inquirer.prompt(\n                    [inquirer.Editor(f'{policy_name}_view', f'Show [{policy_name}]') for policy_name in policy_names],\n                    render=ArkInquirerRender(),\n                    answers={\n                        f'{policy_name}_view': workspace_policies[policy_name].model_dump_json(indent=4) for policy_name in policy_names\n                    },\n                )\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to view the {self._policies_family} policies, '\n                f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def reset_policies(self, reset_policy: ArkSIAResetPolicies) -&gt; None:\n        \"\"\"\n        Resets local workspace policies.\n        When all policies are reset, all local policies are overwritten and deleted policies are removed.\n        Otherwise, the user can select which policies are reset.\n        This function does not alter newly generated uncommitted policies.\n\n        Args:\n            reset_policy (ArkSIAResetPolicies): _description_\n        \"\"\"\n        if reset_policy.all:\n            answers = inquirer.prompt(\n                [inquirer.Confirm('reset', message=f'Are you sure you want to reset all edited {self._policies_family} policies?')]\n            )\n            if not answers:\n                return\n            if answers['reset']:\n                self.load_policies(ArkSIALoadPolicies(override=True))\n        else:\n            policies_diff = self.__load_policies_diff()\n            removed_policies = self.__load_removed_policies_from_workspace()\n            if not policies_diff and not removed_policies:\n                return\n            policy_names = reset_policy.names\n            if not policy_names:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Checkbox(\n                            'names',\n                            f'Which {self._policies_family} policies would you like to reset?, press space to select',\n                            choices=[p for p in policies_diff.keys() + removed_policies.keys()],\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    return\n                policy_names = answers['names']\n            policy_names = [p for p in policy_names if p in policies_diff or p in removed_policies]\n            for policy_name in policy_names:\n                policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n                if policy_name in policies_diff:\n                    policy_path.write_text(policies_diff[policy_name][1].model_dump_json(indent=4))\n                elif policy_name in removed_policies:\n                    policy_path.write_text(removed_policies[policy_name].model_dump_json(indent=4))\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n\n    def generate_policy(self, generate_policy: GeneratePolicyType) -&gt; None:\n        \"\"\"\n        Generates a new policy from a template and the user's parameters.\n        The user is prompted for the parameters when they are not specified in the CLI.\n        After policy's parameters are defined, the policy is generates in memory and can bee edited.\n        The new policy is saved locally until it is committed.\n\n        Args:\n            generate_policy (GeneratePolicyType): _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        policy = self._generate_policy(generate_policy, workspace_policies)\n        policy_path = Path(self.__policies_cache_dir) / (policy.policy_name + '.json.generated')\n        # Let the user edit the generated policy\n        if not generate_policy.disable_edit:\n            try:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Editor(\n                            'policy_editor',\n                            f'Newly {self._policies_family} policy is generated and ready to be edited, once edited, it will be saved to the local workspace',\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                    answers={'policy_editor': policy.model_dump_json(indent=4, exclude_none=True)},\n                )\n                if not answers:\n                    return\n                policy = self.__policy_type.model_validate_json(answers['policy_editor'])\n            except Exception as ex:\n                self._logger.error(\n                    f'An error occurred while trying to edit the {self._policies_family} policy, '\n                    f'the policy will be saved to [{policy_path}] and can be edited manually [{str(ex)}]'\n                )\n        policy_path.write_text(policy.model_dump_json(indent=4))\n\n    def policies_diff(self, policies_diff: ArkSIAPoliciesDiff) -&gt; None:\n        \"\"\"\n        Calculates the diff between the local workspace and remote policies.\n        This diff includes uncommitted removed policies. A unified or per policy diff can be displayed.\n\n        Args:\n            policies_diff (ArkSIAPoliciesDiff): _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        if not loaded_policies_diff and not removed_policies:\n            return\n        if policies_diff.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in policies_diff.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in policies_diff.names}\n        if not loaded_policies_diff and not removed_policies:\n            return\n        diffs = {\n            policy_name: difflib.unified_diff(\n                policy_tuple[1].model_dump_json(indent=4).splitlines(True),\n                policy_tuple[0].model_dump_json(indent=4).splitlines(True),\n                fromfile=f'local policy [{policy_name}]',\n                tofile=f'remote policy [{policy_name}]',\n                n=MAX_LINE_DIFF,\n            )\n            for policy_name, policy_tuple in loaded_policies_diff.items()\n        }\n        diffs.update(\n            {\n                policy_name: difflib.unified_diff(\n                    policy.model_dump_json(indent=4).splitlines(True),\n                    '',\n                    fromfile=f'local policy [{policy_name}]',\n                    tofile=f'remote policy [{policy_name}]',\n                    n=MAX_LINE_DIFF,\n                )\n                for policy_name, policy in removed_policies.items()\n            }\n        )\n        try:\n            if policies_diff.unified:\n                inquirer.prompt(\n                    [inquirer.Editor('diffs', 'Show all diffs')],\n                    render=ArkInquirerRender(),\n                    answers={'diffs': '\\n\\n\\n'.join([''.join(d) for d in diffs.values()])},\n                )\n            else:\n                inquirer.prompt(\n                    [inquirer.Editor(f'{policy_name}_diff', f'Show [{policy_name}] diff') for policy_name in diffs.keys()],\n                    render=ArkInquirerRender(),\n                    answers={f'{policy_name}_diff': ''.join(policy_diffs) for policy_name, policy_diffs in diffs.items()},\n                )\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to show {self._policies_family} policies diff, '\n                f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def policies_status(self, get_policies_status: ArkSIAGetPoliciesStatus) -&gt; ArkSIAPoliciesStatus:\n        \"\"\"\n        Gets the status of locally altered policies.\n\n        Args:\n            get_policies_status (ArkSIAGetPoliciesStatus): _description_\n\n        Returns:\n            ArkSIAPoliciesStatus: _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        generated_policies = self.__load_generated_policies_from_workspace()\n        if get_policies_status.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in get_policies_status.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in get_policies_status.names}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in get_policies_status.names}\n        return ArkSIAPoliciesStatus(\n            modified_policies=list(loaded_policies_diff.keys()),\n            removed_policies=list(removed_policies.keys()),\n            added_policies=list(generated_policies.keys()),\n        )\n\n    def commit_policies(self, commit_policies: ArkSIACommitPolicies) -&gt; None:\n        \"\"\"\n        Commits policies.\n        The function first calculates the differences between the local and remote policies to find out which policies were edited, including\n        the policies selected for deletion and new, uncommitted policies. It also\n        allows selecting whether to commit all the edited policies or only specific policies by name.\n\n        After all policies are committed, the workspace is reorganized accordingly.\n\n        Args:\n            commit_policies (ArkSIACommitPolicies): _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        generated_policies = self.__load_generated_policies_from_workspace()\n        if not loaded_policies_diff and not removed_policies and not generated_policies:\n            return\n        if commit_policies.all:\n            answers = inquirer.prompt(\n                [inquirer.Confirm('reset', message=f'Are you sure you want to commit all edited {self._policies_family} policies?')]\n            )\n            if not answers or not answers['reset']:\n                return\n        else:\n            if commit_policies.names:\n                loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in commit_policies.names}\n                removed_policies = {k: v for k, v in removed_policies.items() if k in commit_policies.names}\n                generated_policies = {k: v for k, v in generated_policies.items() if k in commit_policies.names}\n            else:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Checkbox(\n                            'names',\n                            f'Which {self._policies_family} policies would you like to commit?, press space to select',\n                            choices=list(loaded_policies_diff.keys()) + list(removed_policies.keys()) + list(generated_policies.keys()),\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    return\n                loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in answers['names']}\n                removed_policies = {k: v for k, v in removed_policies.items() if k in answers['names']}\n                generated_policies = {k: v for k, v in generated_policies.items() if k in answers['names']}\n            if not loaded_policies_diff and not removed_policies and not generated_policies:\n                return\n        with ThreadPoolExecutor() as executor:\n            added = executor.map(lambda p: self._add_policy(self.__add_policy_type(**p.model_dump())), generated_policies.values())\n            updated = executor.map(\n                lambda p: self._update_policy(self.__update_policy_type(**p[0].model_dump())), loaded_policies_diff.values()\n            )\n            deleted = executor.map(\n                lambda p: self._delete_policy(ArkSIADeletePolicy(policy_id=p.policy_id, policy_name=p.policy_name)),\n                removed_policies.values(),\n            )\n            # Loop for exception checking\n            added_policies = list(added)\n            for _ in itertools.chain(updated, deleted):\n                pass\n        for policy_name in removed_policies.keys():\n            (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n        for policy_name in generated_policies.keys():\n            for policy in added_policies:\n                if policy.policy_name == policy_name:\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json.generated')).rename(\n                        (Path(self.__policies_cache_dir) / (policy_name + '.json'))\n                    )\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json')).write_text(policy.model_dump_json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.commit_policies","title":"<code>commit_policies(commit_policies)</code>","text":"<p>Commits policies. The function first calculates the differences between the local and remote policies to find out which policies were edited, including the policies selected for deletion and new, uncommitted policies. It also allows selecting whether to commit all the edited policies or only specific policies by name.</p> <p>After all policies are committed, the workspace is reorganized accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>commit_policies</code> <code>ArkSIACommitPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def commit_policies(self, commit_policies: ArkSIACommitPolicies) -&gt; None:\n    \"\"\"\n    Commits policies.\n    The function first calculates the differences between the local and remote policies to find out which policies were edited, including\n    the policies selected for deletion and new, uncommitted policies. It also\n    allows selecting whether to commit all the edited policies or only specific policies by name.\n\n    After all policies are committed, the workspace is reorganized accordingly.\n\n    Args:\n        commit_policies (ArkSIACommitPolicies): _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    generated_policies = self.__load_generated_policies_from_workspace()\n    if not loaded_policies_diff and not removed_policies and not generated_policies:\n        return\n    if commit_policies.all:\n        answers = inquirer.prompt(\n            [inquirer.Confirm('reset', message=f'Are you sure you want to commit all edited {self._policies_family} policies?')]\n        )\n        if not answers or not answers['reset']:\n            return\n    else:\n        if commit_policies.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in commit_policies.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in commit_policies.names}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in commit_policies.names}\n        else:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to commit?, press space to select',\n                        choices=list(loaded_policies_diff.keys()) + list(removed_policies.keys()) + list(generated_policies.keys()),\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in answers['names']}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in answers['names']}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in answers['names']}\n        if not loaded_policies_diff and not removed_policies and not generated_policies:\n            return\n    with ThreadPoolExecutor() as executor:\n        added = executor.map(lambda p: self._add_policy(self.__add_policy_type(**p.model_dump())), generated_policies.values())\n        updated = executor.map(\n            lambda p: self._update_policy(self.__update_policy_type(**p[0].model_dump())), loaded_policies_diff.values()\n        )\n        deleted = executor.map(\n            lambda p: self._delete_policy(ArkSIADeletePolicy(policy_id=p.policy_id, policy_name=p.policy_name)),\n            removed_policies.values(),\n        )\n        # Loop for exception checking\n        added_policies = list(added)\n        for _ in itertools.chain(updated, deleted):\n            pass\n    for policy_name in removed_policies.keys():\n        (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n    for policy_name in generated_policies.keys():\n        for policy in added_policies:\n            if policy.policy_name == policy_name:\n                (Path(self.__policies_cache_dir) / (policy_name + '.json.generated')).rename(\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json'))\n                )\n                (Path(self.__policies_cache_dir) / (policy_name + '.json')).write_text(policy.model_dump_json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.edit_policies","title":"<code>edit_policies(edit_policies)</code>","text":"<p>Edits the set of specified policies one at a time, either via the CLI or the default OS editor. Edited policies are only saved locally until they are committed.</p> <p>Parameters:</p> Name Type Description Default <code>edit_policies</code> <code>ArkSIAEditPolicies</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def edit_policies(self, edit_policies: ArkSIAEditPolicies) -&gt; None:\n    \"\"\"\n    Edits the set of specified policies one at a time, either via the CLI or the default OS editor.\n    Edited policies are only saved locally until they are committed.\n\n    Args:\n        edit_policies (ArkSIAEditPolicies): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    if not workspace_policies:\n        raise ArkServiceException(\n            f'No {self._policies_family} policies to edit in the workspace, please load the policies or generate a new one'\n        )\n    policy_names = edit_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to edit?, press space to select',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    try:\n        answers = inquirer.prompt(\n            [\n                inquirer.Editor(f'{name}_edit', message=f'Chosen {self._policies_family} policy [{name}] is about to be edited')\n                for name in policy_names\n            ],\n            render=ArkInquirerRender(),\n            answers={f'{name}_edit': workspace_policies[name].model_dump_json(indent=4) for name in policy_names},\n        )\n        for name in policy_names:\n            policy = self.__policy_type.model_validate_json(answers[f'{name}_edit'])\n            for path in [\n                Path(self.__policies_cache_dir) / (name + '.json'),\n                Path(self.__policies_cache_dir) / (name + '.json.generated'),\n            ]:\n                if path.exists():\n                    path.write_text(policy.model_dump_json(indent=4))\n                    break\n    except Exception as ex:\n        self._logger.error(\n            f'An error occurred while trying to edit {self._policies_family} policies, '\n            f'you can edit the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.generate_policy","title":"<code>generate_policy(generate_policy)</code>","text":"<p>Generates a new policy from a template and the user's parameters. The user is prompted for the parameters when they are not specified in the CLI. After policy's parameters are defined, the policy is generates in memory and can bee edited. The new policy is saved locally until it is committed.</p> <p>Parameters:</p> Name Type Description Default <code>generate_policy</code> <code>GeneratePolicyType</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def generate_policy(self, generate_policy: GeneratePolicyType) -&gt; None:\n    \"\"\"\n    Generates a new policy from a template and the user's parameters.\n    The user is prompted for the parameters when they are not specified in the CLI.\n    After policy's parameters are defined, the policy is generates in memory and can bee edited.\n    The new policy is saved locally until it is committed.\n\n    Args:\n        generate_policy (GeneratePolicyType): _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    policy = self._generate_policy(generate_policy, workspace_policies)\n    policy_path = Path(self.__policies_cache_dir) / (policy.policy_name + '.json.generated')\n    # Let the user edit the generated policy\n    if not generate_policy.disable_edit:\n        try:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Editor(\n                        'policy_editor',\n                        f'Newly {self._policies_family} policy is generated and ready to be edited, once edited, it will be saved to the local workspace',\n                    )\n                ],\n                render=ArkInquirerRender(),\n                answers={'policy_editor': policy.model_dump_json(indent=4, exclude_none=True)},\n            )\n            if not answers:\n                return\n            policy = self.__policy_type.model_validate_json(answers['policy_editor'])\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to edit the {self._policies_family} policy, '\n                f'the policy will be saved to [{policy_path}] and can be edited manually [{str(ex)}]'\n            )\n    policy_path.write_text(policy.model_dump_json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.load_policies","title":"<code>load_policies(load_policies)</code>","text":"<p>Loads all remote policies into the local workspace. The user is asked whether to overwrite existing policies that were edited either locally or remotely. When default overwrite is enabled, existing policies are overwritten without prompts.</p> <p>Parameters:</p> Name Type Description Default <code>load_policies</code> <code>ArkSIALoadPolicies</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkSIALoadedPolicies</code> <code>ArkSIALoadedPolicies</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def load_policies(self, load_policies: ArkSIALoadPolicies) -&gt; ArkSIALoadedPolicies:\n    \"\"\"\n    Loads all remote policies into the local workspace.\n    The user is asked whether to overwrite existing policies that were edited either locally or remotely.\n    When default overwrite is enabled, existing policies are overwritten without prompts.\n\n    Args:\n        load_policies (ArkSIALoadPolicies): _description_\n\n    Returns:\n        ArkSIALoadedPolicies: _description_\n    \"\"\"\n    policies = self._list_policies()\n    policies_to_query: Dict[str, PolicyType] = []\n    with ThreadPoolExecutor() as executor:\n        policies_to_query = {\n            p.policy_name: p\n            for p in executor.map(lambda p: self.__load_policy_to_workspace(p, load_policies.override), policies)\n            if p is not None\n        }\n    # Build the query editor to ask the user\n    policies_to_override = []\n    if policies_to_query:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'override',\n                    message=f'Conflicts detected, please choose if you wish to override local {self._policies_family} policies or leave them as is',\n                    choices=[p.policy_name for p in policies_to_query.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policies_to_override = answers['override']\n        for policy_name in policies_to_override:\n            policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n            if policy_path.exists() and policy_name in policies_to_query:\n                policy_path.write_text(policies_to_query[policy_name].model_dump_json(indent=4))\n    return ArkSIALoadedPolicies(\n        loaded_path=str(self.__policies_cache_dir),\n        overall_policies_count=len(policies),\n        loaded_policies_count=len(policies) - len(policies_to_query),\n        overriden_policies_count=len(policies_to_override),\n        untouched_policies_count=len(policies_to_query) - len(policies_to_override),\n    )\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.policies_diff","title":"<code>policies_diff(policies_diff)</code>","text":"<p>Calculates the diff between the local workspace and remote policies. This diff includes uncommitted removed policies. A unified or per policy diff can be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>policies_diff</code> <code>ArkSIAPoliciesDiff</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def policies_diff(self, policies_diff: ArkSIAPoliciesDiff) -&gt; None:\n    \"\"\"\n    Calculates the diff between the local workspace and remote policies.\n    This diff includes uncommitted removed policies. A unified or per policy diff can be displayed.\n\n    Args:\n        policies_diff (ArkSIAPoliciesDiff): _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    if not loaded_policies_diff and not removed_policies:\n        return\n    if policies_diff.names:\n        loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in policies_diff.names}\n        removed_policies = {k: v for k, v in removed_policies.items() if k in policies_diff.names}\n    if not loaded_policies_diff and not removed_policies:\n        return\n    diffs = {\n        policy_name: difflib.unified_diff(\n            policy_tuple[1].model_dump_json(indent=4).splitlines(True),\n            policy_tuple[0].model_dump_json(indent=4).splitlines(True),\n            fromfile=f'local policy [{policy_name}]',\n            tofile=f'remote policy [{policy_name}]',\n            n=MAX_LINE_DIFF,\n        )\n        for policy_name, policy_tuple in loaded_policies_diff.items()\n    }\n    diffs.update(\n        {\n            policy_name: difflib.unified_diff(\n                policy.model_dump_json(indent=4).splitlines(True),\n                '',\n                fromfile=f'local policy [{policy_name}]',\n                tofile=f'remote policy [{policy_name}]',\n                n=MAX_LINE_DIFF,\n            )\n            for policy_name, policy in removed_policies.items()\n        }\n    )\n    try:\n        if policies_diff.unified:\n            inquirer.prompt(\n                [inquirer.Editor('diffs', 'Show all diffs')],\n                render=ArkInquirerRender(),\n                answers={'diffs': '\\n\\n\\n'.join([''.join(d) for d in diffs.values()])},\n            )\n        else:\n            inquirer.prompt(\n                [inquirer.Editor(f'{policy_name}_diff', f'Show [{policy_name}] diff') for policy_name in diffs.keys()],\n                render=ArkInquirerRender(),\n                answers={f'{policy_name}_diff': ''.join(policy_diffs) for policy_name, policy_diffs in diffs.items()},\n            )\n    except Exception as ex:\n        self._logger.error(\n            f'An error occurred while trying to show {self._policies_family} policies diff, '\n            f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.policies_status","title":"<code>policies_status(get_policies_status)</code>","text":"<p>Gets the status of locally altered policies.</p> <p>Parameters:</p> Name Type Description Default <code>get_policies_status</code> <code>ArkSIAGetPoliciesStatus</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkSIAPoliciesStatus</code> <code>ArkSIAPoliciesStatus</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def policies_status(self, get_policies_status: ArkSIAGetPoliciesStatus) -&gt; ArkSIAPoliciesStatus:\n    \"\"\"\n    Gets the status of locally altered policies.\n\n    Args:\n        get_policies_status (ArkSIAGetPoliciesStatus): _description_\n\n    Returns:\n        ArkSIAPoliciesStatus: _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    generated_policies = self.__load_generated_policies_from_workspace()\n    if get_policies_status.names:\n        loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in get_policies_status.names}\n        removed_policies = {k: v for k, v in removed_policies.items() if k in get_policies_status.names}\n        generated_policies = {k: v for k, v in generated_policies.items() if k in get_policies_status.names}\n    return ArkSIAPoliciesStatus(\n        modified_policies=list(loaded_policies_diff.keys()),\n        removed_policies=list(removed_policies.keys()),\n        added_policies=list(generated_policies.keys()),\n    )\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.remove_policies","title":"<code>remove_policies(remove_policies)</code>","text":"<p>Removes one or more policies from the local workspace. Until changes are committed, removing a remote policy only appends the <code>.deleted</code> indication to its name. After committing the changes, the policies are deleted both locally and remotely. New, uncommitted policies are deleted locally after the user consents.</p> <p>Parameters:</p> Name Type Description Default <code>remove_policies</code> <code>ArkSIARemovePolicies</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def remove_policies(self, remove_policies: ArkSIARemovePolicies) -&gt; None:\n    \"\"\"\n    Removes one or more policies from the local workspace.\n    Until changes are committed, removing a remote policy only appends the `.deleted` indication to its name.\n    After committing the changes, the policies are deleted both locally and remotely.\n    New, uncommitted policies are deleted locally after the user consents.\n\n    Args:\n        remove_policies (ArkSIARemovePolicies): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    if not workspace_policies:\n        raise ArkServiceException(\n            f'No {self._policies_family} policies to remove in the workspace, please load the policies or generate a new one'\n        )\n    policy_names = remove_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to remove?, press space to select',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    for policy_name in policy_names:\n        for path in [\n            Path(self.__policies_cache_dir) / (policy_name + '.json'),\n            Path(self.__policies_cache_dir) / (policy_name + '.json.generated'),\n        ]:\n            if path.exists():\n                if path.suffix == '.json':\n                    path.rename(Path(self.__policies_cache_dir) / (policy_name + '.json.removed'))\n                else:\n                    answers = inquirer.prompt(\n                        [\n                            inquirer.Confirm(\n                                'remove',\n                                message=f'Are you sure you want to remove local {self._policies_family} policy [{policy_name}]?, removing an uncommitted local policy cannot be reverted',\n                            )\n                        ],\n                        render=ArkInquirerRender(),\n                    )\n                    if not answers:\n                        return\n                    if answers['remove']:\n                        path.unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.reset_policies","title":"<code>reset_policies(reset_policy)</code>","text":"<p>Resets local workspace policies. When all policies are reset, all local policies are overwritten and deleted policies are removed. Otherwise, the user can select which policies are reset. This function does not alter newly generated uncommitted policies.</p> <p>Parameters:</p> Name Type Description Default <code>reset_policy</code> <code>ArkSIAResetPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def reset_policies(self, reset_policy: ArkSIAResetPolicies) -&gt; None:\n    \"\"\"\n    Resets local workspace policies.\n    When all policies are reset, all local policies are overwritten and deleted policies are removed.\n    Otherwise, the user can select which policies are reset.\n    This function does not alter newly generated uncommitted policies.\n\n    Args:\n        reset_policy (ArkSIAResetPolicies): _description_\n    \"\"\"\n    if reset_policy.all:\n        answers = inquirer.prompt(\n            [inquirer.Confirm('reset', message=f'Are you sure you want to reset all edited {self._policies_family} policies?')]\n        )\n        if not answers:\n            return\n        if answers['reset']:\n            self.load_policies(ArkSIALoadPolicies(override=True))\n    else:\n        policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        if not policies_diff and not removed_policies:\n            return\n        policy_names = reset_policy.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to reset?, press space to select',\n                        choices=[p for p in policies_diff.keys() + removed_policies.keys()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        policy_names = [p for p in policy_names if p in policies_diff or p in removed_policies]\n        for policy_name in policy_names:\n            policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n            if policy_name in policies_diff:\n                policy_path.write_text(policies_diff[policy_name][1].model_dump_json(indent=4))\n            elif policy_name in removed_policies:\n                policy_path.write_text(removed_policies[policy_name].model_dump_json(indent=4))\n                (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/cli_services/sia/common/ark_sia_base_policies_editor_service/#ark_sdk_python.cli_services.sia.common.ark_sia_base_policies_editor_service.ArkSIABasePoliciesEditorService.view_policies","title":"<code>view_policies(view_policies)</code>","text":"<p>Allows the user to view one or more policies either together or individually, as defined in the CLI user prompt. Policies are viewed in the machine's default editor (both existing policies and newly generated policies).</p> <p>Parameters:</p> Name Type Description Default <code>view_policies</code> <code>ArkSIAViewPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/sia/common/ark_sia_base_policies_editor_service.py</code> <pre><code>def view_policies(self, view_policies: ArkSIAViewPolicies) -&gt; None:\n    \"\"\"\n    Allows the user to view one or more policies either together or individually, as defined in the CLI user prompt.\n    Policies are viewed in the machine's default editor (both existing policies and newly generated policies).\n\n    Args:\n        view_policies (ArkSIAViewPolicies): _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    policy_names = view_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to view?',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    if not policy_names:\n        return\n    try:\n        if view_policies.unified:\n            inquirer.prompt(\n                [inquirer.Editor('views', f'Show all selected {self._policies_family} policies')],\n                answers={\n                    'views': '\\n\\n\\n'.join(\n                        [\n                            f'# Policy [{policy_name}]\\n{workspace_policies[policy_name].model_dump_json(indent=4)}'\n                            for policy_name in policy_names\n                        ]\n                    )\n                },\n                render=ArkInquirerRender(),\n            )\n        else:\n            inquirer.prompt(\n                [inquirer.Editor(f'{policy_name}_view', f'Show [{policy_name}]') for policy_name in policy_names],\n                render=ArkInquirerRender(),\n                answers={\n                    f'{policy_name}_view': workspace_policies[policy_name].model_dump_json(indent=4) for policy_name in policy_names\n                },\n            )\n    except Exception as ex:\n        self._logger.error(\n            f'An error occurred while trying to view the {self._policies_family} policies, '\n            f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/sia/db/","title":"db","text":""},{"location":"reference/cli_services/sia/db/ark_sia_db_policies_editor_service/","title":"ark_sia_db_policies_editor_service","text":""},{"location":"reference/cli_services/sia/vm/","title":"vm","text":""},{"location":"reference/cli_services/sia/vm/ark_sia_vm_policies_editor_service/","title":"ark_sia_vm_policies_editor_service","text":""},{"location":"reference/common/","title":"common","text":""},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient","title":"<code>ArkAsyncClient</code>","text":"<p>               Bases: <code>ABC</code>, <code>ArkClient</code></p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>class ArkAsyncClient(ABC, ArkClient):\n    def __init__(\n        self,\n        async_request_settings: ArkAsyncRequestSettings = None,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n        origin_verify: Optional[str] = None,\n        origin_verify_header_name: str = 'x-origin-verify',\n    ) -&gt; None:\n        super().__init__(\n            base_url,\n            token,\n            token_type,\n            cookies,\n            auth_header_name,\n            auth,\n            refresh_connection_callback=refresh_connection_callback,\n            origin_verify=origin_verify,\n            origin_verify_header_name=origin_verify_header_name,\n        )\n        self.__async_request_settings = async_request_settings or ArkAsyncRequestSettings()\n\n    @abstractmethod\n    def async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n        \"\"\"\n        Creates an async request for the specified model and task.\n        The request polls for async operations as defined by the poll model's implementation.\n\n        Args:\n            poll_model (ArkPollableModel): _description_\n            async_task (ArkAsyncTask): _description_\n\n        Returns:\n            ArkAsyncRequest: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_task_type() -&gt; Type[ArkAsyncTask]:\n        \"\"\"\n        Returns the client's async task type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_request_type() -&gt; Type[ArkAsyncRequest]:\n        \"\"\"\n        Returns the client's async request type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @property\n    def async_request_settings(self) -&gt; ArkAsyncRequestSettings:\n        return self.__async_request_settings\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_request_for","title":"<code>async_request_for(poll_model, async_task)</code>  <code>abstractmethod</code>","text":"<p>Creates an async request for the specified model and task. The request polls for async operations as defined by the poll model's implementation.</p> <p>Parameters:</p> Name Type Description Default <code>poll_model</code> <code>ArkPollableModel</code> <p>description</p> required <code>async_task</code> <code>ArkAsyncTask</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkAsyncRequest</code> <code>ArkAsyncRequest</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@abstractmethod\ndef async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n    \"\"\"\n    Creates an async request for the specified model and task.\n    The request polls for async operations as defined by the poll model's implementation.\n\n    Args:\n        poll_model (ArkPollableModel): _description_\n        async_task (ArkAsyncTask): _description_\n\n    Returns:\n        ArkAsyncRequest: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_request_type","title":"<code>async_request_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async request type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncRequest]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_request_type() -&gt; Type[ArkAsyncRequest]:\n    \"\"\"\n    Returns the client's async request type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_task_type","title":"<code>async_task_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async task type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncTask]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_task_type() -&gt; Type[ArkAsyncTask]:\n    \"\"\"\n    Returns the client's async task type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest","title":"<code>ArkAsyncRequest</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>class ArkAsyncRequest(ABC):\n    def __init__(self, client: ArkClient, async_task: ArkAsyncTask, async_request_settings: ArkAsyncRequestSettings):\n        self._async_task = async_task\n        self._client = client\n        self._async_request_settings = async_request_settings\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def is_finished(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has finished.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_failed(self) -&gt; bool:\n        \"\"\"\n        Checks whether or the current async request failed.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_timeout(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has timed out.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n        \"\"\"\n        Polls the async request until it has completed.\n        Progress callbacks can also be used to return the async request's status.\n\n        Args:\n            timeout_seconds (int): _description_\n            progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @property\n    def async_task(self) -&gt; ArkAsyncTask:\n        return self._async_task\n\n    @property\n    def client(self) -&gt; ArkClient:\n        return self._client\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.is_finished","title":"<code>is_finished()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has finished.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has finished.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.poll","title":"<code>poll(timeout_seconds, progress_callback)</code>  <code>abstractmethod</code>","text":"<p>Polls the async request until it has completed. Progress callbacks can also be used to return the async request's status.</p> <p>Parameters:</p> Name Type Description Default <code>timeout_seconds</code> <code>int</code> <p>description</p> required <code>progress_callback</code> <code>Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls the async request until it has completed.\n    Progress callbacks can also be used to return the async request's status.\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.task_failed","title":"<code>task_failed()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or the current async request failed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether or the current async request failed.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.task_timeout","title":"<code>task_timeout()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has timed out.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has timed out.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient","title":"<code>ArkClient</code>","text":"Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>class ArkClient:\n    __DEFAULT_REFRESH_RETRY_COUNT: Final[int] = 5\n\n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        cookie_jar: Optional[RequestsCookieJar] = None,\n        verify: Optional[Union[str, bool]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n        origin_verify: Optional[str] = None,\n        origin_verify_header_name: str = 'x-origin-verify',\n    ) -&gt; None:\n        from fake_useragent import UserAgent\n\n        self.__session = Session()\n        self.__base_url = base_url\n        self.__token = token\n        self.__token_type = token_type\n        self.__auth_header_name = auth_header_name\n        self.__refresh_connection_callback = refresh_connection_callback\n        if self.__base_url and not self.__base_url.startswith('https://'):\n            self.__base_url = f'https://{self.__base_url}'\n        if auth:\n            self.__session.auth = auth\n        self.update_token(token)\n        self.update_cookies(cookies, cookie_jar)\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        self.__session.headers['User-Agent'] = UserAgent(browsers=['chrome']).googlechrome\n        if origin_verify is not None and len(origin_verify) &gt; 0:\n            self.__session.headers[origin_verify_header_name] = origin_verify\n\n    @property\n    def base_url(self) -&gt; Optional[str]:\n        return self.__base_url\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__token\n\n    @property\n    def refresh_connection_callback(self) -&gt; Optional[Callable[['ArkClient'], None]]:\n        return self.__refresh_connection_callback\n\n    def add_header(self, key: str, value: str) -&gt; None:\n        self.__session.headers.update({key: value})\n\n    def add_headers(self, headers: Dict[str, str]) -&gt; None:\n        self.__session.headers.update(headers)\n\n    def add_cookie(self, key: str, value: str) -&gt; None:\n        self.__session.cookies[key] = value\n\n    def __generic_http_method_request_with_retry(self, method: str, route: str, refresh_retry_count: int, **kwargs) -&gt; Response:\n        url = route\n        if self.__base_url:\n            url = f'{self.__base_url}'\n            if route and route != '':\n                base_end = self.__base_url.endswith('/')\n                route_start = route.startswith('/')\n                if base_end ^ route_start:\n                    url = f'{self.__base_url}{route}'\n                else:\n                    if base_end and route_start:\n                        url = f'{self.__base_url}{route[1:]}'\n                    else:\n                        url = f'{self.__base_url}/{route}'\n        http_method = getattr(self.__session, method)\n        response: Response = http_method(url, **kwargs)\n        if response.status_code == HTTPStatus.UNAUTHORIZED and self.__refresh_connection_callback and refresh_retry_count &gt; 0:\n            self.__refresh_connection_callback(self)\n            return self.__generic_http_method_request_with_retry(method, route, refresh_retry_count - 1, **kwargs)\n        return response\n\n    def generic_http_method_request(self, method: str, route: str, **kwargs) -&gt; Response:\n        return self.__generic_http_method_request_with_retry(\n            method=method,\n            route=route,\n            refresh_retry_count=ArkClient.__DEFAULT_REFRESH_RETRY_COUNT,\n            **kwargs,\n        )\n\n    def get(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a GET request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('get', route, **kwargs)\n\n    def post(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a POST request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('post', route, **kwargs)\n\n    def put(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PUT request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('put', route, **kwargs)\n\n    def delete(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a DELETE request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('delete', route, **kwargs)\n\n    def patch(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PATCH request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('patch', route, **kwargs)\n\n    def options(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a OPTIONS request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('options', route, **kwargs)\n\n    def update_token(self, token: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Updates a session token.\n\n        Args:\n            token (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\n        self.__token = token\n        if token:\n            if self.__token_type == 'Basic':\n                user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n                self.__session.auth = (user, password)\n            else:\n                if len(self.__token_type) == 0:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n                else:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n\n    def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n        \"\"\"\n        Updates session cookies.\n\n        Args:\n            cookies (Optional[List], optional): _description_. Defaults to None.\n            cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n        \"\"\"\n        if cookies:\n            for c in cookies:\n                self.__session.cookies.set_cookie(c)\n        if cookie_jar:\n            self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.delete","title":"<code>delete(route, **kwargs)</code>","text":"<p>Performs a DELETE request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def delete(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a DELETE request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('delete', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.get","title":"<code>get(route, **kwargs)</code>","text":"<p>Performs a GET request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def get(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a GET request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('get', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.options","title":"<code>options(route, **kwargs)</code>","text":"<p>Performs a OPTIONS request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def options(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a OPTIONS request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('options', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.patch","title":"<code>patch(route, **kwargs)</code>","text":"<p>Performs a PATCH request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def patch(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PATCH request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('patch', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.post","title":"<code>post(route, **kwargs)</code>","text":"<p>Performs a POST request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def post(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a POST request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('post', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.put","title":"<code>put(route, **kwargs)</code>","text":"<p>Performs a PUT request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def put(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PUT request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('put', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.update_cookies","title":"<code>update_cookies(cookies=None, cookie_jar=None)</code>","text":"<p>Updates session cookies.</p> <p>Parameters:</p> Name Type Description Default <code>cookies</code> <code>Optional[List]</code> <p>description. Defaults to None.</p> <code>None</code> <code>cookie_jar</code> <code>Optional[RequestsCookieJar]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n    \"\"\"\n    Updates session cookies.\n\n    Args:\n        cookies (Optional[List], optional): _description_. Defaults to None.\n        cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n    \"\"\"\n    if cookies:\n        for c in cookies:\n            self.__session.cookies.set_cookie(c)\n    if cookie_jar:\n        self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.update_token","title":"<code>update_token(token=None)</code>","text":"<p>Updates a session token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_token(self, token: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Updates a session token.\n\n    Args:\n        token (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\n    self.__token = token\n    if token:\n        if self.__token_type == 'Basic':\n            user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n            self.__session.auth = (user, password)\n        else:\n            if len(self.__token_type) == 0:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n            else:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring","title":"<code>ArkKeyring</code>","text":"Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>class ArkKeyring:\n    def __init__(self, service_name: str) -&gt; None:\n        self.__service_name = service_name\n        self.__logger = get_logger(self.__class__.__name__)\n\n    @staticmethod\n    def __is_docker():\n        path = '/proc/self/cgroup'\n        return os.path.exists('/.dockerenv') or os.path.isfile(path) and any('docker' in line for line in open(path, encoding='utf-8'))\n\n    @staticmethod\n    def get_keyring(enforce_basic_keyring: bool = False):\n        try:\n            from keyring.backends import SecretService, macOS  # pylint: disable=unused-import\n            from keyrings.cryptfile.cryptfile import CryptFileKeyring  # pylint: disable=import-error\n\n            # Docker or WSL\n            if (\n                ArkKeyring.__is_docker()\n                or 'Microsoft' in uname().release\n                or ARK_BASIC_KEYRING_OVERRIDE_ENV_VAR in os.environ\n                or enforce_basic_keyring\n            ):\n                return BasicKeyring()\n            if sys.platform == 'win32':\n                kr = CryptFileKeyring()\n                kr.keyring_key = socket.gethostname()\n                return kr\n            elif sys.platform == 'darwin' or os.path.exists('/etc/redhat-release'):\n                return BasicKeyring()\n            else:\n                if DBUS_SESSION_ENV_VAR not in os.environ:\n                    return BasicKeyring()\n                return SecretService.Keyring()\n        except Exception:\n            return BasicKeyring()\n\n    def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n        \"\"\"\n        Saves the specified token for a profile in the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n        Args:\n            profile (ArkProfile): _description_\n            token (ArkToken): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n        \"\"\"\n        try:\n            self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            kr = self.get_keyring(enforce_basic_keyring)\n            kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.model_dump_json())\n            self.__logger.info('Saved token successfully')\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n                return self.save_token(profile, token, postfix, True)\n            self.__logger.warning(f'Failed to save token [{str(ex)}]')\n\n    def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads a token for a profile from the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n        When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n        When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n        Args:\n            profile (ArkProfile): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        try:\n            kr = self.get_keyring(enforce_basic_keyring)\n            self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            if not token_val:\n                self.__logger.info('No token found')\n                return None\n            token = ArkToken.model_validate_json(token_val)\n            if token.expires_in:\n                if (\n                    not token.refresh_token\n                    and token.token_type != ArkTokenType.Internal\n                    and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and no refresh token exists')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n                elif (\n                    token.refresh_token\n                    and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n            self.__logger.info('Loaded token successfully')\n            return token\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n                return self.load_token(profile, postfix, True)\n            self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n            try:\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            except Exception as ex_deletion:\n                self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n            return None\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring.load_token","title":"<code>load_token(profile, postfix, enforce_basic_keyring=False)</code>","text":"<p>Loads a token for a profile from the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used. When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned. When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads a token for a profile from the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n    When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n    When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n    Args:\n        profile (ArkProfile): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    try:\n        kr = self.get_keyring(enforce_basic_keyring)\n        self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        if not token_val:\n            self.__logger.info('No token found')\n            return None\n        token = ArkToken.model_validate_json(token_val)\n        if token.expires_in:\n            if (\n                not token.refresh_token\n                and token.token_type != ArkTokenType.Internal\n                and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and no refresh token exists')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n            elif (\n                token.refresh_token\n                and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n        self.__logger.info('Loaded token successfully')\n        return token\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n            return self.load_token(profile, postfix, True)\n        self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n        try:\n            kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        except Exception as ex_deletion:\n            self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n        return None\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring.save_token","title":"<code>save_token(profile, token, postfix, enforce_basic_keyring=False)</code>","text":"<p>Saves the specified token for a profile in the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n    \"\"\"\n    Saves the specified token for a profile in the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n    Args:\n        profile (ArkProfile): _description_\n        token (ArkToken): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n    \"\"\"\n    try:\n        self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        kr = self.get_keyring(enforce_basic_keyring)\n        kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.model_dump_json())\n        self.__logger.info('Saved token successfully')\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n            return self.save_token(profile, token, postfix, True)\n        self.__logger.warning(f'Failed to save token [{str(ex)}]')\n</code></pre>"},{"location":"reference/common/ark_async_client/","title":"ark_async_client","text":""},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient","title":"<code>ArkAsyncClient</code>","text":"<p>               Bases: <code>ABC</code>, <code>ArkClient</code></p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>class ArkAsyncClient(ABC, ArkClient):\n    def __init__(\n        self,\n        async_request_settings: ArkAsyncRequestSettings = None,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n        origin_verify: Optional[str] = None,\n        origin_verify_header_name: str = 'x-origin-verify',\n    ) -&gt; None:\n        super().__init__(\n            base_url,\n            token,\n            token_type,\n            cookies,\n            auth_header_name,\n            auth,\n            refresh_connection_callback=refresh_connection_callback,\n            origin_verify=origin_verify,\n            origin_verify_header_name=origin_verify_header_name,\n        )\n        self.__async_request_settings = async_request_settings or ArkAsyncRequestSettings()\n\n    @abstractmethod\n    def async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n        \"\"\"\n        Creates an async request for the specified model and task.\n        The request polls for async operations as defined by the poll model's implementation.\n\n        Args:\n            poll_model (ArkPollableModel): _description_\n            async_task (ArkAsyncTask): _description_\n\n        Returns:\n            ArkAsyncRequest: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_task_type() -&gt; Type[ArkAsyncTask]:\n        \"\"\"\n        Returns the client's async task type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_request_type() -&gt; Type[ArkAsyncRequest]:\n        \"\"\"\n        Returns the client's async request type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @property\n    def async_request_settings(self) -&gt; ArkAsyncRequestSettings:\n        return self.__async_request_settings\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_request_for","title":"<code>async_request_for(poll_model, async_task)</code>  <code>abstractmethod</code>","text":"<p>Creates an async request for the specified model and task. The request polls for async operations as defined by the poll model's implementation.</p> <p>Parameters:</p> Name Type Description Default <code>poll_model</code> <code>ArkPollableModel</code> <p>description</p> required <code>async_task</code> <code>ArkAsyncTask</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkAsyncRequest</code> <code>ArkAsyncRequest</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@abstractmethod\ndef async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n    \"\"\"\n    Creates an async request for the specified model and task.\n    The request polls for async operations as defined by the poll model's implementation.\n\n    Args:\n        poll_model (ArkPollableModel): _description_\n        async_task (ArkAsyncTask): _description_\n\n    Returns:\n        ArkAsyncRequest: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_request_type","title":"<code>async_request_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async request type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncRequest]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_request_type() -&gt; Type[ArkAsyncRequest]:\n    \"\"\"\n    Returns the client's async request type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_task_type","title":"<code>async_task_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async task type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncTask]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_task_type() -&gt; Type[ArkAsyncTask]:\n    \"\"\"\n    Returns the client's async task type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/","title":"ark_async_request","text":""},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest","title":"<code>ArkAsyncRequest</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>class ArkAsyncRequest(ABC):\n    def __init__(self, client: ArkClient, async_task: ArkAsyncTask, async_request_settings: ArkAsyncRequestSettings):\n        self._async_task = async_task\n        self._client = client\n        self._async_request_settings = async_request_settings\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def is_finished(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has finished.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_failed(self) -&gt; bool:\n        \"\"\"\n        Checks whether or the current async request failed.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_timeout(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has timed out.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n        \"\"\"\n        Polls the async request until it has completed.\n        Progress callbacks can also be used to return the async request's status.\n\n        Args:\n            timeout_seconds (int): _description_\n            progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @property\n    def async_task(self) -&gt; ArkAsyncTask:\n        return self._async_task\n\n    @property\n    def client(self) -&gt; ArkClient:\n        return self._client\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.is_finished","title":"<code>is_finished()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has finished.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has finished.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.poll","title":"<code>poll(timeout_seconds, progress_callback)</code>  <code>abstractmethod</code>","text":"<p>Polls the async request until it has completed. Progress callbacks can also be used to return the async request's status.</p> <p>Parameters:</p> Name Type Description Default <code>timeout_seconds</code> <code>int</code> <p>description</p> required <code>progress_callback</code> <code>Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls the async request until it has completed.\n    Progress callbacks can also be used to return the async request's status.\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.task_failed","title":"<code>task_failed()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or the current async request failed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether or the current async request failed.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.task_timeout","title":"<code>task_timeout()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has timed out.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has timed out.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_client/","title":"ark_client","text":""},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient","title":"<code>ArkClient</code>","text":"Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>class ArkClient:\n    __DEFAULT_REFRESH_RETRY_COUNT: Final[int] = 5\n\n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        cookie_jar: Optional[RequestsCookieJar] = None,\n        verify: Optional[Union[str, bool]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n        origin_verify: Optional[str] = None,\n        origin_verify_header_name: str = 'x-origin-verify',\n    ) -&gt; None:\n        from fake_useragent import UserAgent\n\n        self.__session = Session()\n        self.__base_url = base_url\n        self.__token = token\n        self.__token_type = token_type\n        self.__auth_header_name = auth_header_name\n        self.__refresh_connection_callback = refresh_connection_callback\n        if self.__base_url and not self.__base_url.startswith('https://'):\n            self.__base_url = f'https://{self.__base_url}'\n        if auth:\n            self.__session.auth = auth\n        self.update_token(token)\n        self.update_cookies(cookies, cookie_jar)\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        self.__session.headers['User-Agent'] = UserAgent(browsers=['chrome']).googlechrome\n        if origin_verify is not None and len(origin_verify) &gt; 0:\n            self.__session.headers[origin_verify_header_name] = origin_verify\n\n    @property\n    def base_url(self) -&gt; Optional[str]:\n        return self.__base_url\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__token\n\n    @property\n    def refresh_connection_callback(self) -&gt; Optional[Callable[['ArkClient'], None]]:\n        return self.__refresh_connection_callback\n\n    def add_header(self, key: str, value: str) -&gt; None:\n        self.__session.headers.update({key: value})\n\n    def add_headers(self, headers: Dict[str, str]) -&gt; None:\n        self.__session.headers.update(headers)\n\n    def add_cookie(self, key: str, value: str) -&gt; None:\n        self.__session.cookies[key] = value\n\n    def __generic_http_method_request_with_retry(self, method: str, route: str, refresh_retry_count: int, **kwargs) -&gt; Response:\n        url = route\n        if self.__base_url:\n            url = f'{self.__base_url}'\n            if route and route != '':\n                base_end = self.__base_url.endswith('/')\n                route_start = route.startswith('/')\n                if base_end ^ route_start:\n                    url = f'{self.__base_url}{route}'\n                else:\n                    if base_end and route_start:\n                        url = f'{self.__base_url}{route[1:]}'\n                    else:\n                        url = f'{self.__base_url}/{route}'\n        http_method = getattr(self.__session, method)\n        response: Response = http_method(url, **kwargs)\n        if response.status_code == HTTPStatus.UNAUTHORIZED and self.__refresh_connection_callback and refresh_retry_count &gt; 0:\n            self.__refresh_connection_callback(self)\n            return self.__generic_http_method_request_with_retry(method, route, refresh_retry_count - 1, **kwargs)\n        return response\n\n    def generic_http_method_request(self, method: str, route: str, **kwargs) -&gt; Response:\n        return self.__generic_http_method_request_with_retry(\n            method=method,\n            route=route,\n            refresh_retry_count=ArkClient.__DEFAULT_REFRESH_RETRY_COUNT,\n            **kwargs,\n        )\n\n    def get(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a GET request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('get', route, **kwargs)\n\n    def post(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a POST request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('post', route, **kwargs)\n\n    def put(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PUT request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('put', route, **kwargs)\n\n    def delete(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a DELETE request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('delete', route, **kwargs)\n\n    def patch(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PATCH request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('patch', route, **kwargs)\n\n    def options(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a OPTIONS request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('options', route, **kwargs)\n\n    def update_token(self, token: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Updates a session token.\n\n        Args:\n            token (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\n        self.__token = token\n        if token:\n            if self.__token_type == 'Basic':\n                user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n                self.__session.auth = (user, password)\n            else:\n                if len(self.__token_type) == 0:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n                else:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n\n    def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n        \"\"\"\n        Updates session cookies.\n\n        Args:\n            cookies (Optional[List], optional): _description_. Defaults to None.\n            cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n        \"\"\"\n        if cookies:\n            for c in cookies:\n                self.__session.cookies.set_cookie(c)\n        if cookie_jar:\n            self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.delete","title":"<code>delete(route, **kwargs)</code>","text":"<p>Performs a DELETE request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def delete(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a DELETE request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('delete', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.get","title":"<code>get(route, **kwargs)</code>","text":"<p>Performs a GET request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def get(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a GET request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('get', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.options","title":"<code>options(route, **kwargs)</code>","text":"<p>Performs a OPTIONS request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def options(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a OPTIONS request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('options', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.patch","title":"<code>patch(route, **kwargs)</code>","text":"<p>Performs a PATCH request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def patch(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PATCH request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('patch', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.post","title":"<code>post(route, **kwargs)</code>","text":"<p>Performs a POST request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def post(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a POST request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('post', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.put","title":"<code>put(route, **kwargs)</code>","text":"<p>Performs a PUT request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def put(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PUT request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('put', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.update_cookies","title":"<code>update_cookies(cookies=None, cookie_jar=None)</code>","text":"<p>Updates session cookies.</p> <p>Parameters:</p> Name Type Description Default <code>cookies</code> <code>Optional[List]</code> <p>description. Defaults to None.</p> <code>None</code> <code>cookie_jar</code> <code>Optional[RequestsCookieJar]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n    \"\"\"\n    Updates session cookies.\n\n    Args:\n        cookies (Optional[List], optional): _description_. Defaults to None.\n        cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n    \"\"\"\n    if cookies:\n        for c in cookies:\n            self.__session.cookies.set_cookie(c)\n    if cookie_jar:\n        self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.update_token","title":"<code>update_token(token=None)</code>","text":"<p>Updates a session token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_token(self, token: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Updates a session token.\n\n    Args:\n        token (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\n    self.__token = token\n    if token:\n        if self.__token_type == 'Basic':\n            user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n            self.__session.auth = (user, password)\n        else:\n            if len(self.__token_type) == 0:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n            else:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n</code></pre>"},{"location":"reference/common/ark_jwt_utils/","title":"ark_jwt_utils","text":""},{"location":"reference/common/ark_keyring/","title":"ark_keyring","text":""},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring","title":"<code>ArkKeyring</code>","text":"Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>class ArkKeyring:\n    def __init__(self, service_name: str) -&gt; None:\n        self.__service_name = service_name\n        self.__logger = get_logger(self.__class__.__name__)\n\n    @staticmethod\n    def __is_docker():\n        path = '/proc/self/cgroup'\n        return os.path.exists('/.dockerenv') or os.path.isfile(path) and any('docker' in line for line in open(path, encoding='utf-8'))\n\n    @staticmethod\n    def get_keyring(enforce_basic_keyring: bool = False):\n        try:\n            from keyring.backends import SecretService, macOS  # pylint: disable=unused-import\n            from keyrings.cryptfile.cryptfile import CryptFileKeyring  # pylint: disable=import-error\n\n            # Docker or WSL\n            if (\n                ArkKeyring.__is_docker()\n                or 'Microsoft' in uname().release\n                or ARK_BASIC_KEYRING_OVERRIDE_ENV_VAR in os.environ\n                or enforce_basic_keyring\n            ):\n                return BasicKeyring()\n            if sys.platform == 'win32':\n                kr = CryptFileKeyring()\n                kr.keyring_key = socket.gethostname()\n                return kr\n            elif sys.platform == 'darwin' or os.path.exists('/etc/redhat-release'):\n                return BasicKeyring()\n            else:\n                if DBUS_SESSION_ENV_VAR not in os.environ:\n                    return BasicKeyring()\n                return SecretService.Keyring()\n        except Exception:\n            return BasicKeyring()\n\n    def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n        \"\"\"\n        Saves the specified token for a profile in the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n        Args:\n            profile (ArkProfile): _description_\n            token (ArkToken): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n        \"\"\"\n        try:\n            self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            kr = self.get_keyring(enforce_basic_keyring)\n            kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.model_dump_json())\n            self.__logger.info('Saved token successfully')\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n                return self.save_token(profile, token, postfix, True)\n            self.__logger.warning(f'Failed to save token [{str(ex)}]')\n\n    def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads a token for a profile from the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n        When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n        When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n        Args:\n            profile (ArkProfile): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        try:\n            kr = self.get_keyring(enforce_basic_keyring)\n            self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            if not token_val:\n                self.__logger.info('No token found')\n                return None\n            token = ArkToken.model_validate_json(token_val)\n            if token.expires_in:\n                if (\n                    not token.refresh_token\n                    and token.token_type != ArkTokenType.Internal\n                    and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and no refresh token exists')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n                elif (\n                    token.refresh_token\n                    and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n            self.__logger.info('Loaded token successfully')\n            return token\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n                return self.load_token(profile, postfix, True)\n            self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n            try:\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            except Exception as ex_deletion:\n                self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n            return None\n</code></pre>"},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring.load_token","title":"<code>load_token(profile, postfix, enforce_basic_keyring=False)</code>","text":"<p>Loads a token for a profile from the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used. When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned. When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads a token for a profile from the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n    When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n    When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n    Args:\n        profile (ArkProfile): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    try:\n        kr = self.get_keyring(enforce_basic_keyring)\n        self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        if not token_val:\n            self.__logger.info('No token found')\n            return None\n        token = ArkToken.model_validate_json(token_val)\n        if token.expires_in:\n            if (\n                not token.refresh_token\n                and token.token_type != ArkTokenType.Internal\n                and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and no refresh token exists')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n            elif (\n                token.refresh_token\n                and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n        self.__logger.info('Loaded token successfully')\n        return token\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n            return self.load_token(profile, postfix, True)\n        self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n        try:\n            kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        except Exception as ex_deletion:\n            self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n        return None\n</code></pre>"},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring.save_token","title":"<code>save_token(profile, token, postfix, enforce_basic_keyring=False)</code>","text":"<p>Saves the specified token for a profile in the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n    \"\"\"\n    Saves the specified token for a profile in the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n    Args:\n        profile (ArkProfile): _description_\n        token (ArkToken): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n    \"\"\"\n    try:\n        self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        kr = self.get_keyring(enforce_basic_keyring)\n        kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.model_dump_json())\n        self.__logger.info('Saved token successfully')\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n            return self.save_token(profile, token, postfix, True)\n        self.__logger.warning(f'Failed to save token [{str(ex)}]')\n</code></pre>"},{"location":"reference/common/ark_logger/","title":"ark_logger","text":""},{"location":"reference/common/ark_page/","title":"ark_page","text":""},{"location":"reference/common/ark_pollers/","title":"ark_pollers","text":""},{"location":"reference/common/ark_random_utils/","title":"ark_random_utils","text":""},{"location":"reference/common/ark_retry/","title":"ark_retry","text":""},{"location":"reference/common/ark_system_config/","title":"ark_system_config","text":""},{"location":"reference/common/connections/","title":"connections","text":""},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection","title":"<code>ArkConnection</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>class ArkConnection(ABC):\n    def __init__(self) -&gt; None:\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n        \"\"\"\n        Connects to the target with given information\n\n        Args:\n            connection_details (ArkConnectionDetails): _description_\n        \"\"\"\n\n    @abstractmethod\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnects the active session\n        \"\"\"\n\n    @abstractmethod\n    def suspend_connection(self) -&gt; None:\n        \"\"\"\n        Suspends the session from command execution\n        \"\"\"\n\n    @abstractmethod\n    def restore_connection(self) -&gt; None:\n        \"\"\"\n        Restores the session\n        \"\"\"\n\n    @abstractmethod\n    def is_suspended(self) -&gt; bool:\n        \"\"\"\n        Checks whether session is suspended\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Checks whether session is connected\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n        \"\"\"\n        Runs a remote connection command\n\n        Args:\n            command (ArkConnectionCommand): _description_\n\n        Returns:\n            ArkConnectionResult: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection.connect","title":"<code>connect(connection_details)</code>  <code>abstractmethod</code>","text":"<p>Connects to the target with given information</p> <p>Parameters:</p> Name Type Description Default <code>connection_details</code> <code>ArkConnectionDetails</code> <p>description</p> required Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n    \"\"\"\n    Connects to the target with given information\n\n    Args:\n        connection_details (ArkConnectionDetails): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code>","text":"<p>Disconnects the active session</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnects the active session\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection.is_connected","title":"<code>is_connected()</code>  <code>abstractmethod</code>","text":"<p>Checks whether session is connected</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef is_connected(self) -&gt; bool:\n    \"\"\"\n    Checks whether session is connected\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection.is_suspended","title":"<code>is_suspended()</code>  <code>abstractmethod</code>","text":"<p>Checks whether session is suspended</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef is_suspended(self) -&gt; bool:\n    \"\"\"\n    Checks whether session is suspended\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection.restore_connection","title":"<code>restore_connection()</code>  <code>abstractmethod</code>","text":"<p>Restores the session</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef restore_connection(self) -&gt; None:\n    \"\"\"\n    Restores the session\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection.run_command","title":"<code>run_command(command)</code>  <code>abstractmethod</code>","text":"<p>Runs a remote connection command</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ArkConnectionCommand</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkConnectionResult</code> <code>ArkConnectionResult</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n    \"\"\"\n    Runs a remote connection command\n\n    Args:\n        command (ArkConnectionCommand): _description_\n\n    Returns:\n        ArkConnectionResult: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/#ark_sdk_python.common.connections.ArkConnection.suspend_connection","title":"<code>suspend_connection()</code>  <code>abstractmethod</code>","text":"<p>Suspends the session from command execution</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef suspend_connection(self) -&gt; None:\n    \"\"\"\n    Suspends the session from command execution\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/","title":"ark_connection","text":""},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection","title":"<code>ArkConnection</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>class ArkConnection(ABC):\n    def __init__(self) -&gt; None:\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n        \"\"\"\n        Connects to the target with given information\n\n        Args:\n            connection_details (ArkConnectionDetails): _description_\n        \"\"\"\n\n    @abstractmethod\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnects the active session\n        \"\"\"\n\n    @abstractmethod\n    def suspend_connection(self) -&gt; None:\n        \"\"\"\n        Suspends the session from command execution\n        \"\"\"\n\n    @abstractmethod\n    def restore_connection(self) -&gt; None:\n        \"\"\"\n        Restores the session\n        \"\"\"\n\n    @abstractmethod\n    def is_suspended(self) -&gt; bool:\n        \"\"\"\n        Checks whether session is suspended\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Checks whether session is connected\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n        \"\"\"\n        Runs a remote connection command\n\n        Args:\n            command (ArkConnectionCommand): _description_\n\n        Returns:\n            ArkConnectionResult: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection.connect","title":"<code>connect(connection_details)</code>  <code>abstractmethod</code>","text":"<p>Connects to the target with given information</p> <p>Parameters:</p> Name Type Description Default <code>connection_details</code> <code>ArkConnectionDetails</code> <p>description</p> required Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n    \"\"\"\n    Connects to the target with given information\n\n    Args:\n        connection_details (ArkConnectionDetails): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code>","text":"<p>Disconnects the active session</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnects the active session\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection.is_connected","title":"<code>is_connected()</code>  <code>abstractmethod</code>","text":"<p>Checks whether session is connected</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef is_connected(self) -&gt; bool:\n    \"\"\"\n    Checks whether session is connected\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection.is_suspended","title":"<code>is_suspended()</code>  <code>abstractmethod</code>","text":"<p>Checks whether session is suspended</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef is_suspended(self) -&gt; bool:\n    \"\"\"\n    Checks whether session is suspended\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection.restore_connection","title":"<code>restore_connection()</code>  <code>abstractmethod</code>","text":"<p>Restores the session</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef restore_connection(self) -&gt; None:\n    \"\"\"\n    Restores the session\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection.run_command","title":"<code>run_command(command)</code>  <code>abstractmethod</code>","text":"<p>Runs a remote connection command</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ArkConnectionCommand</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkConnectionResult</code> <code>ArkConnectionResult</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n    \"\"\"\n    Runs a remote connection command\n\n    Args:\n        command (ArkConnectionCommand): _description_\n\n    Returns:\n        ArkConnectionResult: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ark_connection/#ark_sdk_python.common.connections.ark_connection.ArkConnection.suspend_connection","title":"<code>suspend_connection()</code>  <code>abstractmethod</code>","text":"<p>Suspends the session from command execution</p> Source code in <code>ark_sdk_python/common/connections/ark_connection.py</code> <pre><code>@abstractmethod\ndef suspend_connection(self) -&gt; None:\n    \"\"\"\n    Suspends the session from command execution\n    \"\"\"\n</code></pre>"},{"location":"reference/common/connections/ssh/","title":"ssh","text":""},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection","title":"<code>ArkSSHConnection</code>","text":"<p>               Bases: <code>ArkConnection</code></p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>class ArkSSHConnection(ArkConnection):\n    def __init__(self):\n        super().__init__()\n        self.__is_connected: bool = False\n        self.__is_suspended: bool = False\n        self.__ssh_client: Optional[Any] = None\n\n    @overrides\n    def connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n        \"\"\"\n        Performs SSH connection with given details or keys\n        Saves the ssh session to be used for command executions\n\n        Args:\n            connection_details (ArkConnectionDetails): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        import paramiko\n\n        if self.__is_connected:\n            return\n        try:\n            target_port = SSH_PORT\n            user = None\n            password = None\n            private_key_data = None\n            private_key = None\n            if connection_details.port:\n                target_port = connection_details.port\n            if connection_details.credentials:\n                user = connection_details.credentials.user\n                if connection_details.credentials.password:\n                    password = connection_details.credentials.password.get_secret_value()\n                elif connection_details.credentials.private_key_filepath:\n                    path = Path(connection_details.credentials.private_key_filepath)\n                    if not path.exists():\n                        raise ArkException(f'Given private key path [{path}] does not exist')\n                    private_key_data = path.read_text(encoding='utf-8')\n                elif connection_details.credentials.private_key_contents:\n                    private_key_data = connection_details.credentials.private_key_contents\n                if private_key_data:\n                    private_key_io = StringIO(private_key_data)\n                    private_key = paramiko.RSAKey.from_private_key(private_key_io)\n                    private_key_io.close()\n            self.__ssh_client = paramiko.SSHClient()\n            self.__ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            self.__ssh_client.connect(\n                hostname=connection_details.address, port=target_port, username=user, password=password, pkey=private_key\n            )\n            self.__is_connected = True\n            self.__is_suspended = False\n        except Exception as ex:\n            raise ArkException(f'Failed to ssh connect [{str(ex)}]') from ex\n\n    @overrides\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnects the ssh session\n        \"\"\"\n        if not self.__is_connected:\n            return\n        self.__ssh_client.close()\n        self.__ssh_client = None\n        self.__is_connected = False\n        self.__is_suspended = False\n\n    @overrides\n    def suspend_connection(self) -&gt; None:\n        \"\"\"\n        Suspends execution of ssh commands\n        \"\"\"\n        self.__is_suspended = True\n\n    @overrides\n    def restore_connection(self) -&gt; None:\n        \"\"\"\n        Restores execution of ssh commands\n        \"\"\"\n        self.__is_suspended = False\n\n    @overrides\n    def is_suspended(self) -&gt; bool:\n        \"\"\"\n        Checks whether ssh commands can be executed or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_suspended\n\n    @overrides\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Checks whether theres a ssh session connected\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_connected\n\n    @overrides\n    def run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n        \"\"\"\n        Runs a command over ssh session, returning the result accordingly\n\n        Args:\n            command (ArkConnectionCommand): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkConnectionResult: _description_\n        \"\"\"\n        if not self.__is_connected or self.__is_suspended:\n            raise ArkException('Cannot run command while not being connected')\n        self._logger.debug(f'Running command [{command.command}]')\n        _, stdout_stream, stderr_stream = self.__ssh_client.exec_command(command=command.command)\n        rc = stdout_stream.channel.recv_exit_status()\n        stdout = ''.join(stdout_stream.readlines())\n        stderr = ''.join(stderr_stream.readlines())\n        if rc != command.expected_rc and command.raise_on_error:\n            raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n        self._logger.debug(f'Command rc: [{rc}]')\n        self._logger.debug(f'Command stdout: [{stdout}]')\n        self._logger.debug(f'Command stderr: [{stderr}]')\n        return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection.connect","title":"<code>connect(connection_details)</code>","text":"<p>Performs SSH connection with given details or keys Saves the ssh session to be used for command executions</p> <p>Parameters:</p> Name Type Description Default <code>connection_details</code> <code>ArkConnectionDetails</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n    \"\"\"\n    Performs SSH connection with given details or keys\n    Saves the ssh session to be used for command executions\n\n    Args:\n        connection_details (ArkConnectionDetails): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    import paramiko\n\n    if self.__is_connected:\n        return\n    try:\n        target_port = SSH_PORT\n        user = None\n        password = None\n        private_key_data = None\n        private_key = None\n        if connection_details.port:\n            target_port = connection_details.port\n        if connection_details.credentials:\n            user = connection_details.credentials.user\n            if connection_details.credentials.password:\n                password = connection_details.credentials.password.get_secret_value()\n            elif connection_details.credentials.private_key_filepath:\n                path = Path(connection_details.credentials.private_key_filepath)\n                if not path.exists():\n                    raise ArkException(f'Given private key path [{path}] does not exist')\n                private_key_data = path.read_text(encoding='utf-8')\n            elif connection_details.credentials.private_key_contents:\n                private_key_data = connection_details.credentials.private_key_contents\n            if private_key_data:\n                private_key_io = StringIO(private_key_data)\n                private_key = paramiko.RSAKey.from_private_key(private_key_io)\n                private_key_io.close()\n        self.__ssh_client = paramiko.SSHClient()\n        self.__ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        self.__ssh_client.connect(\n            hostname=connection_details.address, port=target_port, username=user, password=password, pkey=private_key\n        )\n        self.__is_connected = True\n        self.__is_suspended = False\n    except Exception as ex:\n        raise ArkException(f'Failed to ssh connect [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects the ssh session</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnects the ssh session\n    \"\"\"\n    if not self.__is_connected:\n        return\n    self.__ssh_client.close()\n    self.__ssh_client = None\n    self.__is_connected = False\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection.is_connected","title":"<code>is_connected()</code>","text":"<p>Checks whether theres a ssh session connected</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef is_connected(self) -&gt; bool:\n    \"\"\"\n    Checks whether theres a ssh session connected\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_connected\n</code></pre>"},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection.is_suspended","title":"<code>is_suspended()</code>","text":"<p>Checks whether ssh commands can be executed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef is_suspended(self) -&gt; bool:\n    \"\"\"\n    Checks whether ssh commands can be executed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_suspended\n</code></pre>"},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection.restore_connection","title":"<code>restore_connection()</code>","text":"<p>Restores execution of ssh commands</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef restore_connection(self) -&gt; None:\n    \"\"\"\n    Restores execution of ssh commands\n    \"\"\"\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection.run_command","title":"<code>run_command(command)</code>","text":"<p>Runs a command over ssh session, returning the result accordingly</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ArkConnectionCommand</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkConnectionResult</code> <code>ArkConnectionResult</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n    \"\"\"\n    Runs a command over ssh session, returning the result accordingly\n\n    Args:\n        command (ArkConnectionCommand): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkConnectionResult: _description_\n    \"\"\"\n    if not self.__is_connected or self.__is_suspended:\n        raise ArkException('Cannot run command while not being connected')\n    self._logger.debug(f'Running command [{command.command}]')\n    _, stdout_stream, stderr_stream = self.__ssh_client.exec_command(command=command.command)\n    rc = stdout_stream.channel.recv_exit_status()\n    stdout = ''.join(stdout_stream.readlines())\n    stderr = ''.join(stderr_stream.readlines())\n    if rc != command.expected_rc and command.raise_on_error:\n        raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n    self._logger.debug(f'Command rc: [{rc}]')\n    self._logger.debug(f'Command stdout: [{stdout}]')\n    self._logger.debug(f'Command stderr: [{stderr}]')\n    return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/ssh/#ark_sdk_python.common.connections.ssh.ArkSSHConnection.suspend_connection","title":"<code>suspend_connection()</code>","text":"<p>Suspends execution of ssh commands</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef suspend_connection(self) -&gt; None:\n    \"\"\"\n    Suspends execution of ssh commands\n    \"\"\"\n    self.__is_suspended = True\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/","title":"ark_ssh_connection","text":""},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection","title":"<code>ArkSSHConnection</code>","text":"<p>               Bases: <code>ArkConnection</code></p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>class ArkSSHConnection(ArkConnection):\n    def __init__(self):\n        super().__init__()\n        self.__is_connected: bool = False\n        self.__is_suspended: bool = False\n        self.__ssh_client: Optional[Any] = None\n\n    @overrides\n    def connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n        \"\"\"\n        Performs SSH connection with given details or keys\n        Saves the ssh session to be used for command executions\n\n        Args:\n            connection_details (ArkConnectionDetails): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        import paramiko\n\n        if self.__is_connected:\n            return\n        try:\n            target_port = SSH_PORT\n            user = None\n            password = None\n            private_key_data = None\n            private_key = None\n            if connection_details.port:\n                target_port = connection_details.port\n            if connection_details.credentials:\n                user = connection_details.credentials.user\n                if connection_details.credentials.password:\n                    password = connection_details.credentials.password.get_secret_value()\n                elif connection_details.credentials.private_key_filepath:\n                    path = Path(connection_details.credentials.private_key_filepath)\n                    if not path.exists():\n                        raise ArkException(f'Given private key path [{path}] does not exist')\n                    private_key_data = path.read_text(encoding='utf-8')\n                elif connection_details.credentials.private_key_contents:\n                    private_key_data = connection_details.credentials.private_key_contents\n                if private_key_data:\n                    private_key_io = StringIO(private_key_data)\n                    private_key = paramiko.RSAKey.from_private_key(private_key_io)\n                    private_key_io.close()\n            self.__ssh_client = paramiko.SSHClient()\n            self.__ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            self.__ssh_client.connect(\n                hostname=connection_details.address, port=target_port, username=user, password=password, pkey=private_key\n            )\n            self.__is_connected = True\n            self.__is_suspended = False\n        except Exception as ex:\n            raise ArkException(f'Failed to ssh connect [{str(ex)}]') from ex\n\n    @overrides\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnects the ssh session\n        \"\"\"\n        if not self.__is_connected:\n            return\n        self.__ssh_client.close()\n        self.__ssh_client = None\n        self.__is_connected = False\n        self.__is_suspended = False\n\n    @overrides\n    def suspend_connection(self) -&gt; None:\n        \"\"\"\n        Suspends execution of ssh commands\n        \"\"\"\n        self.__is_suspended = True\n\n    @overrides\n    def restore_connection(self) -&gt; None:\n        \"\"\"\n        Restores execution of ssh commands\n        \"\"\"\n        self.__is_suspended = False\n\n    @overrides\n    def is_suspended(self) -&gt; bool:\n        \"\"\"\n        Checks whether ssh commands can be executed or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_suspended\n\n    @overrides\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Checks whether theres a ssh session connected\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_connected\n\n    @overrides\n    def run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n        \"\"\"\n        Runs a command over ssh session, returning the result accordingly\n\n        Args:\n            command (ArkConnectionCommand): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkConnectionResult: _description_\n        \"\"\"\n        if not self.__is_connected or self.__is_suspended:\n            raise ArkException('Cannot run command while not being connected')\n        self._logger.debug(f'Running command [{command.command}]')\n        _, stdout_stream, stderr_stream = self.__ssh_client.exec_command(command=command.command)\n        rc = stdout_stream.channel.recv_exit_status()\n        stdout = ''.join(stdout_stream.readlines())\n        stderr = ''.join(stderr_stream.readlines())\n        if rc != command.expected_rc and command.raise_on_error:\n            raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n        self._logger.debug(f'Command rc: [{rc}]')\n        self._logger.debug(f'Command stdout: [{stdout}]')\n        self._logger.debug(f'Command stderr: [{stderr}]')\n        return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection.connect","title":"<code>connect(connection_details)</code>","text":"<p>Performs SSH connection with given details or keys Saves the ssh session to be used for command executions</p> <p>Parameters:</p> Name Type Description Default <code>connection_details</code> <code>ArkConnectionDetails</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n    \"\"\"\n    Performs SSH connection with given details or keys\n    Saves the ssh session to be used for command executions\n\n    Args:\n        connection_details (ArkConnectionDetails): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    import paramiko\n\n    if self.__is_connected:\n        return\n    try:\n        target_port = SSH_PORT\n        user = None\n        password = None\n        private_key_data = None\n        private_key = None\n        if connection_details.port:\n            target_port = connection_details.port\n        if connection_details.credentials:\n            user = connection_details.credentials.user\n            if connection_details.credentials.password:\n                password = connection_details.credentials.password.get_secret_value()\n            elif connection_details.credentials.private_key_filepath:\n                path = Path(connection_details.credentials.private_key_filepath)\n                if not path.exists():\n                    raise ArkException(f'Given private key path [{path}] does not exist')\n                private_key_data = path.read_text(encoding='utf-8')\n            elif connection_details.credentials.private_key_contents:\n                private_key_data = connection_details.credentials.private_key_contents\n            if private_key_data:\n                private_key_io = StringIO(private_key_data)\n                private_key = paramiko.RSAKey.from_private_key(private_key_io)\n                private_key_io.close()\n        self.__ssh_client = paramiko.SSHClient()\n        self.__ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        self.__ssh_client.connect(\n            hostname=connection_details.address, port=target_port, username=user, password=password, pkey=private_key\n        )\n        self.__is_connected = True\n        self.__is_suspended = False\n    except Exception as ex:\n        raise ArkException(f'Failed to ssh connect [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects the ssh session</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnects the ssh session\n    \"\"\"\n    if not self.__is_connected:\n        return\n    self.__ssh_client.close()\n    self.__ssh_client = None\n    self.__is_connected = False\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection.is_connected","title":"<code>is_connected()</code>","text":"<p>Checks whether theres a ssh session connected</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef is_connected(self) -&gt; bool:\n    \"\"\"\n    Checks whether theres a ssh session connected\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_connected\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection.is_suspended","title":"<code>is_suspended()</code>","text":"<p>Checks whether ssh commands can be executed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef is_suspended(self) -&gt; bool:\n    \"\"\"\n    Checks whether ssh commands can be executed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_suspended\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection.restore_connection","title":"<code>restore_connection()</code>","text":"<p>Restores execution of ssh commands</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef restore_connection(self) -&gt; None:\n    \"\"\"\n    Restores execution of ssh commands\n    \"\"\"\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection.run_command","title":"<code>run_command(command)</code>","text":"<p>Runs a command over ssh session, returning the result accordingly</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ArkConnectionCommand</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkConnectionResult</code> <code>ArkConnectionResult</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n    \"\"\"\n    Runs a command over ssh session, returning the result accordingly\n\n    Args:\n        command (ArkConnectionCommand): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkConnectionResult: _description_\n    \"\"\"\n    if not self.__is_connected or self.__is_suspended:\n        raise ArkException('Cannot run command while not being connected')\n    self._logger.debug(f'Running command [{command.command}]')\n    _, stdout_stream, stderr_stream = self.__ssh_client.exec_command(command=command.command)\n    rc = stdout_stream.channel.recv_exit_status()\n    stdout = ''.join(stdout_stream.readlines())\n    stderr = ''.join(stderr_stream.readlines())\n    if rc != command.expected_rc and command.raise_on_error:\n        raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n    self._logger.debug(f'Command rc: [{rc}]')\n    self._logger.debug(f'Command stdout: [{stdout}]')\n    self._logger.debug(f'Command stderr: [{stderr}]')\n    return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/ssh/ark_ssh_connection/#ark_sdk_python.common.connections.ssh.ark_ssh_connection.ArkSSHConnection.suspend_connection","title":"<code>suspend_connection()</code>","text":"<p>Suspends execution of ssh commands</p> Source code in <code>ark_sdk_python/common/connections/ssh/ark_ssh_connection.py</code> <pre><code>@overrides\ndef suspend_connection(self) -&gt; None:\n    \"\"\"\n    Suspends execution of ssh commands\n    \"\"\"\n    self.__is_suspended = True\n</code></pre>"},{"location":"reference/common/connections/winrm/","title":"winrm","text":""},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection","title":"<code>ArkWinRMConnection</code>","text":"<p>               Bases: <code>ArkConnection</code></p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>class ArkWinRMConnection(ArkConnection):\n    def __init__(self):\n        super().__init__()\n        self.__is_connected: bool = False\n        self.__is_suspended: bool = False\n        self.__winrm_protocol: Optional[Any] = None\n        self.__winrm_shell_id: Optional[str] = None\n\n    @overrides\n    def connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n        \"\"\"\n        Performs WinRM connection with given details and certificate\n        Saves the winrm protocol session and shell id to be used for command executions\n\n        Args:\n            connection_details (ArkConnectionDetails): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        import winrm\n\n        if self.__is_connected:\n            return\n        try:\n            target_port = WINRM_HTTPS_PORT\n            user = None\n            password = None\n            cert = 'legacy_requests'\n            if connection_details.port:\n                target_port = connection_details.port\n            if connection_details.credentials:\n                user = connection_details.credentials.user\n                if connection_details.credentials.password:\n                    password = connection_details.credentials.password.get_secret_value()\n            if connection_details.connection_data and connection_details.connection_data.certificate:\n                cert = connection_details.connection_data.certificate\n            self.__winrm_protocol = winrm.Protocol(\n                endpoint=f'https://{connection_details.address}:' f'{target_port}/wsman',\n                transport='ntlm',\n                username=user,\n                password=password,\n                ca_trust_path=cert,\n                server_cert_validation='ignore',\n                read_timeout_sec=10,\n                operation_timeout_sec=5,\n            )\n            self.__winrm_shell_id = self.__winrm_protocol.open_shell()\n            self.__is_connected = True\n            self.__is_suspended = False\n        except Exception as ex:\n            raise ArkException(f'Failed to winrm connect [{str(ex)}]') from ex\n\n    @overrides\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnects the winrm session\n        \"\"\"\n        if not self.__is_connected:\n            return\n        self.__winrm_protocol.close_shell(self.__winrm_shell_id)\n        self.__winrm_shell_id = None\n        self.__winrm_protocol = None\n        self.__is_connected = False\n        self.__is_suspended = False\n\n    @overrides\n    def suspend_connection(self) -&gt; None:\n        \"\"\"\n        Suspends execution of winrm commands\n        \"\"\"\n        self.__is_suspended = True\n\n    @overrides\n    def restore_connection(self) -&gt; None:\n        \"\"\"\n        Restores execution of winrm commands\n        \"\"\"\n        self.__is_suspended = False\n\n    @overrides\n    def is_suspended(self) -&gt; bool:\n        \"\"\"\n        Checks whether winrm commands can be executed or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_suspended\n\n    @overrides\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Checks whether theres a winrm session connected\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_connected\n\n    @overrides\n    def run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n        \"\"\"\n        Runs a command over winrm session, returning the result accordingly\n\n        Args:\n            command (ArkConnectionCommand): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkConnectionResult: _description_\n        \"\"\"\n        if not self.__is_connected or self.__is_suspended:\n            raise ArkException('Cannot run command while not being connected')\n        self._logger.debug(f'Running powershell command [{command.command}] of length [{len(command.command)}]')\n        if len(command.command) &gt; 2000 or (command.extra_command_data and command.extra_command_data.get('force_command_split', False)):\n            encoded_command = command.command.encode('utf_16_le')\n            max_size = 4000\n            chunks = [encoded_command[i : i + max_size] for i in range(0, len(encoded_command), max_size)]\n            command_unique_file_name = uuid.uuid4().hex\n            command_file = f'\"C:\\\\temp\\\\{command_unique_file_name}.ps1\"'\n\n            # Ensure C:\\temp exists\n            self.__winrm_protocol.run_command(self.__winrm_shell_id, 'if not exist \"C:\\\\temp\" mkdir C:\\\\temp')\n\n            # Write chunks to the file\n            for chunk in chunks:\n                encoded_chunk_base64 = base64.b64encode(chunk).decode('ascii')\n                command_id = self.__winrm_protocol.run_command(\n                    self.__winrm_shell_id,\n                    f'powershell -Command \"[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(\\'{encoded_chunk_base64}\\')) | Add-Content -Path {command_file} -Encoding Unicode -NoNewline\"',\n                )\n                stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n            # Execute the PowerShell script\n            command_id = self.__winrm_protocol.run_command(self.__winrm_shell_id, f'powershell -File {command_file}')\n            stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n            # Clean up the temporary file\n            self.__winrm_protocol.run_command(self.__winrm_shell_id, f'del /f {command_file}')\n        else:\n            encoded_ps = f'powershell -encodedcommand {base64.b64encode(command.command.encode(\"utf_16_le\")).decode(\"ascii\")}'\n            command_id: str = self.__winrm_protocol.run_command(self.__winrm_shell_id, encoded_ps.split()[0], encoded_ps.split()[1:])\n            stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n        stdout = stdout.decode(\"utf8\")\n        stderr = stderr.decode(\"utf8\")\n        self.__winrm_protocol.cleanup_command(self.__winrm_shell_id, command_id)\n        if command.expected_rc != rc and command.raise_on_error:\n            raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n        self._logger.debug(f'Command rc: [{rc}]')\n        self._logger.debug(f'Command stdout: [{stdout}]')\n        self._logger.debug(f'Command stderr: [{stderr}]')\n        return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection.connect","title":"<code>connect(connection_details)</code>","text":"<p>Performs WinRM connection with given details and certificate Saves the winrm protocol session and shell id to be used for command executions</p> <p>Parameters:</p> Name Type Description Default <code>connection_details</code> <code>ArkConnectionDetails</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n    \"\"\"\n    Performs WinRM connection with given details and certificate\n    Saves the winrm protocol session and shell id to be used for command executions\n\n    Args:\n        connection_details (ArkConnectionDetails): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    import winrm\n\n    if self.__is_connected:\n        return\n    try:\n        target_port = WINRM_HTTPS_PORT\n        user = None\n        password = None\n        cert = 'legacy_requests'\n        if connection_details.port:\n            target_port = connection_details.port\n        if connection_details.credentials:\n            user = connection_details.credentials.user\n            if connection_details.credentials.password:\n                password = connection_details.credentials.password.get_secret_value()\n        if connection_details.connection_data and connection_details.connection_data.certificate:\n            cert = connection_details.connection_data.certificate\n        self.__winrm_protocol = winrm.Protocol(\n            endpoint=f'https://{connection_details.address}:' f'{target_port}/wsman',\n            transport='ntlm',\n            username=user,\n            password=password,\n            ca_trust_path=cert,\n            server_cert_validation='ignore',\n            read_timeout_sec=10,\n            operation_timeout_sec=5,\n        )\n        self.__winrm_shell_id = self.__winrm_protocol.open_shell()\n        self.__is_connected = True\n        self.__is_suspended = False\n    except Exception as ex:\n        raise ArkException(f'Failed to winrm connect [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects the winrm session</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnects the winrm session\n    \"\"\"\n    if not self.__is_connected:\n        return\n    self.__winrm_protocol.close_shell(self.__winrm_shell_id)\n    self.__winrm_shell_id = None\n    self.__winrm_protocol = None\n    self.__is_connected = False\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection.is_connected","title":"<code>is_connected()</code>","text":"<p>Checks whether theres a winrm session connected</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef is_connected(self) -&gt; bool:\n    \"\"\"\n    Checks whether theres a winrm session connected\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_connected\n</code></pre>"},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection.is_suspended","title":"<code>is_suspended()</code>","text":"<p>Checks whether winrm commands can be executed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef is_suspended(self) -&gt; bool:\n    \"\"\"\n    Checks whether winrm commands can be executed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_suspended\n</code></pre>"},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection.restore_connection","title":"<code>restore_connection()</code>","text":"<p>Restores execution of winrm commands</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef restore_connection(self) -&gt; None:\n    \"\"\"\n    Restores execution of winrm commands\n    \"\"\"\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection.run_command","title":"<code>run_command(command)</code>","text":"<p>Runs a command over winrm session, returning the result accordingly</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ArkConnectionCommand</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkConnectionResult</code> <code>ArkConnectionResult</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n    \"\"\"\n    Runs a command over winrm session, returning the result accordingly\n\n    Args:\n        command (ArkConnectionCommand): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkConnectionResult: _description_\n    \"\"\"\n    if not self.__is_connected or self.__is_suspended:\n        raise ArkException('Cannot run command while not being connected')\n    self._logger.debug(f'Running powershell command [{command.command}] of length [{len(command.command)}]')\n    if len(command.command) &gt; 2000 or (command.extra_command_data and command.extra_command_data.get('force_command_split', False)):\n        encoded_command = command.command.encode('utf_16_le')\n        max_size = 4000\n        chunks = [encoded_command[i : i + max_size] for i in range(0, len(encoded_command), max_size)]\n        command_unique_file_name = uuid.uuid4().hex\n        command_file = f'\"C:\\\\temp\\\\{command_unique_file_name}.ps1\"'\n\n        # Ensure C:\\temp exists\n        self.__winrm_protocol.run_command(self.__winrm_shell_id, 'if not exist \"C:\\\\temp\" mkdir C:\\\\temp')\n\n        # Write chunks to the file\n        for chunk in chunks:\n            encoded_chunk_base64 = base64.b64encode(chunk).decode('ascii')\n            command_id = self.__winrm_protocol.run_command(\n                self.__winrm_shell_id,\n                f'powershell -Command \"[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(\\'{encoded_chunk_base64}\\')) | Add-Content -Path {command_file} -Encoding Unicode -NoNewline\"',\n            )\n            stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n        # Execute the PowerShell script\n        command_id = self.__winrm_protocol.run_command(self.__winrm_shell_id, f'powershell -File {command_file}')\n        stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n        # Clean up the temporary file\n        self.__winrm_protocol.run_command(self.__winrm_shell_id, f'del /f {command_file}')\n    else:\n        encoded_ps = f'powershell -encodedcommand {base64.b64encode(command.command.encode(\"utf_16_le\")).decode(\"ascii\")}'\n        command_id: str = self.__winrm_protocol.run_command(self.__winrm_shell_id, encoded_ps.split()[0], encoded_ps.split()[1:])\n        stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n    stdout = stdout.decode(\"utf8\")\n    stderr = stderr.decode(\"utf8\")\n    self.__winrm_protocol.cleanup_command(self.__winrm_shell_id, command_id)\n    if command.expected_rc != rc and command.raise_on_error:\n        raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n    self._logger.debug(f'Command rc: [{rc}]')\n    self._logger.debug(f'Command stdout: [{stdout}]')\n    self._logger.debug(f'Command stderr: [{stderr}]')\n    return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/winrm/#ark_sdk_python.common.connections.winrm.ArkWinRMConnection.suspend_connection","title":"<code>suspend_connection()</code>","text":"<p>Suspends execution of winrm commands</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef suspend_connection(self) -&gt; None:\n    \"\"\"\n    Suspends execution of winrm commands\n    \"\"\"\n    self.__is_suspended = True\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/","title":"ark_winrm_connection","text":""},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection","title":"<code>ArkWinRMConnection</code>","text":"<p>               Bases: <code>ArkConnection</code></p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>class ArkWinRMConnection(ArkConnection):\n    def __init__(self):\n        super().__init__()\n        self.__is_connected: bool = False\n        self.__is_suspended: bool = False\n        self.__winrm_protocol: Optional[Any] = None\n        self.__winrm_shell_id: Optional[str] = None\n\n    @overrides\n    def connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n        \"\"\"\n        Performs WinRM connection with given details and certificate\n        Saves the winrm protocol session and shell id to be used for command executions\n\n        Args:\n            connection_details (ArkConnectionDetails): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        import winrm\n\n        if self.__is_connected:\n            return\n        try:\n            target_port = WINRM_HTTPS_PORT\n            user = None\n            password = None\n            cert = 'legacy_requests'\n            if connection_details.port:\n                target_port = connection_details.port\n            if connection_details.credentials:\n                user = connection_details.credentials.user\n                if connection_details.credentials.password:\n                    password = connection_details.credentials.password.get_secret_value()\n            if connection_details.connection_data and connection_details.connection_data.certificate:\n                cert = connection_details.connection_data.certificate\n            self.__winrm_protocol = winrm.Protocol(\n                endpoint=f'https://{connection_details.address}:' f'{target_port}/wsman',\n                transport='ntlm',\n                username=user,\n                password=password,\n                ca_trust_path=cert,\n                server_cert_validation='ignore',\n                read_timeout_sec=10,\n                operation_timeout_sec=5,\n            )\n            self.__winrm_shell_id = self.__winrm_protocol.open_shell()\n            self.__is_connected = True\n            self.__is_suspended = False\n        except Exception as ex:\n            raise ArkException(f'Failed to winrm connect [{str(ex)}]') from ex\n\n    @overrides\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnects the winrm session\n        \"\"\"\n        if not self.__is_connected:\n            return\n        self.__winrm_protocol.close_shell(self.__winrm_shell_id)\n        self.__winrm_shell_id = None\n        self.__winrm_protocol = None\n        self.__is_connected = False\n        self.__is_suspended = False\n\n    @overrides\n    def suspend_connection(self) -&gt; None:\n        \"\"\"\n        Suspends execution of winrm commands\n        \"\"\"\n        self.__is_suspended = True\n\n    @overrides\n    def restore_connection(self) -&gt; None:\n        \"\"\"\n        Restores execution of winrm commands\n        \"\"\"\n        self.__is_suspended = False\n\n    @overrides\n    def is_suspended(self) -&gt; bool:\n        \"\"\"\n        Checks whether winrm commands can be executed or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_suspended\n\n    @overrides\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Checks whether theres a winrm session connected\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__is_connected\n\n    @overrides\n    def run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n        \"\"\"\n        Runs a command over winrm session, returning the result accordingly\n\n        Args:\n            command (ArkConnectionCommand): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkConnectionResult: _description_\n        \"\"\"\n        if not self.__is_connected or self.__is_suspended:\n            raise ArkException('Cannot run command while not being connected')\n        self._logger.debug(f'Running powershell command [{command.command}] of length [{len(command.command)}]')\n        if len(command.command) &gt; 2000 or (command.extra_command_data and command.extra_command_data.get('force_command_split', False)):\n            encoded_command = command.command.encode('utf_16_le')\n            max_size = 4000\n            chunks = [encoded_command[i : i + max_size] for i in range(0, len(encoded_command), max_size)]\n            command_unique_file_name = uuid.uuid4().hex\n            command_file = f'\"C:\\\\temp\\\\{command_unique_file_name}.ps1\"'\n\n            # Ensure C:\\temp exists\n            self.__winrm_protocol.run_command(self.__winrm_shell_id, 'if not exist \"C:\\\\temp\" mkdir C:\\\\temp')\n\n            # Write chunks to the file\n            for chunk in chunks:\n                encoded_chunk_base64 = base64.b64encode(chunk).decode('ascii')\n                command_id = self.__winrm_protocol.run_command(\n                    self.__winrm_shell_id,\n                    f'powershell -Command \"[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(\\'{encoded_chunk_base64}\\')) | Add-Content -Path {command_file} -Encoding Unicode -NoNewline\"',\n                )\n                stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n            # Execute the PowerShell script\n            command_id = self.__winrm_protocol.run_command(self.__winrm_shell_id, f'powershell -File {command_file}')\n            stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n            # Clean up the temporary file\n            self.__winrm_protocol.run_command(self.__winrm_shell_id, f'del /f {command_file}')\n        else:\n            encoded_ps = f'powershell -encodedcommand {base64.b64encode(command.command.encode(\"utf_16_le\")).decode(\"ascii\")}'\n            command_id: str = self.__winrm_protocol.run_command(self.__winrm_shell_id, encoded_ps.split()[0], encoded_ps.split()[1:])\n            stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n        stdout = stdout.decode(\"utf8\")\n        stderr = stderr.decode(\"utf8\")\n        self.__winrm_protocol.cleanup_command(self.__winrm_shell_id, command_id)\n        if command.expected_rc != rc and command.raise_on_error:\n            raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n        self._logger.debug(f'Command rc: [{rc}]')\n        self._logger.debug(f'Command stdout: [{stdout}]')\n        self._logger.debug(f'Command stderr: [{stderr}]')\n        return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection.connect","title":"<code>connect(connection_details)</code>","text":"<p>Performs WinRM connection with given details and certificate Saves the winrm protocol session and shell id to be used for command executions</p> <p>Parameters:</p> Name Type Description Default <code>connection_details</code> <code>ArkConnectionDetails</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef connect(self, connection_details: ArkConnectionDetails) -&gt; None:\n    \"\"\"\n    Performs WinRM connection with given details and certificate\n    Saves the winrm protocol session and shell id to be used for command executions\n\n    Args:\n        connection_details (ArkConnectionDetails): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    import winrm\n\n    if self.__is_connected:\n        return\n    try:\n        target_port = WINRM_HTTPS_PORT\n        user = None\n        password = None\n        cert = 'legacy_requests'\n        if connection_details.port:\n            target_port = connection_details.port\n        if connection_details.credentials:\n            user = connection_details.credentials.user\n            if connection_details.credentials.password:\n                password = connection_details.credentials.password.get_secret_value()\n        if connection_details.connection_data and connection_details.connection_data.certificate:\n            cert = connection_details.connection_data.certificate\n        self.__winrm_protocol = winrm.Protocol(\n            endpoint=f'https://{connection_details.address}:' f'{target_port}/wsman',\n            transport='ntlm',\n            username=user,\n            password=password,\n            ca_trust_path=cert,\n            server_cert_validation='ignore',\n            read_timeout_sec=10,\n            operation_timeout_sec=5,\n        )\n        self.__winrm_shell_id = self.__winrm_protocol.open_shell()\n        self.__is_connected = True\n        self.__is_suspended = False\n    except Exception as ex:\n        raise ArkException(f'Failed to winrm connect [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects the winrm session</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnects the winrm session\n    \"\"\"\n    if not self.__is_connected:\n        return\n    self.__winrm_protocol.close_shell(self.__winrm_shell_id)\n    self.__winrm_shell_id = None\n    self.__winrm_protocol = None\n    self.__is_connected = False\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection.is_connected","title":"<code>is_connected()</code>","text":"<p>Checks whether theres a winrm session connected</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef is_connected(self) -&gt; bool:\n    \"\"\"\n    Checks whether theres a winrm session connected\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_connected\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection.is_suspended","title":"<code>is_suspended()</code>","text":"<p>Checks whether winrm commands can be executed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef is_suspended(self) -&gt; bool:\n    \"\"\"\n    Checks whether winrm commands can be executed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__is_suspended\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection.restore_connection","title":"<code>restore_connection()</code>","text":"<p>Restores execution of winrm commands</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef restore_connection(self) -&gt; None:\n    \"\"\"\n    Restores execution of winrm commands\n    \"\"\"\n    self.__is_suspended = False\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection.run_command","title":"<code>run_command(command)</code>","text":"<p>Runs a command over winrm session, returning the result accordingly</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ArkConnectionCommand</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkConnectionResult</code> <code>ArkConnectionResult</code> <p>description</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef run_command(self, command: ArkConnectionCommand) -&gt; ArkConnectionResult:\n    \"\"\"\n    Runs a command over winrm session, returning the result accordingly\n\n    Args:\n        command (ArkConnectionCommand): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkConnectionResult: _description_\n    \"\"\"\n    if not self.__is_connected or self.__is_suspended:\n        raise ArkException('Cannot run command while not being connected')\n    self._logger.debug(f'Running powershell command [{command.command}] of length [{len(command.command)}]')\n    if len(command.command) &gt; 2000 or (command.extra_command_data and command.extra_command_data.get('force_command_split', False)):\n        encoded_command = command.command.encode('utf_16_le')\n        max_size = 4000\n        chunks = [encoded_command[i : i + max_size] for i in range(0, len(encoded_command), max_size)]\n        command_unique_file_name = uuid.uuid4().hex\n        command_file = f'\"C:\\\\temp\\\\{command_unique_file_name}.ps1\"'\n\n        # Ensure C:\\temp exists\n        self.__winrm_protocol.run_command(self.__winrm_shell_id, 'if not exist \"C:\\\\temp\" mkdir C:\\\\temp')\n\n        # Write chunks to the file\n        for chunk in chunks:\n            encoded_chunk_base64 = base64.b64encode(chunk).decode('ascii')\n            command_id = self.__winrm_protocol.run_command(\n                self.__winrm_shell_id,\n                f'powershell -Command \"[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(\\'{encoded_chunk_base64}\\')) | Add-Content -Path {command_file} -Encoding Unicode -NoNewline\"',\n            )\n            stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n        # Execute the PowerShell script\n        command_id = self.__winrm_protocol.run_command(self.__winrm_shell_id, f'powershell -File {command_file}')\n        stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n\n        # Clean up the temporary file\n        self.__winrm_protocol.run_command(self.__winrm_shell_id, f'del /f {command_file}')\n    else:\n        encoded_ps = f'powershell -encodedcommand {base64.b64encode(command.command.encode(\"utf_16_le\")).decode(\"ascii\")}'\n        command_id: str = self.__winrm_protocol.run_command(self.__winrm_shell_id, encoded_ps.split()[0], encoded_ps.split()[1:])\n        stdout, stderr, rc = self.__winrm_protocol.get_command_output(self.__winrm_shell_id, command_id)\n    stdout = stdout.decode(\"utf8\")\n    stderr = stderr.decode(\"utf8\")\n    self.__winrm_protocol.cleanup_command(self.__winrm_shell_id, command_id)\n    if command.expected_rc != rc and command.raise_on_error:\n        raise ArkException(f'Failed to execute command [{command.command}] - [{rc}] - [{stderr}]')\n    self._logger.debug(f'Command rc: [{rc}]')\n    self._logger.debug(f'Command stdout: [{stdout}]')\n    self._logger.debug(f'Command stderr: [{stderr}]')\n    return ArkConnectionResult(stdout=stdout, stderr=stderr, rc=rc)\n</code></pre>"},{"location":"reference/common/connections/winrm/ark_winrm_connection/#ark_sdk_python.common.connections.winrm.ark_winrm_connection.ArkWinRMConnection.suspend_connection","title":"<code>suspend_connection()</code>","text":"<p>Suspends execution of winrm commands</p> Source code in <code>ark_sdk_python/common/connections/winrm/ark_winrm_connection.py</code> <pre><code>@overrides\ndef suspend_connection(self) -&gt; None:\n    \"\"\"\n    Suspends execution of winrm commands\n    \"\"\"\n    self.__is_suspended = True\n</code></pre>"},{"location":"reference/common/env/","title":"env","text":""},{"location":"reference/common/env/ark_env_mapping/","title":"ark_env_mapping","text":""},{"location":"reference/common/isp/","title":"isp","text":""},{"location":"reference/common/isp/ark_isp_service_client/","title":"ark_isp_service_client","text":""},{"location":"reference/models/","title":"models","text":""},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader","title":"<code>ArkProfileLoader</code>","text":"Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>class ArkProfileLoader:\n    @staticmethod\n    def profiles_folder() -&gt; str:\n        \"\"\"\n        Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n\n    @staticmethod\n    def default_profile_name() -&gt; str:\n        \"\"\"\n        Getter for the default profile name.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return 'ark'\n\n    @staticmethod\n    def deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Deduces the profile name from the env.\n\n        Args:\n            profile_name (Optional[str], optional): Defaults to `None`\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n            return profile_name\n        if 'ARK_PROFILE' in os.environ:\n            return os.environ['ARK_PROFILE']\n        if profile_name:\n            return profile_name\n        return ArkProfileLoader.default_profile_name()\n\n    @staticmethod\n    def load_default_profile() -&gt; ArkProfile:\n        \"\"\"\n        Loads the default profile, either from the OS or creates a new one.\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        profile_name = ArkProfileLoader.deduce_profile_name()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n            return profile\n        return ArkProfile()\n\n    @staticmethod\n    def load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n        \"\"\"\n        Loads the specified profile from the OS.\n        Returns `None` when a profile is not found with the specified name.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            Optional[ArkProfile]: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n            return profile\n        return None\n\n    @staticmethod\n    def save_profile(profile: ArkProfile) -&gt; None:\n        \"\"\"\n        Saves the profile to the profiles folder on the filesystem.\n\n        Args:\n            profile (ArkProfile): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n            f.write(profile.model_dump_json(indent=4, by_alias=False))\n\n    @staticmethod\n    def load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n        \"\"\"\n        Loads all the profiles that exist on the machine.\n\n        Returns:\n            Optional[List[ArkProfile]]: _description_\n        \"\"\"\n        logger = get_logger('load_all_profiles')\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        profiles: List[ArkProfile] = []\n        for profile_name in os.listdir(folder):\n            try:\n                with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                    profiles.append(ArkProfile.model_validate_json(fh.read()))\n            except Exception as ex:\n                logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n                continue\n        return profiles\n\n    @staticmethod\n    def delete_profile(profile_name: str) -&gt; None:\n        \"\"\"\n        Deletes the specified profile.\n\n        Args:\n            profile_name (str): The name of the profile to delete\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        if os.path.exists(os.path.join(folder, profile_name)):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def clear_all_profiles() -&gt; None:\n        \"\"\"\n        Clears all profiles.\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        for profile_name in os.listdir(folder):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def profile_exists(profile_name: str) -&gt; bool:\n        \"\"\"\n        Checks if the specified profile exists.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return False\n        return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.clear_all_profiles","title":"<code>clear_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Clears all profiles.</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef clear_all_profiles() -&gt; None:\n    \"\"\"\n    Clears all profiles.\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    for profile_name in os.listdir(folder):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.deduce_profile_name","title":"<code>deduce_profile_name(profile_name=None)</code>  <code>staticmethod</code>","text":"<p>Deduces the profile name from the env.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>Optional[str]</code> <p>Defaults to <code>None</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Deduces the profile name from the env.\n\n    Args:\n        profile_name (Optional[str], optional): Defaults to `None`\n\n    Returns:\n        str: _description_\n    \"\"\"\n    if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n        return profile_name\n    if 'ARK_PROFILE' in os.environ:\n        return os.environ['ARK_PROFILE']\n    if profile_name:\n        return profile_name\n    return ArkProfileLoader.default_profile_name()\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.default_profile_name","title":"<code>default_profile_name()</code>  <code>staticmethod</code>","text":"<p>Getter for the default profile name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef default_profile_name() -&gt; str:\n    \"\"\"\n    Getter for the default profile name.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return 'ark'\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.delete_profile","title":"<code>delete_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>The name of the profile to delete</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef delete_profile(profile_name: str) -&gt; None:\n    \"\"\"\n    Deletes the specified profile.\n\n    Args:\n        profile_name (str): The name of the profile to delete\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    if os.path.exists(os.path.join(folder, profile_name)):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_all_profiles","title":"<code>load_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Loads all the profiles that exist on the machine.</p> <p>Returns:</p> Type Description <code>Optional[List[ArkProfile]]</code> <p>Optional[List[ArkProfile]]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n    \"\"\"\n    Loads all the profiles that exist on the machine.\n\n    Returns:\n        Optional[List[ArkProfile]]: _description_\n    \"\"\"\n    logger = get_logger('load_all_profiles')\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    profiles: List[ArkProfile] = []\n    for profile_name in os.listdir(folder):\n        try:\n            with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                profiles.append(ArkProfile.model_validate_json(fh.read()))\n        except Exception as ex:\n            logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n            continue\n    return profiles\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_default_profile","title":"<code>load_default_profile()</code>  <code>staticmethod</code>","text":"<p>Loads the default profile, either from the OS or creates a new one.</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_default_profile() -&gt; ArkProfile:\n    \"\"\"\n    Loads the default profile, either from the OS or creates a new one.\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    profile_name = ArkProfileLoader.deduce_profile_name()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n            profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n        return profile\n    return ArkProfile()\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_profile","title":"<code>load_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Loads the specified profile from the OS. Returns <code>None</code> when a profile is not found with the specified name.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkProfile]</code> <p>Optional[ArkProfile]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n    \"\"\"\n    Loads the specified profile from the OS.\n    Returns `None` when a profile is not found with the specified name.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        Optional[ArkProfile]: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n            profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n        return profile\n    return None\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.profile_exists","title":"<code>profile_exists(profile_name)</code>  <code>staticmethod</code>","text":"<p>Checks if the specified profile exists.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profile_exists(profile_name: str) -&gt; bool:\n    \"\"\"\n    Checks if the specified profile exists.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return False\n    return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.profiles_folder","title":"<code>profiles_folder()</code>  <code>staticmethod</code>","text":"<p>Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profiles_folder() -&gt; str:\n    \"\"\"\n    Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.save_profile","title":"<code>save_profile(profile)</code>  <code>staticmethod</code>","text":"<p>Saves the profile to the profiles folder on the filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef save_profile(profile: ArkProfile) -&gt; None:\n    \"\"\"\n    Saves the profile to the profiles folder on the filesystem.\n\n    Args:\n        profile (ArkProfile): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n        f.write(profile.model_dump_json(indent=4, by_alias=False))\n</code></pre>"},{"location":"reference/models/ark_exceptions/","title":"ark_exceptions","text":""},{"location":"reference/models/ark_model/","title":"ark_model","text":""},{"location":"reference/models/ark_model/#ark_sdk_python.models.ark_model.base64_serializer","title":"<code>base64_serializer(data)</code>","text":"<p>Serializes a dictionary to a base64-encoded JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The dictionary to serialize.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The base64-encoded JSON string.</p> <p>Raises:</p> Type Description <code>ArkException</code> <p>If there is an error during serialization.</p> Source code in <code>ark_sdk_python/models/ark_model.py</code> <pre><code>def base64_serializer(data: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Serializes a dictionary to a base64-encoded JSON string.\n\n    Args:\n        data (Dict[str, Any]): The dictionary to serialize.\n\n    Returns:\n        str: The base64-encoded JSON string.\n\n    Raises:\n        ArkException: If there is an error during serialization.\n    \"\"\"\n    try:\n        json_bytes = json.dumps(data).encode('utf-8')\n        base64_bytes = base64.b64encode(json_bytes)\n        return base64_bytes.decode('utf-8')\n    except (TypeError, ValueError) as e:\n        raise ArkException(f'Error encoding data to base64: {e}') from e\n</code></pre>"},{"location":"reference/models/ark_profile/","title":"ark_profile","text":""},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader","title":"<code>ArkProfileLoader</code>","text":"Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>class ArkProfileLoader:\n    @staticmethod\n    def profiles_folder() -&gt; str:\n        \"\"\"\n        Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n\n    @staticmethod\n    def default_profile_name() -&gt; str:\n        \"\"\"\n        Getter for the default profile name.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return 'ark'\n\n    @staticmethod\n    def deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Deduces the profile name from the env.\n\n        Args:\n            profile_name (Optional[str], optional): Defaults to `None`\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n            return profile_name\n        if 'ARK_PROFILE' in os.environ:\n            return os.environ['ARK_PROFILE']\n        if profile_name:\n            return profile_name\n        return ArkProfileLoader.default_profile_name()\n\n    @staticmethod\n    def load_default_profile() -&gt; ArkProfile:\n        \"\"\"\n        Loads the default profile, either from the OS or creates a new one.\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        profile_name = ArkProfileLoader.deduce_profile_name()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n            return profile\n        return ArkProfile()\n\n    @staticmethod\n    def load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n        \"\"\"\n        Loads the specified profile from the OS.\n        Returns `None` when a profile is not found with the specified name.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            Optional[ArkProfile]: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n            return profile\n        return None\n\n    @staticmethod\n    def save_profile(profile: ArkProfile) -&gt; None:\n        \"\"\"\n        Saves the profile to the profiles folder on the filesystem.\n\n        Args:\n            profile (ArkProfile): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n            f.write(profile.model_dump_json(indent=4, by_alias=False))\n\n    @staticmethod\n    def load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n        \"\"\"\n        Loads all the profiles that exist on the machine.\n\n        Returns:\n            Optional[List[ArkProfile]]: _description_\n        \"\"\"\n        logger = get_logger('load_all_profiles')\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        profiles: List[ArkProfile] = []\n        for profile_name in os.listdir(folder):\n            try:\n                with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                    profiles.append(ArkProfile.model_validate_json(fh.read()))\n            except Exception as ex:\n                logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n                continue\n        return profiles\n\n    @staticmethod\n    def delete_profile(profile_name: str) -&gt; None:\n        \"\"\"\n        Deletes the specified profile.\n\n        Args:\n            profile_name (str): The name of the profile to delete\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        if os.path.exists(os.path.join(folder, profile_name)):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def clear_all_profiles() -&gt; None:\n        \"\"\"\n        Clears all profiles.\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        for profile_name in os.listdir(folder):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def profile_exists(profile_name: str) -&gt; bool:\n        \"\"\"\n        Checks if the specified profile exists.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return False\n        return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.clear_all_profiles","title":"<code>clear_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Clears all profiles.</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef clear_all_profiles() -&gt; None:\n    \"\"\"\n    Clears all profiles.\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    for profile_name in os.listdir(folder):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.deduce_profile_name","title":"<code>deduce_profile_name(profile_name=None)</code>  <code>staticmethod</code>","text":"<p>Deduces the profile name from the env.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>Optional[str]</code> <p>Defaults to <code>None</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Deduces the profile name from the env.\n\n    Args:\n        profile_name (Optional[str], optional): Defaults to `None`\n\n    Returns:\n        str: _description_\n    \"\"\"\n    if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n        return profile_name\n    if 'ARK_PROFILE' in os.environ:\n        return os.environ['ARK_PROFILE']\n    if profile_name:\n        return profile_name\n    return ArkProfileLoader.default_profile_name()\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.default_profile_name","title":"<code>default_profile_name()</code>  <code>staticmethod</code>","text":"<p>Getter for the default profile name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef default_profile_name() -&gt; str:\n    \"\"\"\n    Getter for the default profile name.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return 'ark'\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.delete_profile","title":"<code>delete_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>The name of the profile to delete</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef delete_profile(profile_name: str) -&gt; None:\n    \"\"\"\n    Deletes the specified profile.\n\n    Args:\n        profile_name (str): The name of the profile to delete\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    if os.path.exists(os.path.join(folder, profile_name)):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_all_profiles","title":"<code>load_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Loads all the profiles that exist on the machine.</p> <p>Returns:</p> Type Description <code>Optional[List[ArkProfile]]</code> <p>Optional[List[ArkProfile]]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n    \"\"\"\n    Loads all the profiles that exist on the machine.\n\n    Returns:\n        Optional[List[ArkProfile]]: _description_\n    \"\"\"\n    logger = get_logger('load_all_profiles')\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    profiles: List[ArkProfile] = []\n    for profile_name in os.listdir(folder):\n        try:\n            with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n                profiles.append(ArkProfile.model_validate_json(fh.read()))\n        except Exception as ex:\n            logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n            continue\n    return profiles\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_default_profile","title":"<code>load_default_profile()</code>  <code>staticmethod</code>","text":"<p>Loads the default profile, either from the OS or creates a new one.</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_default_profile() -&gt; ArkProfile:\n    \"\"\"\n    Loads the default profile, either from the OS or creates a new one.\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    profile_name = ArkProfileLoader.deduce_profile_name()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n            profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n        return profile\n    return ArkProfile()\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_profile","title":"<code>load_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Loads the specified profile from the OS. Returns <code>None</code> when a profile is not found with the specified name.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkProfile]</code> <p>Optional[ArkProfile]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n    \"\"\"\n    Loads the specified profile from the OS.\n    Returns `None` when a profile is not found with the specified name.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        Optional[ArkProfile]: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        with open(os.path.join(folder, profile_name), 'r', encoding='utf-8') as fh:\n            profile: ArkProfile = ArkProfile.model_validate_json(fh.read())\n        return profile\n    return None\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.profile_exists","title":"<code>profile_exists(profile_name)</code>  <code>staticmethod</code>","text":"<p>Checks if the specified profile exists.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profile_exists(profile_name: str) -&gt; bool:\n    \"\"\"\n    Checks if the specified profile exists.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return False\n    return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.profiles_folder","title":"<code>profiles_folder()</code>  <code>staticmethod</code>","text":"<p>Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profiles_folder() -&gt; str:\n    \"\"\"\n    Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.save_profile","title":"<code>save_profile(profile)</code>  <code>staticmethod</code>","text":"<p>Saves the profile to the profiles folder on the filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef save_profile(profile: ArkProfile) -&gt; None:\n    \"\"\"\n    Saves the profile to the profiles folder on the filesystem.\n\n    Args:\n        profile (ArkProfile): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n        f.write(profile.model_dump_json(indent=4, by_alias=False))\n</code></pre>"},{"location":"reference/models/actions/","title":"actions","text":""},{"location":"reference/models/actions/ark_configure_action_consts/","title":"ark_configure_action_consts","text":""},{"location":"reference/models/actions/ark_service_action_definition/","title":"ark_service_action_definition","text":""},{"location":"reference/models/actions/services/","title":"services","text":""},{"location":"reference/models/actions/services/ark_cmgr_exec_action_consts/","title":"ark_cmgr_exec_action_consts","text":""},{"location":"reference/models/actions/services/ark_identity_exec_action_consts/","title":"ark_identity_exec_action_consts","text":""},{"location":"reference/models/actions/services/ark_pcloud_exec_action_consts/","title":"ark_pcloud_exec_action_consts","text":""},{"location":"reference/models/actions/services/ark_sia_exec_action_consts/","title":"ark_sia_exec_action_consts","text":""},{"location":"reference/models/actions/services/ark_sm_exec_action_consts/","title":"ark_sm_exec_action_consts","text":""},{"location":"reference/models/auth/","title":"auth","text":""},{"location":"reference/models/auth/ark_auth_method/","title":"ark_auth_method","text":""},{"location":"reference/models/auth/ark_auth_profile/","title":"ark_auth_profile","text":""},{"location":"reference/models/auth/ark_secret/","title":"ark_secret","text":""},{"location":"reference/models/auth/ark_token/","title":"ark_token","text":""},{"location":"reference/models/cli_services/","title":"cli_services","text":""},{"location":"reference/models/cli_services/sia/","title":"sia","text":""},{"location":"reference/models/cli_services/sia/policies_editor/","title":"policies_editor","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/","title":"common","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_base_generate_policy/","title":"ark_sia_base_generate_policy","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_commit_policies/","title":"ark_sia_commit_policies","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_edit_policies/","title":"ark_sia_edit_policies","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_get_policies_status/","title":"ark_sia_get_policies_status","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_load_policies/","title":"ark_sia_load_policies","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_loaded_policies/","title":"ark_sia_loaded_policies","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_policies_diff/","title":"ark_sia_policies_diff","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_policies_status/","title":"ark_sia_policies_status","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_remove_policies/","title":"ark_sia_remove_policies","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_reset_policies/","title":"ark_sia_reset_policies","text":""},{"location":"reference/models/cli_services/sia/policies_editor/common/ark_sia_view_policies/","title":"ark_sia_view_policies","text":""},{"location":"reference/models/cli_services/sia/policies_editor/db/","title":"db","text":""},{"location":"reference/models/cli_services/sia/policies_editor/db/ark_sia_db_generate_policy/","title":"ark_sia_db_generate_policy","text":""},{"location":"reference/models/cli_services/sia/policies_editor/vm/","title":"vm","text":""},{"location":"reference/models/cli_services/sia/policies_editor/vm/ark_sia_vm_generate_policy/","title":"ark_sia_vm_generate_policy","text":""},{"location":"reference/models/common/","title":"common","text":""},{"location":"reference/models/common/ark_access_method/","title":"ark_access_method","text":""},{"location":"reference/models/common/ark_application_code/","title":"ark_application_code","text":""},{"location":"reference/models/common/ark_async_request_settings/","title":"ark_async_request_settings","text":""},{"location":"reference/models/common/ark_async_status/","title":"ark_async_status","text":""},{"location":"reference/models/common/ark_async_task/","title":"ark_async_task","text":""},{"location":"reference/models/common/ark_connection_method/","title":"ark_connection_method","text":""},{"location":"reference/models/common/ark_connector_type/","title":"ark_connector_type","text":""},{"location":"reference/models/common/ark_counted_values/","title":"ark_counted_values","text":""},{"location":"reference/models/common/ark_network_entity_type/","title":"ark_network_entity_type","text":""},{"location":"reference/models/common/ark_os_type/","title":"ark_os_type","text":""},{"location":"reference/models/common/ark_protocol_type/","title":"ark_protocol_type","text":""},{"location":"reference/models/common/ark_region/","title":"ark_region","text":""},{"location":"reference/models/common/ark_status/","title":"ark_status","text":""},{"location":"reference/models/common/ark_status_stats/","title":"ark_status_stats","text":""},{"location":"reference/models/common/ark_validations/","title":"ark_validations","text":""},{"location":"reference/models/common/ark_workspace_type/","title":"ark_workspace_type","text":""},{"location":"reference/models/common/aws/","title":"aws","text":""},{"location":"reference/models/common/aws/ark_cfn_async_task/","title":"ark_cfn_async_task","text":""},{"location":"reference/models/common/connections/","title":"connections","text":""},{"location":"reference/models/common/connections/ark_connection_command/","title":"ark_connection_command","text":""},{"location":"reference/models/common/connections/ark_connection_credentials/","title":"ark_connection_credentials","text":""},{"location":"reference/models/common/connections/ark_connection_details/","title":"ark_connection_details","text":""},{"location":"reference/models/common/connections/ark_connection_result/","title":"ark_connection_result","text":""},{"location":"reference/models/common/connections/connection_data/","title":"connection_data","text":""},{"location":"reference/models/common/connections/connection_data/ark_ssh_connection_data/","title":"ark_ssh_connection_data","text":""},{"location":"reference/models/common/connections/connection_data/ark_winrm_connection_data/","title":"ark_winrm_connection_data","text":""},{"location":"reference/models/common/identity/","title":"identity","text":""},{"location":"reference/models/common/identity/ark_identity_auth_schemas/","title":"ark_identity_auth_schemas","text":""},{"location":"reference/models/common/identity/ark_identity_common_schemas/","title":"ark_identity_common_schemas","text":""},{"location":"reference/models/common/identity/ark_identity_directory_schemas/","title":"ark_identity_directory_schemas","text":""},{"location":"reference/models/common/isp/","title":"isp","text":""},{"location":"reference/models/common/isp/ark_platform_discovery_schemas/","title":"ark_platform_discovery_schemas","text":""},{"location":"reference/models/services/","title":"services","text":""},{"location":"reference/models/services/ark_service_config/","title":"ark_service_config","text":""},{"location":"reference/models/services/cmgr/","title":"cmgr","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_add_network/","title":"ark_cmgr_add_network","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_add_pool/","title":"ark_cmgr_add_pool","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_add_pool_identifiers/","title":"ark_cmgr_add_pool_identifiers","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_bulk_response/","title":"ark_cmgr_bulk_response","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_delete_network/","title":"ark_cmgr_delete_network","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_delete_pool/","title":"ark_cmgr_delete_pool","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_delete_pool_identifiers/","title":"ark_cmgr_delete_pool_identifiers","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_get_network/","title":"ark_cmgr_get_network","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_get_pool/","title":"ark_cmgr_get_pool","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_get_pool_component/","title":"ark_cmgr_get_pool_component","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_list_pool_identifiers/","title":"ark_cmgr_list_pool_identifiers","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_network/","title":"ark_cmgr_network","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_networks_filter/","title":"ark_cmgr_networks_filter","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_networks_stats/","title":"ark_cmgr_networks_stats","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pool/","title":"ark_cmgr_pool","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pool_component/","title":"ark_cmgr_pool_component","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pool_components_filter/","title":"ark_cmgr_pool_components_filter","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pool_identifiers/","title":"ark_cmgr_pool_identifiers","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pool_identifiers_filter/","title":"ark_cmgr_pool_identifiers_filter","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pools_common_filter/","title":"ark_cmgr_pools_common_filter","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pools_filter/","title":"ark_cmgr_pools_filter","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_pools_stats/","title":"ark_cmgr_pools_stats","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_update_network/","title":"ark_cmgr_update_network","text":""},{"location":"reference/models/services/cmgr/ark_cmgr_update_pool/","title":"ark_cmgr_update_pool","text":""},{"location":"reference/models/services/identity/","title":"identity","text":""},{"location":"reference/models/services/identity/connectors/","title":"connectors","text":""},{"location":"reference/models/services/identity/connectors/ark_identity_connector_info/","title":"ark_identity_connector_info","text":""},{"location":"reference/models/services/identity/connectors/ark_identity_connectors_filter/","title":"ark_identity_connectors_filter","text":""},{"location":"reference/models/services/identity/connectors/ark_identity_get_connector/","title":"ark_identity_get_connector","text":""},{"location":"reference/models/services/identity/directories/","title":"directories","text":""},{"location":"reference/models/services/identity/directories/ark_identity_directory/","title":"ark_identity_directory","text":""},{"location":"reference/models/services/identity/directories/ark_identity_entity/","title":"ark_identity_entity","text":""},{"location":"reference/models/services/identity/directories/ark_identity_list_directories/","title":"ark_identity_list_directories","text":""},{"location":"reference/models/services/identity/directories/ark_identity_list_directories_entities/","title":"ark_identity_list_directories_entities","text":""},{"location":"reference/models/services/identity/policies/","title":"policies","text":""},{"location":"reference/models/services/identity/policies/ark_identity_add_authentication_profile/","title":"ark_identity_add_authentication_profile","text":""},{"location":"reference/models/services/identity/policies/ark_identity_add_policy/","title":"ark_identity_add_policy","text":""},{"location":"reference/models/services/identity/policies/ark_identity_authentication_profile/","title":"ark_identity_authentication_profile","text":""},{"location":"reference/models/services/identity/policies/ark_identity_disable_policy/","title":"ark_identity_disable_policy","text":""},{"location":"reference/models/services/identity/policies/ark_identity_enable_policy/","title":"ark_identity_enable_policy","text":""},{"location":"reference/models/services/identity/policies/ark_identity_get_authentication_profile/","title":"ark_identity_get_authentication_profile","text":""},{"location":"reference/models/services/identity/policies/ark_identity_get_policy/","title":"ark_identity_get_policy","text":""},{"location":"reference/models/services/identity/policies/ark_identity_policy/","title":"ark_identity_policy","text":""},{"location":"reference/models/services/identity/policies/ark_identity_policy_info/","title":"ark_identity_policy_info","text":""},{"location":"reference/models/services/identity/policies/ark_identity_policy_operation/","title":"ark_identity_policy_operation","text":""},{"location":"reference/models/services/identity/policies/ark_identity_policy_operation_type/","title":"ark_identity_policy_operation_type","text":""},{"location":"reference/models/services/identity/policies/ark_identity_remove_authentication_profile/","title":"ark_identity_remove_authentication_profile","text":""},{"location":"reference/models/services/identity/policies/ark_identity_remove_policy/","title":"ark_identity_remove_policy","text":""},{"location":"reference/models/services/identity/roles/","title":"roles","text":""},{"location":"reference/models/services/identity/roles/ark_identity_add_admin_right_to_role/","title":"ark_identity_add_admin_right_to_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_add_group_to_role/","title":"ark_identity_add_group_to_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_add_role_to_role/","title":"ark_identity_add_role_to_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_add_user_to_role/","title":"ark_identity_add_user_to_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_admin_right/","title":"ark_identity_admin_right","text":""},{"location":"reference/models/services/identity/roles/ark_identity_create_role/","title":"ark_identity_create_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_delete_role/","title":"ark_identity_delete_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_list_role_members/","title":"ark_identity_list_role_members","text":""},{"location":"reference/models/services/identity/roles/ark_identity_remove_group_from_role/","title":"ark_identity_remove_group_from_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_remove_role_from_role/","title":"ark_identity_remove_role_from_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_remove_user_from_role/","title":"ark_identity_remove_user_from_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_role/","title":"ark_identity_role","text":""},{"location":"reference/models/services/identity/roles/ark_identity_role_id_by_name/","title":"ark_identity_role_id_by_name","text":""},{"location":"reference/models/services/identity/roles/ark_identity_role_member/","title":"ark_identity_role_member","text":""},{"location":"reference/models/services/identity/roles/ark_identity_update_role/","title":"ark_identity_update_role","text":""},{"location":"reference/models/services/identity/users/","title":"users","text":""},{"location":"reference/models/services/identity/users/ark_identity_create_user/","title":"ark_identity_create_user","text":""},{"location":"reference/models/services/identity/users/ark_identity_delete_user/","title":"ark_identity_delete_user","text":""},{"location":"reference/models/services/identity/users/ark_identity_delete_users/","title":"ark_identity_delete_users","text":""},{"location":"reference/models/services/identity/users/ark_identity_reset_user_password/","title":"ark_identity_reset_user_password","text":""},{"location":"reference/models/services/identity/users/ark_identity_update_user/","title":"ark_identity_update_user","text":""},{"location":"reference/models/services/identity/users/ark_identity_user/","title":"ark_identity_user","text":""},{"location":"reference/models/services/identity/users/ark_identity_user_by_id/","title":"ark_identity_user_by_id","text":""},{"location":"reference/models/services/identity/users/ark_identity_user_by_name/","title":"ark_identity_user_by_name","text":""},{"location":"reference/models/services/identity/users/ark_identity_user_id_by_name/","title":"ark_identity_user_id_by_name","text":""},{"location":"reference/models/services/identity/users/ark_identity_user_info/","title":"ark_identity_user_info","text":""},{"location":"reference/models/services/pcloud/","title":"pcloud","text":""},{"location":"reference/models/services/pcloud/accounts/","title":"accounts","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_account/","title":"ark_pcloud_account","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_account_credentials/","title":"ark_pcloud_account_credentials","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_account_secret_version/","title":"ark_pcloud_account_secret_version","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_accounts_filter/","title":"ark_pcloud_accounts_filter","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_accounts_stats/","title":"ark_pcloud_accounts_stats","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_add_account/","title":"ark_pcloud_add_account","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_change_account_credentials/","title":"ark_pcloud_change_account_credentials","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_delete_account/","title":"ark_pcloud_delete_account","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_generate_account_credentials/","title":"ark_pcloud_generate_account_credentials","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_get_account/","title":"ark_pcloud_get_account","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_get_account_credentials/","title":"ark_pcloud_get_account_credentials","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_link_account/","title":"ark_pcloud_link_account","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_list_account_secret_versions/","title":"ark_pcloud_list_account_secret_versions","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_reconcile_account_credentials/","title":"ark_pcloud_reconcile_account_credentials","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_set_account_next_credentials/","title":"ark_pcloud_set_account_next_credentials","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_unlink_account/","title":"ark_pcloud_unlink_account","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_update_account/","title":"ark_pcloud_update_account","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_update_account_credentials_in_vault/","title":"ark_pcloud_update_account_credentials_in_vault","text":""},{"location":"reference/models/services/pcloud/accounts/ark_pcloud_verify_account_credentias/","title":"ark_pcloud_verify_account_credentias","text":""},{"location":"reference/models/services/pcloud/applications/","title":"applications","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_add_application/","title":"ark_pcloud_add_application","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_add_application_auth_method/","title":"ark_pcloud_add_application_auth_method","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_application/","title":"ark_pcloud_application","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_application_auth_method/","title":"ark_pcloud_application_auth_method","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_application_auth_methods_filter/","title":"ark_pcloud_application_auth_methods_filter","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_applications_filter/","title":"ark_pcloud_applications_filter","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_applications_stats/","title":"ark_pcloud_applications_stats","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_delete_application/","title":"ark_pcloud_delete_application","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_delete_application_auth_method/","title":"ark_pcloud_delete_application_auth_method","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_get_application/","title":"ark_pcloud_get_application","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_get_application_auth_method/","title":"ark_pcloud_get_application_auth_method","text":""},{"location":"reference/models/services/pcloud/applications/ark_pcloud_list_application_auth_methods/","title":"ark_pcloud_list_application_auth_methods","text":""},{"location":"reference/models/services/pcloud/platforms/","title":"platforms","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_activate_target_platform/","title":"ark_pcloud_activate_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_deactivate_target_platform/","title":"ark_pcloud_deactivate_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_delete_target_platform/","title":"ark_pcloud_delete_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_duplicate_target_platform/","title":"ark_pcloud_duplicate_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_duplicated_target_platform_info/","title":"ark_pcloud_duplicated_target_platform_info","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_export_platform/","title":"ark_pcloud_export_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_export_target_platform/","title":"ark_pcloud_export_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_get_platform/","title":"ark_pcloud_get_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_get_target_platform/","title":"ark_pcloud_get_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_import_platform/","title":"ark_pcloud_import_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_import_target_platform/","title":"ark_pcloud_import_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_platform/","title":"ark_pcloud_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_platforms_filter/","title":"ark_pcloud_platforms_filter","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_platforms_stats/","title":"ark_pcloud_platforms_stats","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_target_platform/","title":"ark_pcloud_target_platform","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_target_platforms_filter/","title":"ark_pcloud_target_platforms_filter","text":""},{"location":"reference/models/services/pcloud/platforms/ark_pcloud_target_platforms_stats/","title":"ark_pcloud_target_platforms_stats","text":""},{"location":"reference/models/services/pcloud/safes/","title":"safes","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_add_safe/","title":"ark_pcloud_add_safe","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_add_safe_member/","title":"ark_pcloud_add_safe_member","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_delete_safe/","title":"ark_pcloud_delete_safe","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_delete_safe_member/","title":"ark_pcloud_delete_safe_member","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_get_safe/","title":"ark_pcloud_get_safe","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_get_safe_member/","title":"ark_pcloud_get_safe_member","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_get_safe_members_stats/","title":"ark_pcloud_get_safe_members_stats","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_list_safe_members/","title":"ark_pcloud_list_safe_members","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_safe/","title":"ark_pcloud_safe","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_safe_member/","title":"ark_pcloud_safe_member","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_safe_members_filter/","title":"ark_pcloud_safe_members_filter","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_safes_filters/","title":"ark_pcloud_safes_filters","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_safes_members_stats/","title":"ark_pcloud_safes_members_stats","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_safes_stats/","title":"ark_pcloud_safes_stats","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_update_safe/","title":"ark_pcloud_update_safe","text":""},{"location":"reference/models/services/pcloud/safes/ark_pcloud_update_safe_member/","title":"ark_pcloud_update_safe_member","text":""},{"location":"reference/models/services/sia/","title":"sia","text":""},{"location":"reference/models/services/sia/access/","title":"access","text":""},{"location":"reference/models/services/sia/access/ark_sia_access_workspace_type_serializer/","title":"ark_sia_access_workspace_type_serializer","text":""},{"location":"reference/models/services/sia/access/ark_sia_connector_setup_script/","title":"ark_sia_connector_setup_script","text":""},{"location":"reference/models/services/sia/access/ark_sia_get_connector_setup_script/","title":"ark_sia_get_connector_setup_script","text":""},{"location":"reference/models/services/sia/access/ark_sia_install_connector/","title":"ark_sia_install_connector","text":""},{"location":"reference/models/services/sia/access/ark_sia_uninstall_connector/","title":"ark_sia_uninstall_connector","text":""},{"location":"reference/models/services/sia/certificates/","title":"certificates","text":""},{"location":"reference/models/services/sia/certificates/ark_sia_certificates_certificate/","title":"ark_sia_certificates_certificate","text":""},{"location":"reference/models/services/sia/certificates/ark_sia_certificates_delete_certificate/","title":"ark_sia_certificates_delete_certificate","text":""},{"location":"reference/models/services/sia/certificates/ark_sia_certificates_filter/","title":"ark_sia_certificates_filter","text":""},{"location":"reference/models/services/sia/certificates/ark_sia_certificates_get_certificate/","title":"ark_sia_certificates_get_certificate","text":""},{"location":"reference/models/services/sia/certificates/ark_sia_certificates_update_certificate/","title":"ark_sia_certificates_update_certificate","text":""},{"location":"reference/models/services/sia/db/","title":"db","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_assets_type/","title":"ark_sia_db_assets_type","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_base_execution/","title":"ark_sia_db_base_execution","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_base_generate_assets/","title":"ark_sia_db_base_generate_assets","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_generated_assets/","title":"ark_sia_db_generated_assets","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_mysql_execution/","title":"ark_sia_db_mysql_execution","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_oracle_generate_assets/","title":"ark_sia_db_oracle_generate_assets","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_proxy_fullchain_generate_assets/","title":"ark_sia_db_proxy_fullchain_generate_assets","text":""},{"location":"reference/models/services/sia/db/ark_sia_db_psql_execution/","title":"ark_sia_db_psql_execution","text":""},{"location":"reference/models/services/sia/k8s/","title":"k8s","text":""},{"location":"reference/models/services/sia/k8s/ark_sia_k8s_generate_kubeconfig/","title":"ark_sia_k8s_generate_kubeconfig","text":""},{"location":"reference/models/services/sia/policies/","title":"policies","text":""},{"location":"reference/models/services/sia/policies/common/","title":"common","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_add_policy/","title":"ark_sia_base_add_policy","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_authorization_rule/","title":"ark_sia_base_authorization_rule","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_authorization_rule_extended/","title":"ark_sia_base_authorization_rule_extended","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_connection_information/","title":"ark_sia_base_connection_information","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_policies_filter/","title":"ark_sia_base_policies_filter","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_policies_stats/","title":"ark_sia_base_policies_stats","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_policy/","title":"ark_sia_base_policy","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_policy_list_item/","title":"ark_sia_base_policy_list_item","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_policy_list_item_extanded/","title":"ark_sia_base_policy_list_item_extanded","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_base_update_policy/","title":"ark_sia_base_update_policy","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_delete_policy/","title":"ark_sia_delete_policy","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_get_policy/","title":"ark_sia_get_policy","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_rule_status/","title":"ark_sia_rule_status","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_update_policy_status/","title":"ark_sia_update_policy_status","text":""},{"location":"reference/models/services/sia/policies/common/ark_sia_user_data/","title":"ark_sia_user_data","text":""},{"location":"reference/models/services/sia/policies/db/","title":"db","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_add_policy/","title":"ark_sia_db_add_policy","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_authorization_rule/","title":"ark_sia_db_authorization_rule","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_connection_data/","title":"ark_sia_db_connection_data","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_enums/","title":"ark_sia_db_enums","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_policies_filter/","title":"ark_sia_db_policies_filter","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_policies_stats/","title":"ark_sia_db_policies_stats","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_policies_workspace_type_serializer/","title":"ark_sia_db_policies_workspace_type_serializer","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_policy/","title":"ark_sia_db_policy","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_policy_list_item/","title":"ark_sia_db_policy_list_item","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_providers/","title":"ark_sia_db_providers","text":""},{"location":"reference/models/services/sia/policies/db/ark_sia_db_update_policy/","title":"ark_sia_db_update_policy","text":""},{"location":"reference/models/services/sia/policies/vm/","title":"vm","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_add_policy/","title":"ark_sia_vm_add_policy","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_authorization_rule/","title":"ark_sia_vm_authorization_rule","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_connection_data/","title":"ark_sia_vm_connection_data","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_policies_filter/","title":"ark_sia_vm_policies_filter","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_policies_filter_by_query/","title":"ark_sia_vm_policies_filter_by_query","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_policies_protocol_type_serializer/","title":"ark_sia_vm_policies_protocol_type_serializer","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_policies_stats/","title":"ark_sia_vm_policies_stats","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_policies_workspace_type_serializer/","title":"ark_sia_vm_policies_workspace_type_serializer","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_policy/","title":"ark_sia_vm_policy","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_policy_list_item/","title":"ark_sia_vm_policy_list_item","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_providers/","title":"ark_sia_vm_providers","text":""},{"location":"reference/models/services/sia/policies/vm/ark_sia_vm_update_policy/","title":"ark_sia_vm_update_policy","text":""},{"location":"reference/models/services/sia/secrets/","title":"secrets","text":""},{"location":"reference/models/services/sia/secrets/db/","title":"db","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_add_secret/","title":"ark_sia_db_add_secret","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_delete_secret/","title":"ark_sia_db_delete_secret","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_disable_secret/","title":"ark_sia_db_disable_secret","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_enable_secret/","title":"ark_sia_db_enable_secret","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_get_secret/","title":"ark_sia_db_get_secret","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_secret_metadata/","title":"ark_sia_db_secret_metadata","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_secret_type/","title":"ark_sia_db_secret_type","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_secrets_filter/","title":"ark_sia_db_secrets_filter","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_secrets_stats/","title":"ark_sia_db_secrets_stats","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_store_descriptor/","title":"ark_sia_db_store_descriptor","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_store_type/","title":"ark_sia_db_store_type","text":""},{"location":"reference/models/services/sia/secrets/db/ark_sia_db_update_secret/","title":"ark_sia_db_update_secret","text":""},{"location":"reference/models/services/sia/secrets/db/secret_links/","title":"secret_links","text":""},{"location":"reference/models/services/sia/secrets/db/secret_links/ark_sia_db_pam_account_secret_link/","title":"ark_sia_db_pam_account_secret_link","text":""},{"location":"reference/models/services/sia/secrets/db/secrets_data/","title":"secrets_data","text":""},{"location":"reference/models/services/sia/secrets/db/secrets_data/ark_sia_db_atlas_access_keys_secret_data/","title":"ark_sia_db_atlas_access_keys_secret_data","text":""},{"location":"reference/models/services/sia/secrets/db/secrets_data/ark_sia_db_iam_user_secret_data/","title":"ark_sia_db_iam_user_secret_data","text":""},{"location":"reference/models/services/sia/secrets/db/secrets_data/ark_sia_db_user_password_secret_data/","title":"ark_sia_db_user_password_secret_data","text":""},{"location":"reference/models/services/sia/secrets/vm/","title":"vm","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_add_secret/","title":"ark_sia_vm_add_secret","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_change_secret/","title":"ark_sia_vm_change_secret","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_delete_secret/","title":"ark_sia_vm_delete_secret","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_get_secret/","title":"ark_sia_vm_get_secret","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_secret/","title":"ark_sia_vm_secret","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_secret_error/","title":"ark_sia_vm_secret_error","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_secret_info/","title":"ark_sia_vm_secret_info","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_secret_type/","title":"ark_sia_vm_secret_type","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_secrets_filter/","title":"ark_sia_vm_secrets_filter","text":""},{"location":"reference/models/services/sia/secrets/vm/ark_sia_vm_secrets_stats/","title":"ark_sia_vm_secrets_stats","text":""},{"location":"reference/models/services/sia/sso/","title":"sso","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_acquire_token_response/","title":"ark_sia_sso_acquire_token_response","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_get_short_lived_client_certificate/","title":"ark_sia_sso_get_short_lived_client_certificate","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_get_short_lived_oracle_wallet/","title":"ark_sia_sso_get_short_lived_oracle_wallet","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_get_short_lived_password/","title":"ark_sia_sso_get_short_lived_password","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_get_short_lived_rdp_file/","title":"ark_sia_sso_get_short_lived_rdp_file","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_get_ssh_key/","title":"ark_sia_sso_get_ssh_key","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_get_token_info/","title":"ark_sia_sso_get_token_info","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_token_info/","title":"ark_sia_sso_token_info","text":""},{"location":"reference/models/services/sia/sso/ark_sia_sso_token_type/","title":"ark_sia_sso_token_type","text":""},{"location":"reference/models/services/sia/workspaces/","title":"workspaces","text":""},{"location":"reference/models/services/sia/workspaces/db/","title":"db","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_add_database/","title":"ark_sia_db_add_database","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_auth_method/","title":"ark_sia_db_auth_method","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_database/","title":"ark_sia_db_database","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_database_info/","title":"ark_sia_db_database_info","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_database_target_service/","title":"ark_sia_db_database_target_service","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_databases_filter/","title":"ark_sia_db_databases_filter","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_databases_stats/","title":"ark_sia_db_databases_stats","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_delete_database/","title":"ark_sia_db_delete_database","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_get_database/","title":"ark_sia_db_get_database","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_platform_type_serializer/","title":"ark_sia_db_platform_type_serializer","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_provider/","title":"ark_sia_db_provider","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_tag/","title":"ark_sia_db_tag","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_update_database/","title":"ark_sia_db_update_database","text":""},{"location":"reference/models/services/sia/workspaces/db/ark_sia_db_warning/","title":"ark_sia_db_warning","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/","title":"targetsets","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_add_target_set/","title":"ark_sia_add_target_set","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_bulk_add_target_sets/","title":"ark_sia_bulk_add_target_sets","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_bulk_delete_target_sets/","title":"ark_sia_bulk_delete_target_sets","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_bulk_target_set_response/","title":"ark_sia_bulk_target_set_response","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_delete_target_set/","title":"ark_sia_delete_target_set","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_get_target_set/","title":"ark_sia_get_target_set","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_target_set/","title":"ark_sia_target_set","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_target_set_type/","title":"ark_sia_target_set_type","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_target_sets_filter/","title":"ark_sia_target_sets_filter","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_target_sets_stats/","title":"ark_sia_target_sets_stats","text":""},{"location":"reference/models/services/sia/workspaces/targetsets/ark_sia_update_target_set/","title":"ark_sia_update_target_set","text":""},{"location":"reference/models/services/sm/","title":"sm","text":""},{"location":"reference/models/services/sm/ark_sm_get_session/","title":"ark_sm_get_session","text":""},{"location":"reference/models/services/sm/ark_sm_get_session_activities/","title":"ark_sm_get_session_activities","text":""},{"location":"reference/models/services/sm/ark_sm_protocol_type_serializer/","title":"ark_sm_protocol_type_serializer","text":""},{"location":"reference/models/services/sm/ark_sm_session/","title":"ark_sm_session","text":""},{"location":"reference/models/services/sm/ark_sm_session_activity/","title":"ark_sm_session_activity","text":""},{"location":"reference/models/services/sm/ark_sm_session_activity_filter/","title":"ark_sm_session_activity_filter","text":""},{"location":"reference/models/services/sm/ark_sm_sessions_filter/","title":"ark_sm_sessions_filter","text":""},{"location":"reference/models/services/sm/ark_sm_sessions_stats/","title":"ark_sm_sessions_stats","text":""},{"location":"reference/models/services/sm/ark_sm_workspace_type_serializer/","title":"ark_sm_workspace_type_serializer","text":""},{"location":"reference/services/","title":"services","text":""},{"location":"reference/services/ark_service/","title":"ark_service","text":""},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService","title":"<code>ArkService</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>class ArkService(ABC):\n    def __init__(self, *authenticators: Any) -&gt; None:\n        self._logger = get_logger(self.__class__.__name__)\n        self._authenticators = [auth for auth in authenticators if issubclass(type(auth), ArkAuth)]\n        given_auth_names = [auth.authenticator_name() for auth in self._authenticators]\n        if any(a not in given_auth_names for a in self.service_config().required_authenticator_names):\n            raise ArkValidationException(f'{self.service_config().service_name} missing required authenticators for service')\n\n    @property\n    def authenticators(self) -&gt; List[ArkAuth]:\n        \"\"\"\n        Returns all the authenticators for the service.\n\n        Returns:\n            List[ArkAuth]: _description_\n        \"\"\"\n        return self._authenticators\n\n    def authenticator(self, auth_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Finds the appropriate Ark authenticator class for the specified authenticator.\n\n        Args:\n            auth_name (str): _description_\n\n        Raises:\n            ArkNotFoundException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.authenticators:\n            if auth.authenticator_name() == auth_name:\n                return auth\n        raise ArkNotFoundException(f'{self.service_config().service_name} Failed to find authenticator {auth_name}')\n\n    def has_authenticator(self, auth_name: str) -&gt; bool:\n        \"\"\"\n        Checks whether the specified authenticator name exists.\n\n        Args:\n            auth_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return any(auth.authenticator_name() == auth_name for auth in self.authenticators)\n\n    @staticmethod\n    @abstractmethod\n    def service_config() -&gt; ArkServiceConfig:\n        \"\"\"\n        Returns the service configuration, which includes the service name, and its required and optional authenticators.\n\n        Returns:\n            ArkServiceConfig: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.authenticators","title":"<code>authenticators</code>  <code>property</code>","text":"<p>Returns all the authenticators for the service.</p> <p>Returns:</p> Type Description <code>List[ArkAuth]</code> <p>List[ArkAuth]: description</p>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.authenticator","title":"<code>authenticator(auth_name)</code>","text":"<p>Finds the appropriate Ark authenticator class for the specified authenticator.</p> <p>Parameters:</p> Name Type Description Default <code>auth_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkNotFoundException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>def authenticator(self, auth_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Finds the appropriate Ark authenticator class for the specified authenticator.\n\n    Args:\n        auth_name (str): _description_\n\n    Raises:\n        ArkNotFoundException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.authenticators:\n        if auth.authenticator_name() == auth_name:\n            return auth\n    raise ArkNotFoundException(f'{self.service_config().service_name} Failed to find authenticator {auth_name}')\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.has_authenticator","title":"<code>has_authenticator(auth_name)</code>","text":"<p>Checks whether the specified authenticator name exists.</p> <p>Parameters:</p> Name Type Description Default <code>auth_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>def has_authenticator(self, auth_name: str) -&gt; bool:\n    \"\"\"\n    Checks whether the specified authenticator name exists.\n\n    Args:\n        auth_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return any(auth.authenticator_name() == auth_name for auth in self.authenticators)\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.service_config","title":"<code>service_config()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the service configuration, which includes the service name, and its required and optional authenticators.</p> <p>Returns:</p> Name Type Description <code>ArkServiceConfig</code> <code>ArkServiceConfig</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef service_config() -&gt; ArkServiceConfig:\n    \"\"\"\n    Returns the service configuration, which includes the service name, and its required and optional authenticators.\n\n    Returns:\n        ArkServiceConfig: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/services/cmgr/","title":"cmgr","text":""},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService","title":"<code>ArkCmgrService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>class ArkCmgrService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='connectormanagement',\n            refresh_connection_callback=self.__refresh_cmgr_auth,\n        )\n\n    def __refresh_cmgr_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __list_common_pools(\n        self, name: str, route: str, item_type: Type[Any], common_filter: Optional[ArkCmgrPoolsCommonFilter] = None\n    ) -&gt; Iterator[Any]:\n        cont_token = None\n        filters = {'projection': 'EXTENDED'}\n        if common_filter:\n            filters.update(common_filter.model_dump(exclude_none=True))\n        while True:\n            resp = self.__client.get(route, params=filters)\n            if resp.status_code != HTTPStatus.OK:\n                raise ArkServiceException(f'Failed to list {name} [{resp.text}] - [{resp.status_code}]')\n            result = resp.json()\n            yield ArkPage[item_type](TypeAdapter(List[item_type]).validate_python(result['resources']))\n            if 'page' not in result:\n                break\n            page = result['page']\n            if 'continuation_token' not in page or not page['continuation_token']:\n                break\n            cont_token = page['continuation_token']\n            if 'total_resources_count' in page and page['total_resources_count'] and page['page_size'] == page['total_resources_count']:\n                break\n            filters['continuation_token'] = cont_token\n\n    @staticmethod\n    def __identifiers_by_add_pool_identifies_response(response: Response) -&gt; ArkCmgrPoolIdentifiers:\n        identifiers_responses: ArkCmgrBulkResponses = ArkCmgrBulkResponses.model_validate(response.json())\n        identifiers: List[ArkCmgrPoolIdentifier] = []\n        for identifier_response in identifiers_responses.responses.values():\n            if identifier_response.status_code != HTTPStatus.CREATED:\n                raise ArkServiceException(f'Failed to add pool identifiers bulk [{response.text}] - [{response.status_code}]')\n            identifiers.append(ArkCmgrPoolIdentifier.model_validate(identifier_response.body))\n\n        return ArkCmgrPoolIdentifiers(identifiers=identifiers)\n\n    def add_network(self, add_network: ArkCmgrAddNetwork) -&gt; ArkCmgrNetwork:\n        \"\"\"\n        Adds a new network\n\n        Args:\n            add_network (ArkCmgrAddNetwork): _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding new network [{add_network}]')\n        resp: Response = self.__client.post(NETWORKS_API, json=add_network.model_dump())\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkCmgrNetwork.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add network response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add network response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add network [{resp.text}] - [{resp.status_code}]')\n\n    def update_network(self, update_network: ArkCmgrUpdateNetwork) -&gt; ArkCmgrNetwork:\n        \"\"\"\n        Updates a network\n\n        Args:\n            update_network (ArkCmgrUpdateNetwork): _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Updating network [{update_network}]')\n        if not update_network.name:\n            self._logger.info('Nothing to update')\n            return self.network(ArkCmgrGetNetwork(network_id=update_network.network_id))\n        resp: Response = self.__client.patch(\n            NETWORK_API.format(network_id=update_network.network_id), json=update_network.model_dump(exclude={'network_id'})\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrNetwork.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update network response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update network response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update network [{resp.text}] - [{resp.status_code}]')\n\n    def delete_network(self, delete_network: ArkCmgrDeleteNetwork) -&gt; None:\n        \"\"\"\n        Deletes the given network.\n\n        Args:\n            delete_network (ArkCmgrDeleteNetwork): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting network [{delete_network}]')\n        resp: Response = self.__client.delete(NETWORK_API.format(network_id=delete_network.network_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete network [{resp.text}] - [{resp.status_code}]')\n\n    def list_networks(self) -&gt; Iterator[ArkCmgrNetworkPage]:\n        \"\"\"\n        Listing all networks, yielding in pages\n\n        Yields:\n            Iterator[ArkCmgrNetworkPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all networks')\n        yield from self.__list_common_pools(\n            'networks',\n            NETWORKS_API,\n            ArkCmgrNetwork,\n        )\n\n    def list_networks_by(self, networks_filter: ArkCmgrNetworksFilter) -&gt; Iterator[ArkCmgrNetworkPage]:\n        \"\"\"\n        Listing networks by filters, yielding in pages\n\n        Args:\n            networks_filter (ArkCmgrNetworksFilter): _description_\n\n        Yields:\n            Iterator[ArkCmgrNetworkPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing networks by filters [{networks_filter}]')\n        yield from self.__list_common_pools(\n            'networks',\n            NETWORKS_API,\n            ArkCmgrNetwork,\n            networks_filter,\n        )\n\n    def network(self, get_network: ArkCmgrGetNetwork) -&gt; ArkCmgrNetwork:\n        \"\"\"\n        Retrieves a network by ID.\n\n        Args:\n            get_network (ArkCmgrGetNetwork): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving network [{get_network}]')\n        resp: Response = self.__client.get(NETWORK_API.format(network_id=get_network.network_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrNetwork.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse network response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse network response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve network [{get_network.network_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def networks_stats(self) -&gt; ArkCmgrNetworksStats:\n        \"\"\"\n        Calculates network statistics.\n\n        Returns:\n            ArkCmgrNetworksStats: _description_\n        \"\"\"\n        self._logger.info('Calculating network stats')\n        networks = list(itertools.chain.from_iterable([p.items for p in list(self.list_networks())]))\n        networks_stats = ArkCmgrNetworksStats.model_construct()\n        networks_stats.networks_count = len(networks)\n        networks_stats.pools_count_per_network = {n.name: len(n.assigned_pools) for n in networks}\n        return networks_stats\n\n    def add_pool(self, add_pool: ArkCmgrAddPool) -&gt; ArkCmgrPool:\n        \"\"\"\n        Adds a new pool\n\n        Args:\n            add_pool (ArkCmgrAddPool): _description_\n\n        Returns:\n            ArkCmgrPool: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding new pool [{add_pool}]')\n        resp: Response = self.__client.post(POOLS_API, json=add_pool.model_dump())\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkCmgrPool.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add pool response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add pool response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add pool [{resp.text}] - [{resp.status_code}]')\n\n    def update_pool(self, update_pool: ArkCmgrUpdatePool) -&gt; ArkCmgrPool:\n        \"\"\"\n        Updates a pool\n\n        Args:\n            update_pool (ArkCmgrUpdatePool): _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Updating pool [{update_pool}]')\n        if not update_pool.name and not update_pool.assigned_network_ids and not update_pool.description:\n            self._logger.info('Nothing to update')\n            return self.pool(ArkCmgrGetPool(pool_id=update_pool.pool_id))\n        resp: Response = self.__client.patch(POOL_API.format(pool_id=update_pool.pool_id), json=update_pool.model_dump(exclude={'pool_id'}))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrPool.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update pool response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update pool response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update pool [{resp.text}] - [{resp.status_code}]')\n\n    def delete_pool(self, delete_pool: ArkCmgrDeletePool) -&gt; None:\n        \"\"\"\n        Deletes the given pool.\n\n        Args:\n            delete_pool (ArkCmgrDeletePool): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting pool [{delete_pool}]')\n        resp: Response = self.__client.delete(POOL_API.format(pool_id=delete_pool.pool_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete pool [{resp.text}] - [{resp.status_code}]')\n\n    def list_pools(self) -&gt; Iterator[ArkCmgrPoolPage]:\n        \"\"\"\n        Listing all pools, yielding in pages\n\n        Yields:\n            Iterator[ArkCmgrPoolPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all pools')\n        yield from self.__list_common_pools(\n            'pools',\n            POOLS_API,\n            ArkCmgrPool,\n        )\n\n    def list_pools_by(self, pools_filter: ArkCmgrPoolsFilter) -&gt; Iterator[ArkCmgrPoolPage]:\n        \"\"\"\n        Listing pools by filters, yielding in pages\n\n        Args:\n            pools_filter (ArkCmgrPoolsFilter): _description_\n\n        Yields:\n            Iterator[ArkCmgrNetworkPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing pools by filters [{pools_filter}]')\n        yield from self.__list_common_pools(\n            'pools',\n            POOLS_API,\n            ArkCmgrPool,\n            pools_filter,\n        )\n\n    def pool(self, get_pool: ArkCmgrGetPool) -&gt; ArkCmgrPool:\n        \"\"\"\n        Retrieves a pool by ID.\n\n        Args:\n            get_pool (ArkCmgrGetPool): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkCmgrPool: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving pool [{get_pool}]')\n        resp: Response = self.__client.get(POOL_API.format(pool_id=get_pool.pool_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrPool.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse pool response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse pool response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve pool [{get_pool.pool_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def pools_stats(self) -&gt; ArkCmgrPoolsStats:\n        \"\"\"\n        Calculates pools statistics.\n\n        Returns:\n            ArkCmgrPoolsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating pools stats')\n        pools = list(itertools.chain.from_iterable([p.items for p in list(self.list_pools())]))\n        pools_stats = ArkCmgrPoolsStats.model_construct()\n        pools_stats.pools_count = len(pools)\n        pools_stats.networks_count_per_pool = {p.name: len(p.assigned_network_ids) for p in pools}\n        pools_stats.identifiers_count_per_pool = {p.name: p.identifiers_count for p in pools}\n        pools_stats.components_count_per_pool = {p.name: p.components_count for p in pools}\n        return pools_stats\n\n    def add_pool_identifier(self, add_identifier: ArkCmgrAddPoolSingleIdentifier) -&gt; ArkCmgrPoolIdentifier:\n        \"\"\"\n        Adds a new pool identifier\n\n        Args:\n            add_identifier (ArkCmgrAddPoolSingleIdentifier): _description_\n\n        Returns:\n            ArkCmgrPoolIdentifier: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding new pool identifier [{add_identifier}]')\n        resp: Response = self.__client.post(\n            POOL_IDENTIFIERS_API.format(pool_id=add_identifier.pool_id), json=add_identifier.model_dump(exclude={'pool_id'})\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkCmgrPoolIdentifier.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add pool identifier response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add pool identifier response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add pool identifier [{resp.text}] - [{resp.status_code}]')\n\n    def add_pool_identifiers(self, add_identifiers: ArkCmgrAddPoolBulkIdentifier) -&gt; ArkCmgrPoolIdentifiers:\n        \"\"\"\n        Adds a bulk of new pool identifiers.\n\n        Args:\n            add_identifiers (ArkCmgrAddPoolBulkIdentifier): The identifiers to add.\n\n        Returns:\n            ArkCmgrPoolIdentifiers: Detailed information about the added identifiers.\n\n        Raises:\n            ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not CREATED.\n        \"\"\"\n        self._logger.info(f'Adding new pool identifiers bulk [{add_identifiers}]')\n        response: Response = self.__client.post(\n            POOL_IDENTIFIERS_BULK_API.format(pool_id=add_identifiers.pool_id),\n            json={\n                'requests': {str(index): i.model_dump(exclude={'pool_id'}) for index, i in enumerate(add_identifiers.identifiers, start=1)}\n            },\n        )\n        if response.status_code == HTTPStatus.MULTI_STATUS:\n            try:\n                return self.__identifiers_by_add_pool_identifies_response(response=response)\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add pool identifiers bulk response [{str(ex)}] - [{response.text}]')\n                raise ArkServiceException(f'Failed to parse add pool identifiers bulk response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add pool identifiers bulk [{response.text}] - [{response.status_code}]')\n\n    def delete_pool_identifier(self, delete_identifier: ArkCmgrDeletePoolSingleIdentifier) -&gt; None:\n        \"\"\"\n        Deletes the given pool identifier\n\n        Args:\n            delete_identifier (ArkCmgrDeletePoolSingleIdentifier): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting pool identifier [{delete_identifier}]')\n        resp: Response = self.__client.delete(\n            POOL_IDENTIFIER_API.format(pool_id=delete_identifier.pool_id, identifier_id=delete_identifier.identifier_id)\n        )\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n\n    def delete_pool_identifiers(self, delete_identifiers: ArkCmgrDeletePoolBulkIdentifier) -&gt; None:\n        \"\"\"\n        Deletes the given bulk of pool identifiers.\n\n        Args:\n            delete_identifiers (ArkCmgrDeletePoolBulkIdentifier): List of identifiers to delete.\n\n        Raises:\n            ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not NO_CONTENT.\n        \"\"\"\n        self._logger.info(f'Deleting pool identifiers bulk [{delete_identifiers}]')\n        resp: Response = self.__client.delete(\n            POOL_IDENTIFIERS_BULK_API.format(pool_id=delete_identifiers.pool_id),\n            json={'requests': {str(index): {'id': i.identifier_id} for index, i in enumerate(delete_identifiers.identifiers, start=1)}},\n        )\n        if resp.status_code == HTTPStatus.MULTI_STATUS:\n            delete_responses: ArkCmgrBulkResponses = ArkCmgrBulkResponses.model_validate(resp.json())\n            for _, identifier_response in delete_responses.responses.items():\n                if identifier_response.status_code != HTTPStatus.NO_CONTENT:\n                    raise ArkServiceException(f'Failed to delete pool identifiers [{resp.text}] - [{resp.status_code}]')\n        else:\n            raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n\n    def list_pool_identifiers(self, list_identifiers: ArkCmgrListPoolIdentifiers) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n        \"\"\"\n        Listing all pool identifiers, yielding in pages\n\n        Args:\n            list_identifiers (ArkCmgrListPoolIdentifiers): _description_\n\n        Yields:\n            Iterator[ArmCmgrPoolIdentifierPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing all pool [{list_identifiers}] identifiers')\n        yield from self.__list_common_pools(\n            'pool identifiers',\n            POOL_IDENTIFIERS_API.format(pool_id=list_identifiers.pool_id),\n            ArkCmgrPoolIdentifier,\n        )\n\n    def list_pool_identifiers_by(self, identifiers_filter: ArkCmgrPoolIdentifiersFilter) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n        \"\"\"\n        Listing pool identifiers with filters, yielding in pages\n\n        Args:\n            identifiers_filter (ArkCmgrPoolIdentifiersFilter): _description_\n\n        Yields:\n            Iterator[ArmCmgrPoolIdentifierPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing pool identifiers with filters [{identifiers_filter}]')\n        yield from self.__list_common_pools(\n            'pool identifiers',\n            POOL_IDENTIFIERS_API.format(pool_id=identifiers_filter.pool_id),\n            ArkCmgrPoolIdentifier,\n            ArkCmgrPoolsCommonFilter(**identifiers_filter.model_dump()),\n        )\n\n    def list_pools_components(self) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n        \"\"\"\n        Listing all pools components, yielding in pages\n\n        Yields:\n            Iterator[ArkCmgrPoolComponentPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all pools components')\n        yield from self.__list_common_pools(\n            'pools components',\n            POOLS_COMPONENTS_API,\n            ArkCmgrPoolComponent,\n        )\n\n    def list_pools_components_by(self, components_filter: ArkCmgrPoolComponentsFilter) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n        \"\"\"\n        Listing pools components with filters, yielding in pages\n\n        Args:\n            components_filter (ArkCmgrPoolComponentsFilter): _description_\n\n        Yields:\n            Iterator[ArkCmgrPoolComponentPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing pool components with filters [{components_filter}]')\n        yield from self.__list_common_pools(\n            'pools components',\n            POOLS_COMPONENTS_API,\n            ArkCmgrPoolIdentifier,\n            ArkCmgrPoolsCommonFilter(**components_filter.model_dump()),\n        )\n\n    def pool_component(self, get_pool_component: ArkCmgrGetPoolComponent) -&gt; ArkCmgrPoolComponent:\n        \"\"\"\n        Retrieves a pool component by ID.\n\n        Args:\n            get_pool_component (ArkCmgrGetPoolComponent): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkCmgrPoolComponent: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving pool component [{get_pool_component}]')\n        resp: Response = self.__client.get(\n            POOL_COMPONENT_API.format(pool_id=get_pool_component.pool_id, component_id=get_pool_component.component_id)\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrPoolComponent.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse pool component response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse pool component  response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve pool component [{get_pool_component}] [{resp.text}] - [{resp.status_code}]')\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.add_network","title":"<code>add_network(add_network)</code>","text":"<p>Adds a new network</p> <p>Parameters:</p> Name Type Description Default <code>add_network</code> <code>ArkCmgrAddNetwork</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrNetwork</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_network(self, add_network: ArkCmgrAddNetwork) -&gt; ArkCmgrNetwork:\n    \"\"\"\n    Adds a new network\n\n    Args:\n        add_network (ArkCmgrAddNetwork): _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding new network [{add_network}]')\n    resp: Response = self.__client.post(NETWORKS_API, json=add_network.model_dump())\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkCmgrNetwork.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add network response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add network response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add network [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.add_pool","title":"<code>add_pool(add_pool)</code>","text":"<p>Adds a new pool</p> <p>Parameters:</p> Name Type Description Default <code>add_pool</code> <code>ArkCmgrAddPool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrPool</code> <code>ArkCmgrPool</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_pool(self, add_pool: ArkCmgrAddPool) -&gt; ArkCmgrPool:\n    \"\"\"\n    Adds a new pool\n\n    Args:\n        add_pool (ArkCmgrAddPool): _description_\n\n    Returns:\n        ArkCmgrPool: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding new pool [{add_pool}]')\n    resp: Response = self.__client.post(POOLS_API, json=add_pool.model_dump())\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkCmgrPool.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add pool response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add pool response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add pool [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.add_pool_identifier","title":"<code>add_pool_identifier(add_identifier)</code>","text":"<p>Adds a new pool identifier</p> <p>Parameters:</p> Name Type Description Default <code>add_identifier</code> <code>ArkCmgrAddPoolSingleIdentifier</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrPoolIdentifier</code> <code>ArkCmgrPoolIdentifier</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_pool_identifier(self, add_identifier: ArkCmgrAddPoolSingleIdentifier) -&gt; ArkCmgrPoolIdentifier:\n    \"\"\"\n    Adds a new pool identifier\n\n    Args:\n        add_identifier (ArkCmgrAddPoolSingleIdentifier): _description_\n\n    Returns:\n        ArkCmgrPoolIdentifier: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding new pool identifier [{add_identifier}]')\n    resp: Response = self.__client.post(\n        POOL_IDENTIFIERS_API.format(pool_id=add_identifier.pool_id), json=add_identifier.model_dump(exclude={'pool_id'})\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkCmgrPoolIdentifier.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add pool identifier response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add pool identifier response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add pool identifier [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.add_pool_identifiers","title":"<code>add_pool_identifiers(add_identifiers)</code>","text":"<p>Adds a bulk of new pool identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>add_identifiers</code> <code>ArkCmgrAddPoolBulkIdentifier</code> <p>The identifiers to add.</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrPoolIdentifiers</code> <code>ArkCmgrPoolIdentifiers</code> <p>Detailed information about the added identifiers.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>In case the response is not MULTI_STATUS, or if one of the responses is not CREATED.</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_pool_identifiers(self, add_identifiers: ArkCmgrAddPoolBulkIdentifier) -&gt; ArkCmgrPoolIdentifiers:\n    \"\"\"\n    Adds a bulk of new pool identifiers.\n\n    Args:\n        add_identifiers (ArkCmgrAddPoolBulkIdentifier): The identifiers to add.\n\n    Returns:\n        ArkCmgrPoolIdentifiers: Detailed information about the added identifiers.\n\n    Raises:\n        ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not CREATED.\n    \"\"\"\n    self._logger.info(f'Adding new pool identifiers bulk [{add_identifiers}]')\n    response: Response = self.__client.post(\n        POOL_IDENTIFIERS_BULK_API.format(pool_id=add_identifiers.pool_id),\n        json={\n            'requests': {str(index): i.model_dump(exclude={'pool_id'}) for index, i in enumerate(add_identifiers.identifiers, start=1)}\n        },\n    )\n    if response.status_code == HTTPStatus.MULTI_STATUS:\n        try:\n            return self.__identifiers_by_add_pool_identifies_response(response=response)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add pool identifiers bulk response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add pool identifiers bulk response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add pool identifiers bulk [{response.text}] - [{response.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.delete_network","title":"<code>delete_network(delete_network)</code>","text":"<p>Deletes the given network.</p> <p>Parameters:</p> Name Type Description Default <code>delete_network</code> <code>ArkCmgrDeleteNetwork</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_network(self, delete_network: ArkCmgrDeleteNetwork) -&gt; None:\n    \"\"\"\n    Deletes the given network.\n\n    Args:\n        delete_network (ArkCmgrDeleteNetwork): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting network [{delete_network}]')\n    resp: Response = self.__client.delete(NETWORK_API.format(network_id=delete_network.network_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete network [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.delete_pool","title":"<code>delete_pool(delete_pool)</code>","text":"<p>Deletes the given pool.</p> <p>Parameters:</p> Name Type Description Default <code>delete_pool</code> <code>ArkCmgrDeletePool</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_pool(self, delete_pool: ArkCmgrDeletePool) -&gt; None:\n    \"\"\"\n    Deletes the given pool.\n\n    Args:\n        delete_pool (ArkCmgrDeletePool): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting pool [{delete_pool}]')\n    resp: Response = self.__client.delete(POOL_API.format(pool_id=delete_pool.pool_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete pool [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.delete_pool_identifier","title":"<code>delete_pool_identifier(delete_identifier)</code>","text":"<p>Deletes the given pool identifier</p> <p>Parameters:</p> Name Type Description Default <code>delete_identifier</code> <code>ArkCmgrDeletePoolSingleIdentifier</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_pool_identifier(self, delete_identifier: ArkCmgrDeletePoolSingleIdentifier) -&gt; None:\n    \"\"\"\n    Deletes the given pool identifier\n\n    Args:\n        delete_identifier (ArkCmgrDeletePoolSingleIdentifier): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting pool identifier [{delete_identifier}]')\n    resp: Response = self.__client.delete(\n        POOL_IDENTIFIER_API.format(pool_id=delete_identifier.pool_id, identifier_id=delete_identifier.identifier_id)\n    )\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.delete_pool_identifiers","title":"<code>delete_pool_identifiers(delete_identifiers)</code>","text":"<p>Deletes the given bulk of pool identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>delete_identifiers</code> <code>ArkCmgrDeletePoolBulkIdentifier</code> <p>List of identifiers to delete.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>In case the response is not MULTI_STATUS, or if one of the responses is not NO_CONTENT.</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_pool_identifiers(self, delete_identifiers: ArkCmgrDeletePoolBulkIdentifier) -&gt; None:\n    \"\"\"\n    Deletes the given bulk of pool identifiers.\n\n    Args:\n        delete_identifiers (ArkCmgrDeletePoolBulkIdentifier): List of identifiers to delete.\n\n    Raises:\n        ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not NO_CONTENT.\n    \"\"\"\n    self._logger.info(f'Deleting pool identifiers bulk [{delete_identifiers}]')\n    resp: Response = self.__client.delete(\n        POOL_IDENTIFIERS_BULK_API.format(pool_id=delete_identifiers.pool_id),\n        json={'requests': {str(index): {'id': i.identifier_id} for index, i in enumerate(delete_identifiers.identifiers, start=1)}},\n    )\n    if resp.status_code == HTTPStatus.MULTI_STATUS:\n        delete_responses: ArkCmgrBulkResponses = ArkCmgrBulkResponses.model_validate(resp.json())\n        for _, identifier_response in delete_responses.responses.items():\n            if identifier_response.status_code != HTTPStatus.NO_CONTENT:\n                raise ArkServiceException(f'Failed to delete pool identifiers [{resp.text}] - [{resp.status_code}]')\n    else:\n        raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_networks","title":"<code>list_networks()</code>","text":"<p>Listing all networks, yielding in pages</p> <p>Yields:</p> Type Description <code>ArkCmgrNetworkPage</code> <p>Iterator[ArkCmgrNetworkPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_networks(self) -&gt; Iterator[ArkCmgrNetworkPage]:\n    \"\"\"\n    Listing all networks, yielding in pages\n\n    Yields:\n        Iterator[ArkCmgrNetworkPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all networks')\n    yield from self.__list_common_pools(\n        'networks',\n        NETWORKS_API,\n        ArkCmgrNetwork,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_networks_by","title":"<code>list_networks_by(networks_filter)</code>","text":"<p>Listing networks by filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>networks_filter</code> <code>ArkCmgrNetworksFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkCmgrNetworkPage</code> <p>Iterator[ArkCmgrNetworkPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_networks_by(self, networks_filter: ArkCmgrNetworksFilter) -&gt; Iterator[ArkCmgrNetworkPage]:\n    \"\"\"\n    Listing networks by filters, yielding in pages\n\n    Args:\n        networks_filter (ArkCmgrNetworksFilter): _description_\n\n    Yields:\n        Iterator[ArkCmgrNetworkPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing networks by filters [{networks_filter}]')\n    yield from self.__list_common_pools(\n        'networks',\n        NETWORKS_API,\n        ArkCmgrNetwork,\n        networks_filter,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_pool_identifiers","title":"<code>list_pool_identifiers(list_identifiers)</code>","text":"<p>Listing all pool identifiers, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>list_identifiers</code> <code>ArkCmgrListPoolIdentifiers</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArmCmgrPoolIdentifierPage</code> <p>Iterator[ArmCmgrPoolIdentifierPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pool_identifiers(self, list_identifiers: ArkCmgrListPoolIdentifiers) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n    \"\"\"\n    Listing all pool identifiers, yielding in pages\n\n    Args:\n        list_identifiers (ArkCmgrListPoolIdentifiers): _description_\n\n    Yields:\n        Iterator[ArmCmgrPoolIdentifierPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing all pool [{list_identifiers}] identifiers')\n    yield from self.__list_common_pools(\n        'pool identifiers',\n        POOL_IDENTIFIERS_API.format(pool_id=list_identifiers.pool_id),\n        ArkCmgrPoolIdentifier,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_pool_identifiers_by","title":"<code>list_pool_identifiers_by(identifiers_filter)</code>","text":"<p>Listing pool identifiers with filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>identifiers_filter</code> <code>ArkCmgrPoolIdentifiersFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArmCmgrPoolIdentifierPage</code> <p>Iterator[ArmCmgrPoolIdentifierPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pool_identifiers_by(self, identifiers_filter: ArkCmgrPoolIdentifiersFilter) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n    \"\"\"\n    Listing pool identifiers with filters, yielding in pages\n\n    Args:\n        identifiers_filter (ArkCmgrPoolIdentifiersFilter): _description_\n\n    Yields:\n        Iterator[ArmCmgrPoolIdentifierPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing pool identifiers with filters [{identifiers_filter}]')\n    yield from self.__list_common_pools(\n        'pool identifiers',\n        POOL_IDENTIFIERS_API.format(pool_id=identifiers_filter.pool_id),\n        ArkCmgrPoolIdentifier,\n        ArkCmgrPoolsCommonFilter(**identifiers_filter.model_dump()),\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_pools","title":"<code>list_pools()</code>","text":"<p>Listing all pools, yielding in pages</p> <p>Yields:</p> Type Description <code>ArkCmgrPoolPage</code> <p>Iterator[ArkCmgrPoolPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools(self) -&gt; Iterator[ArkCmgrPoolPage]:\n    \"\"\"\n    Listing all pools, yielding in pages\n\n    Yields:\n        Iterator[ArkCmgrPoolPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all pools')\n    yield from self.__list_common_pools(\n        'pools',\n        POOLS_API,\n        ArkCmgrPool,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_pools_by","title":"<code>list_pools_by(pools_filter)</code>","text":"<p>Listing pools by filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>pools_filter</code> <code>ArkCmgrPoolsFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkCmgrPoolPage</code> <p>Iterator[ArkCmgrNetworkPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools_by(self, pools_filter: ArkCmgrPoolsFilter) -&gt; Iterator[ArkCmgrPoolPage]:\n    \"\"\"\n    Listing pools by filters, yielding in pages\n\n    Args:\n        pools_filter (ArkCmgrPoolsFilter): _description_\n\n    Yields:\n        Iterator[ArkCmgrNetworkPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing pools by filters [{pools_filter}]')\n    yield from self.__list_common_pools(\n        'pools',\n        POOLS_API,\n        ArkCmgrPool,\n        pools_filter,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_pools_components","title":"<code>list_pools_components()</code>","text":"<p>Listing all pools components, yielding in pages</p> <p>Yields:</p> Type Description <code>ArkCmgrPoolComponentPage</code> <p>Iterator[ArkCmgrPoolComponentPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools_components(self) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n    \"\"\"\n    Listing all pools components, yielding in pages\n\n    Yields:\n        Iterator[ArkCmgrPoolComponentPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all pools components')\n    yield from self.__list_common_pools(\n        'pools components',\n        POOLS_COMPONENTS_API,\n        ArkCmgrPoolComponent,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.list_pools_components_by","title":"<code>list_pools_components_by(components_filter)</code>","text":"<p>Listing pools components with filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>components_filter</code> <code>ArkCmgrPoolComponentsFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkCmgrPoolComponentPage</code> <p>Iterator[ArkCmgrPoolComponentPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools_components_by(self, components_filter: ArkCmgrPoolComponentsFilter) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n    \"\"\"\n    Listing pools components with filters, yielding in pages\n\n    Args:\n        components_filter (ArkCmgrPoolComponentsFilter): _description_\n\n    Yields:\n        Iterator[ArkCmgrPoolComponentPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing pool components with filters [{components_filter}]')\n    yield from self.__list_common_pools(\n        'pools components',\n        POOLS_COMPONENTS_API,\n        ArkCmgrPoolIdentifier,\n        ArkCmgrPoolsCommonFilter(**components_filter.model_dump()),\n    )\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.network","title":"<code>network(get_network)</code>","text":"<p>Retrieves a network by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_network</code> <code>ArkCmgrGetNetwork</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrNetwork</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def network(self, get_network: ArkCmgrGetNetwork) -&gt; ArkCmgrNetwork:\n    \"\"\"\n    Retrieves a network by ID.\n\n    Args:\n        get_network (ArkCmgrGetNetwork): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving network [{get_network}]')\n    resp: Response = self.__client.get(NETWORK_API.format(network_id=get_network.network_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrNetwork.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse network response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse network response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve network [{get_network.network_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.networks_stats","title":"<code>networks_stats()</code>","text":"<p>Calculates network statistics.</p> <p>Returns:</p> Name Type Description <code>ArkCmgrNetworksStats</code> <code>ArkCmgrNetworksStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def networks_stats(self) -&gt; ArkCmgrNetworksStats:\n    \"\"\"\n    Calculates network statistics.\n\n    Returns:\n        ArkCmgrNetworksStats: _description_\n    \"\"\"\n    self._logger.info('Calculating network stats')\n    networks = list(itertools.chain.from_iterable([p.items for p in list(self.list_networks())]))\n    networks_stats = ArkCmgrNetworksStats.model_construct()\n    networks_stats.networks_count = len(networks)\n    networks_stats.pools_count_per_network = {n.name: len(n.assigned_pools) for n in networks}\n    return networks_stats\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.pool","title":"<code>pool(get_pool)</code>","text":"<p>Retrieves a pool by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_pool</code> <code>ArkCmgrGetPool</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkCmgrPool</code> <code>ArkCmgrPool</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def pool(self, get_pool: ArkCmgrGetPool) -&gt; ArkCmgrPool:\n    \"\"\"\n    Retrieves a pool by ID.\n\n    Args:\n        get_pool (ArkCmgrGetPool): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkCmgrPool: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving pool [{get_pool}]')\n    resp: Response = self.__client.get(POOL_API.format(pool_id=get_pool.pool_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrPool.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse pool response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse pool response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve pool [{get_pool.pool_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.pool_component","title":"<code>pool_component(get_pool_component)</code>","text":"<p>Retrieves a pool component by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_pool_component</code> <code>ArkCmgrGetPoolComponent</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkCmgrPoolComponent</code> <code>ArkCmgrPoolComponent</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def pool_component(self, get_pool_component: ArkCmgrGetPoolComponent) -&gt; ArkCmgrPoolComponent:\n    \"\"\"\n    Retrieves a pool component by ID.\n\n    Args:\n        get_pool_component (ArkCmgrGetPoolComponent): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkCmgrPoolComponent: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving pool component [{get_pool_component}]')\n    resp: Response = self.__client.get(\n        POOL_COMPONENT_API.format(pool_id=get_pool_component.pool_id, component_id=get_pool_component.component_id)\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrPoolComponent.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse pool component response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse pool component  response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve pool component [{get_pool_component}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.pools_stats","title":"<code>pools_stats()</code>","text":"<p>Calculates pools statistics.</p> <p>Returns:</p> Name Type Description <code>ArkCmgrPoolsStats</code> <code>ArkCmgrPoolsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def pools_stats(self) -&gt; ArkCmgrPoolsStats:\n    \"\"\"\n    Calculates pools statistics.\n\n    Returns:\n        ArkCmgrPoolsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating pools stats')\n    pools = list(itertools.chain.from_iterable([p.items for p in list(self.list_pools())]))\n    pools_stats = ArkCmgrPoolsStats.model_construct()\n    pools_stats.pools_count = len(pools)\n    pools_stats.networks_count_per_pool = {p.name: len(p.assigned_network_ids) for p in pools}\n    pools_stats.identifiers_count_per_pool = {p.name: p.identifiers_count for p in pools}\n    pools_stats.components_count_per_pool = {p.name: p.components_count for p in pools}\n    return pools_stats\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.update_network","title":"<code>update_network(update_network)</code>","text":"<p>Updates a network</p> <p>Parameters:</p> Name Type Description Default <code>update_network</code> <code>ArkCmgrUpdateNetwork</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrNetwork</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def update_network(self, update_network: ArkCmgrUpdateNetwork) -&gt; ArkCmgrNetwork:\n    \"\"\"\n    Updates a network\n\n    Args:\n        update_network (ArkCmgrUpdateNetwork): _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Updating network [{update_network}]')\n    if not update_network.name:\n        self._logger.info('Nothing to update')\n        return self.network(ArkCmgrGetNetwork(network_id=update_network.network_id))\n    resp: Response = self.__client.patch(\n        NETWORK_API.format(network_id=update_network.network_id), json=update_network.model_dump(exclude={'network_id'})\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrNetwork.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update network response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update network response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update network [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/#ark_sdk_python.services.cmgr.ArkCmgrService.update_pool","title":"<code>update_pool(update_pool)</code>","text":"<p>Updates a pool</p> <p>Parameters:</p> Name Type Description Default <code>update_pool</code> <code>ArkCmgrUpdatePool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrPool</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def update_pool(self, update_pool: ArkCmgrUpdatePool) -&gt; ArkCmgrPool:\n    \"\"\"\n    Updates a pool\n\n    Args:\n        update_pool (ArkCmgrUpdatePool): _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Updating pool [{update_pool}]')\n    if not update_pool.name and not update_pool.assigned_network_ids and not update_pool.description:\n        self._logger.info('Nothing to update')\n        return self.pool(ArkCmgrGetPool(pool_id=update_pool.pool_id))\n    resp: Response = self.__client.patch(POOL_API.format(pool_id=update_pool.pool_id), json=update_pool.model_dump(exclude={'pool_id'}))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrPool.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update pool response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update pool response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update pool [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/","title":"ark_cmgr_service","text":""},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService","title":"<code>ArkCmgrService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>class ArkCmgrService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='connectormanagement',\n            refresh_connection_callback=self.__refresh_cmgr_auth,\n        )\n\n    def __refresh_cmgr_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __list_common_pools(\n        self, name: str, route: str, item_type: Type[Any], common_filter: Optional[ArkCmgrPoolsCommonFilter] = None\n    ) -&gt; Iterator[Any]:\n        cont_token = None\n        filters = {'projection': 'EXTENDED'}\n        if common_filter:\n            filters.update(common_filter.model_dump(exclude_none=True))\n        while True:\n            resp = self.__client.get(route, params=filters)\n            if resp.status_code != HTTPStatus.OK:\n                raise ArkServiceException(f'Failed to list {name} [{resp.text}] - [{resp.status_code}]')\n            result = resp.json()\n            yield ArkPage[item_type](TypeAdapter(List[item_type]).validate_python(result['resources']))\n            if 'page' not in result:\n                break\n            page = result['page']\n            if 'continuation_token' not in page or not page['continuation_token']:\n                break\n            cont_token = page['continuation_token']\n            if 'total_resources_count' in page and page['total_resources_count'] and page['page_size'] == page['total_resources_count']:\n                break\n            filters['continuation_token'] = cont_token\n\n    @staticmethod\n    def __identifiers_by_add_pool_identifies_response(response: Response) -&gt; ArkCmgrPoolIdentifiers:\n        identifiers_responses: ArkCmgrBulkResponses = ArkCmgrBulkResponses.model_validate(response.json())\n        identifiers: List[ArkCmgrPoolIdentifier] = []\n        for identifier_response in identifiers_responses.responses.values():\n            if identifier_response.status_code != HTTPStatus.CREATED:\n                raise ArkServiceException(f'Failed to add pool identifiers bulk [{response.text}] - [{response.status_code}]')\n            identifiers.append(ArkCmgrPoolIdentifier.model_validate(identifier_response.body))\n\n        return ArkCmgrPoolIdentifiers(identifiers=identifiers)\n\n    def add_network(self, add_network: ArkCmgrAddNetwork) -&gt; ArkCmgrNetwork:\n        \"\"\"\n        Adds a new network\n\n        Args:\n            add_network (ArkCmgrAddNetwork): _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding new network [{add_network}]')\n        resp: Response = self.__client.post(NETWORKS_API, json=add_network.model_dump())\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkCmgrNetwork.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add network response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add network response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add network [{resp.text}] - [{resp.status_code}]')\n\n    def update_network(self, update_network: ArkCmgrUpdateNetwork) -&gt; ArkCmgrNetwork:\n        \"\"\"\n        Updates a network\n\n        Args:\n            update_network (ArkCmgrUpdateNetwork): _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Updating network [{update_network}]')\n        if not update_network.name:\n            self._logger.info('Nothing to update')\n            return self.network(ArkCmgrGetNetwork(network_id=update_network.network_id))\n        resp: Response = self.__client.patch(\n            NETWORK_API.format(network_id=update_network.network_id), json=update_network.model_dump(exclude={'network_id'})\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrNetwork.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update network response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update network response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update network [{resp.text}] - [{resp.status_code}]')\n\n    def delete_network(self, delete_network: ArkCmgrDeleteNetwork) -&gt; None:\n        \"\"\"\n        Deletes the given network.\n\n        Args:\n            delete_network (ArkCmgrDeleteNetwork): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting network [{delete_network}]')\n        resp: Response = self.__client.delete(NETWORK_API.format(network_id=delete_network.network_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete network [{resp.text}] - [{resp.status_code}]')\n\n    def list_networks(self) -&gt; Iterator[ArkCmgrNetworkPage]:\n        \"\"\"\n        Listing all networks, yielding in pages\n\n        Yields:\n            Iterator[ArkCmgrNetworkPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all networks')\n        yield from self.__list_common_pools(\n            'networks',\n            NETWORKS_API,\n            ArkCmgrNetwork,\n        )\n\n    def list_networks_by(self, networks_filter: ArkCmgrNetworksFilter) -&gt; Iterator[ArkCmgrNetworkPage]:\n        \"\"\"\n        Listing networks by filters, yielding in pages\n\n        Args:\n            networks_filter (ArkCmgrNetworksFilter): _description_\n\n        Yields:\n            Iterator[ArkCmgrNetworkPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing networks by filters [{networks_filter}]')\n        yield from self.__list_common_pools(\n            'networks',\n            NETWORKS_API,\n            ArkCmgrNetwork,\n            networks_filter,\n        )\n\n    def network(self, get_network: ArkCmgrGetNetwork) -&gt; ArkCmgrNetwork:\n        \"\"\"\n        Retrieves a network by ID.\n\n        Args:\n            get_network (ArkCmgrGetNetwork): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving network [{get_network}]')\n        resp: Response = self.__client.get(NETWORK_API.format(network_id=get_network.network_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrNetwork.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse network response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse network response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve network [{get_network.network_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def networks_stats(self) -&gt; ArkCmgrNetworksStats:\n        \"\"\"\n        Calculates network statistics.\n\n        Returns:\n            ArkCmgrNetworksStats: _description_\n        \"\"\"\n        self._logger.info('Calculating network stats')\n        networks = list(itertools.chain.from_iterable([p.items for p in list(self.list_networks())]))\n        networks_stats = ArkCmgrNetworksStats.model_construct()\n        networks_stats.networks_count = len(networks)\n        networks_stats.pools_count_per_network = {n.name: len(n.assigned_pools) for n in networks}\n        return networks_stats\n\n    def add_pool(self, add_pool: ArkCmgrAddPool) -&gt; ArkCmgrPool:\n        \"\"\"\n        Adds a new pool\n\n        Args:\n            add_pool (ArkCmgrAddPool): _description_\n\n        Returns:\n            ArkCmgrPool: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding new pool [{add_pool}]')\n        resp: Response = self.__client.post(POOLS_API, json=add_pool.model_dump())\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkCmgrPool.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add pool response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add pool response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add pool [{resp.text}] - [{resp.status_code}]')\n\n    def update_pool(self, update_pool: ArkCmgrUpdatePool) -&gt; ArkCmgrPool:\n        \"\"\"\n        Updates a pool\n\n        Args:\n            update_pool (ArkCmgrUpdatePool): _description_\n\n        Returns:\n            ArkCmgrNetwork: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Updating pool [{update_pool}]')\n        if not update_pool.name and not update_pool.assigned_network_ids and not update_pool.description:\n            self._logger.info('Nothing to update')\n            return self.pool(ArkCmgrGetPool(pool_id=update_pool.pool_id))\n        resp: Response = self.__client.patch(POOL_API.format(pool_id=update_pool.pool_id), json=update_pool.model_dump(exclude={'pool_id'}))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrPool.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update pool response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update pool response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update pool [{resp.text}] - [{resp.status_code}]')\n\n    def delete_pool(self, delete_pool: ArkCmgrDeletePool) -&gt; None:\n        \"\"\"\n        Deletes the given pool.\n\n        Args:\n            delete_pool (ArkCmgrDeletePool): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting pool [{delete_pool}]')\n        resp: Response = self.__client.delete(POOL_API.format(pool_id=delete_pool.pool_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete pool [{resp.text}] - [{resp.status_code}]')\n\n    def list_pools(self) -&gt; Iterator[ArkCmgrPoolPage]:\n        \"\"\"\n        Listing all pools, yielding in pages\n\n        Yields:\n            Iterator[ArkCmgrPoolPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all pools')\n        yield from self.__list_common_pools(\n            'pools',\n            POOLS_API,\n            ArkCmgrPool,\n        )\n\n    def list_pools_by(self, pools_filter: ArkCmgrPoolsFilter) -&gt; Iterator[ArkCmgrPoolPage]:\n        \"\"\"\n        Listing pools by filters, yielding in pages\n\n        Args:\n            pools_filter (ArkCmgrPoolsFilter): _description_\n\n        Yields:\n            Iterator[ArkCmgrNetworkPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing pools by filters [{pools_filter}]')\n        yield from self.__list_common_pools(\n            'pools',\n            POOLS_API,\n            ArkCmgrPool,\n            pools_filter,\n        )\n\n    def pool(self, get_pool: ArkCmgrGetPool) -&gt; ArkCmgrPool:\n        \"\"\"\n        Retrieves a pool by ID.\n\n        Args:\n            get_pool (ArkCmgrGetPool): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkCmgrPool: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving pool [{get_pool}]')\n        resp: Response = self.__client.get(POOL_API.format(pool_id=get_pool.pool_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrPool.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse pool response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse pool response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve pool [{get_pool.pool_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def pools_stats(self) -&gt; ArkCmgrPoolsStats:\n        \"\"\"\n        Calculates pools statistics.\n\n        Returns:\n            ArkCmgrPoolsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating pools stats')\n        pools = list(itertools.chain.from_iterable([p.items for p in list(self.list_pools())]))\n        pools_stats = ArkCmgrPoolsStats.model_construct()\n        pools_stats.pools_count = len(pools)\n        pools_stats.networks_count_per_pool = {p.name: len(p.assigned_network_ids) for p in pools}\n        pools_stats.identifiers_count_per_pool = {p.name: p.identifiers_count for p in pools}\n        pools_stats.components_count_per_pool = {p.name: p.components_count for p in pools}\n        return pools_stats\n\n    def add_pool_identifier(self, add_identifier: ArkCmgrAddPoolSingleIdentifier) -&gt; ArkCmgrPoolIdentifier:\n        \"\"\"\n        Adds a new pool identifier\n\n        Args:\n            add_identifier (ArkCmgrAddPoolSingleIdentifier): _description_\n\n        Returns:\n            ArkCmgrPoolIdentifier: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding new pool identifier [{add_identifier}]')\n        resp: Response = self.__client.post(\n            POOL_IDENTIFIERS_API.format(pool_id=add_identifier.pool_id), json=add_identifier.model_dump(exclude={'pool_id'})\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkCmgrPoolIdentifier.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add pool identifier response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add pool identifier response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add pool identifier [{resp.text}] - [{resp.status_code}]')\n\n    def add_pool_identifiers(self, add_identifiers: ArkCmgrAddPoolBulkIdentifier) -&gt; ArkCmgrPoolIdentifiers:\n        \"\"\"\n        Adds a bulk of new pool identifiers.\n\n        Args:\n            add_identifiers (ArkCmgrAddPoolBulkIdentifier): The identifiers to add.\n\n        Returns:\n            ArkCmgrPoolIdentifiers: Detailed information about the added identifiers.\n\n        Raises:\n            ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not CREATED.\n        \"\"\"\n        self._logger.info(f'Adding new pool identifiers bulk [{add_identifiers}]')\n        response: Response = self.__client.post(\n            POOL_IDENTIFIERS_BULK_API.format(pool_id=add_identifiers.pool_id),\n            json={\n                'requests': {str(index): i.model_dump(exclude={'pool_id'}) for index, i in enumerate(add_identifiers.identifiers, start=1)}\n            },\n        )\n        if response.status_code == HTTPStatus.MULTI_STATUS:\n            try:\n                return self.__identifiers_by_add_pool_identifies_response(response=response)\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add pool identifiers bulk response [{str(ex)}] - [{response.text}]')\n                raise ArkServiceException(f'Failed to parse add pool identifiers bulk response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add pool identifiers bulk [{response.text}] - [{response.status_code}]')\n\n    def delete_pool_identifier(self, delete_identifier: ArkCmgrDeletePoolSingleIdentifier) -&gt; None:\n        \"\"\"\n        Deletes the given pool identifier\n\n        Args:\n            delete_identifier (ArkCmgrDeletePoolSingleIdentifier): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting pool identifier [{delete_identifier}]')\n        resp: Response = self.__client.delete(\n            POOL_IDENTIFIER_API.format(pool_id=delete_identifier.pool_id, identifier_id=delete_identifier.identifier_id)\n        )\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n\n    def delete_pool_identifiers(self, delete_identifiers: ArkCmgrDeletePoolBulkIdentifier) -&gt; None:\n        \"\"\"\n        Deletes the given bulk of pool identifiers.\n\n        Args:\n            delete_identifiers (ArkCmgrDeletePoolBulkIdentifier): List of identifiers to delete.\n\n        Raises:\n            ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not NO_CONTENT.\n        \"\"\"\n        self._logger.info(f'Deleting pool identifiers bulk [{delete_identifiers}]')\n        resp: Response = self.__client.delete(\n            POOL_IDENTIFIERS_BULK_API.format(pool_id=delete_identifiers.pool_id),\n            json={'requests': {str(index): {'id': i.identifier_id} for index, i in enumerate(delete_identifiers.identifiers, start=1)}},\n        )\n        if resp.status_code == HTTPStatus.MULTI_STATUS:\n            delete_responses: ArkCmgrBulkResponses = ArkCmgrBulkResponses.model_validate(resp.json())\n            for _, identifier_response in delete_responses.responses.items():\n                if identifier_response.status_code != HTTPStatus.NO_CONTENT:\n                    raise ArkServiceException(f'Failed to delete pool identifiers [{resp.text}] - [{resp.status_code}]')\n        else:\n            raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n\n    def list_pool_identifiers(self, list_identifiers: ArkCmgrListPoolIdentifiers) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n        \"\"\"\n        Listing all pool identifiers, yielding in pages\n\n        Args:\n            list_identifiers (ArkCmgrListPoolIdentifiers): _description_\n\n        Yields:\n            Iterator[ArmCmgrPoolIdentifierPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing all pool [{list_identifiers}] identifiers')\n        yield from self.__list_common_pools(\n            'pool identifiers',\n            POOL_IDENTIFIERS_API.format(pool_id=list_identifiers.pool_id),\n            ArkCmgrPoolIdentifier,\n        )\n\n    def list_pool_identifiers_by(self, identifiers_filter: ArkCmgrPoolIdentifiersFilter) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n        \"\"\"\n        Listing pool identifiers with filters, yielding in pages\n\n        Args:\n            identifiers_filter (ArkCmgrPoolIdentifiersFilter): _description_\n\n        Yields:\n            Iterator[ArmCmgrPoolIdentifierPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing pool identifiers with filters [{identifiers_filter}]')\n        yield from self.__list_common_pools(\n            'pool identifiers',\n            POOL_IDENTIFIERS_API.format(pool_id=identifiers_filter.pool_id),\n            ArkCmgrPoolIdentifier,\n            ArkCmgrPoolsCommonFilter(**identifiers_filter.model_dump()),\n        )\n\n    def list_pools_components(self) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n        \"\"\"\n        Listing all pools components, yielding in pages\n\n        Yields:\n            Iterator[ArkCmgrPoolComponentPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all pools components')\n        yield from self.__list_common_pools(\n            'pools components',\n            POOLS_COMPONENTS_API,\n            ArkCmgrPoolComponent,\n        )\n\n    def list_pools_components_by(self, components_filter: ArkCmgrPoolComponentsFilter) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n        \"\"\"\n        Listing pools components with filters, yielding in pages\n\n        Args:\n            components_filter (ArkCmgrPoolComponentsFilter): _description_\n\n        Yields:\n            Iterator[ArkCmgrPoolComponentPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing pool components with filters [{components_filter}]')\n        yield from self.__list_common_pools(\n            'pools components',\n            POOLS_COMPONENTS_API,\n            ArkCmgrPoolIdentifier,\n            ArkCmgrPoolsCommonFilter(**components_filter.model_dump()),\n        )\n\n    def pool_component(self, get_pool_component: ArkCmgrGetPoolComponent) -&gt; ArkCmgrPoolComponent:\n        \"\"\"\n        Retrieves a pool component by ID.\n\n        Args:\n            get_pool_component (ArkCmgrGetPoolComponent): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkCmgrPoolComponent: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving pool component [{get_pool_component}]')\n        resp: Response = self.__client.get(\n            POOL_COMPONENT_API.format(pool_id=get_pool_component.pool_id, component_id=get_pool_component.component_id)\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkCmgrPoolComponent.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse pool component response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse pool component  response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve pool component [{get_pool_component}] [{resp.text}] - [{resp.status_code}]')\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.add_network","title":"<code>add_network(add_network)</code>","text":"<p>Adds a new network</p> <p>Parameters:</p> Name Type Description Default <code>add_network</code> <code>ArkCmgrAddNetwork</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrNetwork</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_network(self, add_network: ArkCmgrAddNetwork) -&gt; ArkCmgrNetwork:\n    \"\"\"\n    Adds a new network\n\n    Args:\n        add_network (ArkCmgrAddNetwork): _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding new network [{add_network}]')\n    resp: Response = self.__client.post(NETWORKS_API, json=add_network.model_dump())\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkCmgrNetwork.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add network response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add network response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add network [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.add_pool","title":"<code>add_pool(add_pool)</code>","text":"<p>Adds a new pool</p> <p>Parameters:</p> Name Type Description Default <code>add_pool</code> <code>ArkCmgrAddPool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrPool</code> <code>ArkCmgrPool</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_pool(self, add_pool: ArkCmgrAddPool) -&gt; ArkCmgrPool:\n    \"\"\"\n    Adds a new pool\n\n    Args:\n        add_pool (ArkCmgrAddPool): _description_\n\n    Returns:\n        ArkCmgrPool: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding new pool [{add_pool}]')\n    resp: Response = self.__client.post(POOLS_API, json=add_pool.model_dump())\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkCmgrPool.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add pool response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add pool response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add pool [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.add_pool_identifier","title":"<code>add_pool_identifier(add_identifier)</code>","text":"<p>Adds a new pool identifier</p> <p>Parameters:</p> Name Type Description Default <code>add_identifier</code> <code>ArkCmgrAddPoolSingleIdentifier</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrPoolIdentifier</code> <code>ArkCmgrPoolIdentifier</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_pool_identifier(self, add_identifier: ArkCmgrAddPoolSingleIdentifier) -&gt; ArkCmgrPoolIdentifier:\n    \"\"\"\n    Adds a new pool identifier\n\n    Args:\n        add_identifier (ArkCmgrAddPoolSingleIdentifier): _description_\n\n    Returns:\n        ArkCmgrPoolIdentifier: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding new pool identifier [{add_identifier}]')\n    resp: Response = self.__client.post(\n        POOL_IDENTIFIERS_API.format(pool_id=add_identifier.pool_id), json=add_identifier.model_dump(exclude={'pool_id'})\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkCmgrPoolIdentifier.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add pool identifier response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add pool identifier response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add pool identifier [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.add_pool_identifiers","title":"<code>add_pool_identifiers(add_identifiers)</code>","text":"<p>Adds a bulk of new pool identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>add_identifiers</code> <code>ArkCmgrAddPoolBulkIdentifier</code> <p>The identifiers to add.</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrPoolIdentifiers</code> <code>ArkCmgrPoolIdentifiers</code> <p>Detailed information about the added identifiers.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>In case the response is not MULTI_STATUS, or if one of the responses is not CREATED.</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def add_pool_identifiers(self, add_identifiers: ArkCmgrAddPoolBulkIdentifier) -&gt; ArkCmgrPoolIdentifiers:\n    \"\"\"\n    Adds a bulk of new pool identifiers.\n\n    Args:\n        add_identifiers (ArkCmgrAddPoolBulkIdentifier): The identifiers to add.\n\n    Returns:\n        ArkCmgrPoolIdentifiers: Detailed information about the added identifiers.\n\n    Raises:\n        ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not CREATED.\n    \"\"\"\n    self._logger.info(f'Adding new pool identifiers bulk [{add_identifiers}]')\n    response: Response = self.__client.post(\n        POOL_IDENTIFIERS_BULK_API.format(pool_id=add_identifiers.pool_id),\n        json={\n            'requests': {str(index): i.model_dump(exclude={'pool_id'}) for index, i in enumerate(add_identifiers.identifiers, start=1)}\n        },\n    )\n    if response.status_code == HTTPStatus.MULTI_STATUS:\n        try:\n            return self.__identifiers_by_add_pool_identifies_response(response=response)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add pool identifiers bulk response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add pool identifiers bulk response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add pool identifiers bulk [{response.text}] - [{response.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.delete_network","title":"<code>delete_network(delete_network)</code>","text":"<p>Deletes the given network.</p> <p>Parameters:</p> Name Type Description Default <code>delete_network</code> <code>ArkCmgrDeleteNetwork</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_network(self, delete_network: ArkCmgrDeleteNetwork) -&gt; None:\n    \"\"\"\n    Deletes the given network.\n\n    Args:\n        delete_network (ArkCmgrDeleteNetwork): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting network [{delete_network}]')\n    resp: Response = self.__client.delete(NETWORK_API.format(network_id=delete_network.network_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete network [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.delete_pool","title":"<code>delete_pool(delete_pool)</code>","text":"<p>Deletes the given pool.</p> <p>Parameters:</p> Name Type Description Default <code>delete_pool</code> <code>ArkCmgrDeletePool</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_pool(self, delete_pool: ArkCmgrDeletePool) -&gt; None:\n    \"\"\"\n    Deletes the given pool.\n\n    Args:\n        delete_pool (ArkCmgrDeletePool): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting pool [{delete_pool}]')\n    resp: Response = self.__client.delete(POOL_API.format(pool_id=delete_pool.pool_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete pool [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.delete_pool_identifier","title":"<code>delete_pool_identifier(delete_identifier)</code>","text":"<p>Deletes the given pool identifier</p> <p>Parameters:</p> Name Type Description Default <code>delete_identifier</code> <code>ArkCmgrDeletePoolSingleIdentifier</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_pool_identifier(self, delete_identifier: ArkCmgrDeletePoolSingleIdentifier) -&gt; None:\n    \"\"\"\n    Deletes the given pool identifier\n\n    Args:\n        delete_identifier (ArkCmgrDeletePoolSingleIdentifier): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting pool identifier [{delete_identifier}]')\n    resp: Response = self.__client.delete(\n        POOL_IDENTIFIER_API.format(pool_id=delete_identifier.pool_id, identifier_id=delete_identifier.identifier_id)\n    )\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.delete_pool_identifiers","title":"<code>delete_pool_identifiers(delete_identifiers)</code>","text":"<p>Deletes the given bulk of pool identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>delete_identifiers</code> <code>ArkCmgrDeletePoolBulkIdentifier</code> <p>List of identifiers to delete.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>In case the response is not MULTI_STATUS, or if one of the responses is not NO_CONTENT.</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def delete_pool_identifiers(self, delete_identifiers: ArkCmgrDeletePoolBulkIdentifier) -&gt; None:\n    \"\"\"\n    Deletes the given bulk of pool identifiers.\n\n    Args:\n        delete_identifiers (ArkCmgrDeletePoolBulkIdentifier): List of identifiers to delete.\n\n    Raises:\n        ArkServiceException: In case the response is not MULTI_STATUS, or if one of the responses is not NO_CONTENT.\n    \"\"\"\n    self._logger.info(f'Deleting pool identifiers bulk [{delete_identifiers}]')\n    resp: Response = self.__client.delete(\n        POOL_IDENTIFIERS_BULK_API.format(pool_id=delete_identifiers.pool_id),\n        json={'requests': {str(index): {'id': i.identifier_id} for index, i in enumerate(delete_identifiers.identifiers, start=1)}},\n    )\n    if resp.status_code == HTTPStatus.MULTI_STATUS:\n        delete_responses: ArkCmgrBulkResponses = ArkCmgrBulkResponses.model_validate(resp.json())\n        for _, identifier_response in delete_responses.responses.items():\n            if identifier_response.status_code != HTTPStatus.NO_CONTENT:\n                raise ArkServiceException(f'Failed to delete pool identifiers [{resp.text}] - [{resp.status_code}]')\n    else:\n        raise ArkServiceException(f'Failed to delete pool identifier [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_networks","title":"<code>list_networks()</code>","text":"<p>Listing all networks, yielding in pages</p> <p>Yields:</p> Type Description <code>ArkCmgrNetworkPage</code> <p>Iterator[ArkCmgrNetworkPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_networks(self) -&gt; Iterator[ArkCmgrNetworkPage]:\n    \"\"\"\n    Listing all networks, yielding in pages\n\n    Yields:\n        Iterator[ArkCmgrNetworkPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all networks')\n    yield from self.__list_common_pools(\n        'networks',\n        NETWORKS_API,\n        ArkCmgrNetwork,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_networks_by","title":"<code>list_networks_by(networks_filter)</code>","text":"<p>Listing networks by filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>networks_filter</code> <code>ArkCmgrNetworksFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkCmgrNetworkPage</code> <p>Iterator[ArkCmgrNetworkPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_networks_by(self, networks_filter: ArkCmgrNetworksFilter) -&gt; Iterator[ArkCmgrNetworkPage]:\n    \"\"\"\n    Listing networks by filters, yielding in pages\n\n    Args:\n        networks_filter (ArkCmgrNetworksFilter): _description_\n\n    Yields:\n        Iterator[ArkCmgrNetworkPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing networks by filters [{networks_filter}]')\n    yield from self.__list_common_pools(\n        'networks',\n        NETWORKS_API,\n        ArkCmgrNetwork,\n        networks_filter,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_pool_identifiers","title":"<code>list_pool_identifiers(list_identifiers)</code>","text":"<p>Listing all pool identifiers, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>list_identifiers</code> <code>ArkCmgrListPoolIdentifiers</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArmCmgrPoolIdentifierPage</code> <p>Iterator[ArmCmgrPoolIdentifierPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pool_identifiers(self, list_identifiers: ArkCmgrListPoolIdentifiers) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n    \"\"\"\n    Listing all pool identifiers, yielding in pages\n\n    Args:\n        list_identifiers (ArkCmgrListPoolIdentifiers): _description_\n\n    Yields:\n        Iterator[ArmCmgrPoolIdentifierPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing all pool [{list_identifiers}] identifiers')\n    yield from self.__list_common_pools(\n        'pool identifiers',\n        POOL_IDENTIFIERS_API.format(pool_id=list_identifiers.pool_id),\n        ArkCmgrPoolIdentifier,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_pool_identifiers_by","title":"<code>list_pool_identifiers_by(identifiers_filter)</code>","text":"<p>Listing pool identifiers with filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>identifiers_filter</code> <code>ArkCmgrPoolIdentifiersFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArmCmgrPoolIdentifierPage</code> <p>Iterator[ArmCmgrPoolIdentifierPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pool_identifiers_by(self, identifiers_filter: ArkCmgrPoolIdentifiersFilter) -&gt; Iterator[ArmCmgrPoolIdentifierPage]:\n    \"\"\"\n    Listing pool identifiers with filters, yielding in pages\n\n    Args:\n        identifiers_filter (ArkCmgrPoolIdentifiersFilter): _description_\n\n    Yields:\n        Iterator[ArmCmgrPoolIdentifierPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing pool identifiers with filters [{identifiers_filter}]')\n    yield from self.__list_common_pools(\n        'pool identifiers',\n        POOL_IDENTIFIERS_API.format(pool_id=identifiers_filter.pool_id),\n        ArkCmgrPoolIdentifier,\n        ArkCmgrPoolsCommonFilter(**identifiers_filter.model_dump()),\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_pools","title":"<code>list_pools()</code>","text":"<p>Listing all pools, yielding in pages</p> <p>Yields:</p> Type Description <code>ArkCmgrPoolPage</code> <p>Iterator[ArkCmgrPoolPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools(self) -&gt; Iterator[ArkCmgrPoolPage]:\n    \"\"\"\n    Listing all pools, yielding in pages\n\n    Yields:\n        Iterator[ArkCmgrPoolPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all pools')\n    yield from self.__list_common_pools(\n        'pools',\n        POOLS_API,\n        ArkCmgrPool,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_pools_by","title":"<code>list_pools_by(pools_filter)</code>","text":"<p>Listing pools by filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>pools_filter</code> <code>ArkCmgrPoolsFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkCmgrPoolPage</code> <p>Iterator[ArkCmgrNetworkPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools_by(self, pools_filter: ArkCmgrPoolsFilter) -&gt; Iterator[ArkCmgrPoolPage]:\n    \"\"\"\n    Listing pools by filters, yielding in pages\n\n    Args:\n        pools_filter (ArkCmgrPoolsFilter): _description_\n\n    Yields:\n        Iterator[ArkCmgrNetworkPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing pools by filters [{pools_filter}]')\n    yield from self.__list_common_pools(\n        'pools',\n        POOLS_API,\n        ArkCmgrPool,\n        pools_filter,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_pools_components","title":"<code>list_pools_components()</code>","text":"<p>Listing all pools components, yielding in pages</p> <p>Yields:</p> Type Description <code>ArkCmgrPoolComponentPage</code> <p>Iterator[ArkCmgrPoolComponentPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools_components(self) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n    \"\"\"\n    Listing all pools components, yielding in pages\n\n    Yields:\n        Iterator[ArkCmgrPoolComponentPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all pools components')\n    yield from self.__list_common_pools(\n        'pools components',\n        POOLS_COMPONENTS_API,\n        ArkCmgrPoolComponent,\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.list_pools_components_by","title":"<code>list_pools_components_by(components_filter)</code>","text":"<p>Listing pools components with filters, yielding in pages</p> <p>Parameters:</p> Name Type Description Default <code>components_filter</code> <code>ArkCmgrPoolComponentsFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkCmgrPoolComponentPage</code> <p>Iterator[ArkCmgrPoolComponentPage]: description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def list_pools_components_by(self, components_filter: ArkCmgrPoolComponentsFilter) -&gt; Iterator[ArkCmgrPoolComponentPage]:\n    \"\"\"\n    Listing pools components with filters, yielding in pages\n\n    Args:\n        components_filter (ArkCmgrPoolComponentsFilter): _description_\n\n    Yields:\n        Iterator[ArkCmgrPoolComponentPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing pool components with filters [{components_filter}]')\n    yield from self.__list_common_pools(\n        'pools components',\n        POOLS_COMPONENTS_API,\n        ArkCmgrPoolIdentifier,\n        ArkCmgrPoolsCommonFilter(**components_filter.model_dump()),\n    )\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.network","title":"<code>network(get_network)</code>","text":"<p>Retrieves a network by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_network</code> <code>ArkCmgrGetNetwork</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrNetwork</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def network(self, get_network: ArkCmgrGetNetwork) -&gt; ArkCmgrNetwork:\n    \"\"\"\n    Retrieves a network by ID.\n\n    Args:\n        get_network (ArkCmgrGetNetwork): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving network [{get_network}]')\n    resp: Response = self.__client.get(NETWORK_API.format(network_id=get_network.network_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrNetwork.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse network response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse network response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve network [{get_network.network_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.networks_stats","title":"<code>networks_stats()</code>","text":"<p>Calculates network statistics.</p> <p>Returns:</p> Name Type Description <code>ArkCmgrNetworksStats</code> <code>ArkCmgrNetworksStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def networks_stats(self) -&gt; ArkCmgrNetworksStats:\n    \"\"\"\n    Calculates network statistics.\n\n    Returns:\n        ArkCmgrNetworksStats: _description_\n    \"\"\"\n    self._logger.info('Calculating network stats')\n    networks = list(itertools.chain.from_iterable([p.items for p in list(self.list_networks())]))\n    networks_stats = ArkCmgrNetworksStats.model_construct()\n    networks_stats.networks_count = len(networks)\n    networks_stats.pools_count_per_network = {n.name: len(n.assigned_pools) for n in networks}\n    return networks_stats\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.pool","title":"<code>pool(get_pool)</code>","text":"<p>Retrieves a pool by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_pool</code> <code>ArkCmgrGetPool</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkCmgrPool</code> <code>ArkCmgrPool</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def pool(self, get_pool: ArkCmgrGetPool) -&gt; ArkCmgrPool:\n    \"\"\"\n    Retrieves a pool by ID.\n\n    Args:\n        get_pool (ArkCmgrGetPool): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkCmgrPool: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving pool [{get_pool}]')\n    resp: Response = self.__client.get(POOL_API.format(pool_id=get_pool.pool_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrPool.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse pool response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse pool response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve pool [{get_pool.pool_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.pool_component","title":"<code>pool_component(get_pool_component)</code>","text":"<p>Retrieves a pool component by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_pool_component</code> <code>ArkCmgrGetPoolComponent</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkCmgrPoolComponent</code> <code>ArkCmgrPoolComponent</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def pool_component(self, get_pool_component: ArkCmgrGetPoolComponent) -&gt; ArkCmgrPoolComponent:\n    \"\"\"\n    Retrieves a pool component by ID.\n\n    Args:\n        get_pool_component (ArkCmgrGetPoolComponent): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkCmgrPoolComponent: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving pool component [{get_pool_component}]')\n    resp: Response = self.__client.get(\n        POOL_COMPONENT_API.format(pool_id=get_pool_component.pool_id, component_id=get_pool_component.component_id)\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrPoolComponent.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse pool component response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse pool component  response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve pool component [{get_pool_component}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.pools_stats","title":"<code>pools_stats()</code>","text":"<p>Calculates pools statistics.</p> <p>Returns:</p> Name Type Description <code>ArkCmgrPoolsStats</code> <code>ArkCmgrPoolsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def pools_stats(self) -&gt; ArkCmgrPoolsStats:\n    \"\"\"\n    Calculates pools statistics.\n\n    Returns:\n        ArkCmgrPoolsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating pools stats')\n    pools = list(itertools.chain.from_iterable([p.items for p in list(self.list_pools())]))\n    pools_stats = ArkCmgrPoolsStats.model_construct()\n    pools_stats.pools_count = len(pools)\n    pools_stats.networks_count_per_pool = {p.name: len(p.assigned_network_ids) for p in pools}\n    pools_stats.identifiers_count_per_pool = {p.name: p.identifiers_count for p in pools}\n    pools_stats.components_count_per_pool = {p.name: p.components_count for p in pools}\n    return pools_stats\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.update_network","title":"<code>update_network(update_network)</code>","text":"<p>Updates a network</p> <p>Parameters:</p> Name Type Description Default <code>update_network</code> <code>ArkCmgrUpdateNetwork</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrNetwork</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def update_network(self, update_network: ArkCmgrUpdateNetwork) -&gt; ArkCmgrNetwork:\n    \"\"\"\n    Updates a network\n\n    Args:\n        update_network (ArkCmgrUpdateNetwork): _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Updating network [{update_network}]')\n    if not update_network.name:\n        self._logger.info('Nothing to update')\n        return self.network(ArkCmgrGetNetwork(network_id=update_network.network_id))\n    resp: Response = self.__client.patch(\n        NETWORK_API.format(network_id=update_network.network_id), json=update_network.model_dump(exclude={'network_id'})\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrNetwork.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update network response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update network response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update network [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/cmgr/ark_cmgr_service/#ark_sdk_python.services.cmgr.ark_cmgr_service.ArkCmgrService.update_pool","title":"<code>update_pool(update_pool)</code>","text":"<p>Updates a pool</p> <p>Parameters:</p> Name Type Description Default <code>update_pool</code> <code>ArkCmgrUpdatePool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkCmgrNetwork</code> <code>ArkCmgrPool</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/cmgr/ark_cmgr_service.py</code> <pre><code>def update_pool(self, update_pool: ArkCmgrUpdatePool) -&gt; ArkCmgrPool:\n    \"\"\"\n    Updates a pool\n\n    Args:\n        update_pool (ArkCmgrUpdatePool): _description_\n\n    Returns:\n        ArkCmgrNetwork: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Updating pool [{update_pool}]')\n    if not update_pool.name and not update_pool.assigned_network_ids and not update_pool.description:\n        self._logger.info('Nothing to update')\n        return self.pool(ArkCmgrGetPool(pool_id=update_pool.pool_id))\n    resp: Response = self.__client.patch(POOL_API.format(pool_id=update_pool.pool_id), json=update_pool.model_dump(exclude={'pool_id'}))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkCmgrPool.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update pool response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update pool response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update pool [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/identity/","title":"identity","text":""},{"location":"reference/services/identity/#ark_sdk_python.services.identity.ArkIdentityAPI","title":"<code>ArkIdentityAPI</code>","text":"Source code in <code>ark_sdk_python/services/identity/ark_identity_api.py</code> <pre><code>class ArkIdentityAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__identity_connectors = ArkIdentityConnectorsService(isp_auth)\n        self.__identity_directories = ArkIdentityDirectoriesService(isp_auth)\n        self.__identity_policies = ArkIdentityPoliciesService(isp_auth)\n        self.__identity_roles = ArkIdentityRolesService(isp_auth)\n        self.__identity_users = ArkIdentityUsersService(isp_auth)\n\n    @property\n    def identity_connectors(self) -&gt; ArkIdentityConnectorsService:\n        \"\"\"\n        Getter for the identity connectors service\n\n        Returns:\n            ArkIdentityConnectorsService: _description_\n        \"\"\"\n        return self.__identity_connectors\n\n    @property\n    def identity_directories(self) -&gt; ArkIdentityDirectoriesService:\n        \"\"\"\n        Getter for the identity directories service\n\n        Returns:\n            ArkIdentityDirectoriesService: _description_\n        \"\"\"\n        return self.__identity_directories\n\n    @property\n    def identity_policies(self) -&gt; ArkIdentityPoliciesService:\n        \"\"\"\n        Getter for the identity policies service\n\n        Returns:\n            ArkIdentityPoliciesService: _description_\n        \"\"\"\n        return self.__identity_policies\n\n    @property\n    def identity_roles(self) -&gt; ArkIdentityRolesService:\n        \"\"\"\n        Getter for the identity roles service\n\n        Returns:\n            ArkIdentityRolesService: _description_\n        \"\"\"\n        return self.__identity_roles\n\n    @property\n    def identity_users(self) -&gt; ArkIdentityUsersService:\n        \"\"\"\n        Getter for the identity users service\n\n        Returns:\n            ArkIdentityUsersService: _description_\n        \"\"\"\n        return self.__identity_users\n</code></pre>"},{"location":"reference/services/identity/#ark_sdk_python.services.identity.ArkIdentityAPI.identity_connectors","title":"<code>identity_connectors</code>  <code>property</code>","text":"<p>Getter for the identity connectors service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityConnectorsService</code> <code>ArkIdentityConnectorsService</code> <p>description</p>"},{"location":"reference/services/identity/#ark_sdk_python.services.identity.ArkIdentityAPI.identity_directories","title":"<code>identity_directories</code>  <code>property</code>","text":"<p>Getter for the identity directories service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityDirectoriesService</code> <code>ArkIdentityDirectoriesService</code> <p>description</p>"},{"location":"reference/services/identity/#ark_sdk_python.services.identity.ArkIdentityAPI.identity_policies","title":"<code>identity_policies</code>  <code>property</code>","text":"<p>Getter for the identity policies service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityPoliciesService</code> <code>ArkIdentityPoliciesService</code> <p>description</p>"},{"location":"reference/services/identity/#ark_sdk_python.services.identity.ArkIdentityAPI.identity_roles","title":"<code>identity_roles</code>  <code>property</code>","text":"<p>Getter for the identity roles service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityRolesService</code> <code>ArkIdentityRolesService</code> <p>description</p>"},{"location":"reference/services/identity/#ark_sdk_python.services.identity.ArkIdentityAPI.identity_users","title":"<code>identity_users</code>  <code>property</code>","text":"<p>Getter for the identity users service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUsersService</code> <code>ArkIdentityUsersService</code> <p>description</p>"},{"location":"reference/services/identity/ark_identity_api/","title":"ark_identity_api","text":""},{"location":"reference/services/identity/ark_identity_api/#ark_sdk_python.services.identity.ark_identity_api.ArkIdentityAPI","title":"<code>ArkIdentityAPI</code>","text":"Source code in <code>ark_sdk_python/services/identity/ark_identity_api.py</code> <pre><code>class ArkIdentityAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__identity_connectors = ArkIdentityConnectorsService(isp_auth)\n        self.__identity_directories = ArkIdentityDirectoriesService(isp_auth)\n        self.__identity_policies = ArkIdentityPoliciesService(isp_auth)\n        self.__identity_roles = ArkIdentityRolesService(isp_auth)\n        self.__identity_users = ArkIdentityUsersService(isp_auth)\n\n    @property\n    def identity_connectors(self) -&gt; ArkIdentityConnectorsService:\n        \"\"\"\n        Getter for the identity connectors service\n\n        Returns:\n            ArkIdentityConnectorsService: _description_\n        \"\"\"\n        return self.__identity_connectors\n\n    @property\n    def identity_directories(self) -&gt; ArkIdentityDirectoriesService:\n        \"\"\"\n        Getter for the identity directories service\n\n        Returns:\n            ArkIdentityDirectoriesService: _description_\n        \"\"\"\n        return self.__identity_directories\n\n    @property\n    def identity_policies(self) -&gt; ArkIdentityPoliciesService:\n        \"\"\"\n        Getter for the identity policies service\n\n        Returns:\n            ArkIdentityPoliciesService: _description_\n        \"\"\"\n        return self.__identity_policies\n\n    @property\n    def identity_roles(self) -&gt; ArkIdentityRolesService:\n        \"\"\"\n        Getter for the identity roles service\n\n        Returns:\n            ArkIdentityRolesService: _description_\n        \"\"\"\n        return self.__identity_roles\n\n    @property\n    def identity_users(self) -&gt; ArkIdentityUsersService:\n        \"\"\"\n        Getter for the identity users service\n\n        Returns:\n            ArkIdentityUsersService: _description_\n        \"\"\"\n        return self.__identity_users\n</code></pre>"},{"location":"reference/services/identity/ark_identity_api/#ark_sdk_python.services.identity.ark_identity_api.ArkIdentityAPI.identity_connectors","title":"<code>identity_connectors</code>  <code>property</code>","text":"<p>Getter for the identity connectors service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityConnectorsService</code> <code>ArkIdentityConnectorsService</code> <p>description</p>"},{"location":"reference/services/identity/ark_identity_api/#ark_sdk_python.services.identity.ark_identity_api.ArkIdentityAPI.identity_directories","title":"<code>identity_directories</code>  <code>property</code>","text":"<p>Getter for the identity directories service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityDirectoriesService</code> <code>ArkIdentityDirectoriesService</code> <p>description</p>"},{"location":"reference/services/identity/ark_identity_api/#ark_sdk_python.services.identity.ark_identity_api.ArkIdentityAPI.identity_policies","title":"<code>identity_policies</code>  <code>property</code>","text":"<p>Getter for the identity policies service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityPoliciesService</code> <code>ArkIdentityPoliciesService</code> <p>description</p>"},{"location":"reference/services/identity/ark_identity_api/#ark_sdk_python.services.identity.ark_identity_api.ArkIdentityAPI.identity_roles","title":"<code>identity_roles</code>  <code>property</code>","text":"<p>Getter for the identity roles service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityRolesService</code> <code>ArkIdentityRolesService</code> <p>description</p>"},{"location":"reference/services/identity/ark_identity_api/#ark_sdk_python.services.identity.ark_identity_api.ArkIdentityAPI.identity_users","title":"<code>identity_users</code>  <code>property</code>","text":"<p>Getter for the identity users service</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUsersService</code> <code>ArkIdentityUsersService</code> <p>description</p>"},{"location":"reference/services/identity/common/","title":"common","text":""},{"location":"reference/services/identity/common/ark_identity_base_service/","title":"ark_identity_base_service","text":""},{"location":"reference/services/identity/connectors/","title":"connectors","text":""},{"location":"reference/services/identity/connectors/#ark_sdk_python.services.identity.connectors.ArkIdentityConnectorsService","title":"<code>ArkIdentityConnectorsService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>class ArkIdentityConnectorsService(ArkIdentityBaseService):\n    def list_connectors(self) -&gt; List[ArkIdentityConnectorInfo]:\n        \"\"\"\n        Lists all identity connectors on the tenant\n\n        Returns:\n            List[ArkIdentityConnectorInfo]: _description_\n        \"\"\"\n        self._logger.info('Listing all identity connectors')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": \"Select * from Proxy\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve identity connectors [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success']:\n                raise ArkServiceException('Failed to retrieve identity connectors')\n            if len(query_result['Result'][\"Results\"]) == 0:\n                return []\n            return TypeAdapter(List[ArkIdentityConnectorInfo]).validate_python([r['Row'] for r in query_result['Result'][\"Results\"]])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to retrieve identity connectors [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to retrieve identity connectors [{str(ex)}]') from ex\n\n    def list_connectors_by(self, connectors_filter: ArkIdentityConnectorsFilter) -&gt; List[ArkIdentityConnectorInfo]:\n        \"\"\"\n        Lists identity connectors on the tenant by filters\n\n        Args:\n            connectors_filter (ArkIdentityConnectorsFilter): _description_\n\n        Returns:\n            List[ArkIdentityConnectorInfo]: _description_\n        \"\"\"\n        self._logger.info(f'Listing identity connectors by filters [{connectors_filter}]')\n        connectors = self.list_connectors()\n\n        # Filter by connector online / offline\n        if connectors_filter.online is not None:\n            connectors = [c for c in connectors if c.online == connectors_filter.online]\n\n        # Filter by forest\n        if connectors_filter.forest:\n            connectors = [c for c in connectors if fnmatch(c.forest, connectors_filter.forest)]\n\n        # Filter by dns\n        if connectors_filter.dns:\n            connectors = [c for c in connectors if fnmatch(c.dns_host_name, connectors_filter.dns)]\n\n        # Filter by machine name\n        if connectors_filter.machine_name:\n            connectors = [c for c in connectors if fnmatch(c.machine_name, connectors_filter.machine_name)]\n\n        # Filter by customer name\n        if connectors_filter.customer_name:\n            connectors = [c for c in connectors if fnmatch(c.customer_name, connectors_filter.customer_name)]\n\n        # Filter by forest\n        if connectors_filter.version:\n            connectors = [c for c in connectors if fnmatch(c.version, connectors_filter.version)]\n\n        return connectors\n\n    def connector(self, get_connector: ArkIdentityGetConnector) -&gt; ArkIdentityConnectorInfo:\n        \"\"\"\n        Retrieves a connector by id\n\n        Args:\n            get_connector (ArkIdentityGetConnector): _description_\n\n        Returns:\n            ArkIdentityConnectorInfo: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving identity connector by id [{get_connector.connector_id}]')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": f\"Select * from Proxy WHERE ID='{get_connector.connector_id}'\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve identity connector by id [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve identity connector by id')\n            return ArkIdentityConnectorInfo.model_validate(query_result['Result'][\"Results\"][0]['Row'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to retrieve identity connector by id [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to retrieve identity connector by id [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/connectors/#ark_sdk_python.services.identity.connectors.ArkIdentityConnectorsService.connector","title":"<code>connector(get_connector)</code>","text":"<p>Retrieves a connector by id</p> <p>Parameters:</p> Name Type Description Default <code>get_connector</code> <code>ArkIdentityGetConnector</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityConnectorInfo</code> <code>ArkIdentityConnectorInfo</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>def connector(self, get_connector: ArkIdentityGetConnector) -&gt; ArkIdentityConnectorInfo:\n    \"\"\"\n    Retrieves a connector by id\n\n    Args:\n        get_connector (ArkIdentityGetConnector): _description_\n\n    Returns:\n        ArkIdentityConnectorInfo: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving identity connector by id [{get_connector.connector_id}]')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": f\"Select * from Proxy WHERE ID='{get_connector.connector_id}'\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve identity connector by id [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve identity connector by id')\n        return ArkIdentityConnectorInfo.model_validate(query_result['Result'][\"Results\"][0]['Row'])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to retrieve identity connector by id [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to retrieve identity connector by id [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/connectors/#ark_sdk_python.services.identity.connectors.ArkIdentityConnectorsService.list_connectors","title":"<code>list_connectors()</code>","text":"<p>Lists all identity connectors on the tenant</p> <p>Returns:</p> Type Description <code>List[ArkIdentityConnectorInfo]</code> <p>List[ArkIdentityConnectorInfo]: description</p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>def list_connectors(self) -&gt; List[ArkIdentityConnectorInfo]:\n    \"\"\"\n    Lists all identity connectors on the tenant\n\n    Returns:\n        List[ArkIdentityConnectorInfo]: _description_\n    \"\"\"\n    self._logger.info('Listing all identity connectors')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": \"Select * from Proxy\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve identity connectors [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success']:\n            raise ArkServiceException('Failed to retrieve identity connectors')\n        if len(query_result['Result'][\"Results\"]) == 0:\n            return []\n        return TypeAdapter(List[ArkIdentityConnectorInfo]).validate_python([r['Row'] for r in query_result['Result'][\"Results\"]])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to retrieve identity connectors [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to retrieve identity connectors [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/connectors/#ark_sdk_python.services.identity.connectors.ArkIdentityConnectorsService.list_connectors_by","title":"<code>list_connectors_by(connectors_filter)</code>","text":"<p>Lists identity connectors on the tenant by filters</p> <p>Parameters:</p> Name Type Description Default <code>connectors_filter</code> <code>ArkIdentityConnectorsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkIdentityConnectorInfo]</code> <p>List[ArkIdentityConnectorInfo]: description</p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>def list_connectors_by(self, connectors_filter: ArkIdentityConnectorsFilter) -&gt; List[ArkIdentityConnectorInfo]:\n    \"\"\"\n    Lists identity connectors on the tenant by filters\n\n    Args:\n        connectors_filter (ArkIdentityConnectorsFilter): _description_\n\n    Returns:\n        List[ArkIdentityConnectorInfo]: _description_\n    \"\"\"\n    self._logger.info(f'Listing identity connectors by filters [{connectors_filter}]')\n    connectors = self.list_connectors()\n\n    # Filter by connector online / offline\n    if connectors_filter.online is not None:\n        connectors = [c for c in connectors if c.online == connectors_filter.online]\n\n    # Filter by forest\n    if connectors_filter.forest:\n        connectors = [c for c in connectors if fnmatch(c.forest, connectors_filter.forest)]\n\n    # Filter by dns\n    if connectors_filter.dns:\n        connectors = [c for c in connectors if fnmatch(c.dns_host_name, connectors_filter.dns)]\n\n    # Filter by machine name\n    if connectors_filter.machine_name:\n        connectors = [c for c in connectors if fnmatch(c.machine_name, connectors_filter.machine_name)]\n\n    # Filter by customer name\n    if connectors_filter.customer_name:\n        connectors = [c for c in connectors if fnmatch(c.customer_name, connectors_filter.customer_name)]\n\n    # Filter by forest\n    if connectors_filter.version:\n        connectors = [c for c in connectors if fnmatch(c.version, connectors_filter.version)]\n\n    return connectors\n</code></pre>"},{"location":"reference/services/identity/connectors/ark_identity_connectors_service/","title":"ark_identity_connectors_service","text":""},{"location":"reference/services/identity/connectors/ark_identity_connectors_service/#ark_sdk_python.services.identity.connectors.ark_identity_connectors_service.ArkIdentityConnectorsService","title":"<code>ArkIdentityConnectorsService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>class ArkIdentityConnectorsService(ArkIdentityBaseService):\n    def list_connectors(self) -&gt; List[ArkIdentityConnectorInfo]:\n        \"\"\"\n        Lists all identity connectors on the tenant\n\n        Returns:\n            List[ArkIdentityConnectorInfo]: _description_\n        \"\"\"\n        self._logger.info('Listing all identity connectors')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": \"Select * from Proxy\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve identity connectors [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success']:\n                raise ArkServiceException('Failed to retrieve identity connectors')\n            if len(query_result['Result'][\"Results\"]) == 0:\n                return []\n            return TypeAdapter(List[ArkIdentityConnectorInfo]).validate_python([r['Row'] for r in query_result['Result'][\"Results\"]])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to retrieve identity connectors [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to retrieve identity connectors [{str(ex)}]') from ex\n\n    def list_connectors_by(self, connectors_filter: ArkIdentityConnectorsFilter) -&gt; List[ArkIdentityConnectorInfo]:\n        \"\"\"\n        Lists identity connectors on the tenant by filters\n\n        Args:\n            connectors_filter (ArkIdentityConnectorsFilter): _description_\n\n        Returns:\n            List[ArkIdentityConnectorInfo]: _description_\n        \"\"\"\n        self._logger.info(f'Listing identity connectors by filters [{connectors_filter}]')\n        connectors = self.list_connectors()\n\n        # Filter by connector online / offline\n        if connectors_filter.online is not None:\n            connectors = [c for c in connectors if c.online == connectors_filter.online]\n\n        # Filter by forest\n        if connectors_filter.forest:\n            connectors = [c for c in connectors if fnmatch(c.forest, connectors_filter.forest)]\n\n        # Filter by dns\n        if connectors_filter.dns:\n            connectors = [c for c in connectors if fnmatch(c.dns_host_name, connectors_filter.dns)]\n\n        # Filter by machine name\n        if connectors_filter.machine_name:\n            connectors = [c for c in connectors if fnmatch(c.machine_name, connectors_filter.machine_name)]\n\n        # Filter by customer name\n        if connectors_filter.customer_name:\n            connectors = [c for c in connectors if fnmatch(c.customer_name, connectors_filter.customer_name)]\n\n        # Filter by forest\n        if connectors_filter.version:\n            connectors = [c for c in connectors if fnmatch(c.version, connectors_filter.version)]\n\n        return connectors\n\n    def connector(self, get_connector: ArkIdentityGetConnector) -&gt; ArkIdentityConnectorInfo:\n        \"\"\"\n        Retrieves a connector by id\n\n        Args:\n            get_connector (ArkIdentityGetConnector): _description_\n\n        Returns:\n            ArkIdentityConnectorInfo: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving identity connector by id [{get_connector.connector_id}]')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": f\"Select * from Proxy WHERE ID='{get_connector.connector_id}'\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve identity connector by id [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve identity connector by id')\n            return ArkIdentityConnectorInfo.model_validate(query_result['Result'][\"Results\"][0]['Row'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to retrieve identity connector by id [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to retrieve identity connector by id [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/connectors/ark_identity_connectors_service/#ark_sdk_python.services.identity.connectors.ark_identity_connectors_service.ArkIdentityConnectorsService.connector","title":"<code>connector(get_connector)</code>","text":"<p>Retrieves a connector by id</p> <p>Parameters:</p> Name Type Description Default <code>get_connector</code> <code>ArkIdentityGetConnector</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityConnectorInfo</code> <code>ArkIdentityConnectorInfo</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>def connector(self, get_connector: ArkIdentityGetConnector) -&gt; ArkIdentityConnectorInfo:\n    \"\"\"\n    Retrieves a connector by id\n\n    Args:\n        get_connector (ArkIdentityGetConnector): _description_\n\n    Returns:\n        ArkIdentityConnectorInfo: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving identity connector by id [{get_connector.connector_id}]')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": f\"Select * from Proxy WHERE ID='{get_connector.connector_id}'\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve identity connector by id [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve identity connector by id')\n        return ArkIdentityConnectorInfo.model_validate(query_result['Result'][\"Results\"][0]['Row'])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to retrieve identity connector by id [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to retrieve identity connector by id [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/connectors/ark_identity_connectors_service/#ark_sdk_python.services.identity.connectors.ark_identity_connectors_service.ArkIdentityConnectorsService.list_connectors","title":"<code>list_connectors()</code>","text":"<p>Lists all identity connectors on the tenant</p> <p>Returns:</p> Type Description <code>List[ArkIdentityConnectorInfo]</code> <p>List[ArkIdentityConnectorInfo]: description</p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>def list_connectors(self) -&gt; List[ArkIdentityConnectorInfo]:\n    \"\"\"\n    Lists all identity connectors on the tenant\n\n    Returns:\n        List[ArkIdentityConnectorInfo]: _description_\n    \"\"\"\n    self._logger.info('Listing all identity connectors')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": \"Select * from Proxy\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve identity connectors [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success']:\n            raise ArkServiceException('Failed to retrieve identity connectors')\n        if len(query_result['Result'][\"Results\"]) == 0:\n            return []\n        return TypeAdapter(List[ArkIdentityConnectorInfo]).validate_python([r['Row'] for r in query_result['Result'][\"Results\"]])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to retrieve identity connectors [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to retrieve identity connectors [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/connectors/ark_identity_connectors_service/#ark_sdk_python.services.identity.connectors.ark_identity_connectors_service.ArkIdentityConnectorsService.list_connectors_by","title":"<code>list_connectors_by(connectors_filter)</code>","text":"<p>Lists identity connectors on the tenant by filters</p> <p>Parameters:</p> Name Type Description Default <code>connectors_filter</code> <code>ArkIdentityConnectorsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkIdentityConnectorInfo]</code> <p>List[ArkIdentityConnectorInfo]: description</p> Source code in <code>ark_sdk_python/services/identity/connectors/ark_identity_connectors_service.py</code> <pre><code>def list_connectors_by(self, connectors_filter: ArkIdentityConnectorsFilter) -&gt; List[ArkIdentityConnectorInfo]:\n    \"\"\"\n    Lists identity connectors on the tenant by filters\n\n    Args:\n        connectors_filter (ArkIdentityConnectorsFilter): _description_\n\n    Returns:\n        List[ArkIdentityConnectorInfo]: _description_\n    \"\"\"\n    self._logger.info(f'Listing identity connectors by filters [{connectors_filter}]')\n    connectors = self.list_connectors()\n\n    # Filter by connector online / offline\n    if connectors_filter.online is not None:\n        connectors = [c for c in connectors if c.online == connectors_filter.online]\n\n    # Filter by forest\n    if connectors_filter.forest:\n        connectors = [c for c in connectors if fnmatch(c.forest, connectors_filter.forest)]\n\n    # Filter by dns\n    if connectors_filter.dns:\n        connectors = [c for c in connectors if fnmatch(c.dns_host_name, connectors_filter.dns)]\n\n    # Filter by machine name\n    if connectors_filter.machine_name:\n        connectors = [c for c in connectors if fnmatch(c.machine_name, connectors_filter.machine_name)]\n\n    # Filter by customer name\n    if connectors_filter.customer_name:\n        connectors = [c for c in connectors if fnmatch(c.customer_name, connectors_filter.customer_name)]\n\n    # Filter by forest\n    if connectors_filter.version:\n        connectors = [c for c in connectors if fnmatch(c.version, connectors_filter.version)]\n\n    return connectors\n</code></pre>"},{"location":"reference/services/identity/directories/","title":"directories","text":""},{"location":"reference/services/identity/directories/#ark_sdk_python.services.identity.directories.ArkIdentityDirectoriesService","title":"<code>ArkIdentityDirectoriesService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>class ArkIdentityDirectoriesService(ArkIdentityBaseService):\n    def list_directories(self, list_directories: ArkIdentityListDirectories) -&gt; List[ArkIdentityDirectory]:\n        \"\"\"\n        Get directories for given types\n\n        Args:\n            list_directories (ArkIdentityListDirectories): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkIdentityDirectory]: _description_\n        \"\"\"\n        if not list_directories.directories:\n            list_directories.directories = [d for d in DirectoryService]\n        self._logger.info(f'Retrieving directory services for directories [{list_directories}] [{self._url_prefix}]')\n        response: Response = self._client.get(f'{self._url_prefix}{GET_DIRECTORY_SERVICES_URL}', data={})\n        try:\n            directory_services_result = GetDirectoryServicesResponse.model_validate_json(response.text)\n            requested_directories = set(item.value for item in list_directories.directories)\n            requested_services = list(\n                filter(lambda service: service.row.service in requested_directories, directory_services_result.result.results)\n            )\n            if len(requested_services) == 0:\n                raise ArkServiceException(f'Could not find any directory services matching {requested_directories}')\n            directories = list(\n                map(\n                    lambda service: ArkIdentityDirectory(\n                        directory=DirectoryService(service.row.service), directory_service_uuid=service.row.directory_service_uuid\n                    ),\n                    requested_services,\n                )\n            )\n            return directories\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse directory services response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse directory services response [{str(ex)}]') from ex\n\n    def list_directories_entities(self, list_directories_entities: ArkIdentityListDirectoriesEntities) -&gt; Iterator[ArkIdentityEntitiesPage]:\n        \"\"\"\n        Lists given directories entities by filters of search and type and directories\n        Yields pages of entities\n\n        Args:\n            list_directories_entities (ArkIdentityListDirectoriesEntities): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkIdentityEntitiesPage]: _description_\n        \"\"\"\n        self._logger.info('Listing directories entities')\n        directories = [\n            d.directory_service_uuid\n            for d in self.list_directories(\n                ArkIdentityListDirectories(directories=list_directories_entities.directories or [d for d in DirectoryService])\n            )\n        ]\n        exclusion_list = set()\n        if list_directories_entities.entity_types:\n            if ArkIdentityEntityType.User not in list_directories_entities.entity_types:\n                exclusion_list.add('user')\n            if ArkIdentityEntityType.Group not in list_directories_entities.entity_types:\n                exclusion_list.add('group')\n            if ArkIdentityEntityType.Role not in list_directories_entities.entity_types:\n                exclusion_list.add('roles')\n        response: Response = self._idp_client.post(\n            DIRECTORY_SERVICE_QUERY_URL,\n            json=DirectoryServiceQueryRequest(\n                directory_services=directories,\n                search_string=list_directories_entities.search,\n                args=DirectorySearchArgs(\n                    limit=list_directories_entities.limit, page_number=1, page_size=list_directories_entities.page_size\n                ),\n            ).model_dump(by_alias=True, exclude=exclusion_list),\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to query for directory services entities [{response.text}] - [{response.status_code}]')\n        try:\n            result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n            entities: List[ArkIdentityEntity] = []\n            if result.result.users and result.result.users.results:\n                for user in result.result.users.results:\n                    entities.append(\n                        ArkIdentityUserEntity(\n                            id=user.row.internal_id,\n                            name=user.row.system_name,\n                            entity_type=ArkIdentityEntityType.User,\n                            directory_service_type=user.row.directory_service_type,\n                            display_name=user.row.display_name,\n                            service_instance_localized=user.row.service_instance_localized,\n                            email=user.row.email,\n                            description=user.row.description,\n                        )\n                    )\n            if result.result.groups and result.result.groups.results:\n                for group in result.result.groups.results:\n                    entities.append(\n                        ArkIdentityGroupEntity(\n                            id=group.row.internal_id,\n                            name=group.row.system_name,\n                            entity_type=ArkIdentityEntityType.Group,\n                            directory_service_type=group.row.directory_service_type,\n                            display_name=group.row.display_name,\n                            service_instance_localized=group.row.service_instance_localized,\n                        )\n                    )\n            if result.result.roles and result.result.roles.results:\n                for role in result.result.roles.results:\n                    entities.append(\n                        ArkIdentityRoleEntity(\n                            id=role.row.id,\n                            name=role.row.name,\n                            entity_type=ArkIdentityEntityType.Role,\n                            directory_service_type=DirectoryService.Identity,\n                            display_name=role.row.name,\n                            service_instance_localized=DirectoryService.Identity.value,\n                            admin_rights=role.row.admin_rights,\n                            is_hidden=role.row.is_hidden or False,\n                            description=role.row.description,\n                        )\n                    )\n            while entities:\n                if len(entities) &lt;= list_directories_entities.page_size:\n                    yield ArkIdentityEntitiesPage(entities)\n                    break\n                else:\n                    page = entities[: list_directories_entities.page_size]\n                    entities = entities[list_directories_entities.page_size :]\n                    yield ArkIdentityEntitiesPage(page)\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse list directories entities response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list directories entities response [{str(ex)}]') from ex\n\n    def tenant_default_suffix(self) -&gt; str:\n        \"\"\"\n        Retrieves the tenant default suffix found in identity\n        The suffix is used when creating users based on whats configured on the tenant\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        self._logger.info('Discovering default tenant suffix')\n        response: Response = self._client.post(f'{self._url_prefix}{TENANT_SUFFIX_URL}')\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get directory services [{response.text}]')\n        try:\n            tenant_suffixes_result: GetTenantSuffixResult = GetTenantSuffixResult.model_validate_json(response.text)\n            tenant_suffixes_list: List[str] = [result['Entities'][0]['Key'] for result in tenant_suffixes_result.result['Results']]\n            if len(tenant_suffixes_list) == 0:\n                raise ArkServiceException('No tenant suffix has been found')\n            filtered_urls = list(\n                filter(\n                    lambda suffix: check_if_identity_generated_suffix(suffix, self._env) or SHELL_DOMAIN[self._env] in suffix,\n                    tenant_suffixes_list,\n                )\n            )\n            if filtered_urls:\n                return filtered_urls[0]\n            return tenant_suffixes_list[0]\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse tenant default suffix response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse tenant default suffix response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/directories/#ark_sdk_python.services.identity.directories.ArkIdentityDirectoriesService.list_directories","title":"<code>list_directories(list_directories)</code>","text":"<p>Get directories for given types</p> <p>Parameters:</p> Name Type Description Default <code>list_directories</code> <code>ArkIdentityListDirectories</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkIdentityDirectory]</code> <p>List[ArkIdentityDirectory]: description</p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>def list_directories(self, list_directories: ArkIdentityListDirectories) -&gt; List[ArkIdentityDirectory]:\n    \"\"\"\n    Get directories for given types\n\n    Args:\n        list_directories (ArkIdentityListDirectories): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkIdentityDirectory]: _description_\n    \"\"\"\n    if not list_directories.directories:\n        list_directories.directories = [d for d in DirectoryService]\n    self._logger.info(f'Retrieving directory services for directories [{list_directories}] [{self._url_prefix}]')\n    response: Response = self._client.get(f'{self._url_prefix}{GET_DIRECTORY_SERVICES_URL}', data={})\n    try:\n        directory_services_result = GetDirectoryServicesResponse.model_validate_json(response.text)\n        requested_directories = set(item.value for item in list_directories.directories)\n        requested_services = list(\n            filter(lambda service: service.row.service in requested_directories, directory_services_result.result.results)\n        )\n        if len(requested_services) == 0:\n            raise ArkServiceException(f'Could not find any directory services matching {requested_directories}')\n        directories = list(\n            map(\n                lambda service: ArkIdentityDirectory(\n                    directory=DirectoryService(service.row.service), directory_service_uuid=service.row.directory_service_uuid\n                ),\n                requested_services,\n            )\n        )\n        return directories\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse directory services response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse directory services response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/directories/#ark_sdk_python.services.identity.directories.ArkIdentityDirectoriesService.list_directories_entities","title":"<code>list_directories_entities(list_directories_entities)</code>","text":"<p>Lists given directories entities by filters of search and type and directories Yields pages of entities</p> <p>Parameters:</p> Name Type Description Default <code>list_directories_entities</code> <code>ArkIdentityListDirectoriesEntities</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkIdentityEntitiesPage</code> <p>Iterator[ArkIdentityEntitiesPage]: description</p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>def list_directories_entities(self, list_directories_entities: ArkIdentityListDirectoriesEntities) -&gt; Iterator[ArkIdentityEntitiesPage]:\n    \"\"\"\n    Lists given directories entities by filters of search and type and directories\n    Yields pages of entities\n\n    Args:\n        list_directories_entities (ArkIdentityListDirectoriesEntities): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkIdentityEntitiesPage]: _description_\n    \"\"\"\n    self._logger.info('Listing directories entities')\n    directories = [\n        d.directory_service_uuid\n        for d in self.list_directories(\n            ArkIdentityListDirectories(directories=list_directories_entities.directories or [d for d in DirectoryService])\n        )\n    ]\n    exclusion_list = set()\n    if list_directories_entities.entity_types:\n        if ArkIdentityEntityType.User not in list_directories_entities.entity_types:\n            exclusion_list.add('user')\n        if ArkIdentityEntityType.Group not in list_directories_entities.entity_types:\n            exclusion_list.add('group')\n        if ArkIdentityEntityType.Role not in list_directories_entities.entity_types:\n            exclusion_list.add('roles')\n    response: Response = self._idp_client.post(\n        DIRECTORY_SERVICE_QUERY_URL,\n        json=DirectoryServiceQueryRequest(\n            directory_services=directories,\n            search_string=list_directories_entities.search,\n            args=DirectorySearchArgs(\n                limit=list_directories_entities.limit, page_number=1, page_size=list_directories_entities.page_size\n            ),\n        ).model_dump(by_alias=True, exclude=exclusion_list),\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to query for directory services entities [{response.text}] - [{response.status_code}]')\n    try:\n        result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n        entities: List[ArkIdentityEntity] = []\n        if result.result.users and result.result.users.results:\n            for user in result.result.users.results:\n                entities.append(\n                    ArkIdentityUserEntity(\n                        id=user.row.internal_id,\n                        name=user.row.system_name,\n                        entity_type=ArkIdentityEntityType.User,\n                        directory_service_type=user.row.directory_service_type,\n                        display_name=user.row.display_name,\n                        service_instance_localized=user.row.service_instance_localized,\n                        email=user.row.email,\n                        description=user.row.description,\n                    )\n                )\n        if result.result.groups and result.result.groups.results:\n            for group in result.result.groups.results:\n                entities.append(\n                    ArkIdentityGroupEntity(\n                        id=group.row.internal_id,\n                        name=group.row.system_name,\n                        entity_type=ArkIdentityEntityType.Group,\n                        directory_service_type=group.row.directory_service_type,\n                        display_name=group.row.display_name,\n                        service_instance_localized=group.row.service_instance_localized,\n                    )\n                )\n        if result.result.roles and result.result.roles.results:\n            for role in result.result.roles.results:\n                entities.append(\n                    ArkIdentityRoleEntity(\n                        id=role.row.id,\n                        name=role.row.name,\n                        entity_type=ArkIdentityEntityType.Role,\n                        directory_service_type=DirectoryService.Identity,\n                        display_name=role.row.name,\n                        service_instance_localized=DirectoryService.Identity.value,\n                        admin_rights=role.row.admin_rights,\n                        is_hidden=role.row.is_hidden or False,\n                        description=role.row.description,\n                    )\n                )\n        while entities:\n            if len(entities) &lt;= list_directories_entities.page_size:\n                yield ArkIdentityEntitiesPage(entities)\n                break\n            else:\n                page = entities[: list_directories_entities.page_size]\n                entities = entities[list_directories_entities.page_size :]\n                yield ArkIdentityEntitiesPage(page)\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse list directories entities response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list directories entities response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/directories/#ark_sdk_python.services.identity.directories.ArkIdentityDirectoriesService.tenant_default_suffix","title":"<code>tenant_default_suffix()</code>","text":"<p>Retrieves the tenant default suffix found in identity The suffix is used when creating users based on whats configured on the tenant</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>def tenant_default_suffix(self) -&gt; str:\n    \"\"\"\n    Retrieves the tenant default suffix found in identity\n    The suffix is used when creating users based on whats configured on the tenant\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    self._logger.info('Discovering default tenant suffix')\n    response: Response = self._client.post(f'{self._url_prefix}{TENANT_SUFFIX_URL}')\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to get directory services [{response.text}]')\n    try:\n        tenant_suffixes_result: GetTenantSuffixResult = GetTenantSuffixResult.model_validate_json(response.text)\n        tenant_suffixes_list: List[str] = [result['Entities'][0]['Key'] for result in tenant_suffixes_result.result['Results']]\n        if len(tenant_suffixes_list) == 0:\n            raise ArkServiceException('No tenant suffix has been found')\n        filtered_urls = list(\n            filter(\n                lambda suffix: check_if_identity_generated_suffix(suffix, self._env) or SHELL_DOMAIN[self._env] in suffix,\n                tenant_suffixes_list,\n            )\n        )\n        if filtered_urls:\n            return filtered_urls[0]\n        return tenant_suffixes_list[0]\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse tenant default suffix response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse tenant default suffix response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/directories/ark_identity_directories_service/","title":"ark_identity_directories_service","text":""},{"location":"reference/services/identity/directories/ark_identity_directories_service/#ark_sdk_python.services.identity.directories.ark_identity_directories_service.ArkIdentityDirectoriesService","title":"<code>ArkIdentityDirectoriesService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>class ArkIdentityDirectoriesService(ArkIdentityBaseService):\n    def list_directories(self, list_directories: ArkIdentityListDirectories) -&gt; List[ArkIdentityDirectory]:\n        \"\"\"\n        Get directories for given types\n\n        Args:\n            list_directories (ArkIdentityListDirectories): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkIdentityDirectory]: _description_\n        \"\"\"\n        if not list_directories.directories:\n            list_directories.directories = [d for d in DirectoryService]\n        self._logger.info(f'Retrieving directory services for directories [{list_directories}] [{self._url_prefix}]')\n        response: Response = self._client.get(f'{self._url_prefix}{GET_DIRECTORY_SERVICES_URL}', data={})\n        try:\n            directory_services_result = GetDirectoryServicesResponse.model_validate_json(response.text)\n            requested_directories = set(item.value for item in list_directories.directories)\n            requested_services = list(\n                filter(lambda service: service.row.service in requested_directories, directory_services_result.result.results)\n            )\n            if len(requested_services) == 0:\n                raise ArkServiceException(f'Could not find any directory services matching {requested_directories}')\n            directories = list(\n                map(\n                    lambda service: ArkIdentityDirectory(\n                        directory=DirectoryService(service.row.service), directory_service_uuid=service.row.directory_service_uuid\n                    ),\n                    requested_services,\n                )\n            )\n            return directories\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse directory services response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse directory services response [{str(ex)}]') from ex\n\n    def list_directories_entities(self, list_directories_entities: ArkIdentityListDirectoriesEntities) -&gt; Iterator[ArkIdentityEntitiesPage]:\n        \"\"\"\n        Lists given directories entities by filters of search and type and directories\n        Yields pages of entities\n\n        Args:\n            list_directories_entities (ArkIdentityListDirectoriesEntities): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkIdentityEntitiesPage]: _description_\n        \"\"\"\n        self._logger.info('Listing directories entities')\n        directories = [\n            d.directory_service_uuid\n            for d in self.list_directories(\n                ArkIdentityListDirectories(directories=list_directories_entities.directories or [d for d in DirectoryService])\n            )\n        ]\n        exclusion_list = set()\n        if list_directories_entities.entity_types:\n            if ArkIdentityEntityType.User not in list_directories_entities.entity_types:\n                exclusion_list.add('user')\n            if ArkIdentityEntityType.Group not in list_directories_entities.entity_types:\n                exclusion_list.add('group')\n            if ArkIdentityEntityType.Role not in list_directories_entities.entity_types:\n                exclusion_list.add('roles')\n        response: Response = self._idp_client.post(\n            DIRECTORY_SERVICE_QUERY_URL,\n            json=DirectoryServiceQueryRequest(\n                directory_services=directories,\n                search_string=list_directories_entities.search,\n                args=DirectorySearchArgs(\n                    limit=list_directories_entities.limit, page_number=1, page_size=list_directories_entities.page_size\n                ),\n            ).model_dump(by_alias=True, exclude=exclusion_list),\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to query for directory services entities [{response.text}] - [{response.status_code}]')\n        try:\n            result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n            entities: List[ArkIdentityEntity] = []\n            if result.result.users and result.result.users.results:\n                for user in result.result.users.results:\n                    entities.append(\n                        ArkIdentityUserEntity(\n                            id=user.row.internal_id,\n                            name=user.row.system_name,\n                            entity_type=ArkIdentityEntityType.User,\n                            directory_service_type=user.row.directory_service_type,\n                            display_name=user.row.display_name,\n                            service_instance_localized=user.row.service_instance_localized,\n                            email=user.row.email,\n                            description=user.row.description,\n                        )\n                    )\n            if result.result.groups and result.result.groups.results:\n                for group in result.result.groups.results:\n                    entities.append(\n                        ArkIdentityGroupEntity(\n                            id=group.row.internal_id,\n                            name=group.row.system_name,\n                            entity_type=ArkIdentityEntityType.Group,\n                            directory_service_type=group.row.directory_service_type,\n                            display_name=group.row.display_name,\n                            service_instance_localized=group.row.service_instance_localized,\n                        )\n                    )\n            if result.result.roles and result.result.roles.results:\n                for role in result.result.roles.results:\n                    entities.append(\n                        ArkIdentityRoleEntity(\n                            id=role.row.id,\n                            name=role.row.name,\n                            entity_type=ArkIdentityEntityType.Role,\n                            directory_service_type=DirectoryService.Identity,\n                            display_name=role.row.name,\n                            service_instance_localized=DirectoryService.Identity.value,\n                            admin_rights=role.row.admin_rights,\n                            is_hidden=role.row.is_hidden or False,\n                            description=role.row.description,\n                        )\n                    )\n            while entities:\n                if len(entities) &lt;= list_directories_entities.page_size:\n                    yield ArkIdentityEntitiesPage(entities)\n                    break\n                else:\n                    page = entities[: list_directories_entities.page_size]\n                    entities = entities[list_directories_entities.page_size :]\n                    yield ArkIdentityEntitiesPage(page)\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse list directories entities response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list directories entities response [{str(ex)}]') from ex\n\n    def tenant_default_suffix(self) -&gt; str:\n        \"\"\"\n        Retrieves the tenant default suffix found in identity\n        The suffix is used when creating users based on whats configured on the tenant\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        self._logger.info('Discovering default tenant suffix')\n        response: Response = self._client.post(f'{self._url_prefix}{TENANT_SUFFIX_URL}')\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get directory services [{response.text}]')\n        try:\n            tenant_suffixes_result: GetTenantSuffixResult = GetTenantSuffixResult.model_validate_json(response.text)\n            tenant_suffixes_list: List[str] = [result['Entities'][0]['Key'] for result in tenant_suffixes_result.result['Results']]\n            if len(tenant_suffixes_list) == 0:\n                raise ArkServiceException('No tenant suffix has been found')\n            filtered_urls = list(\n                filter(\n                    lambda suffix: check_if_identity_generated_suffix(suffix, self._env) or SHELL_DOMAIN[self._env] in suffix,\n                    tenant_suffixes_list,\n                )\n            )\n            if filtered_urls:\n                return filtered_urls[0]\n            return tenant_suffixes_list[0]\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse tenant default suffix response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse tenant default suffix response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/directories/ark_identity_directories_service/#ark_sdk_python.services.identity.directories.ark_identity_directories_service.ArkIdentityDirectoriesService.list_directories","title":"<code>list_directories(list_directories)</code>","text":"<p>Get directories for given types</p> <p>Parameters:</p> Name Type Description Default <code>list_directories</code> <code>ArkIdentityListDirectories</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkIdentityDirectory]</code> <p>List[ArkIdentityDirectory]: description</p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>def list_directories(self, list_directories: ArkIdentityListDirectories) -&gt; List[ArkIdentityDirectory]:\n    \"\"\"\n    Get directories for given types\n\n    Args:\n        list_directories (ArkIdentityListDirectories): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkIdentityDirectory]: _description_\n    \"\"\"\n    if not list_directories.directories:\n        list_directories.directories = [d for d in DirectoryService]\n    self._logger.info(f'Retrieving directory services for directories [{list_directories}] [{self._url_prefix}]')\n    response: Response = self._client.get(f'{self._url_prefix}{GET_DIRECTORY_SERVICES_URL}', data={})\n    try:\n        directory_services_result = GetDirectoryServicesResponse.model_validate_json(response.text)\n        requested_directories = set(item.value for item in list_directories.directories)\n        requested_services = list(\n            filter(lambda service: service.row.service in requested_directories, directory_services_result.result.results)\n        )\n        if len(requested_services) == 0:\n            raise ArkServiceException(f'Could not find any directory services matching {requested_directories}')\n        directories = list(\n            map(\n                lambda service: ArkIdentityDirectory(\n                    directory=DirectoryService(service.row.service), directory_service_uuid=service.row.directory_service_uuid\n                ),\n                requested_services,\n            )\n        )\n        return directories\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse directory services response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse directory services response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/directories/ark_identity_directories_service/#ark_sdk_python.services.identity.directories.ark_identity_directories_service.ArkIdentityDirectoriesService.list_directories_entities","title":"<code>list_directories_entities(list_directories_entities)</code>","text":"<p>Lists given directories entities by filters of search and type and directories Yields pages of entities</p> <p>Parameters:</p> Name Type Description Default <code>list_directories_entities</code> <code>ArkIdentityListDirectoriesEntities</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkIdentityEntitiesPage</code> <p>Iterator[ArkIdentityEntitiesPage]: description</p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>def list_directories_entities(self, list_directories_entities: ArkIdentityListDirectoriesEntities) -&gt; Iterator[ArkIdentityEntitiesPage]:\n    \"\"\"\n    Lists given directories entities by filters of search and type and directories\n    Yields pages of entities\n\n    Args:\n        list_directories_entities (ArkIdentityListDirectoriesEntities): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkIdentityEntitiesPage]: _description_\n    \"\"\"\n    self._logger.info('Listing directories entities')\n    directories = [\n        d.directory_service_uuid\n        for d in self.list_directories(\n            ArkIdentityListDirectories(directories=list_directories_entities.directories or [d for d in DirectoryService])\n        )\n    ]\n    exclusion_list = set()\n    if list_directories_entities.entity_types:\n        if ArkIdentityEntityType.User not in list_directories_entities.entity_types:\n            exclusion_list.add('user')\n        if ArkIdentityEntityType.Group not in list_directories_entities.entity_types:\n            exclusion_list.add('group')\n        if ArkIdentityEntityType.Role not in list_directories_entities.entity_types:\n            exclusion_list.add('roles')\n    response: Response = self._idp_client.post(\n        DIRECTORY_SERVICE_QUERY_URL,\n        json=DirectoryServiceQueryRequest(\n            directory_services=directories,\n            search_string=list_directories_entities.search,\n            args=DirectorySearchArgs(\n                limit=list_directories_entities.limit, page_number=1, page_size=list_directories_entities.page_size\n            ),\n        ).model_dump(by_alias=True, exclude=exclusion_list),\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to query for directory services entities [{response.text}] - [{response.status_code}]')\n    try:\n        result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n        entities: List[ArkIdentityEntity] = []\n        if result.result.users and result.result.users.results:\n            for user in result.result.users.results:\n                entities.append(\n                    ArkIdentityUserEntity(\n                        id=user.row.internal_id,\n                        name=user.row.system_name,\n                        entity_type=ArkIdentityEntityType.User,\n                        directory_service_type=user.row.directory_service_type,\n                        display_name=user.row.display_name,\n                        service_instance_localized=user.row.service_instance_localized,\n                        email=user.row.email,\n                        description=user.row.description,\n                    )\n                )\n        if result.result.groups and result.result.groups.results:\n            for group in result.result.groups.results:\n                entities.append(\n                    ArkIdentityGroupEntity(\n                        id=group.row.internal_id,\n                        name=group.row.system_name,\n                        entity_type=ArkIdentityEntityType.Group,\n                        directory_service_type=group.row.directory_service_type,\n                        display_name=group.row.display_name,\n                        service_instance_localized=group.row.service_instance_localized,\n                    )\n                )\n        if result.result.roles and result.result.roles.results:\n            for role in result.result.roles.results:\n                entities.append(\n                    ArkIdentityRoleEntity(\n                        id=role.row.id,\n                        name=role.row.name,\n                        entity_type=ArkIdentityEntityType.Role,\n                        directory_service_type=DirectoryService.Identity,\n                        display_name=role.row.name,\n                        service_instance_localized=DirectoryService.Identity.value,\n                        admin_rights=role.row.admin_rights,\n                        is_hidden=role.row.is_hidden or False,\n                        description=role.row.description,\n                    )\n                )\n        while entities:\n            if len(entities) &lt;= list_directories_entities.page_size:\n                yield ArkIdentityEntitiesPage(entities)\n                break\n            else:\n                page = entities[: list_directories_entities.page_size]\n                entities = entities[list_directories_entities.page_size :]\n                yield ArkIdentityEntitiesPage(page)\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse list directories entities response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list directories entities response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/directories/ark_identity_directories_service/#ark_sdk_python.services.identity.directories.ark_identity_directories_service.ArkIdentityDirectoriesService.tenant_default_suffix","title":"<code>tenant_default_suffix()</code>","text":"<p>Retrieves the tenant default suffix found in identity The suffix is used when creating users based on whats configured on the tenant</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/directories/ark_identity_directories_service.py</code> <pre><code>def tenant_default_suffix(self) -&gt; str:\n    \"\"\"\n    Retrieves the tenant default suffix found in identity\n    The suffix is used when creating users based on whats configured on the tenant\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    self._logger.info('Discovering default tenant suffix')\n    response: Response = self._client.post(f'{self._url_prefix}{TENANT_SUFFIX_URL}')\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to get directory services [{response.text}]')\n    try:\n        tenant_suffixes_result: GetTenantSuffixResult = GetTenantSuffixResult.model_validate_json(response.text)\n        tenant_suffixes_list: List[str] = [result['Entities'][0]['Key'] for result in tenant_suffixes_result.result['Results']]\n        if len(tenant_suffixes_list) == 0:\n            raise ArkServiceException('No tenant suffix has been found')\n        filtered_urls = list(\n            filter(\n                lambda suffix: check_if_identity_generated_suffix(suffix, self._env) or SHELL_DOMAIN[self._env] in suffix,\n                tenant_suffixes_list,\n            )\n        )\n        if filtered_urls:\n            return filtered_urls[0]\n        return tenant_suffixes_list[0]\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse tenant default suffix response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse tenant default suffix response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/","title":"policies","text":""},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService","title":"<code>ArkIdentityPoliciesService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>class ArkIdentityPoliciesService(ArkIdentityBaseService):\n    def add_authentication_profile(\n        self, add_authentication_profile: ArkIdentityAddAuthenticationProfile\n    ) -&gt; ArkIdentityAuthenticationProfile:\n        \"\"\"\n        Adds a new authentication profile\n\n        Args:\n            add_authentication_profile (ArkIdentityAddAuthenticationProfile): _description_\n\n        Returns:\n            ArkIdentityAuthenticationProfile: _description_\n        \"\"\"\n        self._logger.info(f'Adding authentication profile [{add_authentication_profile.auth_profile_name}]')\n        data = {\n            'settings': {\n                'Name': add_authentication_profile.auth_profile_name,\n                'Challenges': [','.join(add_authentication_profile.first_challenges)],\n                'DurationInMinutes': add_authentication_profile.duration_in_minutes,\n            }\n        }\n        if add_authentication_profile.second_challenges:\n            data['settings']['Challenges'].append(','.join(add_authentication_profile.second_challenges))\n        if add_authentication_profile.additional_data:\n            data['settings']['AdditionalData'] = add_authentication_profile.additional_data\n        response: Response = self._client.post(f'{self._url_prefix}{SAVE_PROFILE_URL}', json=data)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add authentication profile [{response.text}] - [{response.status_code}]')\n            return ArkIdentityAuthenticationProfile.model_validate(result['Result'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add authentication profile response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add authentication profile response [{str(ex)}]') from ex\n\n    def remove_authentication_profile(self, remove_authentication_profile: ArkIdentityRemoveAuthenticationProfile) -&gt; None:\n        \"\"\"\n        Removes an authentication profile by name or id\n\n        Args:\n            remove_authentication_profile (ArkIdentityRemoveAuthenticationProfile): _description_\n        \"\"\"\n        if remove_authentication_profile.auth_profile_name and not remove_authentication_profile.auth_profile_id:\n            remove_authentication_profile.auth_profile_id = self.authentication_profile(\n                ArkIdentityGetAuthenticationProfile(auth_profile_name=remove_authentication_profile.auth_profile_name)\n            ).uuid\n        self._logger.info(f'Removing authentication profile [{remove_authentication_profile.auth_profile_id}]')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{DELETE_PROFILE_URL}', json={'uuid': remove_authentication_profile.auth_profile_id}\n        )\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to remove authentication profile [{response.text}] - [{response.status_code}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove authentication profile response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove authentication profile response [{str(ex)}]') from ex\n\n    def list_authentication_profiles(self) -&gt; List[ArkIdentityAuthenticationProfile]:\n        \"\"\"\n        List available authentication profiles\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkIdentityAuthenticationProfile]: _description_\n        \"\"\"\n        self._logger.info('Listing authentication profiles')\n        response: Response = self._client.post(f'{self._url_prefix}{GET_PROFILES_URL}')\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list authentication profiles [{response.text}] - [{response.status_code}]')\n            return TypeAdapter(List[ArkIdentityAuthenticationProfile]).validate_python([r['Row'] for r in result['Result']['Results']])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list authentication profiles response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list authentication profiles response [{str(ex)}]') from ex\n\n    def authentication_profile(self, get_authentication_profile: ArkIdentityGetAuthenticationProfile) -&gt; ArkIdentityAuthenticationProfile:\n        \"\"\"\n        Retrieve an authentication profile by id or name\n\n        Args:\n            get_authentication_profile (ArkIdentityGetAuthenticationProfile): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityAuthenticationProfile: _description_\n        \"\"\"\n        self._logger.info('Retrieving authentication profile')\n        auth_profiles = self.list_authentication_profiles()\n        if get_authentication_profile.auth_profile_id:\n            auth_profiles = [p for p in auth_profiles if p.uuid == get_authentication_profile.auth_profile_id]\n        if get_authentication_profile.auth_profile_name:\n            auth_profiles = [p for p in auth_profiles if p.name == get_authentication_profile.auth_profile_name]\n        if len(auth_profiles) == 0:\n            raise ArkServiceException('Failed to find authentication profile')\n        return auth_profiles[0]\n\n    def add_policy(self, add_policy: ArkIdentityAddPolicy) -&gt; ArkIdentityPolicy:\n        \"\"\"\n        Adds a new policy\n\n        Args:\n            add_policy (ArkIdentityAddPolicy): _description_\n\n        Returns:\n            ArkIdentityPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding policy [{add_policy.policy_name}]')\n        roles_service = ArkIdentityRolesService(self._isp_auth)\n        policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n        policy_name = f'/Policy/{add_policy.policy_name}'\n        policy_link = {\n            \"Description\": add_policy.description,\n            \"PolicySet\": policy_name,\n            \"LinkType\": \"Role\",\n            \"Priority\": 1,\n            \"Params\": [roles_service.role_id_by_name(ArkIdentityRoleIdByName(role_name=role_name)) for role_name in add_policy.role_names],\n            \"Filters\": [],\n            \"Allowedpolicies\": [],\n        }\n        policies_list.insert(0, policy_link)\n        data = {\n            \"plinks\": policies_list,\n            \"policy\": {\n                \"Path\": policy_name,\n                \"Version\": 1,\n                \"Description\": add_policy.description,\n                \"Settings\": {\n                    \"AuthenticationEnabled\": 'true',\n                    \"/Core/Authentication/AuthenticationRulesDefaultProfileId\": self.authentication_profile(\n                        ArkIdentityGetAuthenticationProfile(auth_profile_name=add_policy.auth_profile_name)\n                    ).uuid,\n                    \"/Core/Authentication/CookieAllowPersist\": 'false',\n                    \"/Core/Authentication/AuthSessionMaxConcurrent\": 0,\n                    \"/Core/Authentication/AllowIwa\": 'true',\n                    \"/Core/Authentication/IwaSetKnownEndpoint\": 'false',\n                    \"/Core/Authentication/IwaSatisfiesAllMechs\": 'false',\n                    \"/Core/Authentication/AllowZso\": 'true',\n                    \"/Core/Authentication/ZsoSkipChallenge\": 'true',\n                    \"/Core/Authentication/ZsoSetKnownEndpoint\": 'false',\n                    \"/Core/Authentication/ZsoSatisfiesAllMechs\": 'false',\n                    \"/Core/Authentication/NoMfaMechLogin\": 'false',\n                    \"/Core/Authentication/FederatedLoginAllowsMfa\": 'false',\n                    \"/Core/Authentication/FederatedLoginSatisfiesAllMechs\": 'false',\n                    \"/Core/MfaRestrictions/BlockMobileMechsOnMobileLogin\": 'false',\n                    \"/Core/Authentication/ContinueFailedSessions\": 'true',\n                    \"/Core/Authentication/SkipMechsInFalseAdvance\": 'true',\n                    \"/Core/Authentication/AllowLoginMfaCache\": 'false',\n                },\n                \"Newpolicy\": 'true',\n            },\n        }\n        if add_policy.settings:\n            data['policy']['Settings'].update(add_policy.settings)\n        response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n            return self.policy(ArkIdentityGetPolicy(policy_name=add_policy.policy_name))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add policy response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add policy response [{str(ex)}]') from ex\n\n    def disable_default_policy(self) -&gt; None:\n        \"\"\"\n        Disables the default policy (makes it inactive)\n        \"\"\"\n        self.disable_policy(\n            disable_policy=ArkIdentityDisablePolicy(\n                policy_name='/Policy/Default Policy',\n            ),\n        )\n\n    def enable_default_policy(self) -&gt; None:\n        \"\"\"\n        Enables the default policy (makes it active)\n        \"\"\"\n        self.enable_policy(\n            enable_policy=ArkIdentityEnablePolicy(\n                policy_name='/Policy/Default Policy',\n            ),\n        )\n\n    def perform_action_on_policy(self, policy_operation: ArkIdentityPolicyOperation) -&gt; None:\n        \"\"\"\n        Performs operation on policy (enable/disable)\n\n        Args:\n            policy_operation (ArkIdentityPolicyOperation): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        policy_name = policy_operation.policy_name\n        policy = self.policy(get_policy=ArkIdentityGetPolicy(policy_name=policy_name))\n\n        policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n        for elem in policies_list:\n            if elem['ID'] == policy_name:\n                elem['LinkType'] = policy_operation.operation_type.value\n        data = {\n            \"plinks\": policies_list,\n            \"policy\": {\n                \"Path\": policy_name,\n                \"Version\": 1,\n                \"Description\": policy.description,\n                \"RevStamp\": policy.rev_stamp,\n                \"Settings\": policy.settings,\n                \"Newpolicy\": False,\n            },\n        }\n        response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse perform policy action response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse perform policy action response [{str(ex)}]') from ex\n\n    def enable_policy(self, enable_policy: ArkIdentityEnablePolicy) -&gt; None:\n        \"\"\"\n        Enables a policy by name\n\n        Args:\n            enable_policy (ArkIdentityEnablePolicy): _description_\n\n        \"\"\"\n        self._logger.info(f'Making Policy [{enable_policy.policy_name}] active')\n        self.perform_action_on_policy(\n            policy_operation=ArkIdentityPolicyOperation(\n                policy_name=enable_policy.policy_name,\n                operation_type=ArkIdentityPolicyOperationType.ENABLE,\n            ),\n        )\n\n    def disable_policy(self, disable_policy: ArkIdentityDisablePolicy) -&gt; None:\n        \"\"\"\n        Disables a policy by name\n\n        Args:\n            disable_policy (ArkIdentityDisablePolicy): _description_\n\n        \"\"\"\n        self._logger.info(f'Making Policy [{disable_policy.policy_name}] inactive')\n        self.perform_action_on_policy(\n            policy_operation=ArkIdentityPolicyOperation(\n                policy_name=disable_policy.policy_name,\n                operation_type=ArkIdentityPolicyOperationType.DISABLE,\n            ),\n        )\n\n    def remove_policy(self, remove_policy: ArkIdentityRemovePolicy) -&gt; None:\n        \"\"\"\n        Removes a policy by name\n\n        Args:\n            remove_policy (ArkIdentityRemovePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing policy [{remove_policy.policy_name}]')\n        policy_name = remove_policy.policy_name\n        if not policy_name.startswith('/Policy/'):\n            policy_name = f'/Policy/{policy_name}'\n        response: Response = self._client.post(f'{self._url_prefix}{DELETE_POLICY_URL}', json={'path': policy_name})\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to remove policy [{response.text}] - [{response.status_code}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove policy response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove policy response [{str(ex)}]') from ex\n\n    def list_policies(self) -&gt; List[ArkIdentityPolicyInfo]:\n        \"\"\"\n        Lists all policies short info\n\n        Returns:\n            List[ArkIdentityPolicyInfo]: _description_\n        \"\"\"\n        self._logger.info('Listing all policies')\n        response: Response = self._client.post(f'{self._url_prefix}{LIST_POLICIES_URL}')\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n            return TypeAdapter(List[ArkIdentityPolicyInfo]).validate_python([p['Row'] for p in result['Result']['Results']])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list policies response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list policies response [{str(ex)}]') from ex\n\n    def policy(self, get_policy: ArkIdentityGetPolicy) -&gt; ArkIdentityPolicy:\n        \"\"\"\n        Retrieves a policy full info by name\n\n        Args:\n            get_policy (ArkIdentityGetPolicy): _description_\n\n        Returns:\n            ArkIdentityPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving policy [{get_policy.policy_name}]')\n        policy_name = get_policy.policy_name\n        if not policy_name.startswith('/Policy/'):\n            policy_name = f'/Policy/{policy_name}'\n        response: Response = self._client.post(f'{self._url_prefix}{GET_POLICY_URL}', json={'name': policy_name})\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n            return ArkIdentityPolicy.model_validate(result['Result'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse policy response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.add_authentication_profile","title":"<code>add_authentication_profile(add_authentication_profile)</code>","text":"<p>Adds a new authentication profile</p> <p>Parameters:</p> Name Type Description Default <code>add_authentication_profile</code> <code>ArkIdentityAddAuthenticationProfile</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityAuthenticationProfile</code> <code>ArkIdentityAuthenticationProfile</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def add_authentication_profile(\n    self, add_authentication_profile: ArkIdentityAddAuthenticationProfile\n) -&gt; ArkIdentityAuthenticationProfile:\n    \"\"\"\n    Adds a new authentication profile\n\n    Args:\n        add_authentication_profile (ArkIdentityAddAuthenticationProfile): _description_\n\n    Returns:\n        ArkIdentityAuthenticationProfile: _description_\n    \"\"\"\n    self._logger.info(f'Adding authentication profile [{add_authentication_profile.auth_profile_name}]')\n    data = {\n        'settings': {\n            'Name': add_authentication_profile.auth_profile_name,\n            'Challenges': [','.join(add_authentication_profile.first_challenges)],\n            'DurationInMinutes': add_authentication_profile.duration_in_minutes,\n        }\n    }\n    if add_authentication_profile.second_challenges:\n        data['settings']['Challenges'].append(','.join(add_authentication_profile.second_challenges))\n    if add_authentication_profile.additional_data:\n        data['settings']['AdditionalData'] = add_authentication_profile.additional_data\n    response: Response = self._client.post(f'{self._url_prefix}{SAVE_PROFILE_URL}', json=data)\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add authentication profile [{response.text}] - [{response.status_code}]')\n        return ArkIdentityAuthenticationProfile.model_validate(result['Result'])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add authentication profile response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add authentication profile response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new policy</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkIdentityAddPolicy</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityPolicy</code> <code>ArkIdentityPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkIdentityAddPolicy) -&gt; ArkIdentityPolicy:\n    \"\"\"\n    Adds a new policy\n\n    Args:\n        add_policy (ArkIdentityAddPolicy): _description_\n\n    Returns:\n        ArkIdentityPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding policy [{add_policy.policy_name}]')\n    roles_service = ArkIdentityRolesService(self._isp_auth)\n    policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n    policy_name = f'/Policy/{add_policy.policy_name}'\n    policy_link = {\n        \"Description\": add_policy.description,\n        \"PolicySet\": policy_name,\n        \"LinkType\": \"Role\",\n        \"Priority\": 1,\n        \"Params\": [roles_service.role_id_by_name(ArkIdentityRoleIdByName(role_name=role_name)) for role_name in add_policy.role_names],\n        \"Filters\": [],\n        \"Allowedpolicies\": [],\n    }\n    policies_list.insert(0, policy_link)\n    data = {\n        \"plinks\": policies_list,\n        \"policy\": {\n            \"Path\": policy_name,\n            \"Version\": 1,\n            \"Description\": add_policy.description,\n            \"Settings\": {\n                \"AuthenticationEnabled\": 'true',\n                \"/Core/Authentication/AuthenticationRulesDefaultProfileId\": self.authentication_profile(\n                    ArkIdentityGetAuthenticationProfile(auth_profile_name=add_policy.auth_profile_name)\n                ).uuid,\n                \"/Core/Authentication/CookieAllowPersist\": 'false',\n                \"/Core/Authentication/AuthSessionMaxConcurrent\": 0,\n                \"/Core/Authentication/AllowIwa\": 'true',\n                \"/Core/Authentication/IwaSetKnownEndpoint\": 'false',\n                \"/Core/Authentication/IwaSatisfiesAllMechs\": 'false',\n                \"/Core/Authentication/AllowZso\": 'true',\n                \"/Core/Authentication/ZsoSkipChallenge\": 'true',\n                \"/Core/Authentication/ZsoSetKnownEndpoint\": 'false',\n                \"/Core/Authentication/ZsoSatisfiesAllMechs\": 'false',\n                \"/Core/Authentication/NoMfaMechLogin\": 'false',\n                \"/Core/Authentication/FederatedLoginAllowsMfa\": 'false',\n                \"/Core/Authentication/FederatedLoginSatisfiesAllMechs\": 'false',\n                \"/Core/MfaRestrictions/BlockMobileMechsOnMobileLogin\": 'false',\n                \"/Core/Authentication/ContinueFailedSessions\": 'true',\n                \"/Core/Authentication/SkipMechsInFalseAdvance\": 'true',\n                \"/Core/Authentication/AllowLoginMfaCache\": 'false',\n            },\n            \"Newpolicy\": 'true',\n        },\n    }\n    if add_policy.settings:\n        data['policy']['Settings'].update(add_policy.settings)\n    response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n        return self.policy(ArkIdentityGetPolicy(policy_name=add_policy.policy_name))\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add policy response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.authentication_profile","title":"<code>authentication_profile(get_authentication_profile)</code>","text":"<p>Retrieve an authentication profile by id or name</p> <p>Parameters:</p> Name Type Description Default <code>get_authentication_profile</code> <code>ArkIdentityGetAuthenticationProfile</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityAuthenticationProfile</code> <code>ArkIdentityAuthenticationProfile</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def authentication_profile(self, get_authentication_profile: ArkIdentityGetAuthenticationProfile) -&gt; ArkIdentityAuthenticationProfile:\n    \"\"\"\n    Retrieve an authentication profile by id or name\n\n    Args:\n        get_authentication_profile (ArkIdentityGetAuthenticationProfile): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityAuthenticationProfile: _description_\n    \"\"\"\n    self._logger.info('Retrieving authentication profile')\n    auth_profiles = self.list_authentication_profiles()\n    if get_authentication_profile.auth_profile_id:\n        auth_profiles = [p for p in auth_profiles if p.uuid == get_authentication_profile.auth_profile_id]\n    if get_authentication_profile.auth_profile_name:\n        auth_profiles = [p for p in auth_profiles if p.name == get_authentication_profile.auth_profile_name]\n    if len(auth_profiles) == 0:\n        raise ArkServiceException('Failed to find authentication profile')\n    return auth_profiles[0]\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.disable_default_policy","title":"<code>disable_default_policy()</code>","text":"<p>Disables the default policy (makes it inactive)</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def disable_default_policy(self) -&gt; None:\n    \"\"\"\n    Disables the default policy (makes it inactive)\n    \"\"\"\n    self.disable_policy(\n        disable_policy=ArkIdentityDisablePolicy(\n            policy_name='/Policy/Default Policy',\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.disable_policy","title":"<code>disable_policy(disable_policy)</code>","text":"<p>Disables a policy by name</p> <p>Parameters:</p> Name Type Description Default <code>disable_policy</code> <code>ArkIdentityDisablePolicy</code> <p>description</p> required Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def disable_policy(self, disable_policy: ArkIdentityDisablePolicy) -&gt; None:\n    \"\"\"\n    Disables a policy by name\n\n    Args:\n        disable_policy (ArkIdentityDisablePolicy): _description_\n\n    \"\"\"\n    self._logger.info(f'Making Policy [{disable_policy.policy_name}] inactive')\n    self.perform_action_on_policy(\n        policy_operation=ArkIdentityPolicyOperation(\n            policy_name=disable_policy.policy_name,\n            operation_type=ArkIdentityPolicyOperationType.DISABLE,\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.enable_default_policy","title":"<code>enable_default_policy()</code>","text":"<p>Enables the default policy (makes it active)</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def enable_default_policy(self) -&gt; None:\n    \"\"\"\n    Enables the default policy (makes it active)\n    \"\"\"\n    self.enable_policy(\n        enable_policy=ArkIdentityEnablePolicy(\n            policy_name='/Policy/Default Policy',\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.enable_policy","title":"<code>enable_policy(enable_policy)</code>","text":"<p>Enables a policy by name</p> <p>Parameters:</p> Name Type Description Default <code>enable_policy</code> <code>ArkIdentityEnablePolicy</code> <p>description</p> required Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def enable_policy(self, enable_policy: ArkIdentityEnablePolicy) -&gt; None:\n    \"\"\"\n    Enables a policy by name\n\n    Args:\n        enable_policy (ArkIdentityEnablePolicy): _description_\n\n    \"\"\"\n    self._logger.info(f'Making Policy [{enable_policy.policy_name}] active')\n    self.perform_action_on_policy(\n        policy_operation=ArkIdentityPolicyOperation(\n            policy_name=enable_policy.policy_name,\n            operation_type=ArkIdentityPolicyOperationType.ENABLE,\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.list_authentication_profiles","title":"<code>list_authentication_profiles()</code>","text":"<p>List available authentication profiles</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkIdentityAuthenticationProfile]</code> <p>List[ArkIdentityAuthenticationProfile]: description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def list_authentication_profiles(self) -&gt; List[ArkIdentityAuthenticationProfile]:\n    \"\"\"\n    List available authentication profiles\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkIdentityAuthenticationProfile]: _description_\n    \"\"\"\n    self._logger.info('Listing authentication profiles')\n    response: Response = self._client.post(f'{self._url_prefix}{GET_PROFILES_URL}')\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list authentication profiles [{response.text}] - [{response.status_code}]')\n        return TypeAdapter(List[ArkIdentityAuthenticationProfile]).validate_python([r['Row'] for r in result['Result']['Results']])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse list authentication profiles response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list authentication profiles response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all policies short info</p> <p>Returns:</p> Type Description <code>List[ArkIdentityPolicyInfo]</code> <p>List[ArkIdentityPolicyInfo]: description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkIdentityPolicyInfo]:\n    \"\"\"\n    Lists all policies short info\n\n    Returns:\n        List[ArkIdentityPolicyInfo]: _description_\n    \"\"\"\n    self._logger.info('Listing all policies')\n    response: Response = self._client.post(f'{self._url_prefix}{LIST_POLICIES_URL}')\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n        return TypeAdapter(List[ArkIdentityPolicyInfo]).validate_python([p['Row'] for p in result['Result']['Results']])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse list policies response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list policies response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.perform_action_on_policy","title":"<code>perform_action_on_policy(policy_operation)</code>","text":"<p>Performs operation on policy (enable/disable)</p> <p>Parameters:</p> Name Type Description Default <code>policy_operation</code> <code>ArkIdentityPolicyOperation</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def perform_action_on_policy(self, policy_operation: ArkIdentityPolicyOperation) -&gt; None:\n    \"\"\"\n    Performs operation on policy (enable/disable)\n\n    Args:\n        policy_operation (ArkIdentityPolicyOperation): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    policy_name = policy_operation.policy_name\n    policy = self.policy(get_policy=ArkIdentityGetPolicy(policy_name=policy_name))\n\n    policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n    for elem in policies_list:\n        if elem['ID'] == policy_name:\n            elem['LinkType'] = policy_operation.operation_type.value\n    data = {\n        \"plinks\": policies_list,\n        \"policy\": {\n            \"Path\": policy_name,\n            \"Version\": 1,\n            \"Description\": policy.description,\n            \"RevStamp\": policy.rev_stamp,\n            \"Settings\": policy.settings,\n            \"Newpolicy\": False,\n        },\n    }\n    response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse perform policy action response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse perform policy action response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a policy full info by name</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkIdentityGetPolicy</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityPolicy</code> <code>ArkIdentityPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkIdentityGetPolicy) -&gt; ArkIdentityPolicy:\n    \"\"\"\n    Retrieves a policy full info by name\n\n    Args:\n        get_policy (ArkIdentityGetPolicy): _description_\n\n    Returns:\n        ArkIdentityPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving policy [{get_policy.policy_name}]')\n    policy_name = get_policy.policy_name\n    if not policy_name.startswith('/Policy/'):\n        policy_name = f'/Policy/{policy_name}'\n    response: Response = self._client.post(f'{self._url_prefix}{GET_POLICY_URL}', json={'name': policy_name})\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n        return ArkIdentityPolicy.model_validate(result['Result'])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse policy response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.remove_authentication_profile","title":"<code>remove_authentication_profile(remove_authentication_profile)</code>","text":"<p>Removes an authentication profile by name or id</p> <p>Parameters:</p> Name Type Description Default <code>remove_authentication_profile</code> <code>ArkIdentityRemoveAuthenticationProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def remove_authentication_profile(self, remove_authentication_profile: ArkIdentityRemoveAuthenticationProfile) -&gt; None:\n    \"\"\"\n    Removes an authentication profile by name or id\n\n    Args:\n        remove_authentication_profile (ArkIdentityRemoveAuthenticationProfile): _description_\n    \"\"\"\n    if remove_authentication_profile.auth_profile_name and not remove_authentication_profile.auth_profile_id:\n        remove_authentication_profile.auth_profile_id = self.authentication_profile(\n            ArkIdentityGetAuthenticationProfile(auth_profile_name=remove_authentication_profile.auth_profile_name)\n        ).uuid\n    self._logger.info(f'Removing authentication profile [{remove_authentication_profile.auth_profile_id}]')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{DELETE_PROFILE_URL}', json={'uuid': remove_authentication_profile.auth_profile_id}\n    )\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to remove authentication profile [{response.text}] - [{response.status_code}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove authentication profile response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove authentication profile response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/#ark_sdk_python.services.identity.policies.ArkIdentityPoliciesService.remove_policy","title":"<code>remove_policy(remove_policy)</code>","text":"<p>Removes a policy by name</p> <p>Parameters:</p> Name Type Description Default <code>remove_policy</code> <code>ArkIdentityRemovePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def remove_policy(self, remove_policy: ArkIdentityRemovePolicy) -&gt; None:\n    \"\"\"\n    Removes a policy by name\n\n    Args:\n        remove_policy (ArkIdentityRemovePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing policy [{remove_policy.policy_name}]')\n    policy_name = remove_policy.policy_name\n    if not policy_name.startswith('/Policy/'):\n        policy_name = f'/Policy/{policy_name}'\n    response: Response = self._client.post(f'{self._url_prefix}{DELETE_POLICY_URL}', json={'path': policy_name})\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to remove policy [{response.text}] - [{response.status_code}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove policy response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/","title":"ark_identity_policies_service","text":""},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService","title":"<code>ArkIdentityPoliciesService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>class ArkIdentityPoliciesService(ArkIdentityBaseService):\n    def add_authentication_profile(\n        self, add_authentication_profile: ArkIdentityAddAuthenticationProfile\n    ) -&gt; ArkIdentityAuthenticationProfile:\n        \"\"\"\n        Adds a new authentication profile\n\n        Args:\n            add_authentication_profile (ArkIdentityAddAuthenticationProfile): _description_\n\n        Returns:\n            ArkIdentityAuthenticationProfile: _description_\n        \"\"\"\n        self._logger.info(f'Adding authentication profile [{add_authentication_profile.auth_profile_name}]')\n        data = {\n            'settings': {\n                'Name': add_authentication_profile.auth_profile_name,\n                'Challenges': [','.join(add_authentication_profile.first_challenges)],\n                'DurationInMinutes': add_authentication_profile.duration_in_minutes,\n            }\n        }\n        if add_authentication_profile.second_challenges:\n            data['settings']['Challenges'].append(','.join(add_authentication_profile.second_challenges))\n        if add_authentication_profile.additional_data:\n            data['settings']['AdditionalData'] = add_authentication_profile.additional_data\n        response: Response = self._client.post(f'{self._url_prefix}{SAVE_PROFILE_URL}', json=data)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add authentication profile [{response.text}] - [{response.status_code}]')\n            return ArkIdentityAuthenticationProfile.model_validate(result['Result'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add authentication profile response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add authentication profile response [{str(ex)}]') from ex\n\n    def remove_authentication_profile(self, remove_authentication_profile: ArkIdentityRemoveAuthenticationProfile) -&gt; None:\n        \"\"\"\n        Removes an authentication profile by name or id\n\n        Args:\n            remove_authentication_profile (ArkIdentityRemoveAuthenticationProfile): _description_\n        \"\"\"\n        if remove_authentication_profile.auth_profile_name and not remove_authentication_profile.auth_profile_id:\n            remove_authentication_profile.auth_profile_id = self.authentication_profile(\n                ArkIdentityGetAuthenticationProfile(auth_profile_name=remove_authentication_profile.auth_profile_name)\n            ).uuid\n        self._logger.info(f'Removing authentication profile [{remove_authentication_profile.auth_profile_id}]')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{DELETE_PROFILE_URL}', json={'uuid': remove_authentication_profile.auth_profile_id}\n        )\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to remove authentication profile [{response.text}] - [{response.status_code}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove authentication profile response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove authentication profile response [{str(ex)}]') from ex\n\n    def list_authentication_profiles(self) -&gt; List[ArkIdentityAuthenticationProfile]:\n        \"\"\"\n        List available authentication profiles\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkIdentityAuthenticationProfile]: _description_\n        \"\"\"\n        self._logger.info('Listing authentication profiles')\n        response: Response = self._client.post(f'{self._url_prefix}{GET_PROFILES_URL}')\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list authentication profiles [{response.text}] - [{response.status_code}]')\n            return TypeAdapter(List[ArkIdentityAuthenticationProfile]).validate_python([r['Row'] for r in result['Result']['Results']])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list authentication profiles response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list authentication profiles response [{str(ex)}]') from ex\n\n    def authentication_profile(self, get_authentication_profile: ArkIdentityGetAuthenticationProfile) -&gt; ArkIdentityAuthenticationProfile:\n        \"\"\"\n        Retrieve an authentication profile by id or name\n\n        Args:\n            get_authentication_profile (ArkIdentityGetAuthenticationProfile): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityAuthenticationProfile: _description_\n        \"\"\"\n        self._logger.info('Retrieving authentication profile')\n        auth_profiles = self.list_authentication_profiles()\n        if get_authentication_profile.auth_profile_id:\n            auth_profiles = [p for p in auth_profiles if p.uuid == get_authentication_profile.auth_profile_id]\n        if get_authentication_profile.auth_profile_name:\n            auth_profiles = [p for p in auth_profiles if p.name == get_authentication_profile.auth_profile_name]\n        if len(auth_profiles) == 0:\n            raise ArkServiceException('Failed to find authentication profile')\n        return auth_profiles[0]\n\n    def add_policy(self, add_policy: ArkIdentityAddPolicy) -&gt; ArkIdentityPolicy:\n        \"\"\"\n        Adds a new policy\n\n        Args:\n            add_policy (ArkIdentityAddPolicy): _description_\n\n        Returns:\n            ArkIdentityPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding policy [{add_policy.policy_name}]')\n        roles_service = ArkIdentityRolesService(self._isp_auth)\n        policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n        policy_name = f'/Policy/{add_policy.policy_name}'\n        policy_link = {\n            \"Description\": add_policy.description,\n            \"PolicySet\": policy_name,\n            \"LinkType\": \"Role\",\n            \"Priority\": 1,\n            \"Params\": [roles_service.role_id_by_name(ArkIdentityRoleIdByName(role_name=role_name)) for role_name in add_policy.role_names],\n            \"Filters\": [],\n            \"Allowedpolicies\": [],\n        }\n        policies_list.insert(0, policy_link)\n        data = {\n            \"plinks\": policies_list,\n            \"policy\": {\n                \"Path\": policy_name,\n                \"Version\": 1,\n                \"Description\": add_policy.description,\n                \"Settings\": {\n                    \"AuthenticationEnabled\": 'true',\n                    \"/Core/Authentication/AuthenticationRulesDefaultProfileId\": self.authentication_profile(\n                        ArkIdentityGetAuthenticationProfile(auth_profile_name=add_policy.auth_profile_name)\n                    ).uuid,\n                    \"/Core/Authentication/CookieAllowPersist\": 'false',\n                    \"/Core/Authentication/AuthSessionMaxConcurrent\": 0,\n                    \"/Core/Authentication/AllowIwa\": 'true',\n                    \"/Core/Authentication/IwaSetKnownEndpoint\": 'false',\n                    \"/Core/Authentication/IwaSatisfiesAllMechs\": 'false',\n                    \"/Core/Authentication/AllowZso\": 'true',\n                    \"/Core/Authentication/ZsoSkipChallenge\": 'true',\n                    \"/Core/Authentication/ZsoSetKnownEndpoint\": 'false',\n                    \"/Core/Authentication/ZsoSatisfiesAllMechs\": 'false',\n                    \"/Core/Authentication/NoMfaMechLogin\": 'false',\n                    \"/Core/Authentication/FederatedLoginAllowsMfa\": 'false',\n                    \"/Core/Authentication/FederatedLoginSatisfiesAllMechs\": 'false',\n                    \"/Core/MfaRestrictions/BlockMobileMechsOnMobileLogin\": 'false',\n                    \"/Core/Authentication/ContinueFailedSessions\": 'true',\n                    \"/Core/Authentication/SkipMechsInFalseAdvance\": 'true',\n                    \"/Core/Authentication/AllowLoginMfaCache\": 'false',\n                },\n                \"Newpolicy\": 'true',\n            },\n        }\n        if add_policy.settings:\n            data['policy']['Settings'].update(add_policy.settings)\n        response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n            return self.policy(ArkIdentityGetPolicy(policy_name=add_policy.policy_name))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add policy response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add policy response [{str(ex)}]') from ex\n\n    def disable_default_policy(self) -&gt; None:\n        \"\"\"\n        Disables the default policy (makes it inactive)\n        \"\"\"\n        self.disable_policy(\n            disable_policy=ArkIdentityDisablePolicy(\n                policy_name='/Policy/Default Policy',\n            ),\n        )\n\n    def enable_default_policy(self) -&gt; None:\n        \"\"\"\n        Enables the default policy (makes it active)\n        \"\"\"\n        self.enable_policy(\n            enable_policy=ArkIdentityEnablePolicy(\n                policy_name='/Policy/Default Policy',\n            ),\n        )\n\n    def perform_action_on_policy(self, policy_operation: ArkIdentityPolicyOperation) -&gt; None:\n        \"\"\"\n        Performs operation on policy (enable/disable)\n\n        Args:\n            policy_operation (ArkIdentityPolicyOperation): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        policy_name = policy_operation.policy_name\n        policy = self.policy(get_policy=ArkIdentityGetPolicy(policy_name=policy_name))\n\n        policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n        for elem in policies_list:\n            if elem['ID'] == policy_name:\n                elem['LinkType'] = policy_operation.operation_type.value\n        data = {\n            \"plinks\": policies_list,\n            \"policy\": {\n                \"Path\": policy_name,\n                \"Version\": 1,\n                \"Description\": policy.description,\n                \"RevStamp\": policy.rev_stamp,\n                \"Settings\": policy.settings,\n                \"Newpolicy\": False,\n            },\n        }\n        response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse perform policy action response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse perform policy action response [{str(ex)}]') from ex\n\n    def enable_policy(self, enable_policy: ArkIdentityEnablePolicy) -&gt; None:\n        \"\"\"\n        Enables a policy by name\n\n        Args:\n            enable_policy (ArkIdentityEnablePolicy): _description_\n\n        \"\"\"\n        self._logger.info(f'Making Policy [{enable_policy.policy_name}] active')\n        self.perform_action_on_policy(\n            policy_operation=ArkIdentityPolicyOperation(\n                policy_name=enable_policy.policy_name,\n                operation_type=ArkIdentityPolicyOperationType.ENABLE,\n            ),\n        )\n\n    def disable_policy(self, disable_policy: ArkIdentityDisablePolicy) -&gt; None:\n        \"\"\"\n        Disables a policy by name\n\n        Args:\n            disable_policy (ArkIdentityDisablePolicy): _description_\n\n        \"\"\"\n        self._logger.info(f'Making Policy [{disable_policy.policy_name}] inactive')\n        self.perform_action_on_policy(\n            policy_operation=ArkIdentityPolicyOperation(\n                policy_name=disable_policy.policy_name,\n                operation_type=ArkIdentityPolicyOperationType.DISABLE,\n            ),\n        )\n\n    def remove_policy(self, remove_policy: ArkIdentityRemovePolicy) -&gt; None:\n        \"\"\"\n        Removes a policy by name\n\n        Args:\n            remove_policy (ArkIdentityRemovePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing policy [{remove_policy.policy_name}]')\n        policy_name = remove_policy.policy_name\n        if not policy_name.startswith('/Policy/'):\n            policy_name = f'/Policy/{policy_name}'\n        response: Response = self._client.post(f'{self._url_prefix}{DELETE_POLICY_URL}', json={'path': policy_name})\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to remove policy [{response.text}] - [{response.status_code}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove policy response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove policy response [{str(ex)}]') from ex\n\n    def list_policies(self) -&gt; List[ArkIdentityPolicyInfo]:\n        \"\"\"\n        Lists all policies short info\n\n        Returns:\n            List[ArkIdentityPolicyInfo]: _description_\n        \"\"\"\n        self._logger.info('Listing all policies')\n        response: Response = self._client.post(f'{self._url_prefix}{LIST_POLICIES_URL}')\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n            return TypeAdapter(List[ArkIdentityPolicyInfo]).validate_python([p['Row'] for p in result['Result']['Results']])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list policies response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list policies response [{str(ex)}]') from ex\n\n    def policy(self, get_policy: ArkIdentityGetPolicy) -&gt; ArkIdentityPolicy:\n        \"\"\"\n        Retrieves a policy full info by name\n\n        Args:\n            get_policy (ArkIdentityGetPolicy): _description_\n\n        Returns:\n            ArkIdentityPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving policy [{get_policy.policy_name}]')\n        policy_name = get_policy.policy_name\n        if not policy_name.startswith('/Policy/'):\n            policy_name = f'/Policy/{policy_name}'\n        response: Response = self._client.post(f'{self._url_prefix}{GET_POLICY_URL}', json={'name': policy_name})\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n            return ArkIdentityPolicy.model_validate(result['Result'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse policy response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.add_authentication_profile","title":"<code>add_authentication_profile(add_authentication_profile)</code>","text":"<p>Adds a new authentication profile</p> <p>Parameters:</p> Name Type Description Default <code>add_authentication_profile</code> <code>ArkIdentityAddAuthenticationProfile</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityAuthenticationProfile</code> <code>ArkIdentityAuthenticationProfile</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def add_authentication_profile(\n    self, add_authentication_profile: ArkIdentityAddAuthenticationProfile\n) -&gt; ArkIdentityAuthenticationProfile:\n    \"\"\"\n    Adds a new authentication profile\n\n    Args:\n        add_authentication_profile (ArkIdentityAddAuthenticationProfile): _description_\n\n    Returns:\n        ArkIdentityAuthenticationProfile: _description_\n    \"\"\"\n    self._logger.info(f'Adding authentication profile [{add_authentication_profile.auth_profile_name}]')\n    data = {\n        'settings': {\n            'Name': add_authentication_profile.auth_profile_name,\n            'Challenges': [','.join(add_authentication_profile.first_challenges)],\n            'DurationInMinutes': add_authentication_profile.duration_in_minutes,\n        }\n    }\n    if add_authentication_profile.second_challenges:\n        data['settings']['Challenges'].append(','.join(add_authentication_profile.second_challenges))\n    if add_authentication_profile.additional_data:\n        data['settings']['AdditionalData'] = add_authentication_profile.additional_data\n    response: Response = self._client.post(f'{self._url_prefix}{SAVE_PROFILE_URL}', json=data)\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add authentication profile [{response.text}] - [{response.status_code}]')\n        return ArkIdentityAuthenticationProfile.model_validate(result['Result'])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add authentication profile response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add authentication profile response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new policy</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkIdentityAddPolicy</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityPolicy</code> <code>ArkIdentityPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkIdentityAddPolicy) -&gt; ArkIdentityPolicy:\n    \"\"\"\n    Adds a new policy\n\n    Args:\n        add_policy (ArkIdentityAddPolicy): _description_\n\n    Returns:\n        ArkIdentityPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding policy [{add_policy.policy_name}]')\n    roles_service = ArkIdentityRolesService(self._isp_auth)\n    policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n    policy_name = f'/Policy/{add_policy.policy_name}'\n    policy_link = {\n        \"Description\": add_policy.description,\n        \"PolicySet\": policy_name,\n        \"LinkType\": \"Role\",\n        \"Priority\": 1,\n        \"Params\": [roles_service.role_id_by_name(ArkIdentityRoleIdByName(role_name=role_name)) for role_name in add_policy.role_names],\n        \"Filters\": [],\n        \"Allowedpolicies\": [],\n    }\n    policies_list.insert(0, policy_link)\n    data = {\n        \"plinks\": policies_list,\n        \"policy\": {\n            \"Path\": policy_name,\n            \"Version\": 1,\n            \"Description\": add_policy.description,\n            \"Settings\": {\n                \"AuthenticationEnabled\": 'true',\n                \"/Core/Authentication/AuthenticationRulesDefaultProfileId\": self.authentication_profile(\n                    ArkIdentityGetAuthenticationProfile(auth_profile_name=add_policy.auth_profile_name)\n                ).uuid,\n                \"/Core/Authentication/CookieAllowPersist\": 'false',\n                \"/Core/Authentication/AuthSessionMaxConcurrent\": 0,\n                \"/Core/Authentication/AllowIwa\": 'true',\n                \"/Core/Authentication/IwaSetKnownEndpoint\": 'false',\n                \"/Core/Authentication/IwaSatisfiesAllMechs\": 'false',\n                \"/Core/Authentication/AllowZso\": 'true',\n                \"/Core/Authentication/ZsoSkipChallenge\": 'true',\n                \"/Core/Authentication/ZsoSetKnownEndpoint\": 'false',\n                \"/Core/Authentication/ZsoSatisfiesAllMechs\": 'false',\n                \"/Core/Authentication/NoMfaMechLogin\": 'false',\n                \"/Core/Authentication/FederatedLoginAllowsMfa\": 'false',\n                \"/Core/Authentication/FederatedLoginSatisfiesAllMechs\": 'false',\n                \"/Core/MfaRestrictions/BlockMobileMechsOnMobileLogin\": 'false',\n                \"/Core/Authentication/ContinueFailedSessions\": 'true',\n                \"/Core/Authentication/SkipMechsInFalseAdvance\": 'true',\n                \"/Core/Authentication/AllowLoginMfaCache\": 'false',\n            },\n            \"Newpolicy\": 'true',\n        },\n    }\n    if add_policy.settings:\n        data['policy']['Settings'].update(add_policy.settings)\n    response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n        return self.policy(ArkIdentityGetPolicy(policy_name=add_policy.policy_name))\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add policy response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.authentication_profile","title":"<code>authentication_profile(get_authentication_profile)</code>","text":"<p>Retrieve an authentication profile by id or name</p> <p>Parameters:</p> Name Type Description Default <code>get_authentication_profile</code> <code>ArkIdentityGetAuthenticationProfile</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityAuthenticationProfile</code> <code>ArkIdentityAuthenticationProfile</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def authentication_profile(self, get_authentication_profile: ArkIdentityGetAuthenticationProfile) -&gt; ArkIdentityAuthenticationProfile:\n    \"\"\"\n    Retrieve an authentication profile by id or name\n\n    Args:\n        get_authentication_profile (ArkIdentityGetAuthenticationProfile): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityAuthenticationProfile: _description_\n    \"\"\"\n    self._logger.info('Retrieving authentication profile')\n    auth_profiles = self.list_authentication_profiles()\n    if get_authentication_profile.auth_profile_id:\n        auth_profiles = [p for p in auth_profiles if p.uuid == get_authentication_profile.auth_profile_id]\n    if get_authentication_profile.auth_profile_name:\n        auth_profiles = [p for p in auth_profiles if p.name == get_authentication_profile.auth_profile_name]\n    if len(auth_profiles) == 0:\n        raise ArkServiceException('Failed to find authentication profile')\n    return auth_profiles[0]\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.disable_default_policy","title":"<code>disable_default_policy()</code>","text":"<p>Disables the default policy (makes it inactive)</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def disable_default_policy(self) -&gt; None:\n    \"\"\"\n    Disables the default policy (makes it inactive)\n    \"\"\"\n    self.disable_policy(\n        disable_policy=ArkIdentityDisablePolicy(\n            policy_name='/Policy/Default Policy',\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.disable_policy","title":"<code>disable_policy(disable_policy)</code>","text":"<p>Disables a policy by name</p> <p>Parameters:</p> Name Type Description Default <code>disable_policy</code> <code>ArkIdentityDisablePolicy</code> <p>description</p> required Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def disable_policy(self, disable_policy: ArkIdentityDisablePolicy) -&gt; None:\n    \"\"\"\n    Disables a policy by name\n\n    Args:\n        disable_policy (ArkIdentityDisablePolicy): _description_\n\n    \"\"\"\n    self._logger.info(f'Making Policy [{disable_policy.policy_name}] inactive')\n    self.perform_action_on_policy(\n        policy_operation=ArkIdentityPolicyOperation(\n            policy_name=disable_policy.policy_name,\n            operation_type=ArkIdentityPolicyOperationType.DISABLE,\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.enable_default_policy","title":"<code>enable_default_policy()</code>","text":"<p>Enables the default policy (makes it active)</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def enable_default_policy(self) -&gt; None:\n    \"\"\"\n    Enables the default policy (makes it active)\n    \"\"\"\n    self.enable_policy(\n        enable_policy=ArkIdentityEnablePolicy(\n            policy_name='/Policy/Default Policy',\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.enable_policy","title":"<code>enable_policy(enable_policy)</code>","text":"<p>Enables a policy by name</p> <p>Parameters:</p> Name Type Description Default <code>enable_policy</code> <code>ArkIdentityEnablePolicy</code> <p>description</p> required Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def enable_policy(self, enable_policy: ArkIdentityEnablePolicy) -&gt; None:\n    \"\"\"\n    Enables a policy by name\n\n    Args:\n        enable_policy (ArkIdentityEnablePolicy): _description_\n\n    \"\"\"\n    self._logger.info(f'Making Policy [{enable_policy.policy_name}] active')\n    self.perform_action_on_policy(\n        policy_operation=ArkIdentityPolicyOperation(\n            policy_name=enable_policy.policy_name,\n            operation_type=ArkIdentityPolicyOperationType.ENABLE,\n        ),\n    )\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.list_authentication_profiles","title":"<code>list_authentication_profiles()</code>","text":"<p>List available authentication profiles</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkIdentityAuthenticationProfile]</code> <p>List[ArkIdentityAuthenticationProfile]: description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def list_authentication_profiles(self) -&gt; List[ArkIdentityAuthenticationProfile]:\n    \"\"\"\n    List available authentication profiles\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkIdentityAuthenticationProfile]: _description_\n    \"\"\"\n    self._logger.info('Listing authentication profiles')\n    response: Response = self._client.post(f'{self._url_prefix}{GET_PROFILES_URL}')\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list authentication profiles [{response.text}] - [{response.status_code}]')\n        return TypeAdapter(List[ArkIdentityAuthenticationProfile]).validate_python([r['Row'] for r in result['Result']['Results']])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse list authentication profiles response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list authentication profiles response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all policies short info</p> <p>Returns:</p> Type Description <code>List[ArkIdentityPolicyInfo]</code> <p>List[ArkIdentityPolicyInfo]: description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkIdentityPolicyInfo]:\n    \"\"\"\n    Lists all policies short info\n\n    Returns:\n        List[ArkIdentityPolicyInfo]: _description_\n    \"\"\"\n    self._logger.info('Listing all policies')\n    response: Response = self._client.post(f'{self._url_prefix}{LIST_POLICIES_URL}')\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n        return TypeAdapter(List[ArkIdentityPolicyInfo]).validate_python([p['Row'] for p in result['Result']['Results']])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse list policies response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list policies response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.perform_action_on_policy","title":"<code>perform_action_on_policy(policy_operation)</code>","text":"<p>Performs operation on policy (enable/disable)</p> <p>Parameters:</p> Name Type Description Default <code>policy_operation</code> <code>ArkIdentityPolicyOperation</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def perform_action_on_policy(self, policy_operation: ArkIdentityPolicyOperation) -&gt; None:\n    \"\"\"\n    Performs operation on policy (enable/disable)\n\n    Args:\n        policy_operation (ArkIdentityPolicyOperation): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    policy_name = policy_operation.policy_name\n    policy = self.policy(get_policy=ArkIdentityGetPolicy(policy_name=policy_name))\n\n    policies_list = [p.model_dump(by_alias=True) for p in self.list_policies()]\n    for elem in policies_list:\n        if elem['ID'] == policy_name:\n            elem['LinkType'] = policy_operation.operation_type.value\n    data = {\n        \"plinks\": policies_list,\n        \"policy\": {\n            \"Path\": policy_name,\n            \"Version\": 1,\n            \"Description\": policy.description,\n            \"RevStamp\": policy.rev_stamp,\n            \"Settings\": policy.settings,\n            \"Newpolicy\": False,\n        },\n    }\n    response: Response = self._client.post(f'{self._url_prefix}{SAVE_POLICY_URL}', json=data)\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to add policy [{response.text}] - [{response.status_code}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse perform policy action response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse perform policy action response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a policy full info by name</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkIdentityGetPolicy</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkIdentityPolicy</code> <code>ArkIdentityPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkIdentityGetPolicy) -&gt; ArkIdentityPolicy:\n    \"\"\"\n    Retrieves a policy full info by name\n\n    Args:\n        get_policy (ArkIdentityGetPolicy): _description_\n\n    Returns:\n        ArkIdentityPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving policy [{get_policy.policy_name}]')\n    policy_name = get_policy.policy_name\n    if not policy_name.startswith('/Policy/'):\n        policy_name = f'/Policy/{policy_name}'\n    response: Response = self._client.post(f'{self._url_prefix}{GET_POLICY_URL}', json={'name': policy_name})\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list policies [{response.text}] - [{response.status_code}]')\n        return ArkIdentityPolicy.model_validate(result['Result'])\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse policy response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.remove_authentication_profile","title":"<code>remove_authentication_profile(remove_authentication_profile)</code>","text":"<p>Removes an authentication profile by name or id</p> <p>Parameters:</p> Name Type Description Default <code>remove_authentication_profile</code> <code>ArkIdentityRemoveAuthenticationProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def remove_authentication_profile(self, remove_authentication_profile: ArkIdentityRemoveAuthenticationProfile) -&gt; None:\n    \"\"\"\n    Removes an authentication profile by name or id\n\n    Args:\n        remove_authentication_profile (ArkIdentityRemoveAuthenticationProfile): _description_\n    \"\"\"\n    if remove_authentication_profile.auth_profile_name and not remove_authentication_profile.auth_profile_id:\n        remove_authentication_profile.auth_profile_id = self.authentication_profile(\n            ArkIdentityGetAuthenticationProfile(auth_profile_name=remove_authentication_profile.auth_profile_name)\n        ).uuid\n    self._logger.info(f'Removing authentication profile [{remove_authentication_profile.auth_profile_id}]')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{DELETE_PROFILE_URL}', json={'uuid': remove_authentication_profile.auth_profile_id}\n    )\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to remove authentication profile [{response.text}] - [{response.status_code}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove authentication profile response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove authentication profile response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/policies/ark_identity_policies_service/#ark_sdk_python.services.identity.policies.ark_identity_policies_service.ArkIdentityPoliciesService.remove_policy","title":"<code>remove_policy(remove_policy)</code>","text":"<p>Removes a policy by name</p> <p>Parameters:</p> Name Type Description Default <code>remove_policy</code> <code>ArkIdentityRemovePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/policies/ark_identity_policies_service.py</code> <pre><code>def remove_policy(self, remove_policy: ArkIdentityRemovePolicy) -&gt; None:\n    \"\"\"\n    Removes a policy by name\n\n    Args:\n        remove_policy (ArkIdentityRemovePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing policy [{remove_policy.policy_name}]')\n    policy_name = remove_policy.policy_name\n    if not policy_name.startswith('/Policy/'):\n        policy_name = f'/Policy/{policy_name}'\n    response: Response = self._client.post(f'{self._url_prefix}{DELETE_POLICY_URL}', json={'path': policy_name})\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to remove policy [{response.text}] - [{response.status_code}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove policy response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/","title":"roles","text":""},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService","title":"<code>ArkIdentityRolesService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>class ArkIdentityRolesService(ArkIdentityBaseService):\n    def create_role(self, create_role: ArkIdentityCreateRole) -&gt; ArkIdentityRole:\n        \"\"\"\n        Creates a role by given name and adds admin rights to it\n        If the role exists, will only alter admin rights and return it\n\n        Args:\n            create_role (ArkIdentityCreateRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityRole: _description_\n        \"\"\"\n        role_details = None\n        self._logger.info(f'Trying to create role [{create_role.role_name}]')\n        try:\n            # Role exists\n            role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=create_role.role_name))\n            role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n            self._logger.info(f'Role already exists with id [{role_id}]')\n        except (ValidationError, Exception) as ex:\n            # Create the role\n            create_dict = {'Name': create_role.role_name}\n            if create_role.description:\n                create_dict['Description'] = create_role.description\n            response: Response = self._client.post(f'{self._url_prefix}{CREATE_ROLE_URL}', json=create_dict)\n            try:\n                result = response.json()\n                if response.status_code != HTTPStatus.OK or not result['success']:\n                    raise ArkServiceException(f'Failed to create role [{response.text}]') from ex\n                role_id = result['Result']['_RowKey']\n                role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n                self._logger.info(f'Role created with id [{role_id}]')\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse create role response [{str(ex)}] - [{response.text}]')\n                raise ArkServiceException(f'Failed to parse create role response [{str(ex)}]') from ex\n        # Add admin rights\n        if create_role.admin_rights:\n            self.add_admin_rights_to_role(\n                ArkIdentityAddAdminRightsToRole(role_id=role_details.role_id, admin_rights=create_role.admin_rights)\n            )\n        return role_details\n\n    def update_role(self, update_role: ArkIdentityUpdateRole) -&gt; None:\n        \"\"\"\n        Updates a role details\n\n        Args:\n            update_role (ArkIdentityUpdateRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if update_role.role_name and not update_role.role_id:\n            update_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=update_role.role_name))\n        self._logger.info(f'Updating identity role [{update_role.role_id}]')\n        update_dict = {'Name': update_role.role_id}\n        if update_role.new_role_name:\n            update_dict['NewName'] = update_role.new_role_name\n        if update_role.description:\n            update_role['Description'] = update_role.description\n        response: Response = self._client.post(f'{self._url_prefix}{UPDATE_ROLE_URL}', json=update_dict)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to update role [{response.text}]')\n            self._logger.info('Role updated successfully')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse update role response [{str(ex)}]') from ex\n\n    def list_role_members(self, list_role_members: ArkIdentityListRoleMembers) -&gt; List[ArkIdentityRoleMember]:\n        \"\"\"\n        Lists a role members\n\n        Args:\n            list_role_members (ArkIdentityListRoleMembers): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkIdentityRoleMember]: _description_\n        \"\"\"\n        if list_role_members.role_name and not list_role_members.role_id:\n            list_role_members.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=list_role_members.role_name))\n        self._logger.info(f'Listing identity role [{list_role_members.role_id}] members')\n        response: Response = self._client.post(f'{self._url_prefix}{ROLE_MEMBERS_URL}', json={'Name': list_role_members.role_id})\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list role members [{response.text}]')\n            members = []\n            if 'Result' in result and 'Results' in result['Result'] and len(result['Result']['Results']) &gt; 0:\n                members = [\n                    ArkIdentityRoleMember(\n                        member_id=r['Row']['Guid'],\n                        member_name=r['Row']['Name'],\n                        member_type=ArkIdentityEntityType(r['Row']['Type'].upper()),\n                    )\n                    for r in result['Result']['Results']\n                ]\n            self._logger.info('Listed role members successfully successfully')\n            return members\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list role members response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list role members response [{str(ex)}]') from ex\n\n    def add_admin_rights_to_role(self, add_admin_rights_to_role: ArkIdentityAddAdminRightsToRole) -&gt; None:\n        \"\"\"\n        Adds given admin rights to the role assuming it exists\n\n        Args:\n            add_admin_rights_to_role (ArkIdentityAddAdminRightsToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding admin rights [{add_admin_rights_to_role.admin_rights}] to role [{add_admin_rights_to_role.role_name}]')\n        if not add_admin_rights_to_role.role_id and not add_admin_rights_to_role.role_name:\n            raise ArkServiceException('Either role id or role name must be given')\n        if add_admin_rights_to_role.role_id:\n            role_id = add_admin_rights_to_role.role_id\n        else:\n            role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_admin_rights_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_ADMIN_RIGHTS_TO_ROLE_URL}',\n            json=[{'Role': role_id, 'Path': admin_right.value} for admin_right in add_admin_rights_to_role.admin_rights],\n        )\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to add admin rights to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add admin rights to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add admin rights to role response [{str(ex)}]') from ex\n\n    def role_id_by_name(self, role_id_by_name: ArkIdentityRoleIdByName) -&gt; str:\n        \"\"\"\n        For a given role name, find its identifier on identity\n\n        Args:\n            role_id_by_name (ArkIdentityRoleIdByName): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving role id for name [{role_id_by_name.role_name}]')\n        directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n        directories = [\n            d.directory_service_uuid\n            for d in directories_service.list_directories(ArkIdentityListDirectories(directories=[DirectoryService.Identity]))\n        ]\n        response: Response = self._client.post(\n            f'{self._url_prefix}{DIRECTORY_SERVICE_QUERY_URL}',\n            json=DirectoryServiceQuerySpecificRoleRequest(\n                role_name=role_id_by_name.role_name, directory_services=directories, args=DirectorySearchArgs(limit=1)\n            ).model_dump(by_alias=True, exclude={'users'}),\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to query for directory services role [{response.text}]')\n        try:\n            result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n            all_roles = result.result.roles.results\n            if not len(all_roles):\n                raise ArkServiceException('No role found for given name')\n            return all_roles[0].row.id\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse role id by name response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse role id by name response [{str(ex)}]') from ex\n\n    def add_user_to_role(self, add_user_to_role: ArkIdentityAddUserToRole) -&gt; None:\n        \"\"\"\n        Adds a given user to the role\n\n        Args:\n            add_user_to_role (ArkIdentityAddUserToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding user [{add_user_to_role.username}] to role [{add_user_to_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_user_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n            json={\n                'Name': role_id,\n                'Users': [add_user_to_role.username],\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add user to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add user to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add user to role response [{str(ex)}]') from ex\n\n    def add_group_to_role(self, add_group_to_role: ArkIdentityAddGroupToRole) -&gt; None:\n        \"\"\"\n        Adds a given group to the role\n\n        Args:\n            add_group_to_role (ArkIdentityAddGroupToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding group [{add_group_to_role.group_name}] to role [{add_group_to_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_group_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n            json={\n                'Name': role_id,\n                'Groups': [add_group_to_role.group_name],\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add group to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add group to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add group to role response [{str(ex)}]') from ex\n\n    def add_role_to_role(self, add_role_to_role: ArkIdentityAddRoleToRole) -&gt; None:\n        \"\"\"\n        Adds a given group to the role\n\n        Args:\n            add_role_to_role (ArkIdentityAddRoleToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding role [{add_role_to_role.role_name_to_add}] to role [{add_role_to_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_role_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n            json={\n                'Name': role_id,\n                'Roles': [add_role_to_role.role_name_to_add],\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add role to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add role to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add role to role response [{str(ex)}]') from ex\n\n    def remove_user_from_role(self, remove_user_from_role: ArkIdentityRemoveUserFromRole) -&gt; None:\n        \"\"\"\n        Removes a given user from the given role\n\n        Args:\n            remove_user_from_role (ArkIdentityRemoveUserFromRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing user [{remove_user_from_role.username}] from role [{remove_user_from_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_user_from_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Users': [remove_user_from_role.username]}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to remove user to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove user to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove user to role response [{str(ex)}]') from ex\n\n    def remove_group_from_role(self, remove_group_from_role: ArkIdentityRemoveGroupFromRole) -&gt; None:\n        \"\"\"\n        Removes a given group from the given role\n\n        Args:\n            remove_group_from_role (ArkIdentityRemoveGroupFromRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing group [{remove_group_from_role.group_name}] from role [{remove_group_from_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_group_from_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Groups': [remove_group_from_role.group_name]}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to remove group to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove group to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove group to role response [{str(ex)}]') from ex\n\n    def remove_role_from_role(self, remove_role_from_role: ArkIdentityRemoveRoleFromRole) -&gt; None:\n        \"\"\"\n        Removes a given role from the given role\n\n        Args:\n            remove_role_from_role (ArkIdentityRemoveRoleFromRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing group [{remove_role_from_role.role_name}] from role [{remove_role_from_role.role_name_to_remove}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_role_from_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Roles': [remove_role_from_role.role_name_to_remove]}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to remove role to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove role to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove role to role response [{str(ex)}]') from ex\n\n    def delete_role(self, delete_role: ArkIdentityDeleteRole) -&gt; None:\n        \"\"\"\n        Deletes a given role by name\n\n        Args:\n            delete_role (ArkIdentityDeleteRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting role [{delete_role.role_name}]')\n        if delete_role.role_name and not delete_role.role_id:\n            delete_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=delete_role.role_name))\n        response: Response = self._client.post(f'{self._url_prefix}{DELETE_ROLE_URL}', json={'Name': delete_role.role_id})\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to delete role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse delete role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse delete role response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.add_admin_rights_to_role","title":"<code>add_admin_rights_to_role(add_admin_rights_to_role)</code>","text":"<p>Adds given admin rights to the role assuming it exists</p> <p>Parameters:</p> Name Type Description Default <code>add_admin_rights_to_role</code> <code>ArkIdentityAddAdminRightsToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_admin_rights_to_role(self, add_admin_rights_to_role: ArkIdentityAddAdminRightsToRole) -&gt; None:\n    \"\"\"\n    Adds given admin rights to the role assuming it exists\n\n    Args:\n        add_admin_rights_to_role (ArkIdentityAddAdminRightsToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding admin rights [{add_admin_rights_to_role.admin_rights}] to role [{add_admin_rights_to_role.role_name}]')\n    if not add_admin_rights_to_role.role_id and not add_admin_rights_to_role.role_name:\n        raise ArkServiceException('Either role id or role name must be given')\n    if add_admin_rights_to_role.role_id:\n        role_id = add_admin_rights_to_role.role_id\n    else:\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_admin_rights_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_ADMIN_RIGHTS_TO_ROLE_URL}',\n        json=[{'Role': role_id, 'Path': admin_right.value} for admin_right in add_admin_rights_to_role.admin_rights],\n    )\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to add admin rights to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add admin rights to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add admin rights to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.add_group_to_role","title":"<code>add_group_to_role(add_group_to_role)</code>","text":"<p>Adds a given group to the role</p> <p>Parameters:</p> Name Type Description Default <code>add_group_to_role</code> <code>ArkIdentityAddGroupToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_group_to_role(self, add_group_to_role: ArkIdentityAddGroupToRole) -&gt; None:\n    \"\"\"\n    Adds a given group to the role\n\n    Args:\n        add_group_to_role (ArkIdentityAddGroupToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding group [{add_group_to_role.group_name}] to role [{add_group_to_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_group_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n        json={\n            'Name': role_id,\n            'Groups': [add_group_to_role.group_name],\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add group to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add group to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add group to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.add_role_to_role","title":"<code>add_role_to_role(add_role_to_role)</code>","text":"<p>Adds a given group to the role</p> <p>Parameters:</p> Name Type Description Default <code>add_role_to_role</code> <code>ArkIdentityAddRoleToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_role_to_role(self, add_role_to_role: ArkIdentityAddRoleToRole) -&gt; None:\n    \"\"\"\n    Adds a given group to the role\n\n    Args:\n        add_role_to_role (ArkIdentityAddRoleToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding role [{add_role_to_role.role_name_to_add}] to role [{add_role_to_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_role_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n        json={\n            'Name': role_id,\n            'Roles': [add_role_to_role.role_name_to_add],\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add role to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add role to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add role to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.add_user_to_role","title":"<code>add_user_to_role(add_user_to_role)</code>","text":"<p>Adds a given user to the role</p> <p>Parameters:</p> Name Type Description Default <code>add_user_to_role</code> <code>ArkIdentityAddUserToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_user_to_role(self, add_user_to_role: ArkIdentityAddUserToRole) -&gt; None:\n    \"\"\"\n    Adds a given user to the role\n\n    Args:\n        add_user_to_role (ArkIdentityAddUserToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding user [{add_user_to_role.username}] to role [{add_user_to_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_user_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n        json={\n            'Name': role_id,\n            'Users': [add_user_to_role.username],\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add user to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add user to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add user to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.create_role","title":"<code>create_role(create_role)</code>","text":"<p>Creates a role by given name and adds admin rights to it If the role exists, will only alter admin rights and return it</p> <p>Parameters:</p> Name Type Description Default <code>create_role</code> <code>ArkIdentityCreateRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityRole</code> <code>ArkIdentityRole</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def create_role(self, create_role: ArkIdentityCreateRole) -&gt; ArkIdentityRole:\n    \"\"\"\n    Creates a role by given name and adds admin rights to it\n    If the role exists, will only alter admin rights and return it\n\n    Args:\n        create_role (ArkIdentityCreateRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityRole: _description_\n    \"\"\"\n    role_details = None\n    self._logger.info(f'Trying to create role [{create_role.role_name}]')\n    try:\n        # Role exists\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=create_role.role_name))\n        role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n        self._logger.info(f'Role already exists with id [{role_id}]')\n    except (ValidationError, Exception) as ex:\n        # Create the role\n        create_dict = {'Name': create_role.role_name}\n        if create_role.description:\n            create_dict['Description'] = create_role.description\n        response: Response = self._client.post(f'{self._url_prefix}{CREATE_ROLE_URL}', json=create_dict)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to create role [{response.text}]') from ex\n            role_id = result['Result']['_RowKey']\n            role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n            self._logger.info(f'Role created with id [{role_id}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse create role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse create role response [{str(ex)}]') from ex\n    # Add admin rights\n    if create_role.admin_rights:\n        self.add_admin_rights_to_role(\n            ArkIdentityAddAdminRightsToRole(role_id=role_details.role_id, admin_rights=create_role.admin_rights)\n        )\n    return role_details\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.delete_role","title":"<code>delete_role(delete_role)</code>","text":"<p>Deletes a given role by name</p> <p>Parameters:</p> Name Type Description Default <code>delete_role</code> <code>ArkIdentityDeleteRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def delete_role(self, delete_role: ArkIdentityDeleteRole) -&gt; None:\n    \"\"\"\n    Deletes a given role by name\n\n    Args:\n        delete_role (ArkIdentityDeleteRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting role [{delete_role.role_name}]')\n    if delete_role.role_name and not delete_role.role_id:\n        delete_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=delete_role.role_name))\n    response: Response = self._client.post(f'{self._url_prefix}{DELETE_ROLE_URL}', json={'Name': delete_role.role_id})\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to delete role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse delete role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse delete role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.list_role_members","title":"<code>list_role_members(list_role_members)</code>","text":"<p>Lists a role members</p> <p>Parameters:</p> Name Type Description Default <code>list_role_members</code> <code>ArkIdentityListRoleMembers</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkIdentityRoleMember]</code> <p>List[ArkIdentityRoleMember]: description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def list_role_members(self, list_role_members: ArkIdentityListRoleMembers) -&gt; List[ArkIdentityRoleMember]:\n    \"\"\"\n    Lists a role members\n\n    Args:\n        list_role_members (ArkIdentityListRoleMembers): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkIdentityRoleMember]: _description_\n    \"\"\"\n    if list_role_members.role_name and not list_role_members.role_id:\n        list_role_members.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=list_role_members.role_name))\n    self._logger.info(f'Listing identity role [{list_role_members.role_id}] members')\n    response: Response = self._client.post(f'{self._url_prefix}{ROLE_MEMBERS_URL}', json={'Name': list_role_members.role_id})\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list role members [{response.text}]')\n        members = []\n        if 'Result' in result and 'Results' in result['Result'] and len(result['Result']['Results']) &gt; 0:\n            members = [\n                ArkIdentityRoleMember(\n                    member_id=r['Row']['Guid'],\n                    member_name=r['Row']['Name'],\n                    member_type=ArkIdentityEntityType(r['Row']['Type'].upper()),\n                )\n                for r in result['Result']['Results']\n            ]\n        self._logger.info('Listed role members successfully successfully')\n        return members\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse list role members response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list role members response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.remove_group_from_role","title":"<code>remove_group_from_role(remove_group_from_role)</code>","text":"<p>Removes a given group from the given role</p> <p>Parameters:</p> Name Type Description Default <code>remove_group_from_role</code> <code>ArkIdentityRemoveGroupFromRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def remove_group_from_role(self, remove_group_from_role: ArkIdentityRemoveGroupFromRole) -&gt; None:\n    \"\"\"\n    Removes a given group from the given role\n\n    Args:\n        remove_group_from_role (ArkIdentityRemoveGroupFromRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing group [{remove_group_from_role.group_name}] from role [{remove_group_from_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_group_from_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Groups': [remove_group_from_role.group_name]}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to remove group to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove group to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove group to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.remove_role_from_role","title":"<code>remove_role_from_role(remove_role_from_role)</code>","text":"<p>Removes a given role from the given role</p> <p>Parameters:</p> Name Type Description Default <code>remove_role_from_role</code> <code>ArkIdentityRemoveRoleFromRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def remove_role_from_role(self, remove_role_from_role: ArkIdentityRemoveRoleFromRole) -&gt; None:\n    \"\"\"\n    Removes a given role from the given role\n\n    Args:\n        remove_role_from_role (ArkIdentityRemoveRoleFromRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing group [{remove_role_from_role.role_name}] from role [{remove_role_from_role.role_name_to_remove}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_role_from_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Roles': [remove_role_from_role.role_name_to_remove]}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to remove role to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove role to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove role to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.remove_user_from_role","title":"<code>remove_user_from_role(remove_user_from_role)</code>","text":"<p>Removes a given user from the given role</p> <p>Parameters:</p> Name Type Description Default <code>remove_user_from_role</code> <code>ArkIdentityRemoveUserFromRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def remove_user_from_role(self, remove_user_from_role: ArkIdentityRemoveUserFromRole) -&gt; None:\n    \"\"\"\n    Removes a given user from the given role\n\n    Args:\n        remove_user_from_role (ArkIdentityRemoveUserFromRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing user [{remove_user_from_role.username}] from role [{remove_user_from_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_user_from_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Users': [remove_user_from_role.username]}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to remove user to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove user to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove user to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.role_id_by_name","title":"<code>role_id_by_name(role_id_by_name)</code>","text":"<p>For a given role name, find its identifier on identity</p> <p>Parameters:</p> Name Type Description Default <code>role_id_by_name</code> <code>ArkIdentityRoleIdByName</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def role_id_by_name(self, role_id_by_name: ArkIdentityRoleIdByName) -&gt; str:\n    \"\"\"\n    For a given role name, find its identifier on identity\n\n    Args:\n        role_id_by_name (ArkIdentityRoleIdByName): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving role id for name [{role_id_by_name.role_name}]')\n    directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n    directories = [\n        d.directory_service_uuid\n        for d in directories_service.list_directories(ArkIdentityListDirectories(directories=[DirectoryService.Identity]))\n    ]\n    response: Response = self._client.post(\n        f'{self._url_prefix}{DIRECTORY_SERVICE_QUERY_URL}',\n        json=DirectoryServiceQuerySpecificRoleRequest(\n            role_name=role_id_by_name.role_name, directory_services=directories, args=DirectorySearchArgs(limit=1)\n        ).model_dump(by_alias=True, exclude={'users'}),\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to query for directory services role [{response.text}]')\n    try:\n        result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n        all_roles = result.result.roles.results\n        if not len(all_roles):\n            raise ArkServiceException('No role found for given name')\n        return all_roles[0].row.id\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse role id by name response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse role id by name response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/#ark_sdk_python.services.identity.roles.ArkIdentityRolesService.update_role","title":"<code>update_role(update_role)</code>","text":"<p>Updates a role details</p> <p>Parameters:</p> Name Type Description Default <code>update_role</code> <code>ArkIdentityUpdateRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def update_role(self, update_role: ArkIdentityUpdateRole) -&gt; None:\n    \"\"\"\n    Updates a role details\n\n    Args:\n        update_role (ArkIdentityUpdateRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if update_role.role_name and not update_role.role_id:\n        update_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=update_role.role_name))\n    self._logger.info(f'Updating identity role [{update_role.role_id}]')\n    update_dict = {'Name': update_role.role_id}\n    if update_role.new_role_name:\n        update_dict['NewName'] = update_role.new_role_name\n    if update_role.description:\n        update_role['Description'] = update_role.description\n    response: Response = self._client.post(f'{self._url_prefix}{UPDATE_ROLE_URL}', json=update_dict)\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to update role [{response.text}]')\n        self._logger.info('Role updated successfully')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse update role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse update role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/","title":"ark_identity_roles_service","text":""},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService","title":"<code>ArkIdentityRolesService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>class ArkIdentityRolesService(ArkIdentityBaseService):\n    def create_role(self, create_role: ArkIdentityCreateRole) -&gt; ArkIdentityRole:\n        \"\"\"\n        Creates a role by given name and adds admin rights to it\n        If the role exists, will only alter admin rights and return it\n\n        Args:\n            create_role (ArkIdentityCreateRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityRole: _description_\n        \"\"\"\n        role_details = None\n        self._logger.info(f'Trying to create role [{create_role.role_name}]')\n        try:\n            # Role exists\n            role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=create_role.role_name))\n            role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n            self._logger.info(f'Role already exists with id [{role_id}]')\n        except (ValidationError, Exception) as ex:\n            # Create the role\n            create_dict = {'Name': create_role.role_name}\n            if create_role.description:\n                create_dict['Description'] = create_role.description\n            response: Response = self._client.post(f'{self._url_prefix}{CREATE_ROLE_URL}', json=create_dict)\n            try:\n                result = response.json()\n                if response.status_code != HTTPStatus.OK or not result['success']:\n                    raise ArkServiceException(f'Failed to create role [{response.text}]') from ex\n                role_id = result['Result']['_RowKey']\n                role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n                self._logger.info(f'Role created with id [{role_id}]')\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse create role response [{str(ex)}] - [{response.text}]')\n                raise ArkServiceException(f'Failed to parse create role response [{str(ex)}]') from ex\n        # Add admin rights\n        if create_role.admin_rights:\n            self.add_admin_rights_to_role(\n                ArkIdentityAddAdminRightsToRole(role_id=role_details.role_id, admin_rights=create_role.admin_rights)\n            )\n        return role_details\n\n    def update_role(self, update_role: ArkIdentityUpdateRole) -&gt; None:\n        \"\"\"\n        Updates a role details\n\n        Args:\n            update_role (ArkIdentityUpdateRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if update_role.role_name and not update_role.role_id:\n            update_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=update_role.role_name))\n        self._logger.info(f'Updating identity role [{update_role.role_id}]')\n        update_dict = {'Name': update_role.role_id}\n        if update_role.new_role_name:\n            update_dict['NewName'] = update_role.new_role_name\n        if update_role.description:\n            update_role['Description'] = update_role.description\n        response: Response = self._client.post(f'{self._url_prefix}{UPDATE_ROLE_URL}', json=update_dict)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to update role [{response.text}]')\n            self._logger.info('Role updated successfully')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse update role response [{str(ex)}]') from ex\n\n    def list_role_members(self, list_role_members: ArkIdentityListRoleMembers) -&gt; List[ArkIdentityRoleMember]:\n        \"\"\"\n        Lists a role members\n\n        Args:\n            list_role_members (ArkIdentityListRoleMembers): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkIdentityRoleMember]: _description_\n        \"\"\"\n        if list_role_members.role_name and not list_role_members.role_id:\n            list_role_members.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=list_role_members.role_name))\n        self._logger.info(f'Listing identity role [{list_role_members.role_id}] members')\n        response: Response = self._client.post(f'{self._url_prefix}{ROLE_MEMBERS_URL}', json={'Name': list_role_members.role_id})\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to list role members [{response.text}]')\n            members = []\n            if 'Result' in result and 'Results' in result['Result'] and len(result['Result']['Results']) &gt; 0:\n                members = [\n                    ArkIdentityRoleMember(\n                        member_id=r['Row']['Guid'],\n                        member_name=r['Row']['Name'],\n                        member_type=ArkIdentityEntityType(r['Row']['Type'].upper()),\n                    )\n                    for r in result['Result']['Results']\n                ]\n            self._logger.info('Listed role members successfully successfully')\n            return members\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list role members response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse list role members response [{str(ex)}]') from ex\n\n    def add_admin_rights_to_role(self, add_admin_rights_to_role: ArkIdentityAddAdminRightsToRole) -&gt; None:\n        \"\"\"\n        Adds given admin rights to the role assuming it exists\n\n        Args:\n            add_admin_rights_to_role (ArkIdentityAddAdminRightsToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding admin rights [{add_admin_rights_to_role.admin_rights}] to role [{add_admin_rights_to_role.role_name}]')\n        if not add_admin_rights_to_role.role_id and not add_admin_rights_to_role.role_name:\n            raise ArkServiceException('Either role id or role name must be given')\n        if add_admin_rights_to_role.role_id:\n            role_id = add_admin_rights_to_role.role_id\n        else:\n            role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_admin_rights_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_ADMIN_RIGHTS_TO_ROLE_URL}',\n            json=[{'Role': role_id, 'Path': admin_right.value} for admin_right in add_admin_rights_to_role.admin_rights],\n        )\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to add admin rights to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add admin rights to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add admin rights to role response [{str(ex)}]') from ex\n\n    def role_id_by_name(self, role_id_by_name: ArkIdentityRoleIdByName) -&gt; str:\n        \"\"\"\n        For a given role name, find its identifier on identity\n\n        Args:\n            role_id_by_name (ArkIdentityRoleIdByName): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving role id for name [{role_id_by_name.role_name}]')\n        directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n        directories = [\n            d.directory_service_uuid\n            for d in directories_service.list_directories(ArkIdentityListDirectories(directories=[DirectoryService.Identity]))\n        ]\n        response: Response = self._client.post(\n            f'{self._url_prefix}{DIRECTORY_SERVICE_QUERY_URL}',\n            json=DirectoryServiceQuerySpecificRoleRequest(\n                role_name=role_id_by_name.role_name, directory_services=directories, args=DirectorySearchArgs(limit=1)\n            ).model_dump(by_alias=True, exclude={'users'}),\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to query for directory services role [{response.text}]')\n        try:\n            result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n            all_roles = result.result.roles.results\n            if not len(all_roles):\n                raise ArkServiceException('No role found for given name')\n            return all_roles[0].row.id\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse role id by name response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse role id by name response [{str(ex)}]') from ex\n\n    def add_user_to_role(self, add_user_to_role: ArkIdentityAddUserToRole) -&gt; None:\n        \"\"\"\n        Adds a given user to the role\n\n        Args:\n            add_user_to_role (ArkIdentityAddUserToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding user [{add_user_to_role.username}] to role [{add_user_to_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_user_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n            json={\n                'Name': role_id,\n                'Users': [add_user_to_role.username],\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add user to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add user to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add user to role response [{str(ex)}]') from ex\n\n    def add_group_to_role(self, add_group_to_role: ArkIdentityAddGroupToRole) -&gt; None:\n        \"\"\"\n        Adds a given group to the role\n\n        Args:\n            add_group_to_role (ArkIdentityAddGroupToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding group [{add_group_to_role.group_name}] to role [{add_group_to_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_group_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n            json={\n                'Name': role_id,\n                'Groups': [add_group_to_role.group_name],\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add group to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add group to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add group to role response [{str(ex)}]') from ex\n\n    def add_role_to_role(self, add_role_to_role: ArkIdentityAddRoleToRole) -&gt; None:\n        \"\"\"\n        Adds a given group to the role\n\n        Args:\n            add_role_to_role (ArkIdentityAddRoleToRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Adding role [{add_role_to_role.role_name_to_add}] to role [{add_role_to_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_role_to_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n            json={\n                'Name': role_id,\n                'Roles': [add_role_to_role.role_name_to_add],\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to add role to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add role to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse add role to role response [{str(ex)}]') from ex\n\n    def remove_user_from_role(self, remove_user_from_role: ArkIdentityRemoveUserFromRole) -&gt; None:\n        \"\"\"\n        Removes a given user from the given role\n\n        Args:\n            remove_user_from_role (ArkIdentityRemoveUserFromRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing user [{remove_user_from_role.username}] from role [{remove_user_from_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_user_from_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Users': [remove_user_from_role.username]}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to remove user to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove user to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove user to role response [{str(ex)}]') from ex\n\n    def remove_group_from_role(self, remove_group_from_role: ArkIdentityRemoveGroupFromRole) -&gt; None:\n        \"\"\"\n        Removes a given group from the given role\n\n        Args:\n            remove_group_from_role (ArkIdentityRemoveGroupFromRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing group [{remove_group_from_role.group_name}] from role [{remove_group_from_role.role_name}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_group_from_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Groups': [remove_group_from_role.group_name]}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to remove group to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove group to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove group to role response [{str(ex)}]') from ex\n\n    def remove_role_from_role(self, remove_role_from_role: ArkIdentityRemoveRoleFromRole) -&gt; None:\n        \"\"\"\n        Removes a given role from the given role\n\n        Args:\n            remove_role_from_role (ArkIdentityRemoveRoleFromRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing group [{remove_role_from_role.role_name}] from role [{remove_role_from_role.role_name_to_remove}]')\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_role_from_role.role_name))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Roles': [remove_role_from_role.role_name_to_remove]}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to remove role to role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove role to role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove role to role response [{str(ex)}]') from ex\n\n    def delete_role(self, delete_role: ArkIdentityDeleteRole) -&gt; None:\n        \"\"\"\n        Deletes a given role by name\n\n        Args:\n            delete_role (ArkIdentityDeleteRole): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting role [{delete_role.role_name}]')\n        if delete_role.role_name and not delete_role.role_id:\n            delete_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=delete_role.role_name))\n        response: Response = self._client.post(f'{self._url_prefix}{DELETE_ROLE_URL}', json={'Name': delete_role.role_id})\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to delete role [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse delete role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse delete role response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.add_admin_rights_to_role","title":"<code>add_admin_rights_to_role(add_admin_rights_to_role)</code>","text":"<p>Adds given admin rights to the role assuming it exists</p> <p>Parameters:</p> Name Type Description Default <code>add_admin_rights_to_role</code> <code>ArkIdentityAddAdminRightsToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_admin_rights_to_role(self, add_admin_rights_to_role: ArkIdentityAddAdminRightsToRole) -&gt; None:\n    \"\"\"\n    Adds given admin rights to the role assuming it exists\n\n    Args:\n        add_admin_rights_to_role (ArkIdentityAddAdminRightsToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding admin rights [{add_admin_rights_to_role.admin_rights}] to role [{add_admin_rights_to_role.role_name}]')\n    if not add_admin_rights_to_role.role_id and not add_admin_rights_to_role.role_name:\n        raise ArkServiceException('Either role id or role name must be given')\n    if add_admin_rights_to_role.role_id:\n        role_id = add_admin_rights_to_role.role_id\n    else:\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_admin_rights_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_ADMIN_RIGHTS_TO_ROLE_URL}',\n        json=[{'Role': role_id, 'Path': admin_right.value} for admin_right in add_admin_rights_to_role.admin_rights],\n    )\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to add admin rights to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add admin rights to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add admin rights to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.add_group_to_role","title":"<code>add_group_to_role(add_group_to_role)</code>","text":"<p>Adds a given group to the role</p> <p>Parameters:</p> Name Type Description Default <code>add_group_to_role</code> <code>ArkIdentityAddGroupToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_group_to_role(self, add_group_to_role: ArkIdentityAddGroupToRole) -&gt; None:\n    \"\"\"\n    Adds a given group to the role\n\n    Args:\n        add_group_to_role (ArkIdentityAddGroupToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding group [{add_group_to_role.group_name}] to role [{add_group_to_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_group_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n        json={\n            'Name': role_id,\n            'Groups': [add_group_to_role.group_name],\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add group to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add group to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add group to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.add_role_to_role","title":"<code>add_role_to_role(add_role_to_role)</code>","text":"<p>Adds a given group to the role</p> <p>Parameters:</p> Name Type Description Default <code>add_role_to_role</code> <code>ArkIdentityAddRoleToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_role_to_role(self, add_role_to_role: ArkIdentityAddRoleToRole) -&gt; None:\n    \"\"\"\n    Adds a given group to the role\n\n    Args:\n        add_role_to_role (ArkIdentityAddRoleToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding role [{add_role_to_role.role_name_to_add}] to role [{add_role_to_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_role_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n        json={\n            'Name': role_id,\n            'Roles': [add_role_to_role.role_name_to_add],\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add role to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add role to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add role to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.add_user_to_role","title":"<code>add_user_to_role(add_user_to_role)</code>","text":"<p>Adds a given user to the role</p> <p>Parameters:</p> Name Type Description Default <code>add_user_to_role</code> <code>ArkIdentityAddUserToRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def add_user_to_role(self, add_user_to_role: ArkIdentityAddUserToRole) -&gt; None:\n    \"\"\"\n    Adds a given user to the role\n\n    Args:\n        add_user_to_role (ArkIdentityAddUserToRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Adding user [{add_user_to_role.username}] to role [{add_user_to_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=add_user_to_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{ADD_USER_TO_ROLE_URL}',\n        json={\n            'Name': role_id,\n            'Users': [add_user_to_role.username],\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to add user to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse add user to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse add user to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.create_role","title":"<code>create_role(create_role)</code>","text":"<p>Creates a role by given name and adds admin rights to it If the role exists, will only alter admin rights and return it</p> <p>Parameters:</p> Name Type Description Default <code>create_role</code> <code>ArkIdentityCreateRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityRole</code> <code>ArkIdentityRole</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def create_role(self, create_role: ArkIdentityCreateRole) -&gt; ArkIdentityRole:\n    \"\"\"\n    Creates a role by given name and adds admin rights to it\n    If the role exists, will only alter admin rights and return it\n\n    Args:\n        create_role (ArkIdentityCreateRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityRole: _description_\n    \"\"\"\n    role_details = None\n    self._logger.info(f'Trying to create role [{create_role.role_name}]')\n    try:\n        # Role exists\n        role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=create_role.role_name))\n        role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n        self._logger.info(f'Role already exists with id [{role_id}]')\n    except (ValidationError, Exception) as ex:\n        # Create the role\n        create_dict = {'Name': create_role.role_name}\n        if create_role.description:\n            create_dict['Description'] = create_role.description\n        response: Response = self._client.post(f'{self._url_prefix}{CREATE_ROLE_URL}', json=create_dict)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to create role [{response.text}]') from ex\n            role_id = result['Result']['_RowKey']\n            role_details = ArkIdentityRole(role_name=create_role.role_name, role_id=role_id)\n            self._logger.info(f'Role created with id [{role_id}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse create role response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse create role response [{str(ex)}]') from ex\n    # Add admin rights\n    if create_role.admin_rights:\n        self.add_admin_rights_to_role(\n            ArkIdentityAddAdminRightsToRole(role_id=role_details.role_id, admin_rights=create_role.admin_rights)\n        )\n    return role_details\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.delete_role","title":"<code>delete_role(delete_role)</code>","text":"<p>Deletes a given role by name</p> <p>Parameters:</p> Name Type Description Default <code>delete_role</code> <code>ArkIdentityDeleteRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def delete_role(self, delete_role: ArkIdentityDeleteRole) -&gt; None:\n    \"\"\"\n    Deletes a given role by name\n\n    Args:\n        delete_role (ArkIdentityDeleteRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting role [{delete_role.role_name}]')\n    if delete_role.role_name and not delete_role.role_id:\n        delete_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=delete_role.role_name))\n    response: Response = self._client.post(f'{self._url_prefix}{DELETE_ROLE_URL}', json={'Name': delete_role.role_id})\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to delete role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse delete role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse delete role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.list_role_members","title":"<code>list_role_members(list_role_members)</code>","text":"<p>Lists a role members</p> <p>Parameters:</p> Name Type Description Default <code>list_role_members</code> <code>ArkIdentityListRoleMembers</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkIdentityRoleMember]</code> <p>List[ArkIdentityRoleMember]: description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def list_role_members(self, list_role_members: ArkIdentityListRoleMembers) -&gt; List[ArkIdentityRoleMember]:\n    \"\"\"\n    Lists a role members\n\n    Args:\n        list_role_members (ArkIdentityListRoleMembers): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkIdentityRoleMember]: _description_\n    \"\"\"\n    if list_role_members.role_name and not list_role_members.role_id:\n        list_role_members.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=list_role_members.role_name))\n    self._logger.info(f'Listing identity role [{list_role_members.role_id}] members')\n    response: Response = self._client.post(f'{self._url_prefix}{ROLE_MEMBERS_URL}', json={'Name': list_role_members.role_id})\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to list role members [{response.text}]')\n        members = []\n        if 'Result' in result and 'Results' in result['Result'] and len(result['Result']['Results']) &gt; 0:\n            members = [\n                ArkIdentityRoleMember(\n                    member_id=r['Row']['Guid'],\n                    member_name=r['Row']['Name'],\n                    member_type=ArkIdentityEntityType(r['Row']['Type'].upper()),\n                )\n                for r in result['Result']['Results']\n            ]\n        self._logger.info('Listed role members successfully successfully')\n        return members\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse list role members response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse list role members response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.remove_group_from_role","title":"<code>remove_group_from_role(remove_group_from_role)</code>","text":"<p>Removes a given group from the given role</p> <p>Parameters:</p> Name Type Description Default <code>remove_group_from_role</code> <code>ArkIdentityRemoveGroupFromRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def remove_group_from_role(self, remove_group_from_role: ArkIdentityRemoveGroupFromRole) -&gt; None:\n    \"\"\"\n    Removes a given group from the given role\n\n    Args:\n        remove_group_from_role (ArkIdentityRemoveGroupFromRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing group [{remove_group_from_role.group_name}] from role [{remove_group_from_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_group_from_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Groups': [remove_group_from_role.group_name]}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to remove group to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove group to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove group to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.remove_role_from_role","title":"<code>remove_role_from_role(remove_role_from_role)</code>","text":"<p>Removes a given role from the given role</p> <p>Parameters:</p> Name Type Description Default <code>remove_role_from_role</code> <code>ArkIdentityRemoveRoleFromRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def remove_role_from_role(self, remove_role_from_role: ArkIdentityRemoveRoleFromRole) -&gt; None:\n    \"\"\"\n    Removes a given role from the given role\n\n    Args:\n        remove_role_from_role (ArkIdentityRemoveRoleFromRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing group [{remove_role_from_role.role_name}] from role [{remove_role_from_role.role_name_to_remove}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_role_from_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Roles': [remove_role_from_role.role_name_to_remove]}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to remove role to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove role to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove role to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.remove_user_from_role","title":"<code>remove_user_from_role(remove_user_from_role)</code>","text":"<p>Removes a given user from the given role</p> <p>Parameters:</p> Name Type Description Default <code>remove_user_from_role</code> <code>ArkIdentityRemoveUserFromRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def remove_user_from_role(self, remove_user_from_role: ArkIdentityRemoveUserFromRole) -&gt; None:\n    \"\"\"\n    Removes a given user from the given role\n\n    Args:\n        remove_user_from_role (ArkIdentityRemoveUserFromRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing user [{remove_user_from_role.username}] from role [{remove_user_from_role.role_name}]')\n    role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=remove_user_from_role.role_name))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REMOVE_USER_FROM_ROLE_URL}', json={'Name': role_id, 'Users': [remove_user_from_role.username]}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to remove user to role [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove user to role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove user to role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.role_id_by_name","title":"<code>role_id_by_name(role_id_by_name)</code>","text":"<p>For a given role name, find its identifier on identity</p> <p>Parameters:</p> Name Type Description Default <code>role_id_by_name</code> <code>ArkIdentityRoleIdByName</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def role_id_by_name(self, role_id_by_name: ArkIdentityRoleIdByName) -&gt; str:\n    \"\"\"\n    For a given role name, find its identifier on identity\n\n    Args:\n        role_id_by_name (ArkIdentityRoleIdByName): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving role id for name [{role_id_by_name.role_name}]')\n    directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n    directories = [\n        d.directory_service_uuid\n        for d in directories_service.list_directories(ArkIdentityListDirectories(directories=[DirectoryService.Identity]))\n    ]\n    response: Response = self._client.post(\n        f'{self._url_prefix}{DIRECTORY_SERVICE_QUERY_URL}',\n        json=DirectoryServiceQuerySpecificRoleRequest(\n            role_name=role_id_by_name.role_name, directory_services=directories, args=DirectorySearchArgs(limit=1)\n        ).model_dump(by_alias=True, exclude={'users'}),\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to query for directory services role [{response.text}]')\n    try:\n        result = DirectoryServiceQueryResponse.model_validate_json(response.text)\n        all_roles = result.result.roles.results\n        if not len(all_roles):\n            raise ArkServiceException('No role found for given name')\n        return all_roles[0].row.id\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse role id by name response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse role id by name response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/roles/ark_identity_roles_service/#ark_sdk_python.services.identity.roles.ark_identity_roles_service.ArkIdentityRolesService.update_role","title":"<code>update_role(update_role)</code>","text":"<p>Updates a role details</p> <p>Parameters:</p> Name Type Description Default <code>update_role</code> <code>ArkIdentityUpdateRole</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/roles/ark_identity_roles_service.py</code> <pre><code>def update_role(self, update_role: ArkIdentityUpdateRole) -&gt; None:\n    \"\"\"\n    Updates a role details\n\n    Args:\n        update_role (ArkIdentityUpdateRole): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if update_role.role_name and not update_role.role_id:\n        update_role.role_id = self.role_id_by_name(ArkIdentityRoleIdByName(role_name=update_role.role_name))\n    self._logger.info(f'Updating identity role [{update_role.role_id}]')\n    update_dict = {'Name': update_role.role_id}\n    if update_role.new_role_name:\n        update_dict['NewName'] = update_role.new_role_name\n    if update_role.description:\n        update_role['Description'] = update_role.description\n    response: Response = self._client.post(f'{self._url_prefix}{UPDATE_ROLE_URL}', json=update_dict)\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to update role [{response.text}]')\n        self._logger.info('Role updated successfully')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse update role response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse update role response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/","title":"users","text":""},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService","title":"<code>ArkIdentityUsersService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>class ArkIdentityUsersService(ArkIdentityBaseService):\n    def create_user(self, create_user: ArkIdentityCreateUser) -&gt; ArkIdentityUser:\n        \"\"\"\n        Creates a user with the given details, and returns its finalized details and id\n\n        Args:\n            create_user (ArkIdentityCreateUser): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityUser: _description_\n        \"\"\"\n        self._logger.info(f'Creating identity user [{create_user.username}]')\n        directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n        tenant_suffix = create_user.suffix or directories_service.tenant_default_suffix()\n        response: Response = self._client.post(\n            f'{self._url_prefix}{CREATE_USER_URL}',\n            json={\n                \"DisplayName\": create_user.display_name,\n                \"Name\": f'{create_user.username}@{tenant_suffix}',\n                \"Mail\": create_user.email,\n                \"Password\": create_user.password.get_secret_value(),\n                \"MobileNumber\": create_user.mobile_number,\n                \"InEverybodyRole\": 'true',\n                \"InSysAdminRole\": 'false',\n                \"ForcePasswordChangeNext\": 'false',\n                \"SendEmailInvite\": 'false',\n                \"SendSmsInvite\": 'false',\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to create user [{response.text}]')\n            if create_user.roles:\n                roles_service = ArkIdentityRolesService(self._isp_auth)\n                for role in create_user.roles:\n                    roles_service.add_user_to_role(\n                        ArkIdentityAddUserToRole(username=f'{create_user.username}@{tenant_suffix}', role_name=role)\n                    )\n            self._logger.info(f'User created successfully with id [{result[\"Result\"]}]')\n            return ArkIdentityUser(\n                user_id=result['Result'],\n                username=f'{create_user.username}@{tenant_suffix}',\n                display_name=create_user.display_name,\n                email=create_user.email,\n                mobile_number=create_user.mobile_number,\n                roles=create_user.roles,\n            )\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse create user response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse create user response [{str(ex)}]') from ex\n\n    def update_user(self, update_user: ArkIdentityUpdateUser) -&gt; None:\n        \"\"\"\n        Updates the user information\n\n        Args:\n            update_user (ArkIdentityUpdateUser): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if update_user.username and not update_user.user_id:\n            update_user.user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=update_user.username))\n        self._logger.info(f'Updating identity user [{update_user.user_id}]')\n        update_dict = {}\n        if update_user.new_username:\n            if '@' not in update_user.new_username:\n                tenant_suffix = update_user.username.split('@')[1]\n                update_user.new_username = f'{update_user.new_username}@{tenant_suffix}'\n            update_dict['Name'] = update_user.new_username\n        if update_user.display_name:\n            update_dict['DisplayName'] = update_user.display_name\n        if update_user.email:\n            update_dict['Mail'] = update_user.email\n        if update_user.mobile_number:\n            update_dict['MobileNumber'] = update_user.mobile_number\n        update_dict['ID'] = update_user.user_id\n        response: Response = self._client.post(f'{self._url_prefix}{UPDATE_USER_URL}', json=update_dict)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to update user [{response.text}]')\n            self._logger.info('User updated successfully')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update user response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse update user response [{str(ex)}]') from ex\n\n    def delete_user(self, delete_user: ArkIdentityDeleteUser) -&gt; None:\n        \"\"\"\n        Deletes a user by given name\n\n        Args:\n            delete_user (ArkIdentityDeleteUser): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting user [{delete_user.user_id}]')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{DELETE_USER_URL}', json={'ID': delete_user.user_id or delete_user.username}\n        )\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to delete user [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse delete user response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse delete user response [{str(ex)}]') from ex\n\n    def delete_users(self, delete_users: ArkIdentityDeleteUsers) -&gt; None:\n        \"\"\"\n        Deletes users by given ids\n\n        Args:\n            delete_users (ArkIdentityDeleteUsers): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing users [{\",\".join(delete_users.user_ids)}]')\n        response: Response = self._client.post(f'{self._url_prefix}{REMOVE_USERS_URL}', json={'Users': [delete_users.user_ids]})\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to remove users [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove users response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove users response [{str(ex)}]') from ex\n\n    def user_id_by_name(self, user_id_by_name: ArkIdentityUserIdByName) -&gt; str:\n        \"\"\"\n        Finds the identifier of the given username\n\n        Args:\n            user_id_by_name (ArkIdentityUserIdByName): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": f\"Select ID, Username from User WHERE Username='{user_id_by_name.username}'\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve user id by name')\n            return query_result['Result'][\"Results\"][0][\"Row\"][\"ID\"]\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n\n    def user_by_name(self, user_id_by_name: ArkIdentityUserByName) -&gt; ArkIdentityUser:\n        \"\"\"\n        Finds the identifier of the given username\n\n        Args:\n            user_id_by_name (ArkIdentityUserIdByName): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\n                \"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE Username='{user_id_by_name.username}'\"\n            },\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve user id by name')\n            user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n            last_login = None\n            if last_login := user_row.get('LastLogin'):\n                try:\n                    last_login = last_login.split('(')[1].split(')')[0]\n                    last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                    last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n                except Exception as ex:\n                    self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n            return ArkIdentityUser(\n                user_id=user_row[\"ID\"],\n                username=user_row[\"Username\"],\n                display_name=user_row[\"DisplayName\"],\n                email=user_row[\"Email\"],\n                mobile_number=user_row[\"MobileNumber\"],\n                last_login=last_login,\n            )\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n\n    def user_by_id(self, user_by_id: ArkIdentityUserById) -&gt; ArkIdentityUser:\n        \"\"\"\n        Finds the identifier of the given id\n\n        Args:\n            user_by_id (ArkIdentityUserIdById): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE ID='{user_by_id.user_id}'\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve user id by id [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve user id by id')\n            user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n            last_login = None\n            if last_login := user_row.get('LastLogin'):\n                try:\n                    last_login = last_login.split('(')[1].split(')')[0]\n                    last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                    last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n                except Exception as ex:\n                    self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n            return ArkIdentityUser(\n                user_id=user_row[\"ID\"],\n                username=user_row[\"Username\"],\n                display_name=user_row[\"DisplayName\"],\n                email=user_row[\"Email\"],\n                mobile_number=user_row[\"MobileNumber\"],\n                last_login=last_login,\n            )\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse user id by id response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse user id by id response [{str(ex)}]') from ex\n\n    def reset_user_password(self, reset_user_password: ArkIdentityResetUserPassword) -&gt; None:\n        \"\"\"\n        Resets a given username's password to the new given one\n        Assumes the logged in user has permissions to do so\n\n        Args:\n            reset_user_password (ArkIdentityResetUserPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=reset_user_password.username))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{RESET_USER_PASSWORD_URL}', json={'ID': user_id, 'newPassword': reset_user_password.new_password}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to reset user password [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse reset user password response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse reset user password response [{str(ex)}]') from ex\n\n    def user_info(self) -&gt; ArkIdentityUserInfo:\n        \"\"\"\n        Retrieves the current user info\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityUserInfo: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{USER_INFO_URL}',\n            json={'Scopes': ['userInfo']},\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK:\n                raise ArkServiceException(f'Failed to get user info [{response.text}]')\n            return ArkIdentityUserInfo.model_validate(result)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to get user info [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to get user info [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.create_user","title":"<code>create_user(create_user)</code>","text":"<p>Creates a user with the given details, and returns its finalized details and id</p> <p>Parameters:</p> Name Type Description Default <code>create_user</code> <code>ArkIdentityCreateUser</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUser</code> <code>ArkIdentityUser</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def create_user(self, create_user: ArkIdentityCreateUser) -&gt; ArkIdentityUser:\n    \"\"\"\n    Creates a user with the given details, and returns its finalized details and id\n\n    Args:\n        create_user (ArkIdentityCreateUser): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityUser: _description_\n    \"\"\"\n    self._logger.info(f'Creating identity user [{create_user.username}]')\n    directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n    tenant_suffix = create_user.suffix or directories_service.tenant_default_suffix()\n    response: Response = self._client.post(\n        f'{self._url_prefix}{CREATE_USER_URL}',\n        json={\n            \"DisplayName\": create_user.display_name,\n            \"Name\": f'{create_user.username}@{tenant_suffix}',\n            \"Mail\": create_user.email,\n            \"Password\": create_user.password.get_secret_value(),\n            \"MobileNumber\": create_user.mobile_number,\n            \"InEverybodyRole\": 'true',\n            \"InSysAdminRole\": 'false',\n            \"ForcePasswordChangeNext\": 'false',\n            \"SendEmailInvite\": 'false',\n            \"SendSmsInvite\": 'false',\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to create user [{response.text}]')\n        if create_user.roles:\n            roles_service = ArkIdentityRolesService(self._isp_auth)\n            for role in create_user.roles:\n                roles_service.add_user_to_role(\n                    ArkIdentityAddUserToRole(username=f'{create_user.username}@{tenant_suffix}', role_name=role)\n                )\n        self._logger.info(f'User created successfully with id [{result[\"Result\"]}]')\n        return ArkIdentityUser(\n            user_id=result['Result'],\n            username=f'{create_user.username}@{tenant_suffix}',\n            display_name=create_user.display_name,\n            email=create_user.email,\n            mobile_number=create_user.mobile_number,\n            roles=create_user.roles,\n        )\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse create user response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse create user response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.delete_user","title":"<code>delete_user(delete_user)</code>","text":"<p>Deletes a user by given name</p> <p>Parameters:</p> Name Type Description Default <code>delete_user</code> <code>ArkIdentityDeleteUser</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def delete_user(self, delete_user: ArkIdentityDeleteUser) -&gt; None:\n    \"\"\"\n    Deletes a user by given name\n\n    Args:\n        delete_user (ArkIdentityDeleteUser): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting user [{delete_user.user_id}]')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{DELETE_USER_URL}', json={'ID': delete_user.user_id or delete_user.username}\n    )\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to delete user [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse delete user response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse delete user response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.delete_users","title":"<code>delete_users(delete_users)</code>","text":"<p>Deletes users by given ids</p> <p>Parameters:</p> Name Type Description Default <code>delete_users</code> <code>ArkIdentityDeleteUsers</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def delete_users(self, delete_users: ArkIdentityDeleteUsers) -&gt; None:\n    \"\"\"\n    Deletes users by given ids\n\n    Args:\n        delete_users (ArkIdentityDeleteUsers): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing users [{\",\".join(delete_users.user_ids)}]')\n    response: Response = self._client.post(f'{self._url_prefix}{REMOVE_USERS_URL}', json={'Users': [delete_users.user_ids]})\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to remove users [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove users response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove users response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.reset_user_password","title":"<code>reset_user_password(reset_user_password)</code>","text":"<p>Resets a given username's password to the new given one Assumes the logged in user has permissions to do so</p> <p>Parameters:</p> Name Type Description Default <code>reset_user_password</code> <code>ArkIdentityResetUserPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def reset_user_password(self, reset_user_password: ArkIdentityResetUserPassword) -&gt; None:\n    \"\"\"\n    Resets a given username's password to the new given one\n    Assumes the logged in user has permissions to do so\n\n    Args:\n        reset_user_password (ArkIdentityResetUserPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=reset_user_password.username))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{RESET_USER_PASSWORD_URL}', json={'ID': user_id, 'newPassword': reset_user_password.new_password}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to reset user password [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse reset user password response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse reset user password response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.update_user","title":"<code>update_user(update_user)</code>","text":"<p>Updates the user information</p> <p>Parameters:</p> Name Type Description Default <code>update_user</code> <code>ArkIdentityUpdateUser</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def update_user(self, update_user: ArkIdentityUpdateUser) -&gt; None:\n    \"\"\"\n    Updates the user information\n\n    Args:\n        update_user (ArkIdentityUpdateUser): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if update_user.username and not update_user.user_id:\n        update_user.user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=update_user.username))\n    self._logger.info(f'Updating identity user [{update_user.user_id}]')\n    update_dict = {}\n    if update_user.new_username:\n        if '@' not in update_user.new_username:\n            tenant_suffix = update_user.username.split('@')[1]\n            update_user.new_username = f'{update_user.new_username}@{tenant_suffix}'\n        update_dict['Name'] = update_user.new_username\n    if update_user.display_name:\n        update_dict['DisplayName'] = update_user.display_name\n    if update_user.email:\n        update_dict['Mail'] = update_user.email\n    if update_user.mobile_number:\n        update_dict['MobileNumber'] = update_user.mobile_number\n    update_dict['ID'] = update_user.user_id\n    response: Response = self._client.post(f'{self._url_prefix}{UPDATE_USER_URL}', json=update_dict)\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to update user [{response.text}]')\n        self._logger.info('User updated successfully')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse update user response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse update user response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.user_by_id","title":"<code>user_by_id(user_by_id)</code>","text":"<p>Finds the identifier of the given id</p> <p>Parameters:</p> Name Type Description Default <code>user_by_id</code> <code>ArkIdentityUserIdById</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>ArkIdentityUser</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_by_id(self, user_by_id: ArkIdentityUserById) -&gt; ArkIdentityUser:\n    \"\"\"\n    Finds the identifier of the given id\n\n    Args:\n        user_by_id (ArkIdentityUserIdById): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE ID='{user_by_id.user_id}'\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve user id by id [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve user id by id')\n        user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n        last_login = None\n        if last_login := user_row.get('LastLogin'):\n            try:\n                last_login = last_login.split('(')[1].split(')')[0]\n                last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n            except Exception as ex:\n                self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n        return ArkIdentityUser(\n            user_id=user_row[\"ID\"],\n            username=user_row[\"Username\"],\n            display_name=user_row[\"DisplayName\"],\n            email=user_row[\"Email\"],\n            mobile_number=user_row[\"MobileNumber\"],\n            last_login=last_login,\n        )\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse user id by id response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse user id by id response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.user_by_name","title":"<code>user_by_name(user_id_by_name)</code>","text":"<p>Finds the identifier of the given username</p> <p>Parameters:</p> Name Type Description Default <code>user_id_by_name</code> <code>ArkIdentityUserIdByName</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>ArkIdentityUser</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_by_name(self, user_id_by_name: ArkIdentityUserByName) -&gt; ArkIdentityUser:\n    \"\"\"\n    Finds the identifier of the given username\n\n    Args:\n        user_id_by_name (ArkIdentityUserIdByName): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\n            \"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE Username='{user_id_by_name.username}'\"\n        },\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve user id by name')\n        user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n        last_login = None\n        if last_login := user_row.get('LastLogin'):\n            try:\n                last_login = last_login.split('(')[1].split(')')[0]\n                last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n            except Exception as ex:\n                self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n        return ArkIdentityUser(\n            user_id=user_row[\"ID\"],\n            username=user_row[\"Username\"],\n            display_name=user_row[\"DisplayName\"],\n            email=user_row[\"Email\"],\n            mobile_number=user_row[\"MobileNumber\"],\n            last_login=last_login,\n        )\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.user_id_by_name","title":"<code>user_id_by_name(user_id_by_name)</code>","text":"<p>Finds the identifier of the given username</p> <p>Parameters:</p> Name Type Description Default <code>user_id_by_name</code> <code>ArkIdentityUserIdByName</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_id_by_name(self, user_id_by_name: ArkIdentityUserIdByName) -&gt; str:\n    \"\"\"\n    Finds the identifier of the given username\n\n    Args:\n        user_id_by_name (ArkIdentityUserIdByName): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": f\"Select ID, Username from User WHERE Username='{user_id_by_name.username}'\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve user id by name')\n        return query_result['Result'][\"Results\"][0][\"Row\"][\"ID\"]\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/#ark_sdk_python.services.identity.users.ArkIdentityUsersService.user_info","title":"<code>user_info()</code>","text":"<p>Retrieves the current user info</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUserInfo</code> <code>ArkIdentityUserInfo</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_info(self) -&gt; ArkIdentityUserInfo:\n    \"\"\"\n    Retrieves the current user info\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityUserInfo: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{USER_INFO_URL}',\n        json={'Scopes': ['userInfo']},\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get user info [{response.text}]')\n        return ArkIdentityUserInfo.model_validate(result)\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to get user info [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to get user info [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/","title":"ark_identity_users_service","text":""},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService","title":"<code>ArkIdentityUsersService</code>","text":"<p>               Bases: <code>ArkIdentityBaseService</code></p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>class ArkIdentityUsersService(ArkIdentityBaseService):\n    def create_user(self, create_user: ArkIdentityCreateUser) -&gt; ArkIdentityUser:\n        \"\"\"\n        Creates a user with the given details, and returns its finalized details and id\n\n        Args:\n            create_user (ArkIdentityCreateUser): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityUser: _description_\n        \"\"\"\n        self._logger.info(f'Creating identity user [{create_user.username}]')\n        directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n        tenant_suffix = create_user.suffix or directories_service.tenant_default_suffix()\n        response: Response = self._client.post(\n            f'{self._url_prefix}{CREATE_USER_URL}',\n            json={\n                \"DisplayName\": create_user.display_name,\n                \"Name\": f'{create_user.username}@{tenant_suffix}',\n                \"Mail\": create_user.email,\n                \"Password\": create_user.password.get_secret_value(),\n                \"MobileNumber\": create_user.mobile_number,\n                \"InEverybodyRole\": 'true',\n                \"InSysAdminRole\": 'false',\n                \"ForcePasswordChangeNext\": 'false',\n                \"SendEmailInvite\": 'false',\n                \"SendSmsInvite\": 'false',\n            },\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to create user [{response.text}]')\n            if create_user.roles:\n                roles_service = ArkIdentityRolesService(self._isp_auth)\n                for role in create_user.roles:\n                    roles_service.add_user_to_role(\n                        ArkIdentityAddUserToRole(username=f'{create_user.username}@{tenant_suffix}', role_name=role)\n                    )\n            self._logger.info(f'User created successfully with id [{result[\"Result\"]}]')\n            return ArkIdentityUser(\n                user_id=result['Result'],\n                username=f'{create_user.username}@{tenant_suffix}',\n                display_name=create_user.display_name,\n                email=create_user.email,\n                mobile_number=create_user.mobile_number,\n                roles=create_user.roles,\n            )\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse create user response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse create user response [{str(ex)}]') from ex\n\n    def update_user(self, update_user: ArkIdentityUpdateUser) -&gt; None:\n        \"\"\"\n        Updates the user information\n\n        Args:\n            update_user (ArkIdentityUpdateUser): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if update_user.username and not update_user.user_id:\n            update_user.user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=update_user.username))\n        self._logger.info(f'Updating identity user [{update_user.user_id}]')\n        update_dict = {}\n        if update_user.new_username:\n            if '@' not in update_user.new_username:\n                tenant_suffix = update_user.username.split('@')[1]\n                update_user.new_username = f'{update_user.new_username}@{tenant_suffix}'\n            update_dict['Name'] = update_user.new_username\n        if update_user.display_name:\n            update_dict['DisplayName'] = update_user.display_name\n        if update_user.email:\n            update_dict['Mail'] = update_user.email\n        if update_user.mobile_number:\n            update_dict['MobileNumber'] = update_user.mobile_number\n        update_dict['ID'] = update_user.user_id\n        response: Response = self._client.post(f'{self._url_prefix}{UPDATE_USER_URL}', json=update_dict)\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to update user [{response.text}]')\n            self._logger.info('User updated successfully')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update user response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse update user response [{str(ex)}]') from ex\n\n    def delete_user(self, delete_user: ArkIdentityDeleteUser) -&gt; None:\n        \"\"\"\n        Deletes a user by given name\n\n        Args:\n            delete_user (ArkIdentityDeleteUser): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting user [{delete_user.user_id}]')\n        response: Response = self._client.post(\n            f'{self._url_prefix}{DELETE_USER_URL}', json={'ID': delete_user.user_id or delete_user.username}\n        )\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to delete user [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse delete user response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse delete user response [{str(ex)}]') from ex\n\n    def delete_users(self, delete_users: ArkIdentityDeleteUsers) -&gt; None:\n        \"\"\"\n        Deletes users by given ids\n\n        Args:\n            delete_users (ArkIdentityDeleteUsers): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Removing users [{\",\".join(delete_users.user_ids)}]')\n        response: Response = self._client.post(f'{self._url_prefix}{REMOVE_USERS_URL}', json={'Users': [delete_users.user_ids]})\n        try:\n            if response.status_code != HTTPStatus.OK or not response.json()['success']:\n                raise ArkServiceException(f'Failed to remove users [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse remove users response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse remove users response [{str(ex)}]') from ex\n\n    def user_id_by_name(self, user_id_by_name: ArkIdentityUserIdByName) -&gt; str:\n        \"\"\"\n        Finds the identifier of the given username\n\n        Args:\n            user_id_by_name (ArkIdentityUserIdByName): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": f\"Select ID, Username from User WHERE Username='{user_id_by_name.username}'\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve user id by name')\n            return query_result['Result'][\"Results\"][0][\"Row\"][\"ID\"]\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n\n    def user_by_name(self, user_id_by_name: ArkIdentityUserByName) -&gt; ArkIdentityUser:\n        \"\"\"\n        Finds the identifier of the given username\n\n        Args:\n            user_id_by_name (ArkIdentityUserIdByName): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\n                \"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE Username='{user_id_by_name.username}'\"\n            },\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve user id by name')\n            user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n            last_login = None\n            if last_login := user_row.get('LastLogin'):\n                try:\n                    last_login = last_login.split('(')[1].split(')')[0]\n                    last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                    last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n                except Exception as ex:\n                    self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n            return ArkIdentityUser(\n                user_id=user_row[\"ID\"],\n                username=user_row[\"Username\"],\n                display_name=user_row[\"DisplayName\"],\n                email=user_row[\"Email\"],\n                mobile_number=user_row[\"MobileNumber\"],\n                last_login=last_login,\n            )\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n\n    def user_by_id(self, user_by_id: ArkIdentityUserById) -&gt; ArkIdentityUser:\n        \"\"\"\n        Finds the identifier of the given id\n\n        Args:\n            user_by_id (ArkIdentityUserIdById): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{REDROCK_QUERY}',\n            json={\"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE ID='{user_by_id.user_id}'\"},\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve user id by id [{response.text}] - [{response.status_code}]')\n        try:\n            query_result = response.json()\n            if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n                raise ArkServiceException('Failed to retrieve user id by id')\n            user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n            last_login = None\n            if last_login := user_row.get('LastLogin'):\n                try:\n                    last_login = last_login.split('(')[1].split(')')[0]\n                    last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                    last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n                except Exception as ex:\n                    self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n            return ArkIdentityUser(\n                user_id=user_row[\"ID\"],\n                username=user_row[\"Username\"],\n                display_name=user_row[\"DisplayName\"],\n                email=user_row[\"Email\"],\n                mobile_number=user_row[\"MobileNumber\"],\n                last_login=last_login,\n            )\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse user id by id response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse user id by id response [{str(ex)}]') from ex\n\n    def reset_user_password(self, reset_user_password: ArkIdentityResetUserPassword) -&gt; None:\n        \"\"\"\n        Resets a given username's password to the new given one\n        Assumes the logged in user has permissions to do so\n\n        Args:\n            reset_user_password (ArkIdentityResetUserPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=reset_user_password.username))\n        response: Response = self._client.post(\n            f'{self._url_prefix}{RESET_USER_PASSWORD_URL}', json={'ID': user_id, 'newPassword': reset_user_password.new_password}\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK or not result['success']:\n                raise ArkServiceException(f'Failed to reset user password [{response.text}]')\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse reset user password response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse reset user password response [{str(ex)}]') from ex\n\n    def user_info(self) -&gt; ArkIdentityUserInfo:\n        \"\"\"\n        Retrieves the current user info\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkIdentityUserInfo: _description_\n        \"\"\"\n        response: Response = self._client.post(\n            f'{self._url_prefix}{USER_INFO_URL}',\n            json={'Scopes': ['userInfo']},\n        )\n        try:\n            result = response.json()\n            if response.status_code != HTTPStatus.OK:\n                raise ArkServiceException(f'Failed to get user info [{response.text}]')\n            return ArkIdentityUserInfo.model_validate(result)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to get user info [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to get user info [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.create_user","title":"<code>create_user(create_user)</code>","text":"<p>Creates a user with the given details, and returns its finalized details and id</p> <p>Parameters:</p> Name Type Description Default <code>create_user</code> <code>ArkIdentityCreateUser</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUser</code> <code>ArkIdentityUser</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def create_user(self, create_user: ArkIdentityCreateUser) -&gt; ArkIdentityUser:\n    \"\"\"\n    Creates a user with the given details, and returns its finalized details and id\n\n    Args:\n        create_user (ArkIdentityCreateUser): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityUser: _description_\n    \"\"\"\n    self._logger.info(f'Creating identity user [{create_user.username}]')\n    directories_service = ArkIdentityDirectoriesService(self._isp_auth)\n    tenant_suffix = create_user.suffix or directories_service.tenant_default_suffix()\n    response: Response = self._client.post(\n        f'{self._url_prefix}{CREATE_USER_URL}',\n        json={\n            \"DisplayName\": create_user.display_name,\n            \"Name\": f'{create_user.username}@{tenant_suffix}',\n            \"Mail\": create_user.email,\n            \"Password\": create_user.password.get_secret_value(),\n            \"MobileNumber\": create_user.mobile_number,\n            \"InEverybodyRole\": 'true',\n            \"InSysAdminRole\": 'false',\n            \"ForcePasswordChangeNext\": 'false',\n            \"SendEmailInvite\": 'false',\n            \"SendSmsInvite\": 'false',\n        },\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to create user [{response.text}]')\n        if create_user.roles:\n            roles_service = ArkIdentityRolesService(self._isp_auth)\n            for role in create_user.roles:\n                roles_service.add_user_to_role(\n                    ArkIdentityAddUserToRole(username=f'{create_user.username}@{tenant_suffix}', role_name=role)\n                )\n        self._logger.info(f'User created successfully with id [{result[\"Result\"]}]')\n        return ArkIdentityUser(\n            user_id=result['Result'],\n            username=f'{create_user.username}@{tenant_suffix}',\n            display_name=create_user.display_name,\n            email=create_user.email,\n            mobile_number=create_user.mobile_number,\n            roles=create_user.roles,\n        )\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse create user response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse create user response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.delete_user","title":"<code>delete_user(delete_user)</code>","text":"<p>Deletes a user by given name</p> <p>Parameters:</p> Name Type Description Default <code>delete_user</code> <code>ArkIdentityDeleteUser</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def delete_user(self, delete_user: ArkIdentityDeleteUser) -&gt; None:\n    \"\"\"\n    Deletes a user by given name\n\n    Args:\n        delete_user (ArkIdentityDeleteUser): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting user [{delete_user.user_id}]')\n    response: Response = self._client.post(\n        f'{self._url_prefix}{DELETE_USER_URL}', json={'ID': delete_user.user_id or delete_user.username}\n    )\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to delete user [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse delete user response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse delete user response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.delete_users","title":"<code>delete_users(delete_users)</code>","text":"<p>Deletes users by given ids</p> <p>Parameters:</p> Name Type Description Default <code>delete_users</code> <code>ArkIdentityDeleteUsers</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def delete_users(self, delete_users: ArkIdentityDeleteUsers) -&gt; None:\n    \"\"\"\n    Deletes users by given ids\n\n    Args:\n        delete_users (ArkIdentityDeleteUsers): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Removing users [{\",\".join(delete_users.user_ids)}]')\n    response: Response = self._client.post(f'{self._url_prefix}{REMOVE_USERS_URL}', json={'Users': [delete_users.user_ids]})\n    try:\n        if response.status_code != HTTPStatus.OK or not response.json()['success']:\n            raise ArkServiceException(f'Failed to remove users [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse remove users response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse remove users response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.reset_user_password","title":"<code>reset_user_password(reset_user_password)</code>","text":"<p>Resets a given username's password to the new given one Assumes the logged in user has permissions to do so</p> <p>Parameters:</p> Name Type Description Default <code>reset_user_password</code> <code>ArkIdentityResetUserPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def reset_user_password(self, reset_user_password: ArkIdentityResetUserPassword) -&gt; None:\n    \"\"\"\n    Resets a given username's password to the new given one\n    Assumes the logged in user has permissions to do so\n\n    Args:\n        reset_user_password (ArkIdentityResetUserPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=reset_user_password.username))\n    response: Response = self._client.post(\n        f'{self._url_prefix}{RESET_USER_PASSWORD_URL}', json={'ID': user_id, 'newPassword': reset_user_password.new_password}\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to reset user password [{response.text}]')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse reset user password response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse reset user password response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.update_user","title":"<code>update_user(update_user)</code>","text":"<p>Updates the user information</p> <p>Parameters:</p> Name Type Description Default <code>update_user</code> <code>ArkIdentityUpdateUser</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def update_user(self, update_user: ArkIdentityUpdateUser) -&gt; None:\n    \"\"\"\n    Updates the user information\n\n    Args:\n        update_user (ArkIdentityUpdateUser): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if update_user.username and not update_user.user_id:\n        update_user.user_id = self.user_id_by_name(ArkIdentityUserIdByName(username=update_user.username))\n    self._logger.info(f'Updating identity user [{update_user.user_id}]')\n    update_dict = {}\n    if update_user.new_username:\n        if '@' not in update_user.new_username:\n            tenant_suffix = update_user.username.split('@')[1]\n            update_user.new_username = f'{update_user.new_username}@{tenant_suffix}'\n        update_dict['Name'] = update_user.new_username\n    if update_user.display_name:\n        update_dict['DisplayName'] = update_user.display_name\n    if update_user.email:\n        update_dict['Mail'] = update_user.email\n    if update_user.mobile_number:\n        update_dict['MobileNumber'] = update_user.mobile_number\n    update_dict['ID'] = update_user.user_id\n    response: Response = self._client.post(f'{self._url_prefix}{UPDATE_USER_URL}', json=update_dict)\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK or not result['success']:\n            raise ArkServiceException(f'Failed to update user [{response.text}]')\n        self._logger.info('User updated successfully')\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse update user response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse update user response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.user_by_id","title":"<code>user_by_id(user_by_id)</code>","text":"<p>Finds the identifier of the given id</p> <p>Parameters:</p> Name Type Description Default <code>user_by_id</code> <code>ArkIdentityUserIdById</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>ArkIdentityUser</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_by_id(self, user_by_id: ArkIdentityUserById) -&gt; ArkIdentityUser:\n    \"\"\"\n    Finds the identifier of the given id\n\n    Args:\n        user_by_id (ArkIdentityUserIdById): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE ID='{user_by_id.user_id}'\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve user id by id [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve user id by id')\n        user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n        last_login = None\n        if last_login := user_row.get('LastLogin'):\n            try:\n                last_login = last_login.split('(')[1].split(')')[0]\n                last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n            except Exception as ex:\n                self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n        return ArkIdentityUser(\n            user_id=user_row[\"ID\"],\n            username=user_row[\"Username\"],\n            display_name=user_row[\"DisplayName\"],\n            email=user_row[\"Email\"],\n            mobile_number=user_row[\"MobileNumber\"],\n            last_login=last_login,\n        )\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse user id by id response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse user id by id response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.user_by_name","title":"<code>user_by_name(user_id_by_name)</code>","text":"<p>Finds the identifier of the given username</p> <p>Parameters:</p> Name Type Description Default <code>user_id_by_name</code> <code>ArkIdentityUserIdByName</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>ArkIdentityUser</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_by_name(self, user_id_by_name: ArkIdentityUserByName) -&gt; ArkIdentityUser:\n    \"\"\"\n    Finds the identifier of the given username\n\n    Args:\n        user_id_by_name (ArkIdentityUserIdByName): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\n            \"Script\": f\"Select ID, Username, DisplayName, Email, MobileNumber, LastLogin from User WHERE Username='{user_id_by_name.username}'\"\n        },\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve user id by name')\n        user_row = query_result['Result'][\"Results\"][0][\"Row\"]\n        last_login = None\n        if last_login := user_row.get('LastLogin'):\n            try:\n                last_login = last_login.split('(')[1].split(')')[0]\n                last_login = f'{last_login[:10]}.{last_login[10:]}'  # for milliseconds\n                last_login = datetime.fromtimestamp(float(last_login), timezone.utc)\n            except Exception as ex:\n                self._logger.debug(f'Failed to parse last login [{user_row.get(\"LastLogin\")}] [{str(ex)}]')\n\n        return ArkIdentityUser(\n            user_id=user_row[\"ID\"],\n            username=user_row[\"Username\"],\n            display_name=user_row[\"DisplayName\"],\n            email=user_row[\"Email\"],\n            mobile_number=user_row[\"MobileNumber\"],\n            last_login=last_login,\n        )\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.user_id_by_name","title":"<code>user_id_by_name(user_id_by_name)</code>","text":"<p>Finds the identifier of the given username</p> <p>Parameters:</p> Name Type Description Default <code>user_id_by_name</code> <code>ArkIdentityUserIdByName</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_id_by_name(self, user_id_by_name: ArkIdentityUserIdByName) -&gt; str:\n    \"\"\"\n    Finds the identifier of the given username\n\n    Args:\n        user_id_by_name (ArkIdentityUserIdByName): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{REDROCK_QUERY}',\n        json={\"Script\": f\"Select ID, Username from User WHERE Username='{user_id_by_name.username}'\"},\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve user id by name [{response.text}] - [{response.status_code}]')\n    try:\n        query_result = response.json()\n        if not query_result['success'] or len(query_result['Result'][\"Results\"]) == 0:\n            raise ArkServiceException('Failed to retrieve user id by name')\n        return query_result['Result'][\"Results\"][0][\"Row\"][\"ID\"]\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse user id by name response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse user id by name response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/identity/users/ark_identity_users_service/#ark_sdk_python.services.identity.users.ark_identity_users_service.ArkIdentityUsersService.user_info","title":"<code>user_info()</code>","text":"<p>Retrieves the current user info</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkIdentityUserInfo</code> <code>ArkIdentityUserInfo</code> <p>description</p> Source code in <code>ark_sdk_python/services/identity/users/ark_identity_users_service.py</code> <pre><code>def user_info(self) -&gt; ArkIdentityUserInfo:\n    \"\"\"\n    Retrieves the current user info\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkIdentityUserInfo: _description_\n    \"\"\"\n    response: Response = self._client.post(\n        f'{self._url_prefix}{USER_INFO_URL}',\n        json={'Scopes': ['userInfo']},\n    )\n    try:\n        result = response.json()\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get user info [{response.text}]')\n        return ArkIdentityUserInfo.model_validate(result)\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to get user info [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to get user info [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/pcloud/","title":"pcloud","text":""},{"location":"reference/services/pcloud/ark_pcloud_api/","title":"ark_pcloud_api","text":""},{"location":"reference/services/pcloud/ark_pcloud_api/#ark_sdk_python.services.pcloud.ark_pcloud_api.ArkPCloudAPI","title":"<code>ArkPCloudAPI</code>","text":"Source code in <code>ark_sdk_python/services/pcloud/ark_pcloud_api.py</code> <pre><code>class ArkPCloudAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__accounts_service = ArkPCloudAccountsService(isp_auth)\n        self.__platforms_service = ArkPCloudPlatformsService(isp_auth)\n        self.__safes_service = ArkPCloudSafesService(isp_auth)\n        self.__applications_service = ArkPCloudApplicationsService(isp_auth)\n\n    @property\n    def accounts(self) -&gt; ArkPCloudAccountsService:\n        \"\"\"\n        Getter for the accounts service\n\n        Returns:\n            ArkPCloudAccountsService: _description_\n        \"\"\"\n        return self.__accounts_service\n\n    @property\n    def platforms(self) -&gt; ArkPCloudPlatformsService:\n        \"\"\"\n        Getter for the platforms service\n\n        Returns:\n            ArkPCloudPlatformsService: _description_\n        \"\"\"\n        return self.__platforms_service\n\n    @property\n    def safes(self) -&gt; ArkPCloudSafesService:\n        \"\"\"\n        Getter for the safes service\n\n        Returns:\n            ArkPCloudSafesService: _description_\n        \"\"\"\n        return self.__safes_service\n\n    @property\n    def applications(self) -&gt; ArkPCloudApplicationsService:\n        \"\"\"\n        Getter for the applications service\n\n        Returns:\n            ArkPCloudApplicationsService: _description_\n        \"\"\"\n        return self.__applications_service\n</code></pre>"},{"location":"reference/services/pcloud/ark_pcloud_api/#ark_sdk_python.services.pcloud.ark_pcloud_api.ArkPCloudAPI.accounts","title":"<code>accounts</code>  <code>property</code>","text":"<p>Getter for the accounts service</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountsService</code> <code>ArkPCloudAccountsService</code> <p>description</p>"},{"location":"reference/services/pcloud/ark_pcloud_api/#ark_sdk_python.services.pcloud.ark_pcloud_api.ArkPCloudAPI.applications","title":"<code>applications</code>  <code>property</code>","text":"<p>Getter for the applications service</p> <p>Returns:</p> Name Type Description <code>ArkPCloudApplicationsService</code> <code>ArkPCloudApplicationsService</code> <p>description</p>"},{"location":"reference/services/pcloud/ark_pcloud_api/#ark_sdk_python.services.pcloud.ark_pcloud_api.ArkPCloudAPI.platforms","title":"<code>platforms</code>  <code>property</code>","text":"<p>Getter for the platforms service</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatformsService</code> <code>ArkPCloudPlatformsService</code> <p>description</p>"},{"location":"reference/services/pcloud/ark_pcloud_api/#ark_sdk_python.services.pcloud.ark_pcloud_api.ArkPCloudAPI.safes","title":"<code>safes</code>  <code>property</code>","text":"<p>Getter for the safes service</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafesService</code> <code>ArkPCloudSafesService</code> <p>description</p>"},{"location":"reference/services/pcloud/accounts/","title":"accounts","text":""},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService","title":"<code>ArkPCloudAccountsService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>class ArkPCloudAccountsService(ArkPCloudBaseService):\n    def __list_accounts_with_filters(\n        self,\n        search: Optional[str] = None,\n        search_type: Optional[str] = None,\n        sort: Optional[str] = None,\n        offset: Optional[int] = None,\n        limit: Optional[int] = None,\n        safe_name: Optional[str] = None,\n    ) -&gt; Iterator[ArkPCloudAccountsPage]:\n        query = {}\n        if search:\n            query['search'] = search\n        if search_type:\n            query['searchType'] = search_type\n        if sort:\n            query['sort'] = sort\n        if offset:\n            query['offset'] = offset\n        if limit:\n            query['limit'] = limit\n        if safe_name:\n            query['filter'] = f'safeName eq {safe_name}'\n        while True:\n            resp: Response = self._client.get(ACCOUNTS_URL, params=query)\n            if resp.status_code == HTTPStatus.OK:\n                try:\n                    result = resp.json()\n                    accounts = TypeAdapter(List[ArkPCloudAccount]).validate_python(result['value'])\n                    yield ArkPCloudAccountsPage(items=accounts)\n                    if 'nextLink' in result:\n                        query = parse_qs(urlparse(result['nextLink']).query)\n                    else:\n                        break\n                except (ValidationError, JSONDecodeError, KeyError) as ex:\n                    self._logger.exception(f'Failed to parse list accounts response [{str(ex)}] - [{resp.text}]')\n                    raise ArkServiceException(f'Failed to parse list accounts response [{str(ex)}]') from ex\n            else:\n                raise ArkServiceException(f'Failed to list accounts [{resp.text}] - [{resp.status_code}]')\n\n    def list_accounts(self) -&gt; Iterator[ArkPCloudAccountsPage]:\n        \"\"\"\n        Yields all visible accounts to the logged in user as pages of accounts\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n        Yields:\n            Iterator[ArkPCloudAccountsPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all accounts')\n        yield from self.__list_accounts_with_filters()\n\n    def list_accounts_by(self, accounts_filter: ArkPCloudAccountsFilter) -&gt; Iterator[ArkPCloudAccountsPage]:\n        \"\"\"\n        Yields visible accounts to the logged in user by filters as pages of accounts\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n        Args:\n            accounts_filter (ArkPCloudAccountsFilter): _description_\n\n        Yields:\n            Iterator[ArkPCloudAccountsPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing accounts by filters [{accounts_filter}]')\n        yield from self.__list_accounts_with_filters(\n            accounts_filter.search,\n            accounts_filter.search_type,\n            accounts_filter.sort,\n            accounts_filter.offset,\n            accounts_filter.limit,\n            accounts_filter.safe_name,\n        )\n\n    def list_account_secret_versions(\n        self, list_account_secret_versions: ArkPCloudListAccountSecretVersions\n    ) -&gt; List[ArkPCloudAccountSecretVersion]:\n        \"\"\"\n        Lists the given account secret versions\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Get-versions.htm\n\n        Args:\n            list_account_secret_versions (ArkPCloudListAccountSecretVersions): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkPCloudAccountSecretVersion]: _description_\n        \"\"\"\n        self._logger.info(f'Listing account [{list_account_secret_versions.account_id}] secret versions')\n        resp: Response = self._client.get(ACCOUNT_SECRET_VERSIONS.format(account_id=list_account_secret_versions.account_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkPCloudAccountSecretVersion]).validate_python(resp.json()['versions'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list account secret versions response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list account secret versions response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list account secret versions [{resp.text}] - [{resp.status_code}]')\n\n    def generate_account_credentials(\n        self, generate_account_credentials: ArkPCloudGenerateAccountCredentials\n    ) -&gt; ArkPCloudAccountCredentials:\n        \"\"\"\n        Generate a new random password for an existing account with policy restrictions\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Generate-Password.htm\n\n        Args:\n            generate_account_credentials (ArkPCloudGenerateAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccountCredentials: _description_\n        \"\"\"\n        self._logger.info(f'Generating new password for account [{generate_account_credentials.account_id}]')\n        resp: Response = self._client.post(GENERATE_ACCOUNT_CREDENTIALS.format(account_id=generate_account_credentials.account_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudAccountCredentials(account_id=generate_account_credentials.account_id, password=resp.json()['password'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse genereate account credentials response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse genereate account credentials response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate password for account [{resp.text}] - [{resp.status_code}]')\n\n    def verify_account_credentials(self, verify_account_credentials: ArkPCloudVerifyAccountCredentials) -&gt; None:\n        \"\"\"\n        Marks the account for password verification by CPM\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Verify-credentials-v9-10.htm\n\n        Args:\n            verify_account_credentials (ArkPCloudVerifyAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{verify_account_credentials.account_id}] for verification')\n        resp: Response = self._client.post(VERIFY_ACCOUNT_CREDENTIALS.format(account_id=verify_account_credentials.account_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to mark account for password verification [{resp.text}] - [{resp.status_code}]')\n\n    def change_account_credentials(self, change_account_credentials: ArkPCloudChangeAccountCredentials) -&gt; None:\n        \"\"\"\n        Marks the account for password changing immediately by CPM\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Change-credentials-immediately.htm\n\n        Args:\n            change_account_credentials (ArkPCloudChangeAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{change_account_credentials.account_id}] for changing credentials immediately')\n        resp: Response = self._client.post(CHANGE_ACCOUNT_CREDENTIALS.format(account_id=change_account_credentials.account_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to mark account for changing credentials immediately [{resp.text}] - [{resp.status_code}]')\n\n    def set_account_next_credentials(self, set_account_next_credentials: ArkPCloudSetAccountNextCredentials) -&gt; None:\n        \"\"\"\n        Marks the account to have its password changed to the given one via CPM\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/SetNextPassword.htm\n\n        Args:\n            set_account_next_credentials (ArkPCloudSetAccountNextCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{set_account_next_credentials.account_id}] for changing credentials for the given password')\n        resp: Response = self._client.post(\n            SET_ACCOUNT_NEXT_CREDENTIALS.format(account_id=set_account_next_credentials.account_id),\n            json=set_account_next_credentials.model_dump(exclude={'account_id'}, by_alias=True),\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to mark account for changing credentials next password [{resp.text}] - [{resp.status_code}]')\n\n    def update_account_credentials_in_vault(self, update_account_credentials_in_vault: ArkPCloudUpdateAccountCredentialsInVault) -&gt; None:\n        \"\"\"\n        Updates the account credentials only in the vault without changing it on the machine itself\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/ChangeCredentialsInVault.htm\n\n        Args:\n            update_account_credentials_in_vault (ArkPCloudUpdateAccountCredentialsInVault): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Updates account [{update_account_credentials_in_vault.account_id}] vault credentials')\n        resp: Response = self._client.post(\n            UPDATE_ACCOUNT_CREDENTIALS_IN_VAULT.format(account_id=update_account_credentials_in_vault.account_id),\n            json=update_account_credentials_in_vault.model_dump(exclude={'account_id'}, by_alias=True),\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update credentials in vault for account [{resp.text}] - [{resp.status_code}]')\n\n    def reconcile_account_credentials(self, reconcile_account_credentials: ArkPCloudReconcileAccountCredentials) -&gt; None:\n        \"\"\"\n        Marks the account for reconcilation\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Reconcile-account.htm\n\n        Args:\n            reconcile_account_credentials (ArkPCloudReconcileAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{reconcile_account_credentials.account_id}] for reconcilation')\n        resp: Response = self._client.post(RECONCILE_ACCOUNT_CREDENTIALS.format(account_id=reconcile_account_credentials.account_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to reconcile account credentials [{resp.text}] - [{resp.status_code}]')\n\n    def account(self, get_account: ArkPCloudGetAccount) -&gt; ArkPCloudAccount:\n        \"\"\"\n        Retrieves the account by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Get%20Account%20Details.htm?\n\n        Args:\n            get_account (ArkPCloudGetAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccount: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving account by id [{get_account.account_id}]')\n        resp: Response = self._client.get(ACCOUNT_URL.format(account_id=get_account.account_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudAccount.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse account response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse account response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve account [{resp.text}] - [{resp.status_code}]')\n\n    def account_credentials(self, get_account_credentials: ArkPCloudGetAccountCredentials) -&gt; ArkPCloudAccountCredentials:\n        \"\"\"\n        Retrieves the account credentials\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPasswordValueV10.htm?\n\n        Args:\n            get_account_credentials (ArkPCloudGetAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccountCredentials: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving account password for details [{get_account_credentials}]')\n        body = {\n            k.replace('_', '').title(): v\n            for k, v in get_account_credentials.model_dump(exclude={'account_id', 'reason'}, exclude_none=True).items()\n        }\n        if get_account_credentials.reason:\n            body['reason'] = get_account_credentials.reason\n        resp: Response = self._client.post(RETRIEVE_ACCOUNT_CREDENTIALS.format(account_id=get_account_credentials.account_id), json=body)\n        if resp.status_code == HTTPStatus.OK:\n            return ArkPCloudAccountCredentials(\n                account_id=get_account_credentials.account_id, password=resp.text[1:-1]  # Remove leading and trailing quotes\n            )\n        raise ArkServiceException(f'Failed to retrieve account credentials [{resp.text}] - [{resp.status_code}]')\n\n    def add_account(self, add_account: ArkPCloudAddAccount) -&gt; ArkPCloudAccount:\n        \"\"\"\n        Adds a new account with given details\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Account%20v10.htm?\n\n        Args:\n            add_account (ArkPCloudAddAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccount: _description_\n        \"\"\"\n        self._logger.info('Adding new account')\n        if add_account.remote_machines_access:\n            if (\n                add_account.remote_machines_access.access_restricted_to_remote_machines\n                and not add_account.remote_machines_access.remote_machines\n            ):\n                add_account.remote_machines_access = None\n            elif not add_account.remote_machines_access.access_restricted_to_remote_machines:\n                add_account.remote_machines_access.remote_machines = None\n\n            elif add_account.remote_machines_access.remote_machines:\n                add_account.remote_machines_access.remote_machines = ','.join(add_account.remote_machines_access.remote_machines)\n\n        resp: Response = self._client.post(\n            ACCOUNTS_URL, json=add_account.model_dump(by_alias=True, exclude_none=True, exclude_defaults=True)\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkPCloudAccount.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add account response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add account response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add account [{resp.text}] - [{resp.status_code}]')\n\n    def update_account(self, update_account: ArkPCloudUpdateAccount) -&gt; ArkPCloudAccount:\n        \"\"\"\n        Updates an existing account with new details\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/UpdateAccount%20v10.htm\n\n        Args:\n            update_account (ArkPCloudUpdateAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccount: _description_\n        \"\"\"\n        self._logger.info(f'Updating account [{update_account.account_id}]')\n        if update_account.remote_machines_access and not update_account.remote_machines_access.remote_machines:\n            update_account.remote_machines_access = None\n        operations = []\n        for key, val in update_account.model_dump(exclude={'account_id'}, exclude_none=True, by_alias=True, exclude_defaults=True).items():\n            operations.append({'op': 'replace', 'path': f'/{key}', 'value': val})\n        resp: Response = self._client.patch(ACCOUNT_URL.format(account_id=update_account.account_id), json=operations)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudAccount.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update account response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update account response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update account [{resp.text}] - [{resp.status_code}]')\n\n    def delete_account(self, delete_account: ArkPCloudDeleteAccount) -&gt; None:\n        \"\"\"\n        Deletes an account by given id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Account.htm\n\n        Args:\n            delete_account (ArkPCloudDeleteAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting account [{delete_account.account_id}]')\n        resp: Response = self._client.delete(ACCOUNT_URL.format(account_id=delete_account.account_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete account [{resp.text}] - [{resp.status_code}]')\n\n    def link_account(self, link_account: ArkPCloudLinkAccount) -&gt; None:\n        \"\"\"\n        Link an account by given info\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account.htm\n\n        Args:\n            link_account (ArkPCloudLinkAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(\n            f'Linking account [{link_account.account_id}] '\n            f'to name [{link_account.name}] in safe [{link_account.safe}] in folder [{link_account.folder}] '\n            f'by idx [{link_account.extra_password_index}]'\n        )\n        resp: Response = self._client.post(\n            LINK_ACCOUNT.format(account_id=link_account.account_id), json=link_account.model_dump(exclude={'account_id'}, by_alias=True)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to link account [{resp.text}] - [{resp.status_code}]')\n\n    def unlink_account(self, unlink_account: ArkPCloudUnlinkAccount) -&gt; None:\n        \"\"\"\n        Link an account by given info\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account-unlink.htm\n\n        Args:\n            unlink_account (ArkPCloudUnlinkAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Unlinking account [{unlink_account.account_id}] by idx [{unlink_account.extra_password_index}]')\n        resp: Response = self._client.delete(\n            UNLINK_ACCOUNT.format(account_id=unlink_account.account_id, extra_password_index=unlink_account.extra_password_index)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to unlink account [{resp.text}] - [{resp.status_code}]')\n\n    def accounts_stats(self) -&gt; ArkPCloudAccountsStats:\n        \"\"\"\n        Calculates accounts stats for all visible accounts\n\n        Returns:\n            ArkPCloudAccountsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating accounts statistics')\n        accounts = list(itertools.chain.from_iterable([p.items for p in list(self.list_accounts())]))\n        accounts_stats = ArkPCloudAccountsStats.model_construct()\n        accounts_stats.accounts_count = len(accounts)\n\n        # Get accounts per platform id\n        platform_ids: Set[str] = {a.platform_id for a in accounts}\n        accounts_stats.accounts_count_by_platform_id = {pi: len([a for a in accounts if a.platform_id == pi]) for pi in platform_ids}\n\n        # Get accounts per safe name\n        safe_names: Set[str] = {a.safe_name for a in accounts}\n        accounts_stats.accounts_count_by_safe_name = {sn: len([a for a in accounts if a.safe_name == sn]) for sn in safe_names}\n\n        return accounts_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.account","title":"<code>account(get_account)</code>","text":"<p>Retrieves the account by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Get%20Account%20Details.htm?</p> <p>Parameters:</p> Name Type Description Default <code>get_account</code> <code>ArkPCloudGetAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccount</code> <code>ArkPCloudAccount</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def account(self, get_account: ArkPCloudGetAccount) -&gt; ArkPCloudAccount:\n    \"\"\"\n    Retrieves the account by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Get%20Account%20Details.htm?\n\n    Args:\n        get_account (ArkPCloudGetAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccount: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving account by id [{get_account.account_id}]')\n    resp: Response = self._client.get(ACCOUNT_URL.format(account_id=get_account.account_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudAccount.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse account response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse account response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.account_credentials","title":"<code>account_credentials(get_account_credentials)</code>","text":"<p>Retrieves the account credentials https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPasswordValueV10.htm?</p> <p>Parameters:</p> Name Type Description Default <code>get_account_credentials</code> <code>ArkPCloudGetAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountCredentials</code> <code>ArkPCloudAccountCredentials</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def account_credentials(self, get_account_credentials: ArkPCloudGetAccountCredentials) -&gt; ArkPCloudAccountCredentials:\n    \"\"\"\n    Retrieves the account credentials\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPasswordValueV10.htm?\n\n    Args:\n        get_account_credentials (ArkPCloudGetAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccountCredentials: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving account password for details [{get_account_credentials}]')\n    body = {\n        k.replace('_', '').title(): v\n        for k, v in get_account_credentials.model_dump(exclude={'account_id', 'reason'}, exclude_none=True).items()\n    }\n    if get_account_credentials.reason:\n        body['reason'] = get_account_credentials.reason\n    resp: Response = self._client.post(RETRIEVE_ACCOUNT_CREDENTIALS.format(account_id=get_account_credentials.account_id), json=body)\n    if resp.status_code == HTTPStatus.OK:\n        return ArkPCloudAccountCredentials(\n            account_id=get_account_credentials.account_id, password=resp.text[1:-1]  # Remove leading and trailing quotes\n        )\n    raise ArkServiceException(f'Failed to retrieve account credentials [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.accounts_stats","title":"<code>accounts_stats()</code>","text":"<p>Calculates accounts stats for all visible accounts</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountsStats</code> <code>ArkPCloudAccountsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def accounts_stats(self) -&gt; ArkPCloudAccountsStats:\n    \"\"\"\n    Calculates accounts stats for all visible accounts\n\n    Returns:\n        ArkPCloudAccountsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating accounts statistics')\n    accounts = list(itertools.chain.from_iterable([p.items for p in list(self.list_accounts())]))\n    accounts_stats = ArkPCloudAccountsStats.model_construct()\n    accounts_stats.accounts_count = len(accounts)\n\n    # Get accounts per platform id\n    platform_ids: Set[str] = {a.platform_id for a in accounts}\n    accounts_stats.accounts_count_by_platform_id = {pi: len([a for a in accounts if a.platform_id == pi]) for pi in platform_ids}\n\n    # Get accounts per safe name\n    safe_names: Set[str] = {a.safe_name for a in accounts}\n    accounts_stats.accounts_count_by_safe_name = {sn: len([a for a in accounts if a.safe_name == sn]) for sn in safe_names}\n\n    return accounts_stats\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.add_account","title":"<code>add_account(add_account)</code>","text":"<p>Adds a new account with given details https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Account%20v10.htm?</p> <p>Parameters:</p> Name Type Description Default <code>add_account</code> <code>ArkPCloudAddAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccount</code> <code>ArkPCloudAccount</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def add_account(self, add_account: ArkPCloudAddAccount) -&gt; ArkPCloudAccount:\n    \"\"\"\n    Adds a new account with given details\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Account%20v10.htm?\n\n    Args:\n        add_account (ArkPCloudAddAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccount: _description_\n    \"\"\"\n    self._logger.info('Adding new account')\n    if add_account.remote_machines_access:\n        if (\n            add_account.remote_machines_access.access_restricted_to_remote_machines\n            and not add_account.remote_machines_access.remote_machines\n        ):\n            add_account.remote_machines_access = None\n        elif not add_account.remote_machines_access.access_restricted_to_remote_machines:\n            add_account.remote_machines_access.remote_machines = None\n\n        elif add_account.remote_machines_access.remote_machines:\n            add_account.remote_machines_access.remote_machines = ','.join(add_account.remote_machines_access.remote_machines)\n\n    resp: Response = self._client.post(\n        ACCOUNTS_URL, json=add_account.model_dump(by_alias=True, exclude_none=True, exclude_defaults=True)\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkPCloudAccount.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add account response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add account response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.change_account_credentials","title":"<code>change_account_credentials(change_account_credentials)</code>","text":"<p>Marks the account for password changing immediately by CPM https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Change-credentials-immediately.htm</p> <p>Parameters:</p> Name Type Description Default <code>change_account_credentials</code> <code>ArkPCloudChangeAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def change_account_credentials(self, change_account_credentials: ArkPCloudChangeAccountCredentials) -&gt; None:\n    \"\"\"\n    Marks the account for password changing immediately by CPM\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Change-credentials-immediately.htm\n\n    Args:\n        change_account_credentials (ArkPCloudChangeAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{change_account_credentials.account_id}] for changing credentials immediately')\n    resp: Response = self._client.post(CHANGE_ACCOUNT_CREDENTIALS.format(account_id=change_account_credentials.account_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to mark account for changing credentials immediately [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.delete_account","title":"<code>delete_account(delete_account)</code>","text":"<p>Deletes an account by given id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Account.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_account</code> <code>ArkPCloudDeleteAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def delete_account(self, delete_account: ArkPCloudDeleteAccount) -&gt; None:\n    \"\"\"\n    Deletes an account by given id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Account.htm\n\n    Args:\n        delete_account (ArkPCloudDeleteAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting account [{delete_account.account_id}]')\n    resp: Response = self._client.delete(ACCOUNT_URL.format(account_id=delete_account.account_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.generate_account_credentials","title":"<code>generate_account_credentials(generate_account_credentials)</code>","text":"<p>Generate a new random password for an existing account with policy restrictions https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Generate-Password.htm</p> <p>Parameters:</p> Name Type Description Default <code>generate_account_credentials</code> <code>ArkPCloudGenerateAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountCredentials</code> <code>ArkPCloudAccountCredentials</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def generate_account_credentials(\n    self, generate_account_credentials: ArkPCloudGenerateAccountCredentials\n) -&gt; ArkPCloudAccountCredentials:\n    \"\"\"\n    Generate a new random password for an existing account with policy restrictions\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Generate-Password.htm\n\n    Args:\n        generate_account_credentials (ArkPCloudGenerateAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccountCredentials: _description_\n    \"\"\"\n    self._logger.info(f'Generating new password for account [{generate_account_credentials.account_id}]')\n    resp: Response = self._client.post(GENERATE_ACCOUNT_CREDENTIALS.format(account_id=generate_account_credentials.account_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudAccountCredentials(account_id=generate_account_credentials.account_id, password=resp.json()['password'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse genereate account credentials response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse genereate account credentials response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to generate password for account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.link_account","title":"<code>link_account(link_account)</code>","text":"<p>Link an account by given info https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account.htm</p> <p>Parameters:</p> Name Type Description Default <code>link_account</code> <code>ArkPCloudLinkAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def link_account(self, link_account: ArkPCloudLinkAccount) -&gt; None:\n    \"\"\"\n    Link an account by given info\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account.htm\n\n    Args:\n        link_account (ArkPCloudLinkAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(\n        f'Linking account [{link_account.account_id}] '\n        f'to name [{link_account.name}] in safe [{link_account.safe}] in folder [{link_account.folder}] '\n        f'by idx [{link_account.extra_password_index}]'\n    )\n    resp: Response = self._client.post(\n        LINK_ACCOUNT.format(account_id=link_account.account_id), json=link_account.model_dump(exclude={'account_id'}, by_alias=True)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to link account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.list_account_secret_versions","title":"<code>list_account_secret_versions(list_account_secret_versions)</code>","text":"<p>Lists the given account secret versions https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Get-versions.htm</p> <p>Parameters:</p> Name Type Description Default <code>list_account_secret_versions</code> <code>ArkPCloudListAccountSecretVersions</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkPCloudAccountSecretVersion]</code> <p>List[ArkPCloudAccountSecretVersion]: description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def list_account_secret_versions(\n    self, list_account_secret_versions: ArkPCloudListAccountSecretVersions\n) -&gt; List[ArkPCloudAccountSecretVersion]:\n    \"\"\"\n    Lists the given account secret versions\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Get-versions.htm\n\n    Args:\n        list_account_secret_versions (ArkPCloudListAccountSecretVersions): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkPCloudAccountSecretVersion]: _description_\n    \"\"\"\n    self._logger.info(f'Listing account [{list_account_secret_versions.account_id}] secret versions')\n    resp: Response = self._client.get(ACCOUNT_SECRET_VERSIONS.format(account_id=list_account_secret_versions.account_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return TypeAdapter(List[ArkPCloudAccountSecretVersion]).validate_python(resp.json()['versions'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list account secret versions response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list account secret versions response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list account secret versions [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.list_accounts","title":"<code>list_accounts()</code>","text":"<p>Yields all visible accounts to the logged in user as pages of accounts https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm</p> <p>Yields:</p> Type Description <code>ArkPCloudAccountsPage</code> <p>Iterator[ArkPCloudAccountsPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def list_accounts(self) -&gt; Iterator[ArkPCloudAccountsPage]:\n    \"\"\"\n    Yields all visible accounts to the logged in user as pages of accounts\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n    Yields:\n        Iterator[ArkPCloudAccountsPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all accounts')\n    yield from self.__list_accounts_with_filters()\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.list_accounts_by","title":"<code>list_accounts_by(accounts_filter)</code>","text":"<p>Yields visible accounts to the logged in user by filters as pages of accounts https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm</p> <p>Parameters:</p> Name Type Description Default <code>accounts_filter</code> <code>ArkPCloudAccountsFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkPCloudAccountsPage</code> <p>Iterator[ArkPCloudAccountsPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def list_accounts_by(self, accounts_filter: ArkPCloudAccountsFilter) -&gt; Iterator[ArkPCloudAccountsPage]:\n    \"\"\"\n    Yields visible accounts to the logged in user by filters as pages of accounts\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n    Args:\n        accounts_filter (ArkPCloudAccountsFilter): _description_\n\n    Yields:\n        Iterator[ArkPCloudAccountsPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing accounts by filters [{accounts_filter}]')\n    yield from self.__list_accounts_with_filters(\n        accounts_filter.search,\n        accounts_filter.search_type,\n        accounts_filter.sort,\n        accounts_filter.offset,\n        accounts_filter.limit,\n        accounts_filter.safe_name,\n    )\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.reconcile_account_credentials","title":"<code>reconcile_account_credentials(reconcile_account_credentials)</code>","text":"<p>Marks the account for reconcilation https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Reconcile-account.htm</p> <p>Parameters:</p> Name Type Description Default <code>reconcile_account_credentials</code> <code>ArkPCloudReconcileAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def reconcile_account_credentials(self, reconcile_account_credentials: ArkPCloudReconcileAccountCredentials) -&gt; None:\n    \"\"\"\n    Marks the account for reconcilation\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Reconcile-account.htm\n\n    Args:\n        reconcile_account_credentials (ArkPCloudReconcileAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{reconcile_account_credentials.account_id}] for reconcilation')\n    resp: Response = self._client.post(RECONCILE_ACCOUNT_CREDENTIALS.format(account_id=reconcile_account_credentials.account_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to reconcile account credentials [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.set_account_next_credentials","title":"<code>set_account_next_credentials(set_account_next_credentials)</code>","text":"<p>Marks the account to have its password changed to the given one via CPM https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/SetNextPassword.htm</p> <p>Parameters:</p> Name Type Description Default <code>set_account_next_credentials</code> <code>ArkPCloudSetAccountNextCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def set_account_next_credentials(self, set_account_next_credentials: ArkPCloudSetAccountNextCredentials) -&gt; None:\n    \"\"\"\n    Marks the account to have its password changed to the given one via CPM\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/SetNextPassword.htm\n\n    Args:\n        set_account_next_credentials (ArkPCloudSetAccountNextCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{set_account_next_credentials.account_id}] for changing credentials for the given password')\n    resp: Response = self._client.post(\n        SET_ACCOUNT_NEXT_CREDENTIALS.format(account_id=set_account_next_credentials.account_id),\n        json=set_account_next_credentials.model_dump(exclude={'account_id'}, by_alias=True),\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to mark account for changing credentials next password [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.unlink_account","title":"<code>unlink_account(unlink_account)</code>","text":"<p>Link an account by given info https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account-unlink.htm</p> <p>Parameters:</p> Name Type Description Default <code>unlink_account</code> <code>ArkPCloudUnlinkAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def unlink_account(self, unlink_account: ArkPCloudUnlinkAccount) -&gt; None:\n    \"\"\"\n    Link an account by given info\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account-unlink.htm\n\n    Args:\n        unlink_account (ArkPCloudUnlinkAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Unlinking account [{unlink_account.account_id}] by idx [{unlink_account.extra_password_index}]')\n    resp: Response = self._client.delete(\n        UNLINK_ACCOUNT.format(account_id=unlink_account.account_id, extra_password_index=unlink_account.extra_password_index)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to unlink account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.update_account","title":"<code>update_account(update_account)</code>","text":"<p>Updates an existing account with new details https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/UpdateAccount%20v10.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_account</code> <code>ArkPCloudUpdateAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccount</code> <code>ArkPCloudAccount</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def update_account(self, update_account: ArkPCloudUpdateAccount) -&gt; ArkPCloudAccount:\n    \"\"\"\n    Updates an existing account with new details\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/UpdateAccount%20v10.htm\n\n    Args:\n        update_account (ArkPCloudUpdateAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccount: _description_\n    \"\"\"\n    self._logger.info(f'Updating account [{update_account.account_id}]')\n    if update_account.remote_machines_access and not update_account.remote_machines_access.remote_machines:\n        update_account.remote_machines_access = None\n    operations = []\n    for key, val in update_account.model_dump(exclude={'account_id'}, exclude_none=True, by_alias=True, exclude_defaults=True).items():\n        operations.append({'op': 'replace', 'path': f'/{key}', 'value': val})\n    resp: Response = self._client.patch(ACCOUNT_URL.format(account_id=update_account.account_id), json=operations)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudAccount.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update account response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update account response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.update_account_credentials_in_vault","title":"<code>update_account_credentials_in_vault(update_account_credentials_in_vault)</code>","text":"<p>Updates the account credentials only in the vault without changing it on the machine itself https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/ChangeCredentialsInVault.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_account_credentials_in_vault</code> <code>ArkPCloudUpdateAccountCredentialsInVault</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def update_account_credentials_in_vault(self, update_account_credentials_in_vault: ArkPCloudUpdateAccountCredentialsInVault) -&gt; None:\n    \"\"\"\n    Updates the account credentials only in the vault without changing it on the machine itself\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/ChangeCredentialsInVault.htm\n\n    Args:\n        update_account_credentials_in_vault (ArkPCloudUpdateAccountCredentialsInVault): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Updates account [{update_account_credentials_in_vault.account_id}] vault credentials')\n    resp: Response = self._client.post(\n        UPDATE_ACCOUNT_CREDENTIALS_IN_VAULT.format(account_id=update_account_credentials_in_vault.account_id),\n        json=update_account_credentials_in_vault.model_dump(exclude={'account_id'}, by_alias=True),\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update credentials in vault for account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/#ark_sdk_python.services.pcloud.accounts.ArkPCloudAccountsService.verify_account_credentials","title":"<code>verify_account_credentials(verify_account_credentials)</code>","text":"<p>Marks the account for password verification by CPM https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Verify-credentials-v9-10.htm</p> <p>Parameters:</p> Name Type Description Default <code>verify_account_credentials</code> <code>ArkPCloudVerifyAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def verify_account_credentials(self, verify_account_credentials: ArkPCloudVerifyAccountCredentials) -&gt; None:\n    \"\"\"\n    Marks the account for password verification by CPM\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Verify-credentials-v9-10.htm\n\n    Args:\n        verify_account_credentials (ArkPCloudVerifyAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{verify_account_credentials.account_id}] for verification')\n    resp: Response = self._client.post(VERIFY_ACCOUNT_CREDENTIALS.format(account_id=verify_account_credentials.account_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to mark account for password verification [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/","title":"ark_pcloud_accounts_service","text":""},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService","title":"<code>ArkPCloudAccountsService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>class ArkPCloudAccountsService(ArkPCloudBaseService):\n    def __list_accounts_with_filters(\n        self,\n        search: Optional[str] = None,\n        search_type: Optional[str] = None,\n        sort: Optional[str] = None,\n        offset: Optional[int] = None,\n        limit: Optional[int] = None,\n        safe_name: Optional[str] = None,\n    ) -&gt; Iterator[ArkPCloudAccountsPage]:\n        query = {}\n        if search:\n            query['search'] = search\n        if search_type:\n            query['searchType'] = search_type\n        if sort:\n            query['sort'] = sort\n        if offset:\n            query['offset'] = offset\n        if limit:\n            query['limit'] = limit\n        if safe_name:\n            query['filter'] = f'safeName eq {safe_name}'\n        while True:\n            resp: Response = self._client.get(ACCOUNTS_URL, params=query)\n            if resp.status_code == HTTPStatus.OK:\n                try:\n                    result = resp.json()\n                    accounts = TypeAdapter(List[ArkPCloudAccount]).validate_python(result['value'])\n                    yield ArkPCloudAccountsPage(items=accounts)\n                    if 'nextLink' in result:\n                        query = parse_qs(urlparse(result['nextLink']).query)\n                    else:\n                        break\n                except (ValidationError, JSONDecodeError, KeyError) as ex:\n                    self._logger.exception(f'Failed to parse list accounts response [{str(ex)}] - [{resp.text}]')\n                    raise ArkServiceException(f'Failed to parse list accounts response [{str(ex)}]') from ex\n            else:\n                raise ArkServiceException(f'Failed to list accounts [{resp.text}] - [{resp.status_code}]')\n\n    def list_accounts(self) -&gt; Iterator[ArkPCloudAccountsPage]:\n        \"\"\"\n        Yields all visible accounts to the logged in user as pages of accounts\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n        Yields:\n            Iterator[ArkPCloudAccountsPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all accounts')\n        yield from self.__list_accounts_with_filters()\n\n    def list_accounts_by(self, accounts_filter: ArkPCloudAccountsFilter) -&gt; Iterator[ArkPCloudAccountsPage]:\n        \"\"\"\n        Yields visible accounts to the logged in user by filters as pages of accounts\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n        Args:\n            accounts_filter (ArkPCloudAccountsFilter): _description_\n\n        Yields:\n            Iterator[ArkPCloudAccountsPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing accounts by filters [{accounts_filter}]')\n        yield from self.__list_accounts_with_filters(\n            accounts_filter.search,\n            accounts_filter.search_type,\n            accounts_filter.sort,\n            accounts_filter.offset,\n            accounts_filter.limit,\n            accounts_filter.safe_name,\n        )\n\n    def list_account_secret_versions(\n        self, list_account_secret_versions: ArkPCloudListAccountSecretVersions\n    ) -&gt; List[ArkPCloudAccountSecretVersion]:\n        \"\"\"\n        Lists the given account secret versions\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Get-versions.htm\n\n        Args:\n            list_account_secret_versions (ArkPCloudListAccountSecretVersions): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkPCloudAccountSecretVersion]: _description_\n        \"\"\"\n        self._logger.info(f'Listing account [{list_account_secret_versions.account_id}] secret versions')\n        resp: Response = self._client.get(ACCOUNT_SECRET_VERSIONS.format(account_id=list_account_secret_versions.account_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkPCloudAccountSecretVersion]).validate_python(resp.json()['versions'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list account secret versions response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list account secret versions response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list account secret versions [{resp.text}] - [{resp.status_code}]')\n\n    def generate_account_credentials(\n        self, generate_account_credentials: ArkPCloudGenerateAccountCredentials\n    ) -&gt; ArkPCloudAccountCredentials:\n        \"\"\"\n        Generate a new random password for an existing account with policy restrictions\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Generate-Password.htm\n\n        Args:\n            generate_account_credentials (ArkPCloudGenerateAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccountCredentials: _description_\n        \"\"\"\n        self._logger.info(f'Generating new password for account [{generate_account_credentials.account_id}]')\n        resp: Response = self._client.post(GENERATE_ACCOUNT_CREDENTIALS.format(account_id=generate_account_credentials.account_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudAccountCredentials(account_id=generate_account_credentials.account_id, password=resp.json()['password'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse genereate account credentials response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse genereate account credentials response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate password for account [{resp.text}] - [{resp.status_code}]')\n\n    def verify_account_credentials(self, verify_account_credentials: ArkPCloudVerifyAccountCredentials) -&gt; None:\n        \"\"\"\n        Marks the account for password verification by CPM\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Verify-credentials-v9-10.htm\n\n        Args:\n            verify_account_credentials (ArkPCloudVerifyAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{verify_account_credentials.account_id}] for verification')\n        resp: Response = self._client.post(VERIFY_ACCOUNT_CREDENTIALS.format(account_id=verify_account_credentials.account_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to mark account for password verification [{resp.text}] - [{resp.status_code}]')\n\n    def change_account_credentials(self, change_account_credentials: ArkPCloudChangeAccountCredentials) -&gt; None:\n        \"\"\"\n        Marks the account for password changing immediately by CPM\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Change-credentials-immediately.htm\n\n        Args:\n            change_account_credentials (ArkPCloudChangeAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{change_account_credentials.account_id}] for changing credentials immediately')\n        resp: Response = self._client.post(CHANGE_ACCOUNT_CREDENTIALS.format(account_id=change_account_credentials.account_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to mark account for changing credentials immediately [{resp.text}] - [{resp.status_code}]')\n\n    def set_account_next_credentials(self, set_account_next_credentials: ArkPCloudSetAccountNextCredentials) -&gt; None:\n        \"\"\"\n        Marks the account to have its password changed to the given one via CPM\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/SetNextPassword.htm\n\n        Args:\n            set_account_next_credentials (ArkPCloudSetAccountNextCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{set_account_next_credentials.account_id}] for changing credentials for the given password')\n        resp: Response = self._client.post(\n            SET_ACCOUNT_NEXT_CREDENTIALS.format(account_id=set_account_next_credentials.account_id),\n            json=set_account_next_credentials.model_dump(exclude={'account_id'}, by_alias=True),\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to mark account for changing credentials next password [{resp.text}] - [{resp.status_code}]')\n\n    def update_account_credentials_in_vault(self, update_account_credentials_in_vault: ArkPCloudUpdateAccountCredentialsInVault) -&gt; None:\n        \"\"\"\n        Updates the account credentials only in the vault without changing it on the machine itself\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/ChangeCredentialsInVault.htm\n\n        Args:\n            update_account_credentials_in_vault (ArkPCloudUpdateAccountCredentialsInVault): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Updates account [{update_account_credentials_in_vault.account_id}] vault credentials')\n        resp: Response = self._client.post(\n            UPDATE_ACCOUNT_CREDENTIALS_IN_VAULT.format(account_id=update_account_credentials_in_vault.account_id),\n            json=update_account_credentials_in_vault.model_dump(exclude={'account_id'}, by_alias=True),\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update credentials in vault for account [{resp.text}] - [{resp.status_code}]')\n\n    def reconcile_account_credentials(self, reconcile_account_credentials: ArkPCloudReconcileAccountCredentials) -&gt; None:\n        \"\"\"\n        Marks the account for reconcilation\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Reconcile-account.htm\n\n        Args:\n            reconcile_account_credentials (ArkPCloudReconcileAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Marking account [{reconcile_account_credentials.account_id}] for reconcilation')\n        resp: Response = self._client.post(RECONCILE_ACCOUNT_CREDENTIALS.format(account_id=reconcile_account_credentials.account_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to reconcile account credentials [{resp.text}] - [{resp.status_code}]')\n\n    def account(self, get_account: ArkPCloudGetAccount) -&gt; ArkPCloudAccount:\n        \"\"\"\n        Retrieves the account by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Get%20Account%20Details.htm?\n\n        Args:\n            get_account (ArkPCloudGetAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccount: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving account by id [{get_account.account_id}]')\n        resp: Response = self._client.get(ACCOUNT_URL.format(account_id=get_account.account_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudAccount.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse account response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse account response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve account [{resp.text}] - [{resp.status_code}]')\n\n    def account_credentials(self, get_account_credentials: ArkPCloudGetAccountCredentials) -&gt; ArkPCloudAccountCredentials:\n        \"\"\"\n        Retrieves the account credentials\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPasswordValueV10.htm?\n\n        Args:\n            get_account_credentials (ArkPCloudGetAccountCredentials): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccountCredentials: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving account password for details [{get_account_credentials}]')\n        body = {\n            k.replace('_', '').title(): v\n            for k, v in get_account_credentials.model_dump(exclude={'account_id', 'reason'}, exclude_none=True).items()\n        }\n        if get_account_credentials.reason:\n            body['reason'] = get_account_credentials.reason\n        resp: Response = self._client.post(RETRIEVE_ACCOUNT_CREDENTIALS.format(account_id=get_account_credentials.account_id), json=body)\n        if resp.status_code == HTTPStatus.OK:\n            return ArkPCloudAccountCredentials(\n                account_id=get_account_credentials.account_id, password=resp.text[1:-1]  # Remove leading and trailing quotes\n            )\n        raise ArkServiceException(f'Failed to retrieve account credentials [{resp.text}] - [{resp.status_code}]')\n\n    def add_account(self, add_account: ArkPCloudAddAccount) -&gt; ArkPCloudAccount:\n        \"\"\"\n        Adds a new account with given details\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Account%20v10.htm?\n\n        Args:\n            add_account (ArkPCloudAddAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccount: _description_\n        \"\"\"\n        self._logger.info('Adding new account')\n        if add_account.remote_machines_access:\n            if (\n                add_account.remote_machines_access.access_restricted_to_remote_machines\n                and not add_account.remote_machines_access.remote_machines\n            ):\n                add_account.remote_machines_access = None\n            elif not add_account.remote_machines_access.access_restricted_to_remote_machines:\n                add_account.remote_machines_access.remote_machines = None\n\n            elif add_account.remote_machines_access.remote_machines:\n                add_account.remote_machines_access.remote_machines = ','.join(add_account.remote_machines_access.remote_machines)\n\n        resp: Response = self._client.post(\n            ACCOUNTS_URL, json=add_account.model_dump(by_alias=True, exclude_none=True, exclude_defaults=True)\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkPCloudAccount.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add account response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add account response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add account [{resp.text}] - [{resp.status_code}]')\n\n    def update_account(self, update_account: ArkPCloudUpdateAccount) -&gt; ArkPCloudAccount:\n        \"\"\"\n        Updates an existing account with new details\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/UpdateAccount%20v10.htm\n\n        Args:\n            update_account (ArkPCloudUpdateAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudAccount: _description_\n        \"\"\"\n        self._logger.info(f'Updating account [{update_account.account_id}]')\n        if update_account.remote_machines_access and not update_account.remote_machines_access.remote_machines:\n            update_account.remote_machines_access = None\n        operations = []\n        for key, val in update_account.model_dump(exclude={'account_id'}, exclude_none=True, by_alias=True, exclude_defaults=True).items():\n            operations.append({'op': 'replace', 'path': f'/{key}', 'value': val})\n        resp: Response = self._client.patch(ACCOUNT_URL.format(account_id=update_account.account_id), json=operations)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudAccount.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update account response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update account response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update account [{resp.text}] - [{resp.status_code}]')\n\n    def delete_account(self, delete_account: ArkPCloudDeleteAccount) -&gt; None:\n        \"\"\"\n        Deletes an account by given id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Account.htm\n\n        Args:\n            delete_account (ArkPCloudDeleteAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting account [{delete_account.account_id}]')\n        resp: Response = self._client.delete(ACCOUNT_URL.format(account_id=delete_account.account_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete account [{resp.text}] - [{resp.status_code}]')\n\n    def link_account(self, link_account: ArkPCloudLinkAccount) -&gt; None:\n        \"\"\"\n        Link an account by given info\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account.htm\n\n        Args:\n            link_account (ArkPCloudLinkAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(\n            f'Linking account [{link_account.account_id}] '\n            f'to name [{link_account.name}] in safe [{link_account.safe}] in folder [{link_account.folder}] '\n            f'by idx [{link_account.extra_password_index}]'\n        )\n        resp: Response = self._client.post(\n            LINK_ACCOUNT.format(account_id=link_account.account_id), json=link_account.model_dump(exclude={'account_id'}, by_alias=True)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to link account [{resp.text}] - [{resp.status_code}]')\n\n    def unlink_account(self, unlink_account: ArkPCloudUnlinkAccount) -&gt; None:\n        \"\"\"\n        Link an account by given info\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account-unlink.htm\n\n        Args:\n            unlink_account (ArkPCloudUnlinkAccount): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Unlinking account [{unlink_account.account_id}] by idx [{unlink_account.extra_password_index}]')\n        resp: Response = self._client.delete(\n            UNLINK_ACCOUNT.format(account_id=unlink_account.account_id, extra_password_index=unlink_account.extra_password_index)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to unlink account [{resp.text}] - [{resp.status_code}]')\n\n    def accounts_stats(self) -&gt; ArkPCloudAccountsStats:\n        \"\"\"\n        Calculates accounts stats for all visible accounts\n\n        Returns:\n            ArkPCloudAccountsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating accounts statistics')\n        accounts = list(itertools.chain.from_iterable([p.items for p in list(self.list_accounts())]))\n        accounts_stats = ArkPCloudAccountsStats.model_construct()\n        accounts_stats.accounts_count = len(accounts)\n\n        # Get accounts per platform id\n        platform_ids: Set[str] = {a.platform_id for a in accounts}\n        accounts_stats.accounts_count_by_platform_id = {pi: len([a for a in accounts if a.platform_id == pi]) for pi in platform_ids}\n\n        # Get accounts per safe name\n        safe_names: Set[str] = {a.safe_name for a in accounts}\n        accounts_stats.accounts_count_by_safe_name = {sn: len([a for a in accounts if a.safe_name == sn]) for sn in safe_names}\n\n        return accounts_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.account","title":"<code>account(get_account)</code>","text":"<p>Retrieves the account by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Get%20Account%20Details.htm?</p> <p>Parameters:</p> Name Type Description Default <code>get_account</code> <code>ArkPCloudGetAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccount</code> <code>ArkPCloudAccount</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def account(self, get_account: ArkPCloudGetAccount) -&gt; ArkPCloudAccount:\n    \"\"\"\n    Retrieves the account by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Get%20Account%20Details.htm?\n\n    Args:\n        get_account (ArkPCloudGetAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccount: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving account by id [{get_account.account_id}]')\n    resp: Response = self._client.get(ACCOUNT_URL.format(account_id=get_account.account_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudAccount.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse account response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse account response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.account_credentials","title":"<code>account_credentials(get_account_credentials)</code>","text":"<p>Retrieves the account credentials https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPasswordValueV10.htm?</p> <p>Parameters:</p> Name Type Description Default <code>get_account_credentials</code> <code>ArkPCloudGetAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountCredentials</code> <code>ArkPCloudAccountCredentials</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def account_credentials(self, get_account_credentials: ArkPCloudGetAccountCredentials) -&gt; ArkPCloudAccountCredentials:\n    \"\"\"\n    Retrieves the account credentials\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPasswordValueV10.htm?\n\n    Args:\n        get_account_credentials (ArkPCloudGetAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccountCredentials: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving account password for details [{get_account_credentials}]')\n    body = {\n        k.replace('_', '').title(): v\n        for k, v in get_account_credentials.model_dump(exclude={'account_id', 'reason'}, exclude_none=True).items()\n    }\n    if get_account_credentials.reason:\n        body['reason'] = get_account_credentials.reason\n    resp: Response = self._client.post(RETRIEVE_ACCOUNT_CREDENTIALS.format(account_id=get_account_credentials.account_id), json=body)\n    if resp.status_code == HTTPStatus.OK:\n        return ArkPCloudAccountCredentials(\n            account_id=get_account_credentials.account_id, password=resp.text[1:-1]  # Remove leading and trailing quotes\n        )\n    raise ArkServiceException(f'Failed to retrieve account credentials [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.accounts_stats","title":"<code>accounts_stats()</code>","text":"<p>Calculates accounts stats for all visible accounts</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountsStats</code> <code>ArkPCloudAccountsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def accounts_stats(self) -&gt; ArkPCloudAccountsStats:\n    \"\"\"\n    Calculates accounts stats for all visible accounts\n\n    Returns:\n        ArkPCloudAccountsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating accounts statistics')\n    accounts = list(itertools.chain.from_iterable([p.items for p in list(self.list_accounts())]))\n    accounts_stats = ArkPCloudAccountsStats.model_construct()\n    accounts_stats.accounts_count = len(accounts)\n\n    # Get accounts per platform id\n    platform_ids: Set[str] = {a.platform_id for a in accounts}\n    accounts_stats.accounts_count_by_platform_id = {pi: len([a for a in accounts if a.platform_id == pi]) for pi in platform_ids}\n\n    # Get accounts per safe name\n    safe_names: Set[str] = {a.safe_name for a in accounts}\n    accounts_stats.accounts_count_by_safe_name = {sn: len([a for a in accounts if a.safe_name == sn]) for sn in safe_names}\n\n    return accounts_stats\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.add_account","title":"<code>add_account(add_account)</code>","text":"<p>Adds a new account with given details https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Account%20v10.htm?</p> <p>Parameters:</p> Name Type Description Default <code>add_account</code> <code>ArkPCloudAddAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccount</code> <code>ArkPCloudAccount</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def add_account(self, add_account: ArkPCloudAddAccount) -&gt; ArkPCloudAccount:\n    \"\"\"\n    Adds a new account with given details\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Account%20v10.htm?\n\n    Args:\n        add_account (ArkPCloudAddAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccount: _description_\n    \"\"\"\n    self._logger.info('Adding new account')\n    if add_account.remote_machines_access:\n        if (\n            add_account.remote_machines_access.access_restricted_to_remote_machines\n            and not add_account.remote_machines_access.remote_machines\n        ):\n            add_account.remote_machines_access = None\n        elif not add_account.remote_machines_access.access_restricted_to_remote_machines:\n            add_account.remote_machines_access.remote_machines = None\n\n        elif add_account.remote_machines_access.remote_machines:\n            add_account.remote_machines_access.remote_machines = ','.join(add_account.remote_machines_access.remote_machines)\n\n    resp: Response = self._client.post(\n        ACCOUNTS_URL, json=add_account.model_dump(by_alias=True, exclude_none=True, exclude_defaults=True)\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkPCloudAccount.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add account response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add account response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.change_account_credentials","title":"<code>change_account_credentials(change_account_credentials)</code>","text":"<p>Marks the account for password changing immediately by CPM https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Change-credentials-immediately.htm</p> <p>Parameters:</p> Name Type Description Default <code>change_account_credentials</code> <code>ArkPCloudChangeAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def change_account_credentials(self, change_account_credentials: ArkPCloudChangeAccountCredentials) -&gt; None:\n    \"\"\"\n    Marks the account for password changing immediately by CPM\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Change-credentials-immediately.htm\n\n    Args:\n        change_account_credentials (ArkPCloudChangeAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{change_account_credentials.account_id}] for changing credentials immediately')\n    resp: Response = self._client.post(CHANGE_ACCOUNT_CREDENTIALS.format(account_id=change_account_credentials.account_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to mark account for changing credentials immediately [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.delete_account","title":"<code>delete_account(delete_account)</code>","text":"<p>Deletes an account by given id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Account.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_account</code> <code>ArkPCloudDeleteAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def delete_account(self, delete_account: ArkPCloudDeleteAccount) -&gt; None:\n    \"\"\"\n    Deletes an account by given id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Account.htm\n\n    Args:\n        delete_account (ArkPCloudDeleteAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting account [{delete_account.account_id}]')\n    resp: Response = self._client.delete(ACCOUNT_URL.format(account_id=delete_account.account_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.generate_account_credentials","title":"<code>generate_account_credentials(generate_account_credentials)</code>","text":"<p>Generate a new random password for an existing account with policy restrictions https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Generate-Password.htm</p> <p>Parameters:</p> Name Type Description Default <code>generate_account_credentials</code> <code>ArkPCloudGenerateAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccountCredentials</code> <code>ArkPCloudAccountCredentials</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def generate_account_credentials(\n    self, generate_account_credentials: ArkPCloudGenerateAccountCredentials\n) -&gt; ArkPCloudAccountCredentials:\n    \"\"\"\n    Generate a new random password for an existing account with policy restrictions\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Generate-Password.htm\n\n    Args:\n        generate_account_credentials (ArkPCloudGenerateAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccountCredentials: _description_\n    \"\"\"\n    self._logger.info(f'Generating new password for account [{generate_account_credentials.account_id}]')\n    resp: Response = self._client.post(GENERATE_ACCOUNT_CREDENTIALS.format(account_id=generate_account_credentials.account_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudAccountCredentials(account_id=generate_account_credentials.account_id, password=resp.json()['password'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse genereate account credentials response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse genereate account credentials response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to generate password for account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.link_account","title":"<code>link_account(link_account)</code>","text":"<p>Link an account by given info https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account.htm</p> <p>Parameters:</p> Name Type Description Default <code>link_account</code> <code>ArkPCloudLinkAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def link_account(self, link_account: ArkPCloudLinkAccount) -&gt; None:\n    \"\"\"\n    Link an account by given info\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account.htm\n\n    Args:\n        link_account (ArkPCloudLinkAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(\n        f'Linking account [{link_account.account_id}] '\n        f'to name [{link_account.name}] in safe [{link_account.safe}] in folder [{link_account.folder}] '\n        f'by idx [{link_account.extra_password_index}]'\n    )\n    resp: Response = self._client.post(\n        LINK_ACCOUNT.format(account_id=link_account.account_id), json=link_account.model_dump(exclude={'account_id'}, by_alias=True)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to link account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.list_account_secret_versions","title":"<code>list_account_secret_versions(list_account_secret_versions)</code>","text":"<p>Lists the given account secret versions https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Get-versions.htm</p> <p>Parameters:</p> Name Type Description Default <code>list_account_secret_versions</code> <code>ArkPCloudListAccountSecretVersions</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkPCloudAccountSecretVersion]</code> <p>List[ArkPCloudAccountSecretVersion]: description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def list_account_secret_versions(\n    self, list_account_secret_versions: ArkPCloudListAccountSecretVersions\n) -&gt; List[ArkPCloudAccountSecretVersion]:\n    \"\"\"\n    Lists the given account secret versions\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Secrets-Get-versions.htm\n\n    Args:\n        list_account_secret_versions (ArkPCloudListAccountSecretVersions): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkPCloudAccountSecretVersion]: _description_\n    \"\"\"\n    self._logger.info(f'Listing account [{list_account_secret_versions.account_id}] secret versions')\n    resp: Response = self._client.get(ACCOUNT_SECRET_VERSIONS.format(account_id=list_account_secret_versions.account_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return TypeAdapter(List[ArkPCloudAccountSecretVersion]).validate_python(resp.json()['versions'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list account secret versions response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list account secret versions response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list account secret versions [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.list_accounts","title":"<code>list_accounts()</code>","text":"<p>Yields all visible accounts to the logged in user as pages of accounts https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm</p> <p>Yields:</p> Type Description <code>ArkPCloudAccountsPage</code> <p>Iterator[ArkPCloudAccountsPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def list_accounts(self) -&gt; Iterator[ArkPCloudAccountsPage]:\n    \"\"\"\n    Yields all visible accounts to the logged in user as pages of accounts\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n    Yields:\n        Iterator[ArkPCloudAccountsPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all accounts')\n    yield from self.__list_accounts_with_filters()\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.list_accounts_by","title":"<code>list_accounts_by(accounts_filter)</code>","text":"<p>Yields visible accounts to the logged in user by filters as pages of accounts https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm</p> <p>Parameters:</p> Name Type Description Default <code>accounts_filter</code> <code>ArkPCloudAccountsFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkPCloudAccountsPage</code> <p>Iterator[ArkPCloudAccountsPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def list_accounts_by(self, accounts_filter: ArkPCloudAccountsFilter) -&gt; Iterator[ArkPCloudAccountsPage]:\n    \"\"\"\n    Yields visible accounts to the logged in user by filters as pages of accounts\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/GetAccounts.htm\n\n    Args:\n        accounts_filter (ArkPCloudAccountsFilter): _description_\n\n    Yields:\n        Iterator[ArkPCloudAccountsPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing accounts by filters [{accounts_filter}]')\n    yield from self.__list_accounts_with_filters(\n        accounts_filter.search,\n        accounts_filter.search_type,\n        accounts_filter.sort,\n        accounts_filter.offset,\n        accounts_filter.limit,\n        accounts_filter.safe_name,\n    )\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.reconcile_account_credentials","title":"<code>reconcile_account_credentials(reconcile_account_credentials)</code>","text":"<p>Marks the account for reconcilation https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Reconcile-account.htm</p> <p>Parameters:</p> Name Type Description Default <code>reconcile_account_credentials</code> <code>ArkPCloudReconcileAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def reconcile_account_credentials(self, reconcile_account_credentials: ArkPCloudReconcileAccountCredentials) -&gt; None:\n    \"\"\"\n    Marks the account for reconcilation\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Reconcile-account.htm\n\n    Args:\n        reconcile_account_credentials (ArkPCloudReconcileAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{reconcile_account_credentials.account_id}] for reconcilation')\n    resp: Response = self._client.post(RECONCILE_ACCOUNT_CREDENTIALS.format(account_id=reconcile_account_credentials.account_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to reconcile account credentials [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.set_account_next_credentials","title":"<code>set_account_next_credentials(set_account_next_credentials)</code>","text":"<p>Marks the account to have its password changed to the given one via CPM https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/SetNextPassword.htm</p> <p>Parameters:</p> Name Type Description Default <code>set_account_next_credentials</code> <code>ArkPCloudSetAccountNextCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def set_account_next_credentials(self, set_account_next_credentials: ArkPCloudSetAccountNextCredentials) -&gt; None:\n    \"\"\"\n    Marks the account to have its password changed to the given one via CPM\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/SetNextPassword.htm\n\n    Args:\n        set_account_next_credentials (ArkPCloudSetAccountNextCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{set_account_next_credentials.account_id}] for changing credentials for the given password')\n    resp: Response = self._client.post(\n        SET_ACCOUNT_NEXT_CREDENTIALS.format(account_id=set_account_next_credentials.account_id),\n        json=set_account_next_credentials.model_dump(exclude={'account_id'}, by_alias=True),\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to mark account for changing credentials next password [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.unlink_account","title":"<code>unlink_account(unlink_account)</code>","text":"<p>Link an account by given info https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account-unlink.htm</p> <p>Parameters:</p> Name Type Description Default <code>unlink_account</code> <code>ArkPCloudUnlinkAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def unlink_account(self, unlink_account: ArkPCloudUnlinkAccount) -&gt; None:\n    \"\"\"\n    Link an account by given info\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/Link-account-unlink.htm\n\n    Args:\n        unlink_account (ArkPCloudUnlinkAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Unlinking account [{unlink_account.account_id}] by idx [{unlink_account.extra_password_index}]')\n    resp: Response = self._client.delete(\n        UNLINK_ACCOUNT.format(account_id=unlink_account.account_id, extra_password_index=unlink_account.extra_password_index)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to unlink account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.update_account","title":"<code>update_account(update_account)</code>","text":"<p>Updates an existing account with new details https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/UpdateAccount%20v10.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_account</code> <code>ArkPCloudUpdateAccount</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAccount</code> <code>ArkPCloudAccount</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def update_account(self, update_account: ArkPCloudUpdateAccount) -&gt; ArkPCloudAccount:\n    \"\"\"\n    Updates an existing account with new details\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/UpdateAccount%20v10.htm\n\n    Args:\n        update_account (ArkPCloudUpdateAccount): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudAccount: _description_\n    \"\"\"\n    self._logger.info(f'Updating account [{update_account.account_id}]')\n    if update_account.remote_machines_access and not update_account.remote_machines_access.remote_machines:\n        update_account.remote_machines_access = None\n    operations = []\n    for key, val in update_account.model_dump(exclude={'account_id'}, exclude_none=True, by_alias=True, exclude_defaults=True).items():\n        operations.append({'op': 'replace', 'path': f'/{key}', 'value': val})\n    resp: Response = self._client.patch(ACCOUNT_URL.format(account_id=update_account.account_id), json=operations)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudAccount.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update account response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update account response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.update_account_credentials_in_vault","title":"<code>update_account_credentials_in_vault(update_account_credentials_in_vault)</code>","text":"<p>Updates the account credentials only in the vault without changing it on the machine itself https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/ChangeCredentialsInVault.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_account_credentials_in_vault</code> <code>ArkPCloudUpdateAccountCredentialsInVault</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def update_account_credentials_in_vault(self, update_account_credentials_in_vault: ArkPCloudUpdateAccountCredentialsInVault) -&gt; None:\n    \"\"\"\n    Updates the account credentials only in the vault without changing it on the machine itself\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/ChangeCredentialsInVault.htm\n\n    Args:\n        update_account_credentials_in_vault (ArkPCloudUpdateAccountCredentialsInVault): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Updates account [{update_account_credentials_in_vault.account_id}] vault credentials')\n    resp: Response = self._client.post(\n        UPDATE_ACCOUNT_CREDENTIALS_IN_VAULT.format(account_id=update_account_credentials_in_vault.account_id),\n        json=update_account_credentials_in_vault.model_dump(exclude={'account_id'}, by_alias=True),\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update credentials in vault for account [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/accounts/ark_pcloud_accounts_service/#ark_sdk_python.services.pcloud.accounts.ark_pcloud_accounts_service.ArkPCloudAccountsService.verify_account_credentials","title":"<code>verify_account_credentials(verify_account_credentials)</code>","text":"<p>Marks the account for password verification by CPM https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Verify-credentials-v9-10.htm</p> <p>Parameters:</p> Name Type Description Default <code>verify_account_credentials</code> <code>ArkPCloudVerifyAccountCredentials</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/accounts/ark_pcloud_accounts_service.py</code> <pre><code>def verify_account_credentials(self, verify_account_credentials: ArkPCloudVerifyAccountCredentials) -&gt; None:\n    \"\"\"\n    Marks the account for password verification by CPM\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Verify-credentials-v9-10.htm\n\n    Args:\n        verify_account_credentials (ArkPCloudVerifyAccountCredentials): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Marking account [{verify_account_credentials.account_id}] for verification')\n    resp: Response = self._client.post(VERIFY_ACCOUNT_CREDENTIALS.format(account_id=verify_account_credentials.account_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to mark account for password verification [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/","title":"applications","text":""},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService","title":"<code>ArkPCloudApplicationsService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>class ArkPCloudApplicationsService(ArkPCloudBaseService):\n    def __init__(\n        self,\n        isp_auth: Optional[ArkISPAuth] = None,\n    ) -&gt; None:\n        super().__init__(isp_auth, 'webservices')\n\n    def add_application(self, add_application: ArkPCloudAddApplication) -&gt; ArkPCloudApplication:\n        \"\"\"\n        Adds a new application for CP / CCP\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Application.htm\n\n        Args:\n            add_application (ArkPCloudAddApplication): _description_\n\n        Returns:\n            ArkPCloudApplication: _description_\n        \"\"\"\n        self._logger.info(f'Adding new application with id [{add_application.app_id}]')\n        try:\n            parse(add_application.expiration_date)\n        except Exception as ex:\n            raise ArkServiceException('Expiration date format is invalid') from ex\n        add_dict = add_application.model_dump(by_alias=True, exclude_none=True, exclude={'app_id'})\n        add_dict['AppID'] = add_application.app_id\n        resp: Response = self._client.post(BASE_APPLICATIONS_URL, json={'application': add_dict})\n        if resp.status_code == HTTPStatus.CREATED:\n            return self.application(ArkPCloudGetApplication(app_id=add_application.app_id))\n        raise ArkServiceException(f'Failed to add application [{resp.text}] - [{resp.status_code}]')\n\n    def delete_application(self, delete_application: ArkPCloudDeleteApplication) -&gt; None:\n        \"\"\"\n        Delete application by its id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Application.htm\n\n        Args:\n            delete_application (ArkPCloudDeleteApplication): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting application with id [{delete_application.app_id}]')\n        resp: Response = self._client.delete(BASE_APPLICATION_URL.format(app_id=delete_application.app_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to delete application [{resp.text}] - [{resp.status_code}]')\n\n    def list_applications(self) -&gt; List[ArkPCloudApplication]:\n        \"\"\"\n        Lists all applications\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n        Returns:\n            List[ArkPCloudApplication]: _description_\n        \"\"\"\n        self._logger.info('Listing all applications')\n        resp: Response = self._client.get(BASE_APPLICATIONS_URL)\n        if resp.status_code == HTTPStatus.OK:\n            return TypeAdapter(List[ArkPCloudApplication]).validate_python(resp.json()['application'])\n        raise ArkServiceException(f'Failed to list applications [{resp.text}] - [{resp.status_code}]')\n\n    def list_applications_by(self, applications_filter: ArkPCloudApplicationsFilter) -&gt; List[ArkPCloudApplication]:\n        \"\"\"\n        Lists applications by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n        Args:\n            applications_filter (ArkPCloudApplicationsFilter): _description_\n\n        Returns:\n            List[ArkPCloudApplication]: _description_\n        \"\"\"\n        self._logger.info(f'Listing applications by filters [{applications_filter}]')\n        applications = self.list_applications()\n        if applications_filter.location:\n            applications = [a for a in applications if fnmatch(a.location, applications_filter.location)]\n        if applications_filter.only_enabled:\n            applications = [a for a in applications if not a.disabled]\n        if applications_filter.business_owner_name:\n            applications = [\n                a\n                for a in applications\n                if fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n                or fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n            ]\n        if applications_filter.business_owner_email:\n            applications = [a for a in applications if a.business_owner_email == applications_filter.business_owner_email]\n        return applications\n\n    def application(self, get_application: ArkPCloudGetApplication) -&gt; ArkPCloudApplication:\n        \"\"\"\n        Retrieves an application by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20a%20Specific%20Application.htm\n\n        Args:\n            get_application (ArkPCloudGetApplication): _description_\n\n        Returns:\n            ArkPCloudApplication: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving application by id [{get_application.app_id}]')\n        resp: Response = self._client.get(BASE_APPLICATION_URL.format(app_id=get_application.app_id))\n        if resp.status_code == HTTPStatus.OK:\n            return ArkPCloudApplication.model_validate(resp.json()['application'])\n        raise ArkServiceException(f'Failed to retrieve application [{resp.text}] - [{resp.status_code}]')\n\n    def applications_stats(self) -&gt; ArkPCloudAppicationsStats:\n        \"\"\"\n        Calculates applications stats\n\n        Returns:\n            ArkPCloudAppicationsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating applications stats')\n        applications = self.list_applications()\n        applications_stats = ArkPCloudAppicationsStats.model_construct()\n        applications_stats.count = len(applications)\n        applications_stats.disabled_apps = [a.app_id for a in applications if a.disabled]\n        apps_auth_types = {}\n        for a in applications:\n            auth_methods = self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=a.app_id))\n            apps_auth_types[a.app_id] = [am.auth_type for am in auth_methods]\n        applications_stats.applications_auth_method_types = apps_auth_types\n        applications_stats.auth_types_count = {}\n        for auth_method_types in apps_auth_types.values():\n            for auth_method in auth_method_types:\n                if auth_method not in applications_stats.auth_types_count:\n                    applications_stats.auth_types_count[auth_method] = 0\n                applications_stats.auth_types_count[auth_method] += 1\n        return applications_stats\n\n    def add_application_auth_method(self, add_application_auth_method: ArkPCloudAddApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n        \"\"\"\n        Adds a new auth method for the application\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Authentication.htm\n\n        Args:\n            add_application_auth_method (ArkPCloudAddApplicationAuthMethod): _description_\n\n        Returns:\n            ArkPCloudApplicationAuthMethod: _description_\n        \"\"\"\n        self._logger.info(\n            f'Adding a new auth method [{add_application_auth_method.auth_type}] for app [{add_application_auth_method.app_id}]'\n        )\n        auth_method_dict = None\n        if add_application_auth_method.auth_type in [\n            ArkPCloudApplicationAuthMethodType.Hash,\n            ArkPCloudApplicationAuthMethodType.IP,\n            ArkPCloudApplicationAuthMethodType.OsUser,\n            ArkPCloudApplicationAuthMethodType.Path,\n            ArkPCloudApplicationAuthMethodType.CertificateSerialNumber,\n        ]:\n            if not add_application_auth_method.auth_value:\n                raise ArkServiceException('Auth value is required for the chosen auth method type')\n            keys = {'auth_id', 'auth_type', 'auth_value', 'comment'}\n            if add_application_auth_method.auth_type == ArkPCloudApplicationAuthMethodType.Path:\n                keys = keys.union({'is_folder', 'allow_internal_scripts'})\n            auth_method_dict = add_application_auth_method.model_dump(include=keys, by_alias=True, exclude_none=True)\n        elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Certificate:\n            if (\n                not add_application_auth_method.subject\n                and not add_application_auth_method.issuer\n                and not add_application_auth_method.subject_alternative_name\n            ):\n                raise ArkServiceException('At least issuer, subject or san needs to be given for certificate auth type')\n            auth_method_dict = add_application_auth_method.model_dump(\n                include={'auth_id', 'auth_type', 'auth_value', 'subject', 'issuer', 'subject_alternative_name'},\n                by_alias=True,\n                exclude_none=True,\n            )\n        elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Kubernetes:\n            if (\n                not add_application_auth_method.namespace\n                and not add_application_auth_method.image\n                and not add_application_auth_method.env_var_name\n                or not add_application_auth_method.env_var_value\n            ):\n                raise ArkServiceException('At least namespace, image, env var key and value needs to be given for kubernetes auth type')\n            auth_method_dict = add_application_auth_method.model_dump(\n                include={'auth_id', 'auth_type', 'auth_value', 'namespace', 'image', 'env_var_name', 'env_var_value'},\n                by_alias=True,\n                exclude_none=True,\n            )\n        else:\n            raise ArkServiceException('Unsupported auth method type')\n        resp: Response = self._client.post(\n            BASE_AUTH_METHODS_URL.format(app_id=add_application_auth_method.app_id),\n            json={\n                'authentication': auth_method_dict,\n            },\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            return self.list_application_auth_methods_by(\n                ArkPCloudApplicationAuthMethodsFilter(\n                    app_id=add_application_auth_method.app_id, auth_types=[add_application_auth_method.auth_type]\n                )\n            )[0]\n        raise ArkServiceException(f'Failed to add app auth method [{resp.text}] - [{resp.status_code}]')\n\n    def delete_application_auth_method(self, delete_application_auth_method: ArkPCloudDeleteApplicationAuthMethod) -&gt; None:\n        \"\"\"\n        Deletes an auth method from an application\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Authentication.htm\n\n        Args:\n            delete_application_auth_method (ArkPCloudDeleteApplicationAuthMethod): _description_\n        \"\"\"\n        self._logger.info(\n            f'Deleting auth method from app [{delete_application_auth_method.app_id}] with id [{delete_application_auth_method.auth_id}]'\n        )\n        resp: Response = self._client.delete(\n            BASE_AUTH_METHOD_URL.format(app_id=delete_application_auth_method.app_id, auth_id=delete_application_auth_method.auth_id)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to delete auth method [{resp.text}] - [{resp.status_code}]')\n\n    def list_application_auth_methods(\n        self, list_application_auth_methods: ArkPCloudListApplicationAuthMethods\n    ) -&gt; List[ArkPCloudApplicationAuthMethod]:\n        \"\"\"\n        Lists all application auth methods\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n        Args:\n            list_application_auth_methods (ArkPCloudListApplicationAuthMethods): _description_\n\n        Returns:\n            List[ArkPCloudApplicationAuthMethod]: _description_\n        \"\"\"\n        self._logger.info(f'Listing all application [{list_application_auth_methods.app_id}]] auth methods')\n        resp: Response = self._client.get(BASE_AUTH_METHODS_URL.format(app_id=list_application_auth_methods.app_id))\n        if resp.status_code == HTTPStatus.OK:\n            return TypeAdapter(List[ArkPCloudApplicationAuthMethod]).validate_python(resp.json()['authentication'])\n        raise ArkServiceException(f'Failed to list application auth methods [{resp.text}] - [{resp.status_code}]]')\n\n    def list_application_auth_methods_by(\n        self, application_auth_methods_filter: ArkPCloudApplicationAuthMethodsFilter\n    ) -&gt; List[ArkPCloudApplicationAuthMethod]:\n        \"\"\"\n        Lists application auth methods by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n        Args:\n            application_auth_methods_filter (ArkPCloudApplicationAuthMethodsFilter): _description_\n\n        Returns:\n            List[ArkPCloudApplicationAuthMethod]: _description_\n        \"\"\"\n        self._logger.info(f'Listing auth methods of app filtered [{application_auth_methods_filter}]')\n        auth_methods = self.list_application_auth_methods(\n            ArkPCloudListApplicationAuthMethods(app_id=application_auth_methods_filter.app_id)\n        )\n        if application_auth_methods_filter.auth_types:\n            auth_methods = [a for a in auth_methods if a.auth_type in application_auth_methods_filter.auth_types]\n        return auth_methods\n\n    def application_auth_method(self, get_application_auth_method: ArkPCloudGetApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n        \"\"\"\n        Retrives an auth method by app id and auth id\n\n        Args:\n            get_application_auth_method (ArkPCloudGetApplicationAuthMethod): _description_\n\n        Returns:\n            ArkPCloudApplicationAuthMethod: _description_\n        \"\"\"\n        self._logger.info(\n            f'Retrieving auth method of app [{get_application_auth_method.app_id}] and id [{get_application_auth_method.auth_id}]'\n        )\n        auth_methods = [\n            a\n            for a in self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=get_application_auth_method.app_id))\n            if a.auth_id == get_application_auth_method.auth_id\n        ]\n        if not auth_methods:\n            raise ArkServiceException('Failed to find auth method')\n        return auth_methods[0]\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.add_application","title":"<code>add_application(add_application)</code>","text":"<p>Adds a new application for CP / CCP https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_application</code> <code>ArkPCloudAddApplication</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplication</code> <code>ArkPCloudApplication</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def add_application(self, add_application: ArkPCloudAddApplication) -&gt; ArkPCloudApplication:\n    \"\"\"\n    Adds a new application for CP / CCP\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Application.htm\n\n    Args:\n        add_application (ArkPCloudAddApplication): _description_\n\n    Returns:\n        ArkPCloudApplication: _description_\n    \"\"\"\n    self._logger.info(f'Adding new application with id [{add_application.app_id}]')\n    try:\n        parse(add_application.expiration_date)\n    except Exception as ex:\n        raise ArkServiceException('Expiration date format is invalid') from ex\n    add_dict = add_application.model_dump(by_alias=True, exclude_none=True, exclude={'app_id'})\n    add_dict['AppID'] = add_application.app_id\n    resp: Response = self._client.post(BASE_APPLICATIONS_URL, json={'application': add_dict})\n    if resp.status_code == HTTPStatus.CREATED:\n        return self.application(ArkPCloudGetApplication(app_id=add_application.app_id))\n    raise ArkServiceException(f'Failed to add application [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.add_application_auth_method","title":"<code>add_application_auth_method(add_application_auth_method)</code>","text":"<p>Adds a new auth method for the application https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Authentication.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_application_auth_method</code> <code>ArkPCloudAddApplicationAuthMethod</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplicationAuthMethod</code> <code>ArkPCloudApplicationAuthMethod</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def add_application_auth_method(self, add_application_auth_method: ArkPCloudAddApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n    \"\"\"\n    Adds a new auth method for the application\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Authentication.htm\n\n    Args:\n        add_application_auth_method (ArkPCloudAddApplicationAuthMethod): _description_\n\n    Returns:\n        ArkPCloudApplicationAuthMethod: _description_\n    \"\"\"\n    self._logger.info(\n        f'Adding a new auth method [{add_application_auth_method.auth_type}] for app [{add_application_auth_method.app_id}]'\n    )\n    auth_method_dict = None\n    if add_application_auth_method.auth_type in [\n        ArkPCloudApplicationAuthMethodType.Hash,\n        ArkPCloudApplicationAuthMethodType.IP,\n        ArkPCloudApplicationAuthMethodType.OsUser,\n        ArkPCloudApplicationAuthMethodType.Path,\n        ArkPCloudApplicationAuthMethodType.CertificateSerialNumber,\n    ]:\n        if not add_application_auth_method.auth_value:\n            raise ArkServiceException('Auth value is required for the chosen auth method type')\n        keys = {'auth_id', 'auth_type', 'auth_value', 'comment'}\n        if add_application_auth_method.auth_type == ArkPCloudApplicationAuthMethodType.Path:\n            keys = keys.union({'is_folder', 'allow_internal_scripts'})\n        auth_method_dict = add_application_auth_method.model_dump(include=keys, by_alias=True, exclude_none=True)\n    elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Certificate:\n        if (\n            not add_application_auth_method.subject\n            and not add_application_auth_method.issuer\n            and not add_application_auth_method.subject_alternative_name\n        ):\n            raise ArkServiceException('At least issuer, subject or san needs to be given for certificate auth type')\n        auth_method_dict = add_application_auth_method.model_dump(\n            include={'auth_id', 'auth_type', 'auth_value', 'subject', 'issuer', 'subject_alternative_name'},\n            by_alias=True,\n            exclude_none=True,\n        )\n    elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Kubernetes:\n        if (\n            not add_application_auth_method.namespace\n            and not add_application_auth_method.image\n            and not add_application_auth_method.env_var_name\n            or not add_application_auth_method.env_var_value\n        ):\n            raise ArkServiceException('At least namespace, image, env var key and value needs to be given for kubernetes auth type')\n        auth_method_dict = add_application_auth_method.model_dump(\n            include={'auth_id', 'auth_type', 'auth_value', 'namespace', 'image', 'env_var_name', 'env_var_value'},\n            by_alias=True,\n            exclude_none=True,\n        )\n    else:\n        raise ArkServiceException('Unsupported auth method type')\n    resp: Response = self._client.post(\n        BASE_AUTH_METHODS_URL.format(app_id=add_application_auth_method.app_id),\n        json={\n            'authentication': auth_method_dict,\n        },\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        return self.list_application_auth_methods_by(\n            ArkPCloudApplicationAuthMethodsFilter(\n                app_id=add_application_auth_method.app_id, auth_types=[add_application_auth_method.auth_type]\n            )\n        )[0]\n    raise ArkServiceException(f'Failed to add app auth method [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.application","title":"<code>application(get_application)</code>","text":"<p>Retrieves an application by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_application</code> <code>ArkPCloudGetApplication</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplication</code> <code>ArkPCloudApplication</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def application(self, get_application: ArkPCloudGetApplication) -&gt; ArkPCloudApplication:\n    \"\"\"\n    Retrieves an application by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20a%20Specific%20Application.htm\n\n    Args:\n        get_application (ArkPCloudGetApplication): _description_\n\n    Returns:\n        ArkPCloudApplication: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving application by id [{get_application.app_id}]')\n    resp: Response = self._client.get(BASE_APPLICATION_URL.format(app_id=get_application.app_id))\n    if resp.status_code == HTTPStatus.OK:\n        return ArkPCloudApplication.model_validate(resp.json()['application'])\n    raise ArkServiceException(f'Failed to retrieve application [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.application_auth_method","title":"<code>application_auth_method(get_application_auth_method)</code>","text":"<p>Retrives an auth method by app id and auth id</p> <p>Parameters:</p> Name Type Description Default <code>get_application_auth_method</code> <code>ArkPCloudGetApplicationAuthMethod</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplicationAuthMethod</code> <code>ArkPCloudApplicationAuthMethod</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def application_auth_method(self, get_application_auth_method: ArkPCloudGetApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n    \"\"\"\n    Retrives an auth method by app id and auth id\n\n    Args:\n        get_application_auth_method (ArkPCloudGetApplicationAuthMethod): _description_\n\n    Returns:\n        ArkPCloudApplicationAuthMethod: _description_\n    \"\"\"\n    self._logger.info(\n        f'Retrieving auth method of app [{get_application_auth_method.app_id}] and id [{get_application_auth_method.auth_id}]'\n    )\n    auth_methods = [\n        a\n        for a in self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=get_application_auth_method.app_id))\n        if a.auth_id == get_application_auth_method.auth_id\n    ]\n    if not auth_methods:\n        raise ArkServiceException('Failed to find auth method')\n    return auth_methods[0]\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.applications_stats","title":"<code>applications_stats()</code>","text":"<p>Calculates applications stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAppicationsStats</code> <code>ArkPCloudAppicationsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def applications_stats(self) -&gt; ArkPCloudAppicationsStats:\n    \"\"\"\n    Calculates applications stats\n\n    Returns:\n        ArkPCloudAppicationsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating applications stats')\n    applications = self.list_applications()\n    applications_stats = ArkPCloudAppicationsStats.model_construct()\n    applications_stats.count = len(applications)\n    applications_stats.disabled_apps = [a.app_id for a in applications if a.disabled]\n    apps_auth_types = {}\n    for a in applications:\n        auth_methods = self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=a.app_id))\n        apps_auth_types[a.app_id] = [am.auth_type for am in auth_methods]\n    applications_stats.applications_auth_method_types = apps_auth_types\n    applications_stats.auth_types_count = {}\n    for auth_method_types in apps_auth_types.values():\n        for auth_method in auth_method_types:\n            if auth_method not in applications_stats.auth_types_count:\n                applications_stats.auth_types_count[auth_method] = 0\n            applications_stats.auth_types_count[auth_method] += 1\n    return applications_stats\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.delete_application","title":"<code>delete_application(delete_application)</code>","text":"<p>Delete application by its id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_application</code> <code>ArkPCloudDeleteApplication</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def delete_application(self, delete_application: ArkPCloudDeleteApplication) -&gt; None:\n    \"\"\"\n    Delete application by its id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Application.htm\n\n    Args:\n        delete_application (ArkPCloudDeleteApplication): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting application with id [{delete_application.app_id}]')\n    resp: Response = self._client.delete(BASE_APPLICATION_URL.format(app_id=delete_application.app_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to delete application [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.delete_application_auth_method","title":"<code>delete_application_auth_method(delete_application_auth_method)</code>","text":"<p>Deletes an auth method from an application https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Authentication.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_application_auth_method</code> <code>ArkPCloudDeleteApplicationAuthMethod</code> <p>description</p> required Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def delete_application_auth_method(self, delete_application_auth_method: ArkPCloudDeleteApplicationAuthMethod) -&gt; None:\n    \"\"\"\n    Deletes an auth method from an application\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Authentication.htm\n\n    Args:\n        delete_application_auth_method (ArkPCloudDeleteApplicationAuthMethod): _description_\n    \"\"\"\n    self._logger.info(\n        f'Deleting auth method from app [{delete_application_auth_method.app_id}] with id [{delete_application_auth_method.auth_id}]'\n    )\n    resp: Response = self._client.delete(\n        BASE_AUTH_METHOD_URL.format(app_id=delete_application_auth_method.app_id, auth_id=delete_application_auth_method.auth_id)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to delete auth method [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.list_application_auth_methods","title":"<code>list_application_auth_methods(list_application_auth_methods)</code>","text":"<p>Lists all application auth methods https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>list_application_auth_methods</code> <code>ArkPCloudListApplicationAuthMethods</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudApplicationAuthMethod]</code> <p>List[ArkPCloudApplicationAuthMethod]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_application_auth_methods(\n    self, list_application_auth_methods: ArkPCloudListApplicationAuthMethods\n) -&gt; List[ArkPCloudApplicationAuthMethod]:\n    \"\"\"\n    Lists all application auth methods\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n    Args:\n        list_application_auth_methods (ArkPCloudListApplicationAuthMethods): _description_\n\n    Returns:\n        List[ArkPCloudApplicationAuthMethod]: _description_\n    \"\"\"\n    self._logger.info(f'Listing all application [{list_application_auth_methods.app_id}]] auth methods')\n    resp: Response = self._client.get(BASE_AUTH_METHODS_URL.format(app_id=list_application_auth_methods.app_id))\n    if resp.status_code == HTTPStatus.OK:\n        return TypeAdapter(List[ArkPCloudApplicationAuthMethod]).validate_python(resp.json()['authentication'])\n    raise ArkServiceException(f'Failed to list application auth methods [{resp.text}] - [{resp.status_code}]]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.list_application_auth_methods_by","title":"<code>list_application_auth_methods_by(application_auth_methods_filter)</code>","text":"<p>Lists application auth methods by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>application_auth_methods_filter</code> <code>ArkPCloudApplicationAuthMethodsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudApplicationAuthMethod]</code> <p>List[ArkPCloudApplicationAuthMethod]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_application_auth_methods_by(\n    self, application_auth_methods_filter: ArkPCloudApplicationAuthMethodsFilter\n) -&gt; List[ArkPCloudApplicationAuthMethod]:\n    \"\"\"\n    Lists application auth methods by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n    Args:\n        application_auth_methods_filter (ArkPCloudApplicationAuthMethodsFilter): _description_\n\n    Returns:\n        List[ArkPCloudApplicationAuthMethod]: _description_\n    \"\"\"\n    self._logger.info(f'Listing auth methods of app filtered [{application_auth_methods_filter}]')\n    auth_methods = self.list_application_auth_methods(\n        ArkPCloudListApplicationAuthMethods(app_id=application_auth_methods_filter.app_id)\n    )\n    if application_auth_methods_filter.auth_types:\n        auth_methods = [a for a in auth_methods if a.auth_type in application_auth_methods_filter.auth_types]\n    return auth_methods\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.list_applications","title":"<code>list_applications()</code>","text":"<p>Lists all applications https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm</p> <p>Returns:</p> Type Description <code>List[ArkPCloudApplication]</code> <p>List[ArkPCloudApplication]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_applications(self) -&gt; List[ArkPCloudApplication]:\n    \"\"\"\n    Lists all applications\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n    Returns:\n        List[ArkPCloudApplication]: _description_\n    \"\"\"\n    self._logger.info('Listing all applications')\n    resp: Response = self._client.get(BASE_APPLICATIONS_URL)\n    if resp.status_code == HTTPStatus.OK:\n        return TypeAdapter(List[ArkPCloudApplication]).validate_python(resp.json()['application'])\n    raise ArkServiceException(f'Failed to list applications [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/#ark_sdk_python.services.pcloud.applications.ArkPCloudApplicationsService.list_applications_by","title":"<code>list_applications_by(applications_filter)</code>","text":"<p>Lists applications by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm</p> <p>Parameters:</p> Name Type Description Default <code>applications_filter</code> <code>ArkPCloudApplicationsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudApplication]</code> <p>List[ArkPCloudApplication]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_applications_by(self, applications_filter: ArkPCloudApplicationsFilter) -&gt; List[ArkPCloudApplication]:\n    \"\"\"\n    Lists applications by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n    Args:\n        applications_filter (ArkPCloudApplicationsFilter): _description_\n\n    Returns:\n        List[ArkPCloudApplication]: _description_\n    \"\"\"\n    self._logger.info(f'Listing applications by filters [{applications_filter}]')\n    applications = self.list_applications()\n    if applications_filter.location:\n        applications = [a for a in applications if fnmatch(a.location, applications_filter.location)]\n    if applications_filter.only_enabled:\n        applications = [a for a in applications if not a.disabled]\n    if applications_filter.business_owner_name:\n        applications = [\n            a\n            for a in applications\n            if fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n            or fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n        ]\n    if applications_filter.business_owner_email:\n        applications = [a for a in applications if a.business_owner_email == applications_filter.business_owner_email]\n    return applications\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/","title":"ark_pcloud_applications_service","text":""},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService","title":"<code>ArkPCloudApplicationsService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>class ArkPCloudApplicationsService(ArkPCloudBaseService):\n    def __init__(\n        self,\n        isp_auth: Optional[ArkISPAuth] = None,\n    ) -&gt; None:\n        super().__init__(isp_auth, 'webservices')\n\n    def add_application(self, add_application: ArkPCloudAddApplication) -&gt; ArkPCloudApplication:\n        \"\"\"\n        Adds a new application for CP / CCP\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Application.htm\n\n        Args:\n            add_application (ArkPCloudAddApplication): _description_\n\n        Returns:\n            ArkPCloudApplication: _description_\n        \"\"\"\n        self._logger.info(f'Adding new application with id [{add_application.app_id}]')\n        try:\n            parse(add_application.expiration_date)\n        except Exception as ex:\n            raise ArkServiceException('Expiration date format is invalid') from ex\n        add_dict = add_application.model_dump(by_alias=True, exclude_none=True, exclude={'app_id'})\n        add_dict['AppID'] = add_application.app_id\n        resp: Response = self._client.post(BASE_APPLICATIONS_URL, json={'application': add_dict})\n        if resp.status_code == HTTPStatus.CREATED:\n            return self.application(ArkPCloudGetApplication(app_id=add_application.app_id))\n        raise ArkServiceException(f'Failed to add application [{resp.text}] - [{resp.status_code}]')\n\n    def delete_application(self, delete_application: ArkPCloudDeleteApplication) -&gt; None:\n        \"\"\"\n        Delete application by its id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Application.htm\n\n        Args:\n            delete_application (ArkPCloudDeleteApplication): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting application with id [{delete_application.app_id}]')\n        resp: Response = self._client.delete(BASE_APPLICATION_URL.format(app_id=delete_application.app_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to delete application [{resp.text}] - [{resp.status_code}]')\n\n    def list_applications(self) -&gt; List[ArkPCloudApplication]:\n        \"\"\"\n        Lists all applications\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n        Returns:\n            List[ArkPCloudApplication]: _description_\n        \"\"\"\n        self._logger.info('Listing all applications')\n        resp: Response = self._client.get(BASE_APPLICATIONS_URL)\n        if resp.status_code == HTTPStatus.OK:\n            return TypeAdapter(List[ArkPCloudApplication]).validate_python(resp.json()['application'])\n        raise ArkServiceException(f'Failed to list applications [{resp.text}] - [{resp.status_code}]')\n\n    def list_applications_by(self, applications_filter: ArkPCloudApplicationsFilter) -&gt; List[ArkPCloudApplication]:\n        \"\"\"\n        Lists applications by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n        Args:\n            applications_filter (ArkPCloudApplicationsFilter): _description_\n\n        Returns:\n            List[ArkPCloudApplication]: _description_\n        \"\"\"\n        self._logger.info(f'Listing applications by filters [{applications_filter}]')\n        applications = self.list_applications()\n        if applications_filter.location:\n            applications = [a for a in applications if fnmatch(a.location, applications_filter.location)]\n        if applications_filter.only_enabled:\n            applications = [a for a in applications if not a.disabled]\n        if applications_filter.business_owner_name:\n            applications = [\n                a\n                for a in applications\n                if fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n                or fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n            ]\n        if applications_filter.business_owner_email:\n            applications = [a for a in applications if a.business_owner_email == applications_filter.business_owner_email]\n        return applications\n\n    def application(self, get_application: ArkPCloudGetApplication) -&gt; ArkPCloudApplication:\n        \"\"\"\n        Retrieves an application by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20a%20Specific%20Application.htm\n\n        Args:\n            get_application (ArkPCloudGetApplication): _description_\n\n        Returns:\n            ArkPCloudApplication: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving application by id [{get_application.app_id}]')\n        resp: Response = self._client.get(BASE_APPLICATION_URL.format(app_id=get_application.app_id))\n        if resp.status_code == HTTPStatus.OK:\n            return ArkPCloudApplication.model_validate(resp.json()['application'])\n        raise ArkServiceException(f'Failed to retrieve application [{resp.text}] - [{resp.status_code}]')\n\n    def applications_stats(self) -&gt; ArkPCloudAppicationsStats:\n        \"\"\"\n        Calculates applications stats\n\n        Returns:\n            ArkPCloudAppicationsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating applications stats')\n        applications = self.list_applications()\n        applications_stats = ArkPCloudAppicationsStats.model_construct()\n        applications_stats.count = len(applications)\n        applications_stats.disabled_apps = [a.app_id for a in applications if a.disabled]\n        apps_auth_types = {}\n        for a in applications:\n            auth_methods = self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=a.app_id))\n            apps_auth_types[a.app_id] = [am.auth_type for am in auth_methods]\n        applications_stats.applications_auth_method_types = apps_auth_types\n        applications_stats.auth_types_count = {}\n        for auth_method_types in apps_auth_types.values():\n            for auth_method in auth_method_types:\n                if auth_method not in applications_stats.auth_types_count:\n                    applications_stats.auth_types_count[auth_method] = 0\n                applications_stats.auth_types_count[auth_method] += 1\n        return applications_stats\n\n    def add_application_auth_method(self, add_application_auth_method: ArkPCloudAddApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n        \"\"\"\n        Adds a new auth method for the application\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Authentication.htm\n\n        Args:\n            add_application_auth_method (ArkPCloudAddApplicationAuthMethod): _description_\n\n        Returns:\n            ArkPCloudApplicationAuthMethod: _description_\n        \"\"\"\n        self._logger.info(\n            f'Adding a new auth method [{add_application_auth_method.auth_type}] for app [{add_application_auth_method.app_id}]'\n        )\n        auth_method_dict = None\n        if add_application_auth_method.auth_type in [\n            ArkPCloudApplicationAuthMethodType.Hash,\n            ArkPCloudApplicationAuthMethodType.IP,\n            ArkPCloudApplicationAuthMethodType.OsUser,\n            ArkPCloudApplicationAuthMethodType.Path,\n            ArkPCloudApplicationAuthMethodType.CertificateSerialNumber,\n        ]:\n            if not add_application_auth_method.auth_value:\n                raise ArkServiceException('Auth value is required for the chosen auth method type')\n            keys = {'auth_id', 'auth_type', 'auth_value', 'comment'}\n            if add_application_auth_method.auth_type == ArkPCloudApplicationAuthMethodType.Path:\n                keys = keys.union({'is_folder', 'allow_internal_scripts'})\n            auth_method_dict = add_application_auth_method.model_dump(include=keys, by_alias=True, exclude_none=True)\n        elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Certificate:\n            if (\n                not add_application_auth_method.subject\n                and not add_application_auth_method.issuer\n                and not add_application_auth_method.subject_alternative_name\n            ):\n                raise ArkServiceException('At least issuer, subject or san needs to be given for certificate auth type')\n            auth_method_dict = add_application_auth_method.model_dump(\n                include={'auth_id', 'auth_type', 'auth_value', 'subject', 'issuer', 'subject_alternative_name'},\n                by_alias=True,\n                exclude_none=True,\n            )\n        elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Kubernetes:\n            if (\n                not add_application_auth_method.namespace\n                and not add_application_auth_method.image\n                and not add_application_auth_method.env_var_name\n                or not add_application_auth_method.env_var_value\n            ):\n                raise ArkServiceException('At least namespace, image, env var key and value needs to be given for kubernetes auth type')\n            auth_method_dict = add_application_auth_method.model_dump(\n                include={'auth_id', 'auth_type', 'auth_value', 'namespace', 'image', 'env_var_name', 'env_var_value'},\n                by_alias=True,\n                exclude_none=True,\n            )\n        else:\n            raise ArkServiceException('Unsupported auth method type')\n        resp: Response = self._client.post(\n            BASE_AUTH_METHODS_URL.format(app_id=add_application_auth_method.app_id),\n            json={\n                'authentication': auth_method_dict,\n            },\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            return self.list_application_auth_methods_by(\n                ArkPCloudApplicationAuthMethodsFilter(\n                    app_id=add_application_auth_method.app_id, auth_types=[add_application_auth_method.auth_type]\n                )\n            )[0]\n        raise ArkServiceException(f'Failed to add app auth method [{resp.text}] - [{resp.status_code}]')\n\n    def delete_application_auth_method(self, delete_application_auth_method: ArkPCloudDeleteApplicationAuthMethod) -&gt; None:\n        \"\"\"\n        Deletes an auth method from an application\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Authentication.htm\n\n        Args:\n            delete_application_auth_method (ArkPCloudDeleteApplicationAuthMethod): _description_\n        \"\"\"\n        self._logger.info(\n            f'Deleting auth method from app [{delete_application_auth_method.app_id}] with id [{delete_application_auth_method.auth_id}]'\n        )\n        resp: Response = self._client.delete(\n            BASE_AUTH_METHOD_URL.format(app_id=delete_application_auth_method.app_id, auth_id=delete_application_auth_method.auth_id)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to delete auth method [{resp.text}] - [{resp.status_code}]')\n\n    def list_application_auth_methods(\n        self, list_application_auth_methods: ArkPCloudListApplicationAuthMethods\n    ) -&gt; List[ArkPCloudApplicationAuthMethod]:\n        \"\"\"\n        Lists all application auth methods\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n        Args:\n            list_application_auth_methods (ArkPCloudListApplicationAuthMethods): _description_\n\n        Returns:\n            List[ArkPCloudApplicationAuthMethod]: _description_\n        \"\"\"\n        self._logger.info(f'Listing all application [{list_application_auth_methods.app_id}]] auth methods')\n        resp: Response = self._client.get(BASE_AUTH_METHODS_URL.format(app_id=list_application_auth_methods.app_id))\n        if resp.status_code == HTTPStatus.OK:\n            return TypeAdapter(List[ArkPCloudApplicationAuthMethod]).validate_python(resp.json()['authentication'])\n        raise ArkServiceException(f'Failed to list application auth methods [{resp.text}] - [{resp.status_code}]]')\n\n    def list_application_auth_methods_by(\n        self, application_auth_methods_filter: ArkPCloudApplicationAuthMethodsFilter\n    ) -&gt; List[ArkPCloudApplicationAuthMethod]:\n        \"\"\"\n        Lists application auth methods by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n        Args:\n            application_auth_methods_filter (ArkPCloudApplicationAuthMethodsFilter): _description_\n\n        Returns:\n            List[ArkPCloudApplicationAuthMethod]: _description_\n        \"\"\"\n        self._logger.info(f'Listing auth methods of app filtered [{application_auth_methods_filter}]')\n        auth_methods = self.list_application_auth_methods(\n            ArkPCloudListApplicationAuthMethods(app_id=application_auth_methods_filter.app_id)\n        )\n        if application_auth_methods_filter.auth_types:\n            auth_methods = [a for a in auth_methods if a.auth_type in application_auth_methods_filter.auth_types]\n        return auth_methods\n\n    def application_auth_method(self, get_application_auth_method: ArkPCloudGetApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n        \"\"\"\n        Retrives an auth method by app id and auth id\n\n        Args:\n            get_application_auth_method (ArkPCloudGetApplicationAuthMethod): _description_\n\n        Returns:\n            ArkPCloudApplicationAuthMethod: _description_\n        \"\"\"\n        self._logger.info(\n            f'Retrieving auth method of app [{get_application_auth_method.app_id}] and id [{get_application_auth_method.auth_id}]'\n        )\n        auth_methods = [\n            a\n            for a in self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=get_application_auth_method.app_id))\n            if a.auth_id == get_application_auth_method.auth_id\n        ]\n        if not auth_methods:\n            raise ArkServiceException('Failed to find auth method')\n        return auth_methods[0]\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.add_application","title":"<code>add_application(add_application)</code>","text":"<p>Adds a new application for CP / CCP https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_application</code> <code>ArkPCloudAddApplication</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplication</code> <code>ArkPCloudApplication</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def add_application(self, add_application: ArkPCloudAddApplication) -&gt; ArkPCloudApplication:\n    \"\"\"\n    Adds a new application for CP / CCP\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Application.htm\n\n    Args:\n        add_application (ArkPCloudAddApplication): _description_\n\n    Returns:\n        ArkPCloudApplication: _description_\n    \"\"\"\n    self._logger.info(f'Adding new application with id [{add_application.app_id}]')\n    try:\n        parse(add_application.expiration_date)\n    except Exception as ex:\n        raise ArkServiceException('Expiration date format is invalid') from ex\n    add_dict = add_application.model_dump(by_alias=True, exclude_none=True, exclude={'app_id'})\n    add_dict['AppID'] = add_application.app_id\n    resp: Response = self._client.post(BASE_APPLICATIONS_URL, json={'application': add_dict})\n    if resp.status_code == HTTPStatus.CREATED:\n        return self.application(ArkPCloudGetApplication(app_id=add_application.app_id))\n    raise ArkServiceException(f'Failed to add application [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.add_application_auth_method","title":"<code>add_application_auth_method(add_application_auth_method)</code>","text":"<p>Adds a new auth method for the application https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Authentication.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_application_auth_method</code> <code>ArkPCloudAddApplicationAuthMethod</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplicationAuthMethod</code> <code>ArkPCloudApplicationAuthMethod</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def add_application_auth_method(self, add_application_auth_method: ArkPCloudAddApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n    \"\"\"\n    Adds a new auth method for the application\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Add%20Authentication.htm\n\n    Args:\n        add_application_auth_method (ArkPCloudAddApplicationAuthMethod): _description_\n\n    Returns:\n        ArkPCloudApplicationAuthMethod: _description_\n    \"\"\"\n    self._logger.info(\n        f'Adding a new auth method [{add_application_auth_method.auth_type}] for app [{add_application_auth_method.app_id}]'\n    )\n    auth_method_dict = None\n    if add_application_auth_method.auth_type in [\n        ArkPCloudApplicationAuthMethodType.Hash,\n        ArkPCloudApplicationAuthMethodType.IP,\n        ArkPCloudApplicationAuthMethodType.OsUser,\n        ArkPCloudApplicationAuthMethodType.Path,\n        ArkPCloudApplicationAuthMethodType.CertificateSerialNumber,\n    ]:\n        if not add_application_auth_method.auth_value:\n            raise ArkServiceException('Auth value is required for the chosen auth method type')\n        keys = {'auth_id', 'auth_type', 'auth_value', 'comment'}\n        if add_application_auth_method.auth_type == ArkPCloudApplicationAuthMethodType.Path:\n            keys = keys.union({'is_folder', 'allow_internal_scripts'})\n        auth_method_dict = add_application_auth_method.model_dump(include=keys, by_alias=True, exclude_none=True)\n    elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Certificate:\n        if (\n            not add_application_auth_method.subject\n            and not add_application_auth_method.issuer\n            and not add_application_auth_method.subject_alternative_name\n        ):\n            raise ArkServiceException('At least issuer, subject or san needs to be given for certificate auth type')\n        auth_method_dict = add_application_auth_method.model_dump(\n            include={'auth_id', 'auth_type', 'auth_value', 'subject', 'issuer', 'subject_alternative_name'},\n            by_alias=True,\n            exclude_none=True,\n        )\n    elif add_application_auth_method == ArkPCloudApplicationAuthMethodType.Kubernetes:\n        if (\n            not add_application_auth_method.namespace\n            and not add_application_auth_method.image\n            and not add_application_auth_method.env_var_name\n            or not add_application_auth_method.env_var_value\n        ):\n            raise ArkServiceException('At least namespace, image, env var key and value needs to be given for kubernetes auth type')\n        auth_method_dict = add_application_auth_method.model_dump(\n            include={'auth_id', 'auth_type', 'auth_value', 'namespace', 'image', 'env_var_name', 'env_var_value'},\n            by_alias=True,\n            exclude_none=True,\n        )\n    else:\n        raise ArkServiceException('Unsupported auth method type')\n    resp: Response = self._client.post(\n        BASE_AUTH_METHODS_URL.format(app_id=add_application_auth_method.app_id),\n        json={\n            'authentication': auth_method_dict,\n        },\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        return self.list_application_auth_methods_by(\n            ArkPCloudApplicationAuthMethodsFilter(\n                app_id=add_application_auth_method.app_id, auth_types=[add_application_auth_method.auth_type]\n            )\n        )[0]\n    raise ArkServiceException(f'Failed to add app auth method [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.application","title":"<code>application(get_application)</code>","text":"<p>Retrieves an application by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_application</code> <code>ArkPCloudGetApplication</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplication</code> <code>ArkPCloudApplication</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def application(self, get_application: ArkPCloudGetApplication) -&gt; ArkPCloudApplication:\n    \"\"\"\n    Retrieves an application by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20a%20Specific%20Application.htm\n\n    Args:\n        get_application (ArkPCloudGetApplication): _description_\n\n    Returns:\n        ArkPCloudApplication: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving application by id [{get_application.app_id}]')\n    resp: Response = self._client.get(BASE_APPLICATION_URL.format(app_id=get_application.app_id))\n    if resp.status_code == HTTPStatus.OK:\n        return ArkPCloudApplication.model_validate(resp.json()['application'])\n    raise ArkServiceException(f'Failed to retrieve application [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.application_auth_method","title":"<code>application_auth_method(get_application_auth_method)</code>","text":"<p>Retrives an auth method by app id and auth id</p> <p>Parameters:</p> Name Type Description Default <code>get_application_auth_method</code> <code>ArkPCloudGetApplicationAuthMethod</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudApplicationAuthMethod</code> <code>ArkPCloudApplicationAuthMethod</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def application_auth_method(self, get_application_auth_method: ArkPCloudGetApplicationAuthMethod) -&gt; ArkPCloudApplicationAuthMethod:\n    \"\"\"\n    Retrives an auth method by app id and auth id\n\n    Args:\n        get_application_auth_method (ArkPCloudGetApplicationAuthMethod): _description_\n\n    Returns:\n        ArkPCloudApplicationAuthMethod: _description_\n    \"\"\"\n    self._logger.info(\n        f'Retrieving auth method of app [{get_application_auth_method.app_id}] and id [{get_application_auth_method.auth_id}]'\n    )\n    auth_methods = [\n        a\n        for a in self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=get_application_auth_method.app_id))\n        if a.auth_id == get_application_auth_method.auth_id\n    ]\n    if not auth_methods:\n        raise ArkServiceException('Failed to find auth method')\n    return auth_methods[0]\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.applications_stats","title":"<code>applications_stats()</code>","text":"<p>Calculates applications stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudAppicationsStats</code> <code>ArkPCloudAppicationsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def applications_stats(self) -&gt; ArkPCloudAppicationsStats:\n    \"\"\"\n    Calculates applications stats\n\n    Returns:\n        ArkPCloudAppicationsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating applications stats')\n    applications = self.list_applications()\n    applications_stats = ArkPCloudAppicationsStats.model_construct()\n    applications_stats.count = len(applications)\n    applications_stats.disabled_apps = [a.app_id for a in applications if a.disabled]\n    apps_auth_types = {}\n    for a in applications:\n        auth_methods = self.list_application_auth_methods(ArkPCloudListApplicationAuthMethods(app_id=a.app_id))\n        apps_auth_types[a.app_id] = [am.auth_type for am in auth_methods]\n    applications_stats.applications_auth_method_types = apps_auth_types\n    applications_stats.auth_types_count = {}\n    for auth_method_types in apps_auth_types.values():\n        for auth_method in auth_method_types:\n            if auth_method not in applications_stats.auth_types_count:\n                applications_stats.auth_types_count[auth_method] = 0\n            applications_stats.auth_types_count[auth_method] += 1\n    return applications_stats\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.delete_application","title":"<code>delete_application(delete_application)</code>","text":"<p>Delete application by its id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_application</code> <code>ArkPCloudDeleteApplication</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def delete_application(self, delete_application: ArkPCloudDeleteApplication) -&gt; None:\n    \"\"\"\n    Delete application by its id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Application.htm\n\n    Args:\n        delete_application (ArkPCloudDeleteApplication): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting application with id [{delete_application.app_id}]')\n    resp: Response = self._client.delete(BASE_APPLICATION_URL.format(app_id=delete_application.app_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to delete application [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.delete_application_auth_method","title":"<code>delete_application_auth_method(delete_application_auth_method)</code>","text":"<p>Deletes an auth method from an application https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Authentication.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_application_auth_method</code> <code>ArkPCloudDeleteApplicationAuthMethod</code> <p>description</p> required Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def delete_application_auth_method(self, delete_application_auth_method: ArkPCloudDeleteApplicationAuthMethod) -&gt; None:\n    \"\"\"\n    Deletes an auth method from an application\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/Delete%20a%20Specific%20Authentication.htm\n\n    Args:\n        delete_application_auth_method (ArkPCloudDeleteApplicationAuthMethod): _description_\n    \"\"\"\n    self._logger.info(\n        f'Deleting auth method from app [{delete_application_auth_method.app_id}] with id [{delete_application_auth_method.auth_id}]'\n    )\n    resp: Response = self._client.delete(\n        BASE_AUTH_METHOD_URL.format(app_id=delete_application_auth_method.app_id, auth_id=delete_application_auth_method.auth_id)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to delete auth method [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.list_application_auth_methods","title":"<code>list_application_auth_methods(list_application_auth_methods)</code>","text":"<p>Lists all application auth methods https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>list_application_auth_methods</code> <code>ArkPCloudListApplicationAuthMethods</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudApplicationAuthMethod]</code> <p>List[ArkPCloudApplicationAuthMethod]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_application_auth_methods(\n    self, list_application_auth_methods: ArkPCloudListApplicationAuthMethods\n) -&gt; List[ArkPCloudApplicationAuthMethod]:\n    \"\"\"\n    Lists all application auth methods\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n    Args:\n        list_application_auth_methods (ArkPCloudListApplicationAuthMethods): _description_\n\n    Returns:\n        List[ArkPCloudApplicationAuthMethod]: _description_\n    \"\"\"\n    self._logger.info(f'Listing all application [{list_application_auth_methods.app_id}]] auth methods')\n    resp: Response = self._client.get(BASE_AUTH_METHODS_URL.format(app_id=list_application_auth_methods.app_id))\n    if resp.status_code == HTTPStatus.OK:\n        return TypeAdapter(List[ArkPCloudApplicationAuthMethod]).validate_python(resp.json()['authentication'])\n    raise ArkServiceException(f'Failed to list application auth methods [{resp.text}] - [{resp.status_code}]]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.list_application_auth_methods_by","title":"<code>list_application_auth_methods_by(application_auth_methods_filter)</code>","text":"<p>Lists application auth methods by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm</p> <p>Parameters:</p> Name Type Description Default <code>application_auth_methods_filter</code> <code>ArkPCloudApplicationAuthMethodsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudApplicationAuthMethod]</code> <p>List[ArkPCloudApplicationAuthMethod]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_application_auth_methods_by(\n    self, application_auth_methods_filter: ArkPCloudApplicationAuthMethodsFilter\n) -&gt; List[ArkPCloudApplicationAuthMethod]:\n    \"\"\"\n    Lists application auth methods by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20all%20Authentication%20Methods%20of%20a%20Specific%20Application.htm\n\n    Args:\n        application_auth_methods_filter (ArkPCloudApplicationAuthMethodsFilter): _description_\n\n    Returns:\n        List[ArkPCloudApplicationAuthMethod]: _description_\n    \"\"\"\n    self._logger.info(f'Listing auth methods of app filtered [{application_auth_methods_filter}]')\n    auth_methods = self.list_application_auth_methods(\n        ArkPCloudListApplicationAuthMethods(app_id=application_auth_methods_filter.app_id)\n    )\n    if application_auth_methods_filter.auth_types:\n        auth_methods = [a for a in auth_methods if a.auth_type in application_auth_methods_filter.auth_types]\n    return auth_methods\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.list_applications","title":"<code>list_applications()</code>","text":"<p>Lists all applications https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm</p> <p>Returns:</p> Type Description <code>List[ArkPCloudApplication]</code> <p>List[ArkPCloudApplication]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_applications(self) -&gt; List[ArkPCloudApplication]:\n    \"\"\"\n    Lists all applications\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n    Returns:\n        List[ArkPCloudApplication]: _description_\n    \"\"\"\n    self._logger.info('Listing all applications')\n    resp: Response = self._client.get(BASE_APPLICATIONS_URL)\n    if resp.status_code == HTTPStatus.OK:\n        return TypeAdapter(List[ArkPCloudApplication]).validate_python(resp.json()['application'])\n    raise ArkServiceException(f'Failed to list applications [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/applications/ark_pcloud_applications_service/#ark_sdk_python.services.pcloud.applications.ark_pcloud_applications_service.ArkPCloudApplicationsService.list_applications_by","title":"<code>list_applications_by(applications_filter)</code>","text":"<p>Lists applications by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm</p> <p>Parameters:</p> Name Type Description Default <code>applications_filter</code> <code>ArkPCloudApplicationsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudApplication]</code> <p>List[ArkPCloudApplication]: description</p> Source code in <code>ark_sdk_python/services/pcloud/applications/ark_pcloud_applications_service.py</code> <pre><code>def list_applications_by(self, applications_filter: ArkPCloudApplicationsFilter) -&gt; List[ArkPCloudApplication]:\n    \"\"\"\n    Lists applications by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud/Latest/en/Content/WebServices/List%20Applications.htm\n\n    Args:\n        applications_filter (ArkPCloudApplicationsFilter): _description_\n\n    Returns:\n        List[ArkPCloudApplication]: _description_\n    \"\"\"\n    self._logger.info(f'Listing applications by filters [{applications_filter}]')\n    applications = self.list_applications()\n    if applications_filter.location:\n        applications = [a for a in applications if fnmatch(a.location, applications_filter.location)]\n    if applications_filter.only_enabled:\n        applications = [a for a in applications if not a.disabled]\n    if applications_filter.business_owner_name:\n        applications = [\n            a\n            for a in applications\n            if fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n            or fnmatch(a.business_owner_first_name, applications_filter.business_owner_name)\n        ]\n    if applications_filter.business_owner_email:\n        applications = [a for a in applications if a.business_owner_email == applications_filter.business_owner_email]\n    return applications\n</code></pre>"},{"location":"reference/services/pcloud/common/","title":"common","text":""},{"location":"reference/services/pcloud/common/ark_pcloud_base_service/","title":"ark_pcloud_base_service","text":""},{"location":"reference/services/pcloud/platforms/","title":"platforms","text":""},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService","title":"<code>ArkPCloudPlatformsService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>class ArkPCloudPlatformsService(ArkPCloudBaseService):\n    def __list_platforms_by_filters(\n        self, active: Optional[bool] = None, platform_type: Optional[ArkPCloudPlatformType] = None, platform_name: Optional[str] = None\n    ) -&gt; List[ArkPCloudPlatform]:\n        args = {}\n        if active is not None:\n            args['Active'] = active\n        if platform_type:\n            args['PlatformType'] = platform_type.value\n        if platform_name:\n            args['Search'] = platform_name\n        resp: Response = self._client.get(PLATFORMS_URL, params=args)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                data = resp.json()\n                # Platform type may come in uppercase, lowercase it just in case\n                for p in data['Platforms']:\n                    p['general']['platformType'] = p['general']['platformType'].lower()\n                return TypeAdapter(List[ArkPCloudPlatform]).validate_python(data['Platforms'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list platforms response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list platforms response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list platforms [{resp.text}] - [{resp.status_code}]')\n\n    def list_platforms(self) -&gt; List[ArkPCloudPlatform]:\n        \"\"\"\n        Lists all the platforms visible to the user\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n        Returns:\n            List[ArkPCloudPlatform]: _description_\n        \"\"\"\n        self._logger.info('Listing all platforms')\n        return self.__list_platforms_by_filters()\n\n    def list_platforms_by(self, platforms_filter: ArkPCloudPlatformsFilter) -&gt; List[ArkPCloudPlatform]:\n        \"\"\"\n        Lists platforms by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n        Args:\n            platforms_filter (ArkPCloudPlatformsFilter): _description_\n\n        Returns:\n            List[ArkPCloudPlatform]: _description_\n        \"\"\"\n        self._logger.info(f'Listing platforms by filter [{platforms_filter}]')\n        return self.__list_platforms_by_filters(\n            active=platforms_filter.active, platform_type=platforms_filter.platform_type, platform_name=platforms_filter.platform_name\n        )\n\n    def platform(self, get_platform: ArkPCloudGetPlatform) -&gt; ArkPCloudPlatform:\n        \"\"\"\n        Retrieves a platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPlatformDetails.htm\n\n        Args:\n            get_platform (ArkPCloudGetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudPlatform: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving platform [{get_platform.platform_id}]')\n        resp: Response = self._client.get(PLATFORM_URL.format(platform_id=get_platform.platform_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudPlatform.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve platform [{resp.text}] - [{resp.status_code}]')\n\n    def import_platform(self, import_platform: ArkPCloudImportPlatform) -&gt; ArkPCloudPlatform:\n        \"\"\"\n        Tries to import a platform zip data\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n        Args:\n            import_platform (ArkPCloudImportPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudPlatform: _description_\n        \"\"\"\n        self._logger.info('Importing platform')\n        platform_path = Path(import_platform.platform_zip_path)\n        if not platform_path.exists():\n            raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n        zip_data = b64encode(platform_path.read_bytes()).decode()\n        resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                platform_id = resp.json()['PlatformID']\n                return self.platform(ArkPCloudGetPlatform(platform_id=platform_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n\n    def import_target_platform(self, import_platform: ArkPCloudImportTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n        \"\"\"\n        Tries to import a platform zip data\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n        Args:\n            import_platform (ArkPCloudImportTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudTargetPlatform: _description_\n        \"\"\"\n        self._logger.info('Importing target platform')\n        platform_path = Path(import_platform.platform_zip_path)\n        if not platform_path.exists():\n            raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n        zip_data = b64encode(platform_path.read_bytes()).decode()\n        resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                platform_id = resp.json()['PlatformID']\n                platforms = self.list_target_platforms_by(ArkPCloudTargetPlatformsFilter(platform_id=platform_id))\n                if platforms:\n                    return platforms[0]\n                raise ArkServiceException('Failed to find target platform after importing it')\n\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n\n    def export_platform(self, export_platform: ArkPCloudExportPlatform) -&gt; None:\n        \"\"\"\n        Exports a platform zip data to a given folder by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n        Args:\n            export_platform (ArkPCloudExportPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Exporting platform [{export_platform.platform_id}] to folder [{export_platform.output_folder}]')\n        output_folder = Path(export_platform.output_folder)\n        output_folder.mkdir(exist_ok=True, parents=True)\n        resp: Response = self._client.post(EXPORT_PLATFORM_URL.format(platform_id=export_platform.platform_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n        (output_folder / export_platform.platform_id).write_bytes(resp.text.encode())\n\n    def export_target_platform(self, export_platform: ArkPCloudExportTargetPlatform) -&gt; None:\n        \"\"\"\n        Exports a platform zip data to a given folder by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n        Args:\n            export_platform (ArkPCloudExportTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Exporting platform [{export_platform.target_platform_id}] to folder [{export_platform.output_folder}]')\n        output_folder = Path(export_platform.output_folder)\n        output_folder.mkdir(exist_ok=True, parents=True)\n        target_platform: ArkPCloudTargetPlatform = self.target_platform(\n            ArkPCloudGetTargetPlatform(target_platform_id=export_platform.target_platform_id)\n        )\n        resp: Response = self._client.post(EXPORT_TARGET_PLATFORM_URL.format(target_platform_id=export_platform.target_platform_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n        (output_folder / target_platform.platform_id).write_bytes(resp.text.encode())\n\n    def platforms_stats(self) -&gt; ArkPCloudPlatformsStats:\n        \"\"\"\n        Calculates platforms stats\n\n        Returns:\n            ArkPCloudPlatformsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating platform statistics')\n        platforms = self.list_platforms()\n        platforms_stats = ArkPCloudPlatformsStats.model_construct()\n        platforms_stats.platforms_count = len(platforms)\n\n        # Get platforms per platform type\n        platform_types: Set[ArkPCloudPlatformType] = {p.general.platform_type for p in platforms}\n        platforms_stats.platforms_count_by_type = {\n            pt: len([p for p in platforms if p.general.platform_type == pt]) for pt in platform_types\n        }\n\n        return platforms_stats\n\n    def __list_target_platforms_by_filters(\n        self,\n        active: Optional[bool] = None,\n        system_type: Optional[str] = None,\n        periodic_verify: Optional[bool] = None,\n        manual_verify: Optional[bool] = None,\n        periodic_change: Optional[bool] = None,\n        manual_change: Optional[bool] = None,\n        automatic_reconcile: Optional[bool] = None,\n        manual_reconcile: Optional[bool] = None,\n    ) -&gt; List[ArkPCloudTargetPlatform]:\n        args = {}\n        if active is not None:\n            args['active'] = active\n        if system_type is not None:\n            args['systemType'] = system_type\n        if periodic_verify is not None:\n            args['periodicVerify'] = str(periodic_verify)\n        if manual_verify is not None:\n            args['manualVerify'] = str(manual_verify)\n        if periodic_change is not None:\n            args['periodicChange'] = str(periodic_change)\n        if manual_change is not None:\n            args['manualChange'] = str(manual_change)\n        if automatic_reconcile is not None:\n            args['automaticReconcile'] = str(automatic_reconcile)\n        if manual_reconcile is not None:\n            args['manualReconcile'] = str(manual_reconcile)\n        params = \" AND \".join([f\"{k} eq {v}\" for k, v in args.items()])\n        resp: Response = self._client.get(TARGET_PLATFORMS_URL, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkPCloudTargetPlatform]).validate_python(resp.json()['Platforms'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list target platforms response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list target platforms response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list target platforms [{resp.text}] - [{resp.status_code}]')\n\n    def list_target_platforms(self) -&gt; List[ArkPCloudTargetPlatform]:\n        \"\"\"\n        Lists all the target platforms visible to the user\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n        Returns:\n            List[ArkPCloudTargetPlatform]: _description_\n        \"\"\"\n        self._logger.info('Listing all target platforms')\n        return self.__list_target_platforms_by_filters()\n\n    def list_target_platforms_by(self, target_platforms_filter: ArkPCloudTargetPlatformsFilter) -&gt; List[ArkPCloudTargetPlatform]:\n        \"\"\"\n        Lists target platforms by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n        Args:\n            target_platforms_filter (ArkPCloudTargetPlatformsFilter): _description_\n\n        Returns:\n            List[ArkPCloudTargetPlatform]: _description_\n        \"\"\"\n        self._logger.info(f'Listing target platforms by filter [{target_platforms_filter}]')\n        target_platforms = self.__list_target_platforms_by_filters(\n            active=target_platforms_filter.active,\n            system_type=target_platforms_filter.system_type,\n            periodic_verify=target_platforms_filter.periodic_verify,\n            manual_verify=target_platforms_filter.manual_verify,\n            periodic_change=target_platforms_filter.periodic_change,\n            manual_change=target_platforms_filter.manual_change,\n            automatic_reconcile=target_platforms_filter.automatic_reconcile,\n            manual_reconcile=target_platforms_filter.manual_reconcile,\n        )\n\n        # Filter by platform id\n        if target_platforms_filter.platform_id:\n            target_platforms = [p for p in target_platforms if fnmatch(p.platform_id.lower(), target_platforms_filter.platform_id.lower())]\n\n        # Filter by name\n        if target_platforms_filter.name:\n            target_platforms = [p for p in target_platforms if fnmatch(p.name.lower(), target_platforms_filter.name.lower())]\n\n        # Filter by active\n        if target_platforms_filter.active is not None:\n            target_platforms = [p for p in target_platforms if p.active is target_platforms_filter.active]\n\n        return target_platforms\n\n    def target_platform(self, get_target_platform: ArkPCloudGetTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n        \"\"\"\n        Gets a target platform by id\n        https://docs.cyberark.com/privilege-cloud-shared-services/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n        Args:\n            get_target_platform (ArkPCloudGetTargetPlatform): _description_\n\n        Returns:\n            ArkPCloudTargetPlatform: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving target platform [{get_target_platform.target_platform_id}]')\n        target_platform = [p for p in self.list_target_platforms() if p.id == get_target_platform.target_platform_id]\n        if len(target_platform) != 1:\n            raise ArkServiceException('Failed to get target platform')\n        return target_platform[0]\n\n    def activate_target_platform(self, activate_target_platform: ArkPCloudActivateTargetPlatform) -&gt; None:\n        \"\"\"\n        Activates a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-activate-target-platform.htm\n\n        Args:\n            activate_target_platform (ArkPCloudActivateTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Activating target platform [{activate_target_platform.target_platform_id}]')\n        resp: Response = self._client.post(\n            ACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=activate_target_platform.target_platform_id)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to activate target platform [{resp.text}] - [{resp.status_code}]')\n\n    def deactivate_target_platform(self, deactivate_target_platform: ArkPCloudDeactivateTargetPlatform) -&gt; None:\n        \"\"\"\n        Deactivates a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-deactivate-target-platform.htm\n\n        Args:\n            deactivate_target_platform (ArkPCloudDeactivateTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deactivating target platform [{deactivate_target_platform.target_platform_id}]')\n        resp: Response = self._client.post(\n            DEACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=deactivate_target_platform.target_platform_id)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to deactivate target platform [{resp.text}] - [{resp.status_code}]')\n\n    def duplicate_target_platform(\n        self, duplicate_target_platform: ArkPCloudDuplicateTargetPlatform\n    ) -&gt; ArkPCloudDuplicatedTargetPlatformInfo:\n        \"\"\"\n        Duplicates a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-duplicate-target-platforms.htm\n\n        Args:\n            duplicate_target_platform (ArkPCloudDuplicateTargetPlatform): _description_\n\n        Returns:\n            ArkPCloudDuplicatedTargetPlatformInfo: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(\n            f'Duplicates target platform [{duplicate_target_platform.target_platform_id}] to name [{duplicate_target_platform.name}]'\n        )\n        resp: Response = self._client.post(\n            DUPLICATE_TARGET_PLATFORM_URL.format(target_platform_id=duplicate_target_platform.target_platform_id),\n            json=duplicate_target_platform.model_dump(by_alias=True, exclude={'target_platform_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudDuplicatedTargetPlatformInfo.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse duplicate target platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse duplicate target platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to duplicate target platform [{resp.text}] - [{resp.status_code}]')\n\n    def delete_target_platform(self, delete_target_platform: ArkPCloudDeleteTargetPlatform) -&gt; None:\n        \"\"\"\n        Deletes a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-delete-target-platform.htm\n\n        Args:\n            delete_target_platform (ArkPCloudDeleteTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting target platform [{delete_target_platform.target_platform_id}]')\n        resp: Response = self._client.delete(TARGET_PLATFORM_URL.format(target_platform_id=delete_target_platform.target_platform_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete target platform [{resp.text}] - [{resp.status_code}]')\n\n    def target_platforms_stats(self) -&gt; ArkPCloudTargetPlatformsStats:\n        \"\"\"\n        Calculates target platforms stats\n\n        Returns:\n            ArkPCloudTargetPlatformsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating target platform statistics')\n        target_platforms = self.list_target_platforms()\n        target_platforms_stats = ArkPCloudTargetPlatformsStats.model_construct()\n        target_platforms_stats.target_platforms_count = len(target_platforms)\n\n        # Get target platforms per system type\n        target_platform_system_types: Set[str] = {p.system_type for p in target_platforms}\n        target_platforms_stats.target_platforms_count_by_system_type = {\n            pt: len([p for p in target_platforms if p.system_type == pt]) for pt in target_platform_system_types\n        }\n\n        return target_platforms_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.activate_target_platform","title":"<code>activate_target_platform(activate_target_platform)</code>","text":"<p>Activates a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-activate-target-platform.htm</p> <p>Parameters:</p> Name Type Description Default <code>activate_target_platform</code> <code>ArkPCloudActivateTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def activate_target_platform(self, activate_target_platform: ArkPCloudActivateTargetPlatform) -&gt; None:\n    \"\"\"\n    Activates a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-activate-target-platform.htm\n\n    Args:\n        activate_target_platform (ArkPCloudActivateTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Activating target platform [{activate_target_platform.target_platform_id}]')\n    resp: Response = self._client.post(\n        ACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=activate_target_platform.target_platform_id)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to activate target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.deactivate_target_platform","title":"<code>deactivate_target_platform(deactivate_target_platform)</code>","text":"<p>Deactivates a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-deactivate-target-platform.htm</p> <p>Parameters:</p> Name Type Description Default <code>deactivate_target_platform</code> <code>ArkPCloudDeactivateTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def deactivate_target_platform(self, deactivate_target_platform: ArkPCloudDeactivateTargetPlatform) -&gt; None:\n    \"\"\"\n    Deactivates a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-deactivate-target-platform.htm\n\n    Args:\n        deactivate_target_platform (ArkPCloudDeactivateTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deactivating target platform [{deactivate_target_platform.target_platform_id}]')\n    resp: Response = self._client.post(\n        DEACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=deactivate_target_platform.target_platform_id)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to deactivate target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.delete_target_platform","title":"<code>delete_target_platform(delete_target_platform)</code>","text":"<p>Deletes a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-delete-target-platform.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_target_platform</code> <code>ArkPCloudDeleteTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def delete_target_platform(self, delete_target_platform: ArkPCloudDeleteTargetPlatform) -&gt; None:\n    \"\"\"\n    Deletes a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-delete-target-platform.htm\n\n    Args:\n        delete_target_platform (ArkPCloudDeleteTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting target platform [{delete_target_platform.target_platform_id}]')\n    resp: Response = self._client.delete(TARGET_PLATFORM_URL.format(target_platform_id=delete_target_platform.target_platform_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.duplicate_target_platform","title":"<code>duplicate_target_platform(duplicate_target_platform)</code>","text":"<p>Duplicates a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-duplicate-target-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>duplicate_target_platform</code> <code>ArkPCloudDuplicateTargetPlatform</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudDuplicatedTargetPlatformInfo</code> <code>ArkPCloudDuplicatedTargetPlatformInfo</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def duplicate_target_platform(\n    self, duplicate_target_platform: ArkPCloudDuplicateTargetPlatform\n) -&gt; ArkPCloudDuplicatedTargetPlatformInfo:\n    \"\"\"\n    Duplicates a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-duplicate-target-platforms.htm\n\n    Args:\n        duplicate_target_platform (ArkPCloudDuplicateTargetPlatform): _description_\n\n    Returns:\n        ArkPCloudDuplicatedTargetPlatformInfo: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(\n        f'Duplicates target platform [{duplicate_target_platform.target_platform_id}] to name [{duplicate_target_platform.name}]'\n    )\n    resp: Response = self._client.post(\n        DUPLICATE_TARGET_PLATFORM_URL.format(target_platform_id=duplicate_target_platform.target_platform_id),\n        json=duplicate_target_platform.model_dump(by_alias=True, exclude={'target_platform_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudDuplicatedTargetPlatformInfo.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse duplicate target platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse duplicate target platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to duplicate target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.export_platform","title":"<code>export_platform(export_platform)</code>","text":"<p>Exports a platform zip data to a given folder by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>export_platform</code> <code>ArkPCloudExportPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def export_platform(self, export_platform: ArkPCloudExportPlatform) -&gt; None:\n    \"\"\"\n    Exports a platform zip data to a given folder by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n    Args:\n        export_platform (ArkPCloudExportPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Exporting platform [{export_platform.platform_id}] to folder [{export_platform.output_folder}]')\n    output_folder = Path(export_platform.output_folder)\n    output_folder.mkdir(exist_ok=True, parents=True)\n    resp: Response = self._client.post(EXPORT_PLATFORM_URL.format(platform_id=export_platform.platform_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n    (output_folder / export_platform.platform_id).write_bytes(resp.text.encode())\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.export_target_platform","title":"<code>export_target_platform(export_platform)</code>","text":"<p>Exports a platform zip data to a given folder by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>export_platform</code> <code>ArkPCloudExportTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def export_target_platform(self, export_platform: ArkPCloudExportTargetPlatform) -&gt; None:\n    \"\"\"\n    Exports a platform zip data to a given folder by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n    Args:\n        export_platform (ArkPCloudExportTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Exporting platform [{export_platform.target_platform_id}] to folder [{export_platform.output_folder}]')\n    output_folder = Path(export_platform.output_folder)\n    output_folder.mkdir(exist_ok=True, parents=True)\n    target_platform: ArkPCloudTargetPlatform = self.target_platform(\n        ArkPCloudGetTargetPlatform(target_platform_id=export_platform.target_platform_id)\n    )\n    resp: Response = self._client.post(EXPORT_TARGET_PLATFORM_URL.format(target_platform_id=export_platform.target_platform_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n    (output_folder / target_platform.platform_id).write_bytes(resp.text.encode())\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.import_platform","title":"<code>import_platform(import_platform)</code>","text":"<p>Tries to import a platform zip data https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>import_platform</code> <code>ArkPCloudImportPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatform</code> <code>ArkPCloudPlatform</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def import_platform(self, import_platform: ArkPCloudImportPlatform) -&gt; ArkPCloudPlatform:\n    \"\"\"\n    Tries to import a platform zip data\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n    Args:\n        import_platform (ArkPCloudImportPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudPlatform: _description_\n    \"\"\"\n    self._logger.info('Importing platform')\n    platform_path = Path(import_platform.platform_zip_path)\n    if not platform_path.exists():\n        raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n    zip_data = b64encode(platform_path.read_bytes()).decode()\n    resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            platform_id = resp.json()['PlatformID']\n            return self.platform(ArkPCloudGetPlatform(platform_id=platform_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.import_target_platform","title":"<code>import_target_platform(import_platform)</code>","text":"<p>Tries to import a platform zip data https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>import_platform</code> <code>ArkPCloudImportTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudTargetPlatform</code> <code>ArkPCloudTargetPlatform</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def import_target_platform(self, import_platform: ArkPCloudImportTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n    \"\"\"\n    Tries to import a platform zip data\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n    Args:\n        import_platform (ArkPCloudImportTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudTargetPlatform: _description_\n    \"\"\"\n    self._logger.info('Importing target platform')\n    platform_path = Path(import_platform.platform_zip_path)\n    if not platform_path.exists():\n        raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n    zip_data = b64encode(platform_path.read_bytes()).decode()\n    resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            platform_id = resp.json()['PlatformID']\n            platforms = self.list_target_platforms_by(ArkPCloudTargetPlatformsFilter(platform_id=platform_id))\n            if platforms:\n                return platforms[0]\n            raise ArkServiceException('Failed to find target platform after importing it')\n\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.list_platforms","title":"<code>list_platforms()</code>","text":"<p>Lists all the platforms visible to the user https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm</p> <p>Returns:</p> Type Description <code>List[ArkPCloudPlatform]</code> <p>List[ArkPCloudPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_platforms(self) -&gt; List[ArkPCloudPlatform]:\n    \"\"\"\n    Lists all the platforms visible to the user\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n    Returns:\n        List[ArkPCloudPlatform]: _description_\n    \"\"\"\n    self._logger.info('Listing all platforms')\n    return self.__list_platforms_by_filters()\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.list_platforms_by","title":"<code>list_platforms_by(platforms_filter)</code>","text":"<p>Lists platforms by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>platforms_filter</code> <code>ArkPCloudPlatformsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudPlatform]</code> <p>List[ArkPCloudPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_platforms_by(self, platforms_filter: ArkPCloudPlatformsFilter) -&gt; List[ArkPCloudPlatform]:\n    \"\"\"\n    Lists platforms by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n    Args:\n        platforms_filter (ArkPCloudPlatformsFilter): _description_\n\n    Returns:\n        List[ArkPCloudPlatform]: _description_\n    \"\"\"\n    self._logger.info(f'Listing platforms by filter [{platforms_filter}]')\n    return self.__list_platforms_by_filters(\n        active=platforms_filter.active, platform_type=platforms_filter.platform_type, platform_name=platforms_filter.platform_name\n    )\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.list_target_platforms","title":"<code>list_target_platforms()</code>","text":"<p>Lists all the target platforms visible to the user https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm</p> <p>Returns:</p> Type Description <code>List[ArkPCloudTargetPlatform]</code> <p>List[ArkPCloudTargetPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_target_platforms(self) -&gt; List[ArkPCloudTargetPlatform]:\n    \"\"\"\n    Lists all the target platforms visible to the user\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n    Returns:\n        List[ArkPCloudTargetPlatform]: _description_\n    \"\"\"\n    self._logger.info('Listing all target platforms')\n    return self.__list_target_platforms_by_filters()\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.list_target_platforms_by","title":"<code>list_target_platforms_by(target_platforms_filter)</code>","text":"<p>Lists target platforms by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>target_platforms_filter</code> <code>ArkPCloudTargetPlatformsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudTargetPlatform]</code> <p>List[ArkPCloudTargetPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_target_platforms_by(self, target_platforms_filter: ArkPCloudTargetPlatformsFilter) -&gt; List[ArkPCloudTargetPlatform]:\n    \"\"\"\n    Lists target platforms by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n    Args:\n        target_platforms_filter (ArkPCloudTargetPlatformsFilter): _description_\n\n    Returns:\n        List[ArkPCloudTargetPlatform]: _description_\n    \"\"\"\n    self._logger.info(f'Listing target platforms by filter [{target_platforms_filter}]')\n    target_platforms = self.__list_target_platforms_by_filters(\n        active=target_platforms_filter.active,\n        system_type=target_platforms_filter.system_type,\n        periodic_verify=target_platforms_filter.periodic_verify,\n        manual_verify=target_platforms_filter.manual_verify,\n        periodic_change=target_platforms_filter.periodic_change,\n        manual_change=target_platforms_filter.manual_change,\n        automatic_reconcile=target_platforms_filter.automatic_reconcile,\n        manual_reconcile=target_platforms_filter.manual_reconcile,\n    )\n\n    # Filter by platform id\n    if target_platforms_filter.platform_id:\n        target_platforms = [p for p in target_platforms if fnmatch(p.platform_id.lower(), target_platforms_filter.platform_id.lower())]\n\n    # Filter by name\n    if target_platforms_filter.name:\n        target_platforms = [p for p in target_platforms if fnmatch(p.name.lower(), target_platforms_filter.name.lower())]\n\n    # Filter by active\n    if target_platforms_filter.active is not None:\n        target_platforms = [p for p in target_platforms if p.active is target_platforms_filter.active]\n\n    return target_platforms\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.platform","title":"<code>platform(get_platform)</code>","text":"<p>Retrieves a platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPlatformDetails.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_platform</code> <code>ArkPCloudGetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatform</code> <code>ArkPCloudPlatform</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def platform(self, get_platform: ArkPCloudGetPlatform) -&gt; ArkPCloudPlatform:\n    \"\"\"\n    Retrieves a platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPlatformDetails.htm\n\n    Args:\n        get_platform (ArkPCloudGetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudPlatform: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving platform [{get_platform.platform_id}]')\n    resp: Response = self._client.get(PLATFORM_URL.format(platform_id=get_platform.platform_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudPlatform.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.platforms_stats","title":"<code>platforms_stats()</code>","text":"<p>Calculates platforms stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatformsStats</code> <code>ArkPCloudPlatformsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def platforms_stats(self) -&gt; ArkPCloudPlatformsStats:\n    \"\"\"\n    Calculates platforms stats\n\n    Returns:\n        ArkPCloudPlatformsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating platform statistics')\n    platforms = self.list_platforms()\n    platforms_stats = ArkPCloudPlatformsStats.model_construct()\n    platforms_stats.platforms_count = len(platforms)\n\n    # Get platforms per platform type\n    platform_types: Set[ArkPCloudPlatformType] = {p.general.platform_type for p in platforms}\n    platforms_stats.platforms_count_by_type = {\n        pt: len([p for p in platforms if p.general.platform_type == pt]) for pt in platform_types\n    }\n\n    return platforms_stats\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.target_platform","title":"<code>target_platform(get_target_platform)</code>","text":"<p>Gets a target platform by id https://docs.cyberark.com/privilege-cloud-shared-services/Latest/en/Content/SDK/rest-api-get-target-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_target_platform</code> <code>ArkPCloudGetTargetPlatform</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudTargetPlatform</code> <code>ArkPCloudTargetPlatform</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def target_platform(self, get_target_platform: ArkPCloudGetTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n    \"\"\"\n    Gets a target platform by id\n    https://docs.cyberark.com/privilege-cloud-shared-services/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n    Args:\n        get_target_platform (ArkPCloudGetTargetPlatform): _description_\n\n    Returns:\n        ArkPCloudTargetPlatform: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving target platform [{get_target_platform.target_platform_id}]')\n    target_platform = [p for p in self.list_target_platforms() if p.id == get_target_platform.target_platform_id]\n    if len(target_platform) != 1:\n        raise ArkServiceException('Failed to get target platform')\n    return target_platform[0]\n</code></pre>"},{"location":"reference/services/pcloud/platforms/#ark_sdk_python.services.pcloud.platforms.ArkPCloudPlatformsService.target_platforms_stats","title":"<code>target_platforms_stats()</code>","text":"<p>Calculates target platforms stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudTargetPlatformsStats</code> <code>ArkPCloudTargetPlatformsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def target_platforms_stats(self) -&gt; ArkPCloudTargetPlatformsStats:\n    \"\"\"\n    Calculates target platforms stats\n\n    Returns:\n        ArkPCloudTargetPlatformsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating target platform statistics')\n    target_platforms = self.list_target_platforms()\n    target_platforms_stats = ArkPCloudTargetPlatformsStats.model_construct()\n    target_platforms_stats.target_platforms_count = len(target_platforms)\n\n    # Get target platforms per system type\n    target_platform_system_types: Set[str] = {p.system_type for p in target_platforms}\n    target_platforms_stats.target_platforms_count_by_system_type = {\n        pt: len([p for p in target_platforms if p.system_type == pt]) for pt in target_platform_system_types\n    }\n\n    return target_platforms_stats\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/","title":"ark_pcloud_platforms_service","text":""},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService","title":"<code>ArkPCloudPlatformsService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>class ArkPCloudPlatformsService(ArkPCloudBaseService):\n    def __list_platforms_by_filters(\n        self, active: Optional[bool] = None, platform_type: Optional[ArkPCloudPlatformType] = None, platform_name: Optional[str] = None\n    ) -&gt; List[ArkPCloudPlatform]:\n        args = {}\n        if active is not None:\n            args['Active'] = active\n        if platform_type:\n            args['PlatformType'] = platform_type.value\n        if platform_name:\n            args['Search'] = platform_name\n        resp: Response = self._client.get(PLATFORMS_URL, params=args)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                data = resp.json()\n                # Platform type may come in uppercase, lowercase it just in case\n                for p in data['Platforms']:\n                    p['general']['platformType'] = p['general']['platformType'].lower()\n                return TypeAdapter(List[ArkPCloudPlatform]).validate_python(data['Platforms'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list platforms response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list platforms response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list platforms [{resp.text}] - [{resp.status_code}]')\n\n    def list_platforms(self) -&gt; List[ArkPCloudPlatform]:\n        \"\"\"\n        Lists all the platforms visible to the user\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n        Returns:\n            List[ArkPCloudPlatform]: _description_\n        \"\"\"\n        self._logger.info('Listing all platforms')\n        return self.__list_platforms_by_filters()\n\n    def list_platforms_by(self, platforms_filter: ArkPCloudPlatformsFilter) -&gt; List[ArkPCloudPlatform]:\n        \"\"\"\n        Lists platforms by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n        Args:\n            platforms_filter (ArkPCloudPlatformsFilter): _description_\n\n        Returns:\n            List[ArkPCloudPlatform]: _description_\n        \"\"\"\n        self._logger.info(f'Listing platforms by filter [{platforms_filter}]')\n        return self.__list_platforms_by_filters(\n            active=platforms_filter.active, platform_type=platforms_filter.platform_type, platform_name=platforms_filter.platform_name\n        )\n\n    def platform(self, get_platform: ArkPCloudGetPlatform) -&gt; ArkPCloudPlatform:\n        \"\"\"\n        Retrieves a platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPlatformDetails.htm\n\n        Args:\n            get_platform (ArkPCloudGetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudPlatform: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving platform [{get_platform.platform_id}]')\n        resp: Response = self._client.get(PLATFORM_URL.format(platform_id=get_platform.platform_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudPlatform.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve platform [{resp.text}] - [{resp.status_code}]')\n\n    def import_platform(self, import_platform: ArkPCloudImportPlatform) -&gt; ArkPCloudPlatform:\n        \"\"\"\n        Tries to import a platform zip data\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n        Args:\n            import_platform (ArkPCloudImportPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudPlatform: _description_\n        \"\"\"\n        self._logger.info('Importing platform')\n        platform_path = Path(import_platform.platform_zip_path)\n        if not platform_path.exists():\n            raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n        zip_data = b64encode(platform_path.read_bytes()).decode()\n        resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                platform_id = resp.json()['PlatformID']\n                return self.platform(ArkPCloudGetPlatform(platform_id=platform_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n\n    def import_target_platform(self, import_platform: ArkPCloudImportTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n        \"\"\"\n        Tries to import a platform zip data\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n        Args:\n            import_platform (ArkPCloudImportTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudTargetPlatform: _description_\n        \"\"\"\n        self._logger.info('Importing target platform')\n        platform_path = Path(import_platform.platform_zip_path)\n        if not platform_path.exists():\n            raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n        zip_data = b64encode(platform_path.read_bytes()).decode()\n        resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                platform_id = resp.json()['PlatformID']\n                platforms = self.list_target_platforms_by(ArkPCloudTargetPlatformsFilter(platform_id=platform_id))\n                if platforms:\n                    return platforms[0]\n                raise ArkServiceException('Failed to find target platform after importing it')\n\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n\n    def export_platform(self, export_platform: ArkPCloudExportPlatform) -&gt; None:\n        \"\"\"\n        Exports a platform zip data to a given folder by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n        Args:\n            export_platform (ArkPCloudExportPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Exporting platform [{export_platform.platform_id}] to folder [{export_platform.output_folder}]')\n        output_folder = Path(export_platform.output_folder)\n        output_folder.mkdir(exist_ok=True, parents=True)\n        resp: Response = self._client.post(EXPORT_PLATFORM_URL.format(platform_id=export_platform.platform_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n        (output_folder / export_platform.platform_id).write_bytes(resp.text.encode())\n\n    def export_target_platform(self, export_platform: ArkPCloudExportTargetPlatform) -&gt; None:\n        \"\"\"\n        Exports a platform zip data to a given folder by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n        Args:\n            export_platform (ArkPCloudExportTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Exporting platform [{export_platform.target_platform_id}] to folder [{export_platform.output_folder}]')\n        output_folder = Path(export_platform.output_folder)\n        output_folder.mkdir(exist_ok=True, parents=True)\n        target_platform: ArkPCloudTargetPlatform = self.target_platform(\n            ArkPCloudGetTargetPlatform(target_platform_id=export_platform.target_platform_id)\n        )\n        resp: Response = self._client.post(EXPORT_TARGET_PLATFORM_URL.format(target_platform_id=export_platform.target_platform_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n        (output_folder / target_platform.platform_id).write_bytes(resp.text.encode())\n\n    def platforms_stats(self) -&gt; ArkPCloudPlatformsStats:\n        \"\"\"\n        Calculates platforms stats\n\n        Returns:\n            ArkPCloudPlatformsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating platform statistics')\n        platforms = self.list_platforms()\n        platforms_stats = ArkPCloudPlatformsStats.model_construct()\n        platforms_stats.platforms_count = len(platforms)\n\n        # Get platforms per platform type\n        platform_types: Set[ArkPCloudPlatformType] = {p.general.platform_type for p in platforms}\n        platforms_stats.platforms_count_by_type = {\n            pt: len([p for p in platforms if p.general.platform_type == pt]) for pt in platform_types\n        }\n\n        return platforms_stats\n\n    def __list_target_platforms_by_filters(\n        self,\n        active: Optional[bool] = None,\n        system_type: Optional[str] = None,\n        periodic_verify: Optional[bool] = None,\n        manual_verify: Optional[bool] = None,\n        periodic_change: Optional[bool] = None,\n        manual_change: Optional[bool] = None,\n        automatic_reconcile: Optional[bool] = None,\n        manual_reconcile: Optional[bool] = None,\n    ) -&gt; List[ArkPCloudTargetPlatform]:\n        args = {}\n        if active is not None:\n            args['active'] = active\n        if system_type is not None:\n            args['systemType'] = system_type\n        if periodic_verify is not None:\n            args['periodicVerify'] = str(periodic_verify)\n        if manual_verify is not None:\n            args['manualVerify'] = str(manual_verify)\n        if periodic_change is not None:\n            args['periodicChange'] = str(periodic_change)\n        if manual_change is not None:\n            args['manualChange'] = str(manual_change)\n        if automatic_reconcile is not None:\n            args['automaticReconcile'] = str(automatic_reconcile)\n        if manual_reconcile is not None:\n            args['manualReconcile'] = str(manual_reconcile)\n        params = \" AND \".join([f\"{k} eq {v}\" for k, v in args.items()])\n        resp: Response = self._client.get(TARGET_PLATFORMS_URL, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkPCloudTargetPlatform]).validate_python(resp.json()['Platforms'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list target platforms response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list target platforms response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list target platforms [{resp.text}] - [{resp.status_code}]')\n\n    def list_target_platforms(self) -&gt; List[ArkPCloudTargetPlatform]:\n        \"\"\"\n        Lists all the target platforms visible to the user\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n        Returns:\n            List[ArkPCloudTargetPlatform]: _description_\n        \"\"\"\n        self._logger.info('Listing all target platforms')\n        return self.__list_target_platforms_by_filters()\n\n    def list_target_platforms_by(self, target_platforms_filter: ArkPCloudTargetPlatformsFilter) -&gt; List[ArkPCloudTargetPlatform]:\n        \"\"\"\n        Lists target platforms by given filters\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n        Args:\n            target_platforms_filter (ArkPCloudTargetPlatformsFilter): _description_\n\n        Returns:\n            List[ArkPCloudTargetPlatform]: _description_\n        \"\"\"\n        self._logger.info(f'Listing target platforms by filter [{target_platforms_filter}]')\n        target_platforms = self.__list_target_platforms_by_filters(\n            active=target_platforms_filter.active,\n            system_type=target_platforms_filter.system_type,\n            periodic_verify=target_platforms_filter.periodic_verify,\n            manual_verify=target_platforms_filter.manual_verify,\n            periodic_change=target_platforms_filter.periodic_change,\n            manual_change=target_platforms_filter.manual_change,\n            automatic_reconcile=target_platforms_filter.automatic_reconcile,\n            manual_reconcile=target_platforms_filter.manual_reconcile,\n        )\n\n        # Filter by platform id\n        if target_platforms_filter.platform_id:\n            target_platforms = [p for p in target_platforms if fnmatch(p.platform_id.lower(), target_platforms_filter.platform_id.lower())]\n\n        # Filter by name\n        if target_platforms_filter.name:\n            target_platforms = [p for p in target_platforms if fnmatch(p.name.lower(), target_platforms_filter.name.lower())]\n\n        # Filter by active\n        if target_platforms_filter.active is not None:\n            target_platforms = [p for p in target_platforms if p.active is target_platforms_filter.active]\n\n        return target_platforms\n\n    def target_platform(self, get_target_platform: ArkPCloudGetTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n        \"\"\"\n        Gets a target platform by id\n        https://docs.cyberark.com/privilege-cloud-shared-services/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n        Args:\n            get_target_platform (ArkPCloudGetTargetPlatform): _description_\n\n        Returns:\n            ArkPCloudTargetPlatform: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving target platform [{get_target_platform.target_platform_id}]')\n        target_platform = [p for p in self.list_target_platforms() if p.id == get_target_platform.target_platform_id]\n        if len(target_platform) != 1:\n            raise ArkServiceException('Failed to get target platform')\n        return target_platform[0]\n\n    def activate_target_platform(self, activate_target_platform: ArkPCloudActivateTargetPlatform) -&gt; None:\n        \"\"\"\n        Activates a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-activate-target-platform.htm\n\n        Args:\n            activate_target_platform (ArkPCloudActivateTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Activating target platform [{activate_target_platform.target_platform_id}]')\n        resp: Response = self._client.post(\n            ACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=activate_target_platform.target_platform_id)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to activate target platform [{resp.text}] - [{resp.status_code}]')\n\n    def deactivate_target_platform(self, deactivate_target_platform: ArkPCloudDeactivateTargetPlatform) -&gt; None:\n        \"\"\"\n        Deactivates a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-deactivate-target-platform.htm\n\n        Args:\n            deactivate_target_platform (ArkPCloudDeactivateTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deactivating target platform [{deactivate_target_platform.target_platform_id}]')\n        resp: Response = self._client.post(\n            DEACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=deactivate_target_platform.target_platform_id)\n        )\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to deactivate target platform [{resp.text}] - [{resp.status_code}]')\n\n    def duplicate_target_platform(\n        self, duplicate_target_platform: ArkPCloudDuplicateTargetPlatform\n    ) -&gt; ArkPCloudDuplicatedTargetPlatformInfo:\n        \"\"\"\n        Duplicates a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-duplicate-target-platforms.htm\n\n        Args:\n            duplicate_target_platform (ArkPCloudDuplicateTargetPlatform): _description_\n\n        Returns:\n            ArkPCloudDuplicatedTargetPlatformInfo: _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(\n            f'Duplicates target platform [{duplicate_target_platform.target_platform_id}] to name [{duplicate_target_platform.name}]'\n        )\n        resp: Response = self._client.post(\n            DUPLICATE_TARGET_PLATFORM_URL.format(target_platform_id=duplicate_target_platform.target_platform_id),\n            json=duplicate_target_platform.model_dump(by_alias=True, exclude={'target_platform_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudDuplicatedTargetPlatformInfo.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse duplicate target platform response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse duplicate target platform response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to duplicate target platform [{resp.text}] - [{resp.status_code}]')\n\n    def delete_target_platform(self, delete_target_platform: ArkPCloudDeleteTargetPlatform) -&gt; None:\n        \"\"\"\n        Deletes a target platform by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-delete-target-platform.htm\n\n        Args:\n            delete_target_platform (ArkPCloudDeleteTargetPlatform): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting target platform [{delete_target_platform.target_platform_id}]')\n        resp: Response = self._client.delete(TARGET_PLATFORM_URL.format(target_platform_id=delete_target_platform.target_platform_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete target platform [{resp.text}] - [{resp.status_code}]')\n\n    def target_platforms_stats(self) -&gt; ArkPCloudTargetPlatformsStats:\n        \"\"\"\n        Calculates target platforms stats\n\n        Returns:\n            ArkPCloudTargetPlatformsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating target platform statistics')\n        target_platforms = self.list_target_platforms()\n        target_platforms_stats = ArkPCloudTargetPlatformsStats.model_construct()\n        target_platforms_stats.target_platforms_count = len(target_platforms)\n\n        # Get target platforms per system type\n        target_platform_system_types: Set[str] = {p.system_type for p in target_platforms}\n        target_platforms_stats.target_platforms_count_by_system_type = {\n            pt: len([p for p in target_platforms if p.system_type == pt]) for pt in target_platform_system_types\n        }\n\n        return target_platforms_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.activate_target_platform","title":"<code>activate_target_platform(activate_target_platform)</code>","text":"<p>Activates a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-activate-target-platform.htm</p> <p>Parameters:</p> Name Type Description Default <code>activate_target_platform</code> <code>ArkPCloudActivateTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def activate_target_platform(self, activate_target_platform: ArkPCloudActivateTargetPlatform) -&gt; None:\n    \"\"\"\n    Activates a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-activate-target-platform.htm\n\n    Args:\n        activate_target_platform (ArkPCloudActivateTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Activating target platform [{activate_target_platform.target_platform_id}]')\n    resp: Response = self._client.post(\n        ACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=activate_target_platform.target_platform_id)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to activate target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.deactivate_target_platform","title":"<code>deactivate_target_platform(deactivate_target_platform)</code>","text":"<p>Deactivates a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-deactivate-target-platform.htm</p> <p>Parameters:</p> Name Type Description Default <code>deactivate_target_platform</code> <code>ArkPCloudDeactivateTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def deactivate_target_platform(self, deactivate_target_platform: ArkPCloudDeactivateTargetPlatform) -&gt; None:\n    \"\"\"\n    Deactivates a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/rest-api-deactivate-target-platform.htm\n\n    Args:\n        deactivate_target_platform (ArkPCloudDeactivateTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deactivating target platform [{deactivate_target_platform.target_platform_id}]')\n    resp: Response = self._client.post(\n        DEACTIVATE_TARGET_PLATFORM_URL.format(target_platform_id=deactivate_target_platform.target_platform_id)\n    )\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to deactivate target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.delete_target_platform","title":"<code>delete_target_platform(delete_target_platform)</code>","text":"<p>Deletes a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-delete-target-platform.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_target_platform</code> <code>ArkPCloudDeleteTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def delete_target_platform(self, delete_target_platform: ArkPCloudDeleteTargetPlatform) -&gt; None:\n    \"\"\"\n    Deletes a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-delete-target-platform.htm\n\n    Args:\n        delete_target_platform (ArkPCloudDeleteTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting target platform [{delete_target_platform.target_platform_id}]')\n    resp: Response = self._client.delete(TARGET_PLATFORM_URL.format(target_platform_id=delete_target_platform.target_platform_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.duplicate_target_platform","title":"<code>duplicate_target_platform(duplicate_target_platform)</code>","text":"<p>Duplicates a target platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-duplicate-target-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>duplicate_target_platform</code> <code>ArkPCloudDuplicateTargetPlatform</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudDuplicatedTargetPlatformInfo</code> <code>ArkPCloudDuplicatedTargetPlatformInfo</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def duplicate_target_platform(\n    self, duplicate_target_platform: ArkPCloudDuplicateTargetPlatform\n) -&gt; ArkPCloudDuplicatedTargetPlatformInfo:\n    \"\"\"\n    Duplicates a target platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-duplicate-target-platforms.htm\n\n    Args:\n        duplicate_target_platform (ArkPCloudDuplicateTargetPlatform): _description_\n\n    Returns:\n        ArkPCloudDuplicatedTargetPlatformInfo: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(\n        f'Duplicates target platform [{duplicate_target_platform.target_platform_id}] to name [{duplicate_target_platform.name}]'\n    )\n    resp: Response = self._client.post(\n        DUPLICATE_TARGET_PLATFORM_URL.format(target_platform_id=duplicate_target_platform.target_platform_id),\n        json=duplicate_target_platform.model_dump(by_alias=True, exclude={'target_platform_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudDuplicatedTargetPlatformInfo.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse duplicate target platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse duplicate target platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to duplicate target platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.export_platform","title":"<code>export_platform(export_platform)</code>","text":"<p>Exports a platform zip data to a given folder by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>export_platform</code> <code>ArkPCloudExportPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def export_platform(self, export_platform: ArkPCloudExportPlatform) -&gt; None:\n    \"\"\"\n    Exports a platform zip data to a given folder by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n    Args:\n        export_platform (ArkPCloudExportPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Exporting platform [{export_platform.platform_id}] to folder [{export_platform.output_folder}]')\n    output_folder = Path(export_platform.output_folder)\n    output_folder.mkdir(exist_ok=True, parents=True)\n    resp: Response = self._client.post(EXPORT_PLATFORM_URL.format(platform_id=export_platform.platform_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n    (output_folder / export_platform.platform_id).write_bytes(resp.text.encode())\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.export_target_platform","title":"<code>export_target_platform(export_platform)</code>","text":"<p>Exports a platform zip data to a given folder by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>export_platform</code> <code>ArkPCloudExportTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def export_target_platform(self, export_platform: ArkPCloudExportTargetPlatform) -&gt; None:\n    \"\"\"\n    Exports a platform zip data to a given folder by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/SDK/ExportPlatform.htm\n\n    Args:\n        export_platform (ArkPCloudExportTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Exporting platform [{export_platform.target_platform_id}] to folder [{export_platform.output_folder}]')\n    output_folder = Path(export_platform.output_folder)\n    output_folder.mkdir(exist_ok=True, parents=True)\n    target_platform: ArkPCloudTargetPlatform = self.target_platform(\n        ArkPCloudGetTargetPlatform(target_platform_id=export_platform.target_platform_id)\n    )\n    resp: Response = self._client.post(EXPORT_TARGET_PLATFORM_URL.format(target_platform_id=export_platform.target_platform_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to export platform [{resp.text}] - [{resp.status_code}]')\n    (output_folder / target_platform.platform_id).write_bytes(resp.text.encode())\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.import_platform","title":"<code>import_platform(import_platform)</code>","text":"<p>Tries to import a platform zip data https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>import_platform</code> <code>ArkPCloudImportPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatform</code> <code>ArkPCloudPlatform</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def import_platform(self, import_platform: ArkPCloudImportPlatform) -&gt; ArkPCloudPlatform:\n    \"\"\"\n    Tries to import a platform zip data\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n    Args:\n        import_platform (ArkPCloudImportPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudPlatform: _description_\n    \"\"\"\n    self._logger.info('Importing platform')\n    platform_path = Path(import_platform.platform_zip_path)\n    if not platform_path.exists():\n        raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n    zip_data = b64encode(platform_path.read_bytes()).decode()\n    resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            platform_id = resp.json()['PlatformID']\n            return self.platform(ArkPCloudGetPlatform(platform_id=platform_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.import_target_platform","title":"<code>import_target_platform(import_platform)</code>","text":"<p>Tries to import a platform zip data https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm</p> <p>Parameters:</p> Name Type Description Default <code>import_platform</code> <code>ArkPCloudImportTargetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudTargetPlatform</code> <code>ArkPCloudTargetPlatform</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def import_target_platform(self, import_platform: ArkPCloudImportTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n    \"\"\"\n    Tries to import a platform zip data\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PrivCloud-SS/Latest/en/Content/WebServices/ImportPlatform.htm\n\n    Args:\n        import_platform (ArkPCloudImportTargetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudTargetPlatform: _description_\n    \"\"\"\n    self._logger.info('Importing target platform')\n    platform_path = Path(import_platform.platform_zip_path)\n    if not platform_path.exists():\n        raise ArkServiceException(f'Given path [{str(platform_path)}] does not exist or is invalid')\n    zip_data = b64encode(platform_path.read_bytes()).decode()\n    resp: Response = self._client.post(IMPORT_PLATFORM_URL, json={'ImportFile': zip_data})\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            platform_id = resp.json()['PlatformID']\n            platforms = self.list_target_platforms_by(ArkPCloudTargetPlatformsFilter(platform_id=platform_id))\n            if platforms:\n                return platforms[0]\n            raise ArkServiceException('Failed to find target platform after importing it')\n\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse import platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse import platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to import platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.list_platforms","title":"<code>list_platforms()</code>","text":"<p>Lists all the platforms visible to the user https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm</p> <p>Returns:</p> Type Description <code>List[ArkPCloudPlatform]</code> <p>List[ArkPCloudPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_platforms(self) -&gt; List[ArkPCloudPlatform]:\n    \"\"\"\n    Lists all the platforms visible to the user\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n    Returns:\n        List[ArkPCloudPlatform]: _description_\n    \"\"\"\n    self._logger.info('Listing all platforms')\n    return self.__list_platforms_by_filters()\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.list_platforms_by","title":"<code>list_platforms_by(platforms_filter)</code>","text":"<p>Lists platforms by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>platforms_filter</code> <code>ArkPCloudPlatformsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudPlatform]</code> <p>List[ArkPCloudPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_platforms_by(self, platforms_filter: ArkPCloudPlatformsFilter) -&gt; List[ArkPCloudPlatform]:\n    \"\"\"\n    Lists platforms by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-platforms.htm\n\n    Args:\n        platforms_filter (ArkPCloudPlatformsFilter): _description_\n\n    Returns:\n        List[ArkPCloudPlatform]: _description_\n    \"\"\"\n    self._logger.info(f'Listing platforms by filter [{platforms_filter}]')\n    return self.__list_platforms_by_filters(\n        active=platforms_filter.active, platform_type=platforms_filter.platform_type, platform_name=platforms_filter.platform_name\n    )\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.list_target_platforms","title":"<code>list_target_platforms()</code>","text":"<p>Lists all the target platforms visible to the user https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm</p> <p>Returns:</p> Type Description <code>List[ArkPCloudTargetPlatform]</code> <p>List[ArkPCloudTargetPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_target_platforms(self) -&gt; List[ArkPCloudTargetPlatform]:\n    \"\"\"\n    Lists all the target platforms visible to the user\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n    Returns:\n        List[ArkPCloudTargetPlatform]: _description_\n    \"\"\"\n    self._logger.info('Listing all target platforms')\n    return self.__list_target_platforms_by_filters()\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.list_target_platforms_by","title":"<code>list_target_platforms_by(target_platforms_filter)</code>","text":"<p>Lists target platforms by given filters https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>target_platforms_filter</code> <code>ArkPCloudTargetPlatformsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkPCloudTargetPlatform]</code> <p>List[ArkPCloudTargetPlatform]: description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def list_target_platforms_by(self, target_platforms_filter: ArkPCloudTargetPlatformsFilter) -&gt; List[ArkPCloudTargetPlatform]:\n    \"\"\"\n    Lists target platforms by given filters\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n    Args:\n        target_platforms_filter (ArkPCloudTargetPlatformsFilter): _description_\n\n    Returns:\n        List[ArkPCloudTargetPlatform]: _description_\n    \"\"\"\n    self._logger.info(f'Listing target platforms by filter [{target_platforms_filter}]')\n    target_platforms = self.__list_target_platforms_by_filters(\n        active=target_platforms_filter.active,\n        system_type=target_platforms_filter.system_type,\n        periodic_verify=target_platforms_filter.periodic_verify,\n        manual_verify=target_platforms_filter.manual_verify,\n        periodic_change=target_platforms_filter.periodic_change,\n        manual_change=target_platforms_filter.manual_change,\n        automatic_reconcile=target_platforms_filter.automatic_reconcile,\n        manual_reconcile=target_platforms_filter.manual_reconcile,\n    )\n\n    # Filter by platform id\n    if target_platforms_filter.platform_id:\n        target_platforms = [p for p in target_platforms if fnmatch(p.platform_id.lower(), target_platforms_filter.platform_id.lower())]\n\n    # Filter by name\n    if target_platforms_filter.name:\n        target_platforms = [p for p in target_platforms if fnmatch(p.name.lower(), target_platforms_filter.name.lower())]\n\n    # Filter by active\n    if target_platforms_filter.active is not None:\n        target_platforms = [p for p in target_platforms if p.active is target_platforms_filter.active]\n\n    return target_platforms\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.platform","title":"<code>platform(get_platform)</code>","text":"<p>Retrieves a platform by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPlatformDetails.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_platform</code> <code>ArkPCloudGetPlatform</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatform</code> <code>ArkPCloudPlatform</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def platform(self, get_platform: ArkPCloudGetPlatform) -&gt; ArkPCloudPlatform:\n    \"\"\"\n    Retrieves a platform by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/GetPlatformDetails.htm\n\n    Args:\n        get_platform (ArkPCloudGetPlatform): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudPlatform: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving platform [{get_platform.platform_id}]')\n    resp: Response = self._client.get(PLATFORM_URL.format(platform_id=get_platform.platform_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudPlatform.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse platform response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse platform response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve platform [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.platforms_stats","title":"<code>platforms_stats()</code>","text":"<p>Calculates platforms stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudPlatformsStats</code> <code>ArkPCloudPlatformsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def platforms_stats(self) -&gt; ArkPCloudPlatformsStats:\n    \"\"\"\n    Calculates platforms stats\n\n    Returns:\n        ArkPCloudPlatformsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating platform statistics')\n    platforms = self.list_platforms()\n    platforms_stats = ArkPCloudPlatformsStats.model_construct()\n    platforms_stats.platforms_count = len(platforms)\n\n    # Get platforms per platform type\n    platform_types: Set[ArkPCloudPlatformType] = {p.general.platform_type for p in platforms}\n    platforms_stats.platforms_count_by_type = {\n        pt: len([p for p in platforms if p.general.platform_type == pt]) for pt in platform_types\n    }\n\n    return platforms_stats\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.target_platform","title":"<code>target_platform(get_target_platform)</code>","text":"<p>Gets a target platform by id https://docs.cyberark.com/privilege-cloud-shared-services/Latest/en/Content/SDK/rest-api-get-target-platforms.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_target_platform</code> <code>ArkPCloudGetTargetPlatform</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudTargetPlatform</code> <code>ArkPCloudTargetPlatform</code> <p>description</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def target_platform(self, get_target_platform: ArkPCloudGetTargetPlatform) -&gt; ArkPCloudTargetPlatform:\n    \"\"\"\n    Gets a target platform by id\n    https://docs.cyberark.com/privilege-cloud-shared-services/Latest/en/Content/SDK/rest-api-get-target-platforms.htm\n\n    Args:\n        get_target_platform (ArkPCloudGetTargetPlatform): _description_\n\n    Returns:\n        ArkPCloudTargetPlatform: _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving target platform [{get_target_platform.target_platform_id}]')\n    target_platform = [p for p in self.list_target_platforms() if p.id == get_target_platform.target_platform_id]\n    if len(target_platform) != 1:\n        raise ArkServiceException('Failed to get target platform')\n    return target_platform[0]\n</code></pre>"},{"location":"reference/services/pcloud/platforms/ark_pcloud_platforms_service/#ark_sdk_python.services.pcloud.platforms.ark_pcloud_platforms_service.ArkPCloudPlatformsService.target_platforms_stats","title":"<code>target_platforms_stats()</code>","text":"<p>Calculates target platforms stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudTargetPlatformsStats</code> <code>ArkPCloudTargetPlatformsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/platforms/ark_pcloud_platforms_service.py</code> <pre><code>def target_platforms_stats(self) -&gt; ArkPCloudTargetPlatformsStats:\n    \"\"\"\n    Calculates target platforms stats\n\n    Returns:\n        ArkPCloudTargetPlatformsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating target platform statistics')\n    target_platforms = self.list_target_platforms()\n    target_platforms_stats = ArkPCloudTargetPlatformsStats.model_construct()\n    target_platforms_stats.target_platforms_count = len(target_platforms)\n\n    # Get target platforms per system type\n    target_platform_system_types: Set[str] = {p.system_type for p in target_platforms}\n    target_platforms_stats.target_platforms_count_by_system_type = {\n        pt: len([p for p in target_platforms if p.system_type == pt]) for pt in target_platform_system_types\n    }\n\n    return target_platforms_stats\n</code></pre>"},{"location":"reference/services/pcloud/safes/","title":"safes","text":""},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService","title":"<code>ArkPCloudSafesService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>class ArkPCloudSafesService(ArkPCloudBaseService):\n    def __list_safes_with_filters(\n        self, search: Optional[str] = None, sort: Optional[str] = None, offset: Optional[int] = None, limit: Optional[int] = None\n    ) -&gt; Iterator[ArkPCloudSafesPage]:\n        query = {}\n        if search:\n            query['search'] = search\n        if sort:\n            query['sort'] = sort\n        if offset:\n            query['offset'] = offset\n        if limit:\n            query['limit'] = limit\n        while True:\n            resp: Response = self._client.get(SAFES_URL, params=query)\n            if resp.status_code == HTTPStatus.OK:\n                try:\n                    result = resp.json()\n                    safes = None\n                    if 'value' in result:\n                        safes = result['value']\n                    elif 'Safes' in result:\n                        safes = result['Safes']\n                    if not safes:\n                        raise ArkServiceException('Failed to list safes, unexpected result')\n                    safes = [{f'{k[0].lower()}{k[1:]}': v for k, v in safe.items()} for safe in safes]\n                    accounts = TypeAdapter(List[ArkPCloudSafe]).validate_python(safes)\n                    yield ArkPCloudSafesPage(items=accounts)\n                    if 'nextLink' in result:\n                        query = parse_qs(urlparse(result['nextLink']).query)\n                    else:\n                        break\n                except (ValidationError, JSONDecodeError, KeyError) as ex:\n                    self._logger.exception(f'Failed to parse list safes response [{str(ex)}] - [{resp.text}]')\n                    raise ArkServiceException(f'Failed to parse list safes response [{str(ex)}]') from ex\n            else:\n                raise ArkServiceException(f'Failed to list safes [{resp.text}] - [{resp.status_code}]')\n\n    def __list_safe_members_with_filters(\n        self,\n        safe_id: str,\n        search: Optional[str] = None,\n        sort: Optional[str] = None,\n        offset: Optional[int] = None,\n        limit: Optional[int] = None,\n        member_type: Optional[ArkPCloudSafeMemberType] = None,\n    ) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n        query = {}\n        if search:\n            query['search'] = search\n        if sort:\n            query['sort'] = sort\n        if offset:\n            query['offset'] = offset\n        if limit:\n            query['limit'] = limit\n        if member_type:\n            query['filter'] = f'memberType eq {member_type.value}'\n        while True:\n            resp: Response = self._client.get(SAFE_MEMBERS_URL.format(safe_id=safe_id), params=query)\n            if resp.status_code == HTTPStatus.OK:\n                try:\n                    result = resp.json()\n                    safe_members = TypeAdapter(List[ArkPCloudSafeMember]).validate_python(result['value'])\n                    for sm in safe_members:\n                        sm.permission_set = (\n                            [p for p in SAFE_MEMBER_PERMISSIONS_SETS.keys() if SAFE_MEMBER_PERMISSIONS_SETS[p] == sm.permissions]\n                            + [ArkPCloudSafeMemberPermissionSet.Custom]\n                        )[0]\n                    yield ArkPCloudSafeMembersPage(items=safe_members)\n                    if 'nextLink' in result:\n                        query = parse_qs(urlparse(result['nextLink']).query)\n                    else:\n                        break\n                except (ValidationError, JSONDecodeError, KeyError) as ex:\n                    self._logger.exception(f'Failed to parse list safe members response [{str(ex)}] - [{resp.text}]')\n                    raise ArkServiceException(f'Failed to parse list safe members response [{str(ex)}]') from ex\n            else:\n                raise ArkServiceException(f'Failed to list safe members [{resp.text}] - [{resp.status_code}]')\n\n    def list_safes(self) -&gt; Iterator[ArkPCloudSafesPage]:\n        \"\"\"\n        Lists all the visible safes of the logged in user as pages of safes\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n        Yields:\n            Iterator[ArkPCloudSafesPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all safes')\n        yield from self.__list_safes_with_filters()\n\n    def list_safes_by(self, safes_filter: ArkPCloudSafesFilters) -&gt; Iterator[ArkPCloudSafesPage]:\n        \"\"\"\n        Lists the visible safes of the logged in user by filters as pages of safes\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n        Yields:\n            Iterator[ArkPCloudSafesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing safes by filter [{safes_filter}]')\n        yield from self.__list_safes_with_filters(safes_filter.search, safes_filter.sort, safes_filter.offset, safes_filter.limit)\n\n    def list_safe_members(self, list_safe_members: ArkPCloudListSafeMembers) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n        \"\"\"\n        Lists all safe mmebers of a given safe that are visible to the logged in user as pages of safe members\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n        Args:\n            list_safe_members (ArkPCloudListSafeMembers): _description_\n\n        Yields:\n            Iterator[ArkPCloudSafeMembersPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all safe members')\n        yield from self.__list_safe_members_with_filters(list_safe_members.safe_id)\n\n    def list_safe_members_by(self, safe_members_filter: ArkPCloudSafeMembersFilters) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n        \"\"\"\n        Lists safe mmebers of a given safe that are visible to the logged in user by filters as pages of safe members\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n        Args:\n            safe_members_filter (ArkPCloudSafeMembersFilters): _description_\n\n        Yields:\n            Iterator[ArkPCloudSafeMembersPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing safe members by filter [{safe_members_filter}]')\n        yield from self.__list_safe_members_with_filters(\n            safe_members_filter.safe_id,\n            safe_members_filter.search,\n            safe_members_filter.sort,\n            safe_members_filter.offset,\n            safe_members_filter.limit,\n            safe_members_filter.member_type,\n        )\n\n    def safe(self, get_safe: ArkPCloudGetSafe) -&gt; ArkPCloudSafe:\n        \"\"\"\n        Retrieves a safe by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20Get%20Safes%20Details.htm\n\n        Args:\n            get_safe (ArkPCloudGetSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafe: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving safe by id [{get_safe.safe_id}]')\n        resp: Response = self._client.get(SAFE_URL.format(safe_id=get_safe.safe_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudSafe.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse safe response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse safe response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve safe [{resp.text}] - [{resp.status_code}]')\n\n    def safe_member(self, get_safe_member: ArkPCloudGetSafeMember) -&gt; ArkPCloudSafeMember:\n        \"\"\"\n        Retrieves a safe member by safe id and member name\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Member.htm\n\n        Args:\n            get_safe_member (ArkPCloudGetSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafeMember: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving safe member by safe [{get_safe_member.safe_id}] and member name [{get_safe_member.member_name}]')\n        resp: Response = self._client.get(SAFE_MEMBER_URL.format(safe_id=get_safe_member.safe_id, member_name=get_safe_member.member_name))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                safe_member = ArkPCloudSafeMember.model_validate(resp.json())\n                safe_member.permission_set = (\n                    [p for p in SAFE_MEMBER_PERMISSIONS_SETS.keys() if SAFE_MEMBER_PERMISSIONS_SETS[p] == safe_member.permissions]\n                    + [ArkPCloudSafeMemberPermissionSet.Custom]\n                )[0]\n                return safe_member\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse safe member response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse safe member response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve safe member [{resp.text}] - [{resp.status_code}]')\n\n    def add_safe(self, add_safe: ArkPCloudAddSafe) -&gt; ArkPCloudSafe:\n        \"\"\"\n        Adds a new safe with given details\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe.htm\n\n        Args:\n            add_safe (ArkPCloudAddSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafe: _description_\n        \"\"\"\n        self._logger.info('Adding new safe')\n        resp: Response = self._client.post(SAFES_URL, json=add_safe.model_dump(by_alias=True))\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkPCloudSafe.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add safe response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add safe response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add safe [{resp.text}] - [{resp.status_code}]')\n\n    def add_safe_member(self, add_safe_member: ArkPCloudAddSafeMember) -&gt; ArkPCloudSafeMember:\n        \"\"\"\n        Adds a new member to a safe by given safe id and member name, along with fitting permissions or permission set\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe%20Member.htm\n\n        Args:\n            add_safe_member (ArkPCloudAddSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafeMember: _description_\n        \"\"\"\n        self._logger.info(f'Adding new safe member for safe [{add_safe_member.safe_id}] and name [{add_safe_member.member_name}]')\n        if (\n            add_safe_member.permission_set\n            and add_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n            and not add_safe_member.permissions\n        ):\n            raise ArkServiceException('Custom permissions must have permissions model set')\n        if add_safe_member.permission_set and add_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n            add_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[add_safe_member.permission_set].model_copy()\n        resp: Response = self._client.post(\n            SAFE_MEMBERS_URL.format(safe_id=add_safe_member.safe_id),\n            json=add_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'permission_set'}),\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkPCloudSafeMember.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add safe member response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add safe member response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add safe member [{resp.text}] - [{resp.status_code}]')\n\n    def delete_safe(self, delete_safe: ArkPCloudDeleteSafe) -&gt; None:\n        \"\"\"\n        Deletes a safe by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe.htm\n\n        Args:\n            delete_safe (ArkPCloudDeleteSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting safe [{delete_safe.safe_id}]')\n        resp: Response = self._client.delete(SAFE_URL.format(safe_id=delete_safe.safe_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete safe [{resp.text}] - [{resp.status_code}]')\n\n    def delete_safe_member(self, delete_safe_member: ArkPCloudDeleteSafeMember) -&gt; None:\n        \"\"\"\n        Deletes a safe member from a safe by safe id and name\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe%20Member.htm\n\n        Args:\n            delete_safe_member (ArkPCloudDeleteSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting safe member from safe [{delete_safe_member.safe_id}] with name [{delete_safe_member.member_name}]')\n        resp: Response = self._client.delete(\n            f'{SAFE_MEMBER_URL.format(safe_id=delete_safe_member.safe_id, member_name=delete_safe_member.member_name)}/'\n        )\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete safe member [{resp.text}] - [{resp.status_code}]')\n\n    def update_safe(self, update_safe: ArkPCloudUpdateSafe) -&gt; ArkPCloudSafe:\n        \"\"\"\n        Updates safe details by safe id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe.htm\n\n        Args:\n            update_safe (ArkPCloudUpdateSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafe: _description_\n        \"\"\"\n        self._logger.info(f'Updating safe [{update_safe.safe_id}]')\n        resp: Response = self._client.put(\n            SAFE_URL.format(safe_id=update_safe.safe_id), json=update_safe.model_dump(by_alias=True, exclude={'safe_id'}, exclude_none=True)\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudSafe.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update safe response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update safe response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update safe [{resp.text}] - [{resp.status_code}]')\n\n    def update_safe_member(self, update_safe_member: ArkPCloudUpdateSafeMember) -&gt; ArkPCloudSafeMember:\n        \"\"\"\n        Updates a safe member by safe id and member name\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe%20Member.htm\n\n        Args:\n            update_safe_member (ArkPCloudUpdateSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafeMember: _description_\n        \"\"\"\n        self._logger.info(f'Updating safe member of safe [{update_safe_member.safe_id}] and name [{update_safe_member.member_name}]')\n        if (\n            update_safe_member.permission_set\n            and update_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n            and not update_safe_member.permissions\n        ):\n            raise ArkServiceException('Custom permissions must have permissions model set')\n        if update_safe_member.permission_set and update_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n            update_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[update_safe_member.permission_set].model_copy()\n        resp: Response = self._client.put(\n            SAFE_MEMBER_URL.format(safe_id=update_safe_member.safe_id, member_name=update_safe_member.member_name),\n            json=update_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'member_name', 'permission_set'}, exclude_none=True),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudSafeMember.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update safe member response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update safe member response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update safe member [{resp.text}] - [{resp.status_code}]')\n\n    def safes_stats(self) -&gt; ArkPCloudSafesStats:\n        \"\"\"\n        Calculates safe stats\n\n        Returns:\n            ArkPCloudSafesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating safes statistics')\n        safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n        safes_stats = ArkPCloudSafesStats.model_construct()\n        safes_stats.safes_count = len(safes)\n\n        # Get safes per location\n        locations: Set[str] = {s.location for s in safes}\n        safes_stats.safes_count_by_location = {l: len([s for s in safes if s.location == l]) for l in locations}\n\n        # Get safes per creator\n        creators: Set[str] = {s.creator.name for s in safes}\n        safes_stats.safes_count_by_creator = {c: len([s for s in safes if s.creator.name == c]) for c in creators}\n\n        return safes_stats\n\n    def safe_members_stats(self, get_safe_members_stats: ArkPCloudGetSafeMembersStats) -&gt; ArkPCloudSafeMembersStats:\n        \"\"\"\n        Calculates safe members stats for a given safe\n\n        Args:\n            get_safe_members_stats (ArkPCloudGetSafeMembersStats): _description_\n\n        Returns:\n            ArkPCloudSafeMembersStats: _description_\n        \"\"\"\n        self._logger.info(f'Calculating safe members statistics for safe [{get_safe_members_stats.safe_id}]')\n        safe_members = list(\n            itertools.chain.from_iterable(\n                [p.items for p in list(self.list_safe_members(ArkPCloudListSafeMembers(safe_id=get_safe_members_stats.safe_id)))]\n            )\n        )\n        safe_members_stats = ArkPCloudSafeMembersStats.model_construct()\n        safe_members_stats.safe_members_count = len(safe_members)\n\n        # Get safe members count and names per permission set\n        permission_sets: Set[ArkPCloudSafeMemberPermissionSet] = {sm.permission_set for sm in safe_members}\n        safe_members_stats.safe_members_permission_sets = {\n            ps: ArkCountedValues(\n                count=len([sm for sm in safe_members if sm.permission_set == ps]),\n                values=[sm.member_name for sm in safe_members if sm.permission_set == ps],\n            )\n            for ps in permission_sets\n        }\n\n        # Get safe members count per type\n        member_types: Set[ArkPCloudSafeMemberType] = {sm.member_type for sm in safe_members}\n        safe_members_stats.safe_members_types_count = {mt: len([sm for sm in safe_members if sm.member_type == mt]) for mt in member_types}\n\n        return safe_members_stats\n\n    def safes_members_stats(self) -&gt; ArkPCloudSafesMembersStats:\n        \"\"\"\n        Calculates all safes members stats\n\n        Returns:\n            ArkPCloudSafesMembersStats: _description_\n        \"\"\"\n        self._logger.info('Calculating safes members statistics')\n        safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n        safes_members_stats = ArkPCloudSafesMembersStats.model_construct()\n        with ThreadPoolExecutor() as executor:\n            safe_members_stats_tuples = executor.map(\n                lambda s: (s.safe_name, self.safe_members_stats(ArkPCloudGetSafeMembersStats(safe_id=s.safe_id))), safes\n            )\n            safes_members_stats.safe_members_stats = dict((a, b) for a, b in safe_members_stats_tuples)\n        return safes_members_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.add_safe","title":"<code>add_safe(add_safe)</code>","text":"<p>Adds a new safe with given details https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_safe</code> <code>ArkPCloudAddSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafe</code> <code>ArkPCloudSafe</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def add_safe(self, add_safe: ArkPCloudAddSafe) -&gt; ArkPCloudSafe:\n    \"\"\"\n    Adds a new safe with given details\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe.htm\n\n    Args:\n        add_safe (ArkPCloudAddSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafe: _description_\n    \"\"\"\n    self._logger.info('Adding new safe')\n    resp: Response = self._client.post(SAFES_URL, json=add_safe.model_dump(by_alias=True))\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkPCloudSafe.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add safe response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add safe response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.add_safe_member","title":"<code>add_safe_member(add_safe_member)</code>","text":"<p>Adds a new member to a safe by given safe id and member name, along with fitting permissions or permission set https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_safe_member</code> <code>ArkPCloudAddSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMember</code> <code>ArkPCloudSafeMember</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def add_safe_member(self, add_safe_member: ArkPCloudAddSafeMember) -&gt; ArkPCloudSafeMember:\n    \"\"\"\n    Adds a new member to a safe by given safe id and member name, along with fitting permissions or permission set\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe%20Member.htm\n\n    Args:\n        add_safe_member (ArkPCloudAddSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafeMember: _description_\n    \"\"\"\n    self._logger.info(f'Adding new safe member for safe [{add_safe_member.safe_id}] and name [{add_safe_member.member_name}]')\n    if (\n        add_safe_member.permission_set\n        and add_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n        and not add_safe_member.permissions\n    ):\n        raise ArkServiceException('Custom permissions must have permissions model set')\n    if add_safe_member.permission_set and add_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n        add_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[add_safe_member.permission_set].model_copy()\n    resp: Response = self._client.post(\n        SAFE_MEMBERS_URL.format(safe_id=add_safe_member.safe_id),\n        json=add_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'permission_set'}),\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkPCloudSafeMember.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add safe member response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add safe member response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.delete_safe","title":"<code>delete_safe(delete_safe)</code>","text":"<p>Deletes a safe by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_safe</code> <code>ArkPCloudDeleteSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def delete_safe(self, delete_safe: ArkPCloudDeleteSafe) -&gt; None:\n    \"\"\"\n    Deletes a safe by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe.htm\n\n    Args:\n        delete_safe (ArkPCloudDeleteSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting safe [{delete_safe.safe_id}]')\n    resp: Response = self._client.delete(SAFE_URL.format(safe_id=delete_safe.safe_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.delete_safe_member","title":"<code>delete_safe_member(delete_safe_member)</code>","text":"<p>Deletes a safe member from a safe by safe id and name https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_safe_member</code> <code>ArkPCloudDeleteSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def delete_safe_member(self, delete_safe_member: ArkPCloudDeleteSafeMember) -&gt; None:\n    \"\"\"\n    Deletes a safe member from a safe by safe id and name\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe%20Member.htm\n\n    Args:\n        delete_safe_member (ArkPCloudDeleteSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting safe member from safe [{delete_safe_member.safe_id}] with name [{delete_safe_member.member_name}]')\n    resp: Response = self._client.delete(\n        f'{SAFE_MEMBER_URL.format(safe_id=delete_safe_member.safe_id, member_name=delete_safe_member.member_name)}/'\n    )\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.list_safe_members","title":"<code>list_safe_members(list_safe_members)</code>","text":"<p>Lists all safe mmebers of a given safe that are visible to the logged in user as pages of safe members https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm</p> <p>Parameters:</p> Name Type Description Default <code>list_safe_members</code> <code>ArkPCloudListSafeMembers</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkPCloudSafeMembersPage</code> <p>Iterator[ArkPCloudSafeMembersPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safe_members(self, list_safe_members: ArkPCloudListSafeMembers) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n    \"\"\"\n    Lists all safe mmebers of a given safe that are visible to the logged in user as pages of safe members\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n    Args:\n        list_safe_members (ArkPCloudListSafeMembers): _description_\n\n    Yields:\n        Iterator[ArkPCloudSafeMembersPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all safe members')\n    yield from self.__list_safe_members_with_filters(list_safe_members.safe_id)\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.list_safe_members_by","title":"<code>list_safe_members_by(safe_members_filter)</code>","text":"<p>Lists safe mmebers of a given safe that are visible to the logged in user by filters as pages of safe members https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm</p> <p>Parameters:</p> Name Type Description Default <code>safe_members_filter</code> <code>ArkPCloudSafeMembersFilters</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkPCloudSafeMembersPage</code> <p>Iterator[ArkPCloudSafeMembersPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safe_members_by(self, safe_members_filter: ArkPCloudSafeMembersFilters) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n    \"\"\"\n    Lists safe mmebers of a given safe that are visible to the logged in user by filters as pages of safe members\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n    Args:\n        safe_members_filter (ArkPCloudSafeMembersFilters): _description_\n\n    Yields:\n        Iterator[ArkPCloudSafeMembersPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing safe members by filter [{safe_members_filter}]')\n    yield from self.__list_safe_members_with_filters(\n        safe_members_filter.safe_id,\n        safe_members_filter.search,\n        safe_members_filter.sort,\n        safe_members_filter.offset,\n        safe_members_filter.limit,\n        safe_members_filter.member_type,\n    )\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.list_safes","title":"<code>list_safes()</code>","text":"<p>Lists all the visible safes of the logged in user as pages of safes https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?</p> <p>Yields:</p> Type Description <code>ArkPCloudSafesPage</code> <p>Iterator[ArkPCloudSafesPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safes(self) -&gt; Iterator[ArkPCloudSafesPage]:\n    \"\"\"\n    Lists all the visible safes of the logged in user as pages of safes\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n    Yields:\n        Iterator[ArkPCloudSafesPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all safes')\n    yield from self.__list_safes_with_filters()\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.list_safes_by","title":"<code>list_safes_by(safes_filter)</code>","text":"<p>Lists the visible safes of the logged in user by filters as pages of safes https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?</p> <p>Yields:</p> Type Description <code>ArkPCloudSafesPage</code> <p>Iterator[ArkPCloudSafesPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safes_by(self, safes_filter: ArkPCloudSafesFilters) -&gt; Iterator[ArkPCloudSafesPage]:\n    \"\"\"\n    Lists the visible safes of the logged in user by filters as pages of safes\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n    Yields:\n        Iterator[ArkPCloudSafesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing safes by filter [{safes_filter}]')\n    yield from self.__list_safes_with_filters(safes_filter.search, safes_filter.sort, safes_filter.offset, safes_filter.limit)\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.safe","title":"<code>safe(get_safe)</code>","text":"<p>Retrieves a safe by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20Get%20Safes%20Details.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_safe</code> <code>ArkPCloudGetSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafe</code> <code>ArkPCloudSafe</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safe(self, get_safe: ArkPCloudGetSafe) -&gt; ArkPCloudSafe:\n    \"\"\"\n    Retrieves a safe by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20Get%20Safes%20Details.htm\n\n    Args:\n        get_safe (ArkPCloudGetSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafe: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving safe by id [{get_safe.safe_id}]')\n    resp: Response = self._client.get(SAFE_URL.format(safe_id=get_safe.safe_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudSafe.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse safe response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse safe response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.safe_member","title":"<code>safe_member(get_safe_member)</code>","text":"<p>Retrieves a safe member by safe id and member name https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_safe_member</code> <code>ArkPCloudGetSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMember</code> <code>ArkPCloudSafeMember</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safe_member(self, get_safe_member: ArkPCloudGetSafeMember) -&gt; ArkPCloudSafeMember:\n    \"\"\"\n    Retrieves a safe member by safe id and member name\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Member.htm\n\n    Args:\n        get_safe_member (ArkPCloudGetSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafeMember: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving safe member by safe [{get_safe_member.safe_id}] and member name [{get_safe_member.member_name}]')\n    resp: Response = self._client.get(SAFE_MEMBER_URL.format(safe_id=get_safe_member.safe_id, member_name=get_safe_member.member_name))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            safe_member = ArkPCloudSafeMember.model_validate(resp.json())\n            safe_member.permission_set = (\n                [p for p in SAFE_MEMBER_PERMISSIONS_SETS.keys() if SAFE_MEMBER_PERMISSIONS_SETS[p] == safe_member.permissions]\n                + [ArkPCloudSafeMemberPermissionSet.Custom]\n            )[0]\n            return safe_member\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse safe member response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse safe member response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.safe_members_stats","title":"<code>safe_members_stats(get_safe_members_stats)</code>","text":"<p>Calculates safe members stats for a given safe</p> <p>Parameters:</p> Name Type Description Default <code>get_safe_members_stats</code> <code>ArkPCloudGetSafeMembersStats</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMembersStats</code> <code>ArkPCloudSafeMembersStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safe_members_stats(self, get_safe_members_stats: ArkPCloudGetSafeMembersStats) -&gt; ArkPCloudSafeMembersStats:\n    \"\"\"\n    Calculates safe members stats for a given safe\n\n    Args:\n        get_safe_members_stats (ArkPCloudGetSafeMembersStats): _description_\n\n    Returns:\n        ArkPCloudSafeMembersStats: _description_\n    \"\"\"\n    self._logger.info(f'Calculating safe members statistics for safe [{get_safe_members_stats.safe_id}]')\n    safe_members = list(\n        itertools.chain.from_iterable(\n            [p.items for p in list(self.list_safe_members(ArkPCloudListSafeMembers(safe_id=get_safe_members_stats.safe_id)))]\n        )\n    )\n    safe_members_stats = ArkPCloudSafeMembersStats.model_construct()\n    safe_members_stats.safe_members_count = len(safe_members)\n\n    # Get safe members count and names per permission set\n    permission_sets: Set[ArkPCloudSafeMemberPermissionSet] = {sm.permission_set for sm in safe_members}\n    safe_members_stats.safe_members_permission_sets = {\n        ps: ArkCountedValues(\n            count=len([sm for sm in safe_members if sm.permission_set == ps]),\n            values=[sm.member_name for sm in safe_members if sm.permission_set == ps],\n        )\n        for ps in permission_sets\n    }\n\n    # Get safe members count per type\n    member_types: Set[ArkPCloudSafeMemberType] = {sm.member_type for sm in safe_members}\n    safe_members_stats.safe_members_types_count = {mt: len([sm for sm in safe_members if sm.member_type == mt]) for mt in member_types}\n\n    return safe_members_stats\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.safes_members_stats","title":"<code>safes_members_stats()</code>","text":"<p>Calculates all safes members stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafesMembersStats</code> <code>ArkPCloudSafesMembersStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safes_members_stats(self) -&gt; ArkPCloudSafesMembersStats:\n    \"\"\"\n    Calculates all safes members stats\n\n    Returns:\n        ArkPCloudSafesMembersStats: _description_\n    \"\"\"\n    self._logger.info('Calculating safes members statistics')\n    safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n    safes_members_stats = ArkPCloudSafesMembersStats.model_construct()\n    with ThreadPoolExecutor() as executor:\n        safe_members_stats_tuples = executor.map(\n            lambda s: (s.safe_name, self.safe_members_stats(ArkPCloudGetSafeMembersStats(safe_id=s.safe_id))), safes\n        )\n        safes_members_stats.safe_members_stats = dict((a, b) for a, b in safe_members_stats_tuples)\n    return safes_members_stats\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.safes_stats","title":"<code>safes_stats()</code>","text":"<p>Calculates safe stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafesStats</code> <code>ArkPCloudSafesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safes_stats(self) -&gt; ArkPCloudSafesStats:\n    \"\"\"\n    Calculates safe stats\n\n    Returns:\n        ArkPCloudSafesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating safes statistics')\n    safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n    safes_stats = ArkPCloudSafesStats.model_construct()\n    safes_stats.safes_count = len(safes)\n\n    # Get safes per location\n    locations: Set[str] = {s.location for s in safes}\n    safes_stats.safes_count_by_location = {l: len([s for s in safes if s.location == l]) for l in locations}\n\n    # Get safes per creator\n    creators: Set[str] = {s.creator.name for s in safes}\n    safes_stats.safes_count_by_creator = {c: len([s for s in safes if s.creator.name == c]) for c in creators}\n\n    return safes_stats\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.update_safe","title":"<code>update_safe(update_safe)</code>","text":"<p>Updates safe details by safe id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_safe</code> <code>ArkPCloudUpdateSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafe</code> <code>ArkPCloudSafe</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def update_safe(self, update_safe: ArkPCloudUpdateSafe) -&gt; ArkPCloudSafe:\n    \"\"\"\n    Updates safe details by safe id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe.htm\n\n    Args:\n        update_safe (ArkPCloudUpdateSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafe: _description_\n    \"\"\"\n    self._logger.info(f'Updating safe [{update_safe.safe_id}]')\n    resp: Response = self._client.put(\n        SAFE_URL.format(safe_id=update_safe.safe_id), json=update_safe.model_dump(by_alias=True, exclude={'safe_id'}, exclude_none=True)\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudSafe.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update safe response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update safe response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/#ark_sdk_python.services.pcloud.safes.ArkPCloudSafesService.update_safe_member","title":"<code>update_safe_member(update_safe_member)</code>","text":"<p>Updates a safe member by safe id and member name https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_safe_member</code> <code>ArkPCloudUpdateSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMember</code> <code>ArkPCloudSafeMember</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def update_safe_member(self, update_safe_member: ArkPCloudUpdateSafeMember) -&gt; ArkPCloudSafeMember:\n    \"\"\"\n    Updates a safe member by safe id and member name\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe%20Member.htm\n\n    Args:\n        update_safe_member (ArkPCloudUpdateSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafeMember: _description_\n    \"\"\"\n    self._logger.info(f'Updating safe member of safe [{update_safe_member.safe_id}] and name [{update_safe_member.member_name}]')\n    if (\n        update_safe_member.permission_set\n        and update_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n        and not update_safe_member.permissions\n    ):\n        raise ArkServiceException('Custom permissions must have permissions model set')\n    if update_safe_member.permission_set and update_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n        update_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[update_safe_member.permission_set].model_copy()\n    resp: Response = self._client.put(\n        SAFE_MEMBER_URL.format(safe_id=update_safe_member.safe_id, member_name=update_safe_member.member_name),\n        json=update_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'member_name', 'permission_set'}, exclude_none=True),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudSafeMember.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update safe member response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update safe member response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/","title":"ark_pcloud_safes_service","text":""},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService","title":"<code>ArkPCloudSafesService</code>","text":"<p>               Bases: <code>ArkPCloudBaseService</code></p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>class ArkPCloudSafesService(ArkPCloudBaseService):\n    def __list_safes_with_filters(\n        self, search: Optional[str] = None, sort: Optional[str] = None, offset: Optional[int] = None, limit: Optional[int] = None\n    ) -&gt; Iterator[ArkPCloudSafesPage]:\n        query = {}\n        if search:\n            query['search'] = search\n        if sort:\n            query['sort'] = sort\n        if offset:\n            query['offset'] = offset\n        if limit:\n            query['limit'] = limit\n        while True:\n            resp: Response = self._client.get(SAFES_URL, params=query)\n            if resp.status_code == HTTPStatus.OK:\n                try:\n                    result = resp.json()\n                    safes = None\n                    if 'value' in result:\n                        safes = result['value']\n                    elif 'Safes' in result:\n                        safes = result['Safes']\n                    if not safes:\n                        raise ArkServiceException('Failed to list safes, unexpected result')\n                    safes = [{f'{k[0].lower()}{k[1:]}': v for k, v in safe.items()} for safe in safes]\n                    accounts = TypeAdapter(List[ArkPCloudSafe]).validate_python(safes)\n                    yield ArkPCloudSafesPage(items=accounts)\n                    if 'nextLink' in result:\n                        query = parse_qs(urlparse(result['nextLink']).query)\n                    else:\n                        break\n                except (ValidationError, JSONDecodeError, KeyError) as ex:\n                    self._logger.exception(f'Failed to parse list safes response [{str(ex)}] - [{resp.text}]')\n                    raise ArkServiceException(f'Failed to parse list safes response [{str(ex)}]') from ex\n            else:\n                raise ArkServiceException(f'Failed to list safes [{resp.text}] - [{resp.status_code}]')\n\n    def __list_safe_members_with_filters(\n        self,\n        safe_id: str,\n        search: Optional[str] = None,\n        sort: Optional[str] = None,\n        offset: Optional[int] = None,\n        limit: Optional[int] = None,\n        member_type: Optional[ArkPCloudSafeMemberType] = None,\n    ) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n        query = {}\n        if search:\n            query['search'] = search\n        if sort:\n            query['sort'] = sort\n        if offset:\n            query['offset'] = offset\n        if limit:\n            query['limit'] = limit\n        if member_type:\n            query['filter'] = f'memberType eq {member_type.value}'\n        while True:\n            resp: Response = self._client.get(SAFE_MEMBERS_URL.format(safe_id=safe_id), params=query)\n            if resp.status_code == HTTPStatus.OK:\n                try:\n                    result = resp.json()\n                    safe_members = TypeAdapter(List[ArkPCloudSafeMember]).validate_python(result['value'])\n                    for sm in safe_members:\n                        sm.permission_set = (\n                            [p for p in SAFE_MEMBER_PERMISSIONS_SETS.keys() if SAFE_MEMBER_PERMISSIONS_SETS[p] == sm.permissions]\n                            + [ArkPCloudSafeMemberPermissionSet.Custom]\n                        )[0]\n                    yield ArkPCloudSafeMembersPage(items=safe_members)\n                    if 'nextLink' in result:\n                        query = parse_qs(urlparse(result['nextLink']).query)\n                    else:\n                        break\n                except (ValidationError, JSONDecodeError, KeyError) as ex:\n                    self._logger.exception(f'Failed to parse list safe members response [{str(ex)}] - [{resp.text}]')\n                    raise ArkServiceException(f'Failed to parse list safe members response [{str(ex)}]') from ex\n            else:\n                raise ArkServiceException(f'Failed to list safe members [{resp.text}] - [{resp.status_code}]')\n\n    def list_safes(self) -&gt; Iterator[ArkPCloudSafesPage]:\n        \"\"\"\n        Lists all the visible safes of the logged in user as pages of safes\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n        Yields:\n            Iterator[ArkPCloudSafesPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all safes')\n        yield from self.__list_safes_with_filters()\n\n    def list_safes_by(self, safes_filter: ArkPCloudSafesFilters) -&gt; Iterator[ArkPCloudSafesPage]:\n        \"\"\"\n        Lists the visible safes of the logged in user by filters as pages of safes\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n        Yields:\n            Iterator[ArkPCloudSafesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing safes by filter [{safes_filter}]')\n        yield from self.__list_safes_with_filters(safes_filter.search, safes_filter.sort, safes_filter.offset, safes_filter.limit)\n\n    def list_safe_members(self, list_safe_members: ArkPCloudListSafeMembers) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n        \"\"\"\n        Lists all safe mmebers of a given safe that are visible to the logged in user as pages of safe members\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n        Args:\n            list_safe_members (ArkPCloudListSafeMembers): _description_\n\n        Yields:\n            Iterator[ArkPCloudSafeMembersPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all safe members')\n        yield from self.__list_safe_members_with_filters(list_safe_members.safe_id)\n\n    def list_safe_members_by(self, safe_members_filter: ArkPCloudSafeMembersFilters) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n        \"\"\"\n        Lists safe mmebers of a given safe that are visible to the logged in user by filters as pages of safe members\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n        Args:\n            safe_members_filter (ArkPCloudSafeMembersFilters): _description_\n\n        Yields:\n            Iterator[ArkPCloudSafeMembersPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing safe members by filter [{safe_members_filter}]')\n        yield from self.__list_safe_members_with_filters(\n            safe_members_filter.safe_id,\n            safe_members_filter.search,\n            safe_members_filter.sort,\n            safe_members_filter.offset,\n            safe_members_filter.limit,\n            safe_members_filter.member_type,\n        )\n\n    def safe(self, get_safe: ArkPCloudGetSafe) -&gt; ArkPCloudSafe:\n        \"\"\"\n        Retrieves a safe by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20Get%20Safes%20Details.htm\n\n        Args:\n            get_safe (ArkPCloudGetSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafe: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving safe by id [{get_safe.safe_id}]')\n        resp: Response = self._client.get(SAFE_URL.format(safe_id=get_safe.safe_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudSafe.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse safe response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse safe response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve safe [{resp.text}] - [{resp.status_code}]')\n\n    def safe_member(self, get_safe_member: ArkPCloudGetSafeMember) -&gt; ArkPCloudSafeMember:\n        \"\"\"\n        Retrieves a safe member by safe id and member name\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Member.htm\n\n        Args:\n            get_safe_member (ArkPCloudGetSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafeMember: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving safe member by safe [{get_safe_member.safe_id}] and member name [{get_safe_member.member_name}]')\n        resp: Response = self._client.get(SAFE_MEMBER_URL.format(safe_id=get_safe_member.safe_id, member_name=get_safe_member.member_name))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                safe_member = ArkPCloudSafeMember.model_validate(resp.json())\n                safe_member.permission_set = (\n                    [p for p in SAFE_MEMBER_PERMISSIONS_SETS.keys() if SAFE_MEMBER_PERMISSIONS_SETS[p] == safe_member.permissions]\n                    + [ArkPCloudSafeMemberPermissionSet.Custom]\n                )[0]\n                return safe_member\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse safe member response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse safe member response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve safe member [{resp.text}] - [{resp.status_code}]')\n\n    def add_safe(self, add_safe: ArkPCloudAddSafe) -&gt; ArkPCloudSafe:\n        \"\"\"\n        Adds a new safe with given details\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe.htm\n\n        Args:\n            add_safe (ArkPCloudAddSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafe: _description_\n        \"\"\"\n        self._logger.info('Adding new safe')\n        resp: Response = self._client.post(SAFES_URL, json=add_safe.model_dump(by_alias=True))\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkPCloudSafe.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add safe response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add safe response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add safe [{resp.text}] - [{resp.status_code}]')\n\n    def add_safe_member(self, add_safe_member: ArkPCloudAddSafeMember) -&gt; ArkPCloudSafeMember:\n        \"\"\"\n        Adds a new member to a safe by given safe id and member name, along with fitting permissions or permission set\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe%20Member.htm\n\n        Args:\n            add_safe_member (ArkPCloudAddSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafeMember: _description_\n        \"\"\"\n        self._logger.info(f'Adding new safe member for safe [{add_safe_member.safe_id}] and name [{add_safe_member.member_name}]')\n        if (\n            add_safe_member.permission_set\n            and add_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n            and not add_safe_member.permissions\n        ):\n            raise ArkServiceException('Custom permissions must have permissions model set')\n        if add_safe_member.permission_set and add_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n            add_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[add_safe_member.permission_set].model_copy()\n        resp: Response = self._client.post(\n            SAFE_MEMBERS_URL.format(safe_id=add_safe_member.safe_id),\n            json=add_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'permission_set'}),\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkPCloudSafeMember.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add safe member response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add safe member response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add safe member [{resp.text}] - [{resp.status_code}]')\n\n    def delete_safe(self, delete_safe: ArkPCloudDeleteSafe) -&gt; None:\n        \"\"\"\n        Deletes a safe by id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe.htm\n\n        Args:\n            delete_safe (ArkPCloudDeleteSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting safe [{delete_safe.safe_id}]')\n        resp: Response = self._client.delete(SAFE_URL.format(safe_id=delete_safe.safe_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete safe [{resp.text}] - [{resp.status_code}]')\n\n    def delete_safe_member(self, delete_safe_member: ArkPCloudDeleteSafeMember) -&gt; None:\n        \"\"\"\n        Deletes a safe member from a safe by safe id and name\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe%20Member.htm\n\n        Args:\n            delete_safe_member (ArkPCloudDeleteSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting safe member from safe [{delete_safe_member.safe_id}] with name [{delete_safe_member.member_name}]')\n        resp: Response = self._client.delete(\n            f'{SAFE_MEMBER_URL.format(safe_id=delete_safe_member.safe_id, member_name=delete_safe_member.member_name)}/'\n        )\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete safe member [{resp.text}] - [{resp.status_code}]')\n\n    def update_safe(self, update_safe: ArkPCloudUpdateSafe) -&gt; ArkPCloudSafe:\n        \"\"\"\n        Updates safe details by safe id\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe.htm\n\n        Args:\n            update_safe (ArkPCloudUpdateSafe): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafe: _description_\n        \"\"\"\n        self._logger.info(f'Updating safe [{update_safe.safe_id}]')\n        resp: Response = self._client.put(\n            SAFE_URL.format(safe_id=update_safe.safe_id), json=update_safe.model_dump(by_alias=True, exclude={'safe_id'}, exclude_none=True)\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudSafe.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update safe response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update safe response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update safe [{resp.text}] - [{resp.status_code}]')\n\n    def update_safe_member(self, update_safe_member: ArkPCloudUpdateSafeMember) -&gt; ArkPCloudSafeMember:\n        \"\"\"\n        Updates a safe member by safe id and member name\n        https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe%20Member.htm\n\n        Args:\n            update_safe_member (ArkPCloudUpdateSafeMember): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkPCloudSafeMember: _description_\n        \"\"\"\n        self._logger.info(f'Updating safe member of safe [{update_safe_member.safe_id}] and name [{update_safe_member.member_name}]')\n        if (\n            update_safe_member.permission_set\n            and update_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n            and not update_safe_member.permissions\n        ):\n            raise ArkServiceException('Custom permissions must have permissions model set')\n        if update_safe_member.permission_set and update_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n            update_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[update_safe_member.permission_set].model_copy()\n        resp: Response = self._client.put(\n            SAFE_MEMBER_URL.format(safe_id=update_safe_member.safe_id, member_name=update_safe_member.member_name),\n            json=update_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'member_name', 'permission_set'}, exclude_none=True),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkPCloudSafeMember.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update safe member response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update safe member response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update safe member [{resp.text}] - [{resp.status_code}]')\n\n    def safes_stats(self) -&gt; ArkPCloudSafesStats:\n        \"\"\"\n        Calculates safe stats\n\n        Returns:\n            ArkPCloudSafesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating safes statistics')\n        safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n        safes_stats = ArkPCloudSafesStats.model_construct()\n        safes_stats.safes_count = len(safes)\n\n        # Get safes per location\n        locations: Set[str] = {s.location for s in safes}\n        safes_stats.safes_count_by_location = {l: len([s for s in safes if s.location == l]) for l in locations}\n\n        # Get safes per creator\n        creators: Set[str] = {s.creator.name for s in safes}\n        safes_stats.safes_count_by_creator = {c: len([s for s in safes if s.creator.name == c]) for c in creators}\n\n        return safes_stats\n\n    def safe_members_stats(self, get_safe_members_stats: ArkPCloudGetSafeMembersStats) -&gt; ArkPCloudSafeMembersStats:\n        \"\"\"\n        Calculates safe members stats for a given safe\n\n        Args:\n            get_safe_members_stats (ArkPCloudGetSafeMembersStats): _description_\n\n        Returns:\n            ArkPCloudSafeMembersStats: _description_\n        \"\"\"\n        self._logger.info(f'Calculating safe members statistics for safe [{get_safe_members_stats.safe_id}]')\n        safe_members = list(\n            itertools.chain.from_iterable(\n                [p.items for p in list(self.list_safe_members(ArkPCloudListSafeMembers(safe_id=get_safe_members_stats.safe_id)))]\n            )\n        )\n        safe_members_stats = ArkPCloudSafeMembersStats.model_construct()\n        safe_members_stats.safe_members_count = len(safe_members)\n\n        # Get safe members count and names per permission set\n        permission_sets: Set[ArkPCloudSafeMemberPermissionSet] = {sm.permission_set for sm in safe_members}\n        safe_members_stats.safe_members_permission_sets = {\n            ps: ArkCountedValues(\n                count=len([sm for sm in safe_members if sm.permission_set == ps]),\n                values=[sm.member_name for sm in safe_members if sm.permission_set == ps],\n            )\n            for ps in permission_sets\n        }\n\n        # Get safe members count per type\n        member_types: Set[ArkPCloudSafeMemberType] = {sm.member_type for sm in safe_members}\n        safe_members_stats.safe_members_types_count = {mt: len([sm for sm in safe_members if sm.member_type == mt]) for mt in member_types}\n\n        return safe_members_stats\n\n    def safes_members_stats(self) -&gt; ArkPCloudSafesMembersStats:\n        \"\"\"\n        Calculates all safes members stats\n\n        Returns:\n            ArkPCloudSafesMembersStats: _description_\n        \"\"\"\n        self._logger.info('Calculating safes members statistics')\n        safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n        safes_members_stats = ArkPCloudSafesMembersStats.model_construct()\n        with ThreadPoolExecutor() as executor:\n            safe_members_stats_tuples = executor.map(\n                lambda s: (s.safe_name, self.safe_members_stats(ArkPCloudGetSafeMembersStats(safe_id=s.safe_id))), safes\n            )\n            safes_members_stats.safe_members_stats = dict((a, b) for a, b in safe_members_stats_tuples)\n        return safes_members_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.add_safe","title":"<code>add_safe(add_safe)</code>","text":"<p>Adds a new safe with given details https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_safe</code> <code>ArkPCloudAddSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafe</code> <code>ArkPCloudSafe</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def add_safe(self, add_safe: ArkPCloudAddSafe) -&gt; ArkPCloudSafe:\n    \"\"\"\n    Adds a new safe with given details\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe.htm\n\n    Args:\n        add_safe (ArkPCloudAddSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafe: _description_\n    \"\"\"\n    self._logger.info('Adding new safe')\n    resp: Response = self._client.post(SAFES_URL, json=add_safe.model_dump(by_alias=True))\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkPCloudSafe.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add safe response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add safe response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.add_safe_member","title":"<code>add_safe_member(add_safe_member)</code>","text":"<p>Adds a new member to a safe by given safe id and member name, along with fitting permissions or permission set https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>add_safe_member</code> <code>ArkPCloudAddSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMember</code> <code>ArkPCloudSafeMember</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def add_safe_member(self, add_safe_member: ArkPCloudAddSafeMember) -&gt; ArkPCloudSafeMember:\n    \"\"\"\n    Adds a new member to a safe by given safe id and member name, along with fitting permissions or permission set\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Add%20Safe%20Member.htm\n\n    Args:\n        add_safe_member (ArkPCloudAddSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafeMember: _description_\n    \"\"\"\n    self._logger.info(f'Adding new safe member for safe [{add_safe_member.safe_id}] and name [{add_safe_member.member_name}]')\n    if (\n        add_safe_member.permission_set\n        and add_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n        and not add_safe_member.permissions\n    ):\n        raise ArkServiceException('Custom permissions must have permissions model set')\n    if add_safe_member.permission_set and add_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n        add_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[add_safe_member.permission_set].model_copy()\n    resp: Response = self._client.post(\n        SAFE_MEMBERS_URL.format(safe_id=add_safe_member.safe_id),\n        json=add_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'permission_set'}),\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkPCloudSafeMember.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add safe member response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add safe member response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.delete_safe","title":"<code>delete_safe(delete_safe)</code>","text":"<p>Deletes a safe by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_safe</code> <code>ArkPCloudDeleteSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def delete_safe(self, delete_safe: ArkPCloudDeleteSafe) -&gt; None:\n    \"\"\"\n    Deletes a safe by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe.htm\n\n    Args:\n        delete_safe (ArkPCloudDeleteSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting safe [{delete_safe.safe_id}]')\n    resp: Response = self._client.delete(SAFE_URL.format(safe_id=delete_safe.safe_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.delete_safe_member","title":"<code>delete_safe_member(delete_safe_member)</code>","text":"<p>Deletes a safe member from a safe by safe id and name https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>delete_safe_member</code> <code>ArkPCloudDeleteSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def delete_safe_member(self, delete_safe_member: ArkPCloudDeleteSafeMember) -&gt; None:\n    \"\"\"\n    Deletes a safe member from a safe by safe id and name\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Delete%20Safe%20Member.htm\n\n    Args:\n        delete_safe_member (ArkPCloudDeleteSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting safe member from safe [{delete_safe_member.safe_id}] with name [{delete_safe_member.member_name}]')\n    resp: Response = self._client.delete(\n        f'{SAFE_MEMBER_URL.format(safe_id=delete_safe_member.safe_id, member_name=delete_safe_member.member_name)}/'\n    )\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.list_safe_members","title":"<code>list_safe_members(list_safe_members)</code>","text":"<p>Lists all safe mmebers of a given safe that are visible to the logged in user as pages of safe members https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm</p> <p>Parameters:</p> Name Type Description Default <code>list_safe_members</code> <code>ArkPCloudListSafeMembers</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkPCloudSafeMembersPage</code> <p>Iterator[ArkPCloudSafeMembersPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safe_members(self, list_safe_members: ArkPCloudListSafeMembers) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n    \"\"\"\n    Lists all safe mmebers of a given safe that are visible to the logged in user as pages of safe members\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n    Args:\n        list_safe_members (ArkPCloudListSafeMembers): _description_\n\n    Yields:\n        Iterator[ArkPCloudSafeMembersPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all safe members')\n    yield from self.__list_safe_members_with_filters(list_safe_members.safe_id)\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.list_safe_members_by","title":"<code>list_safe_members_by(safe_members_filter)</code>","text":"<p>Lists safe mmebers of a given safe that are visible to the logged in user by filters as pages of safe members https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm</p> <p>Parameters:</p> Name Type Description Default <code>safe_members_filter</code> <code>ArkPCloudSafeMembersFilters</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkPCloudSafeMembersPage</code> <p>Iterator[ArkPCloudSafeMembersPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safe_members_by(self, safe_members_filter: ArkPCloudSafeMembersFilters) -&gt; Iterator[ArkPCloudSafeMembersPage]:\n    \"\"\"\n    Lists safe mmebers of a given safe that are visible to the logged in user by filters as pages of safe members\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Members.htm\n\n    Args:\n        safe_members_filter (ArkPCloudSafeMembersFilters): _description_\n\n    Yields:\n        Iterator[ArkPCloudSafeMembersPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing safe members by filter [{safe_members_filter}]')\n    yield from self.__list_safe_members_with_filters(\n        safe_members_filter.safe_id,\n        safe_members_filter.search,\n        safe_members_filter.sort,\n        safe_members_filter.offset,\n        safe_members_filter.limit,\n        safe_members_filter.member_type,\n    )\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.list_safes","title":"<code>list_safes()</code>","text":"<p>Lists all the visible safes of the logged in user as pages of safes https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?</p> <p>Yields:</p> Type Description <code>ArkPCloudSafesPage</code> <p>Iterator[ArkPCloudSafesPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safes(self) -&gt; Iterator[ArkPCloudSafesPage]:\n    \"\"\"\n    Lists all the visible safes of the logged in user as pages of safes\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n    Yields:\n        Iterator[ArkPCloudSafesPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all safes')\n    yield from self.__list_safes_with_filters()\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.list_safes_by","title":"<code>list_safes_by(safes_filter)</code>","text":"<p>Lists the visible safes of the logged in user by filters as pages of safes https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?</p> <p>Yields:</p> Type Description <code>ArkPCloudSafesPage</code> <p>Iterator[ArkPCloudSafesPage]: description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def list_safes_by(self, safes_filter: ArkPCloudSafesFilters) -&gt; Iterator[ArkPCloudSafesPage]:\n    \"\"\"\n    Lists the visible safes of the logged in user by filters as pages of safes\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20List%20Safes.htm?\n\n    Yields:\n        Iterator[ArkPCloudSafesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing safes by filter [{safes_filter}]')\n    yield from self.__list_safes_with_filters(safes_filter.search, safes_filter.sort, safes_filter.offset, safes_filter.limit)\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.safe","title":"<code>safe(get_safe)</code>","text":"<p>Retrieves a safe by id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20Get%20Safes%20Details.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_safe</code> <code>ArkPCloudGetSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafe</code> <code>ArkPCloudSafe</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safe(self, get_safe: ArkPCloudGetSafe) -&gt; ArkPCloudSafe:\n    \"\"\"\n    Retrieves a safe by id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safes%20Web%20Services%20-%20Get%20Safes%20Details.htm\n\n    Args:\n        get_safe (ArkPCloudGetSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafe: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving safe by id [{get_safe.safe_id}]')\n    resp: Response = self._client.get(SAFE_URL.format(safe_id=get_safe.safe_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudSafe.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse safe response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse safe response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.safe_member","title":"<code>safe_member(get_safe_member)</code>","text":"<p>Retrieves a safe member by safe id and member name https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>get_safe_member</code> <code>ArkPCloudGetSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMember</code> <code>ArkPCloudSafeMember</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safe_member(self, get_safe_member: ArkPCloudGetSafeMember) -&gt; ArkPCloudSafeMember:\n    \"\"\"\n    Retrieves a safe member by safe id and member name\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/SDK/Safe%20Members%20WS%20-%20List%20Safe%20Member.htm\n\n    Args:\n        get_safe_member (ArkPCloudGetSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafeMember: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving safe member by safe [{get_safe_member.safe_id}] and member name [{get_safe_member.member_name}]')\n    resp: Response = self._client.get(SAFE_MEMBER_URL.format(safe_id=get_safe_member.safe_id, member_name=get_safe_member.member_name))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            safe_member = ArkPCloudSafeMember.model_validate(resp.json())\n            safe_member.permission_set = (\n                [p for p in SAFE_MEMBER_PERMISSIONS_SETS.keys() if SAFE_MEMBER_PERMISSIONS_SETS[p] == safe_member.permissions]\n                + [ArkPCloudSafeMemberPermissionSet.Custom]\n            )[0]\n            return safe_member\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse safe member response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse safe member response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.safe_members_stats","title":"<code>safe_members_stats(get_safe_members_stats)</code>","text":"<p>Calculates safe members stats for a given safe</p> <p>Parameters:</p> Name Type Description Default <code>get_safe_members_stats</code> <code>ArkPCloudGetSafeMembersStats</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMembersStats</code> <code>ArkPCloudSafeMembersStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safe_members_stats(self, get_safe_members_stats: ArkPCloudGetSafeMembersStats) -&gt; ArkPCloudSafeMembersStats:\n    \"\"\"\n    Calculates safe members stats for a given safe\n\n    Args:\n        get_safe_members_stats (ArkPCloudGetSafeMembersStats): _description_\n\n    Returns:\n        ArkPCloudSafeMembersStats: _description_\n    \"\"\"\n    self._logger.info(f'Calculating safe members statistics for safe [{get_safe_members_stats.safe_id}]')\n    safe_members = list(\n        itertools.chain.from_iterable(\n            [p.items for p in list(self.list_safe_members(ArkPCloudListSafeMembers(safe_id=get_safe_members_stats.safe_id)))]\n        )\n    )\n    safe_members_stats = ArkPCloudSafeMembersStats.model_construct()\n    safe_members_stats.safe_members_count = len(safe_members)\n\n    # Get safe members count and names per permission set\n    permission_sets: Set[ArkPCloudSafeMemberPermissionSet] = {sm.permission_set for sm in safe_members}\n    safe_members_stats.safe_members_permission_sets = {\n        ps: ArkCountedValues(\n            count=len([sm for sm in safe_members if sm.permission_set == ps]),\n            values=[sm.member_name for sm in safe_members if sm.permission_set == ps],\n        )\n        for ps in permission_sets\n    }\n\n    # Get safe members count per type\n    member_types: Set[ArkPCloudSafeMemberType] = {sm.member_type for sm in safe_members}\n    safe_members_stats.safe_members_types_count = {mt: len([sm for sm in safe_members if sm.member_type == mt]) for mt in member_types}\n\n    return safe_members_stats\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.safes_members_stats","title":"<code>safes_members_stats()</code>","text":"<p>Calculates all safes members stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafesMembersStats</code> <code>ArkPCloudSafesMembersStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safes_members_stats(self) -&gt; ArkPCloudSafesMembersStats:\n    \"\"\"\n    Calculates all safes members stats\n\n    Returns:\n        ArkPCloudSafesMembersStats: _description_\n    \"\"\"\n    self._logger.info('Calculating safes members statistics')\n    safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n    safes_members_stats = ArkPCloudSafesMembersStats.model_construct()\n    with ThreadPoolExecutor() as executor:\n        safe_members_stats_tuples = executor.map(\n            lambda s: (s.safe_name, self.safe_members_stats(ArkPCloudGetSafeMembersStats(safe_id=s.safe_id))), safes\n        )\n        safes_members_stats.safe_members_stats = dict((a, b) for a, b in safe_members_stats_tuples)\n    return safes_members_stats\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.safes_stats","title":"<code>safes_stats()</code>","text":"<p>Calculates safe stats</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafesStats</code> <code>ArkPCloudSafesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def safes_stats(self) -&gt; ArkPCloudSafesStats:\n    \"\"\"\n    Calculates safe stats\n\n    Returns:\n        ArkPCloudSafesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating safes statistics')\n    safes = list(itertools.chain.from_iterable([p.items for p in list(self.list_safes())]))\n    safes_stats = ArkPCloudSafesStats.model_construct()\n    safes_stats.safes_count = len(safes)\n\n    # Get safes per location\n    locations: Set[str] = {s.location for s in safes}\n    safes_stats.safes_count_by_location = {l: len([s for s in safes if s.location == l]) for l in locations}\n\n    # Get safes per creator\n    creators: Set[str] = {s.creator.name for s in safes}\n    safes_stats.safes_count_by_creator = {c: len([s for s in safes if s.creator.name == c]) for c in creators}\n\n    return safes_stats\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.update_safe","title":"<code>update_safe(update_safe)</code>","text":"<p>Updates safe details by safe id https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_safe</code> <code>ArkPCloudUpdateSafe</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafe</code> <code>ArkPCloudSafe</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def update_safe(self, update_safe: ArkPCloudUpdateSafe) -&gt; ArkPCloudSafe:\n    \"\"\"\n    Updates safe details by safe id\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe.htm\n\n    Args:\n        update_safe (ArkPCloudUpdateSafe): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafe: _description_\n    \"\"\"\n    self._logger.info(f'Updating safe [{update_safe.safe_id}]')\n    resp: Response = self._client.put(\n        SAFE_URL.format(safe_id=update_safe.safe_id), json=update_safe.model_dump(by_alias=True, exclude={'safe_id'}, exclude_none=True)\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudSafe.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update safe response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update safe response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update safe [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/pcloud/safes/ark_pcloud_safes_service/#ark_sdk_python.services.pcloud.safes.ark_pcloud_safes_service.ArkPCloudSafesService.update_safe_member","title":"<code>update_safe_member(update_safe_member)</code>","text":"<p>Updates a safe member by safe id and member name https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe%20Member.htm</p> <p>Parameters:</p> Name Type Description Default <code>update_safe_member</code> <code>ArkPCloudUpdateSafeMember</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkPCloudSafeMember</code> <code>ArkPCloudSafeMember</code> <p>description</p> Source code in <code>ark_sdk_python/services/pcloud/safes/ark_pcloud_safes_service.py</code> <pre><code>def update_safe_member(self, update_safe_member: ArkPCloudUpdateSafeMember) -&gt; ArkPCloudSafeMember:\n    \"\"\"\n    Updates a safe member by safe id and member name\n    https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/Update%20Safe%20Member.htm\n\n    Args:\n        update_safe_member (ArkPCloudUpdateSafeMember): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkPCloudSafeMember: _description_\n    \"\"\"\n    self._logger.info(f'Updating safe member of safe [{update_safe_member.safe_id}] and name [{update_safe_member.member_name}]')\n    if (\n        update_safe_member.permission_set\n        and update_safe_member.permission_set == ArkPCloudSafeMemberPermissionSet.Custom\n        and not update_safe_member.permissions\n    ):\n        raise ArkServiceException('Custom permissions must have permissions model set')\n    if update_safe_member.permission_set and update_safe_member.permission_set != ArkPCloudSafeMemberPermissionSet.Custom:\n        update_safe_member.permissions = SAFE_MEMBER_PERMISSIONS_SETS[update_safe_member.permission_set].model_copy()\n    resp: Response = self._client.put(\n        SAFE_MEMBER_URL.format(safe_id=update_safe_member.safe_id, member_name=update_safe_member.member_name),\n        json=update_safe_member.model_dump(by_alias=True, exclude={'safe_id', 'member_name', 'permission_set'}, exclude_none=True),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkPCloudSafeMember.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update safe member response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update safe member response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update safe member [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/","title":"sia","text":""},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI","title":"<code>ArkSIAAPI</code>","text":"Source code in <code>ark_sdk_python/services/sia/ark_sia_api.py</code> <pre><code>class ArkSIAAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__db_workspace_service = ArkSIADBWorkspaceService(isp_auth)\n        self.__targetsets_workspace_service = ArkSIATargetSetsWorkspaceService(isp_auth)\n        self.__vm_policies_service = ArkSIAVMPoliciesService(isp_auth)\n        self.__db_policies_service = ArkSIADBPoliciesService(isp_auth)\n        self.__db_secrets_service = ArkSIADBSecretsService(isp_auth)\n        self.__vm_secrets_service = ArkSIAVMSecretsService(isp_auth)\n        self.__sso_service = ArkSIASSOService(isp_auth)\n        self.__db_service = ArkSIADBService(isp_auth)\n        self.__certificates_service = ArkSIACertificatesService(isp_auth)\n        self.__k8s_service = ArkSIAK8SService(isp_auth)\n        self.__access_service = ArkSIAAccessService(isp_auth)\n\n    @property\n    def workspace_db(self) -&gt; ArkSIADBWorkspaceService:\n        \"\"\"\n        Getter for the DB workspace service.\n\n        Returns:\n            ArkSIADBWorkspaceService: _description_\n        \"\"\"\n        return self.__db_workspace_service\n\n    @property\n    def workspace_target_sets(self) -&gt; ArkSIATargetSetsWorkspaceService:\n        \"\"\"\n        Getter for the Target Sets workspace service.\n\n        Returns:\n            ArkSIATargetSetsWorkspaceService: _description_\n        \"\"\"\n        return self.__targetsets_workspace_service\n\n    @property\n    def access(self) -&gt; ArkSIAAccessService:\n        \"\"\"\n        Getter for the Access service\n\n        Returns:\n            ArkSIAAccessService: _description_\n        \"\"\"\n        return self.__access_service\n\n    @property\n    def policies_vm(self) -&gt; ArkSIAVMPoliciesService:\n        \"\"\"\n        Getter for the VM policies service.\n\n        Returns:\n            ArkSIAVMPoliciesService: _description_\n        \"\"\"\n        return self.__vm_policies_service\n\n    @property\n    def policies_db(self) -&gt; ArkSIADBPoliciesService:\n        \"\"\"\n        Getter for the DB policies service.\n\n        Returns:\n            ArkSIADBPoliciesService: _description_\n        \"\"\"\n        return self.__db_policies_service\n\n    @property\n    def secrets_db(self) -&gt; ArkSIADBSecretsService:\n        \"\"\"\n        Getter for the DB secrets service.\n\n        Returns:\n            ArkSIADBSecretsService: _description_\n        \"\"\"\n        return self.__db_secrets_service\n\n    @property\n    def secrets_vm(self) -&gt; ArkSIADBSecretsService:\n        \"\"\"\n        Getter for the VM secrets service.\n\n        Returns:\n            ArkSIAVMSecretsService: _description_\n        \"\"\"\n        return self.__vm_secrets_service\n\n    @property\n    def sso(self) -&gt; ArkSIASSOService:\n        \"\"\"\n        Getter for the SSO service.\n\n        Returns:\n            ArkSIASSOService: _description_\n        \"\"\"\n        return self.__sso_service\n\n    @property\n    def db(self) -&gt; ArkSIADBService:\n        \"\"\"\n        Getter for the DB service.\n\n        Returns:\n            ArkSIADBService: _description_\n        \"\"\"\n        return self.__db_service\n\n    @property\n    def certificates(self) -&gt; ArkSIACertificatesService:\n        \"\"\"\n        Getter for the certificates service.\n\n        Returns:\n            ArkSIACertificatesService: _description_\n        \"\"\"\n        return self.__certificates_service\n\n    @property\n    def k8s(self) -&gt; ArkSIAK8SService:\n        \"\"\"\n        Getter for the K8s service.\n\n        Returns:\n            ArkSIAK8SService: _description_\n        \"\"\"\n        return self.__k8s_service\n</code></pre>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.access","title":"<code>access</code>  <code>property</code>","text":"<p>Getter for the Access service</p> <p>Returns:</p> Name Type Description <code>ArkSIAAccessService</code> <code>ArkSIAAccessService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.certificates","title":"<code>certificates</code>  <code>property</code>","text":"<p>Getter for the certificates service.</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificatesService</code> <code>ArkSIACertificatesService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.db","title":"<code>db</code>  <code>property</code>","text":"<p>Getter for the DB service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBService</code> <code>ArkSIADBService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.k8s","title":"<code>k8s</code>  <code>property</code>","text":"<p>Getter for the K8s service.</p> <p>Returns:</p> Name Type Description <code>ArkSIAK8SService</code> <code>ArkSIAK8SService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.policies_db","title":"<code>policies_db</code>  <code>property</code>","text":"<p>Getter for the DB policies service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesService</code> <code>ArkSIADBPoliciesService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.policies_vm","title":"<code>policies_vm</code>  <code>property</code>","text":"<p>Getter for the VM policies service.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesService</code> <code>ArkSIAVMPoliciesService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.secrets_db","title":"<code>secrets_db</code>  <code>property</code>","text":"<p>Getter for the DB secrets service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretsService</code> <code>ArkSIADBSecretsService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.secrets_vm","title":"<code>secrets_vm</code>  <code>property</code>","text":"<p>Getter for the VM secrets service.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecretsService</code> <code>ArkSIADBSecretsService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.sso","title":"<code>sso</code>  <code>property</code>","text":"<p>Getter for the SSO service.</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOService</code> <code>ArkSIASSOService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.workspace_db","title":"<code>workspace_db</code>  <code>property</code>","text":"<p>Getter for the DB workspace service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBWorkspaceService</code> <code>ArkSIADBWorkspaceService</code> <p>description</p>"},{"location":"reference/services/sia/#ark_sdk_python.services.sia.ArkSIAAPI.workspace_target_sets","title":"<code>workspace_target_sets</code>  <code>property</code>","text":"<p>Getter for the Target Sets workspace service.</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSetsWorkspaceService</code> <code>ArkSIATargetSetsWorkspaceService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/","title":"ark_sia_api","text":""},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI","title":"<code>ArkSIAAPI</code>","text":"Source code in <code>ark_sdk_python/services/sia/ark_sia_api.py</code> <pre><code>class ArkSIAAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__db_workspace_service = ArkSIADBWorkspaceService(isp_auth)\n        self.__targetsets_workspace_service = ArkSIATargetSetsWorkspaceService(isp_auth)\n        self.__vm_policies_service = ArkSIAVMPoliciesService(isp_auth)\n        self.__db_policies_service = ArkSIADBPoliciesService(isp_auth)\n        self.__db_secrets_service = ArkSIADBSecretsService(isp_auth)\n        self.__vm_secrets_service = ArkSIAVMSecretsService(isp_auth)\n        self.__sso_service = ArkSIASSOService(isp_auth)\n        self.__db_service = ArkSIADBService(isp_auth)\n        self.__certificates_service = ArkSIACertificatesService(isp_auth)\n        self.__k8s_service = ArkSIAK8SService(isp_auth)\n        self.__access_service = ArkSIAAccessService(isp_auth)\n\n    @property\n    def workspace_db(self) -&gt; ArkSIADBWorkspaceService:\n        \"\"\"\n        Getter for the DB workspace service.\n\n        Returns:\n            ArkSIADBWorkspaceService: _description_\n        \"\"\"\n        return self.__db_workspace_service\n\n    @property\n    def workspace_target_sets(self) -&gt; ArkSIATargetSetsWorkspaceService:\n        \"\"\"\n        Getter for the Target Sets workspace service.\n\n        Returns:\n            ArkSIATargetSetsWorkspaceService: _description_\n        \"\"\"\n        return self.__targetsets_workspace_service\n\n    @property\n    def access(self) -&gt; ArkSIAAccessService:\n        \"\"\"\n        Getter for the Access service\n\n        Returns:\n            ArkSIAAccessService: _description_\n        \"\"\"\n        return self.__access_service\n\n    @property\n    def policies_vm(self) -&gt; ArkSIAVMPoliciesService:\n        \"\"\"\n        Getter for the VM policies service.\n\n        Returns:\n            ArkSIAVMPoliciesService: _description_\n        \"\"\"\n        return self.__vm_policies_service\n\n    @property\n    def policies_db(self) -&gt; ArkSIADBPoliciesService:\n        \"\"\"\n        Getter for the DB policies service.\n\n        Returns:\n            ArkSIADBPoliciesService: _description_\n        \"\"\"\n        return self.__db_policies_service\n\n    @property\n    def secrets_db(self) -&gt; ArkSIADBSecretsService:\n        \"\"\"\n        Getter for the DB secrets service.\n\n        Returns:\n            ArkSIADBSecretsService: _description_\n        \"\"\"\n        return self.__db_secrets_service\n\n    @property\n    def secrets_vm(self) -&gt; ArkSIADBSecretsService:\n        \"\"\"\n        Getter for the VM secrets service.\n\n        Returns:\n            ArkSIAVMSecretsService: _description_\n        \"\"\"\n        return self.__vm_secrets_service\n\n    @property\n    def sso(self) -&gt; ArkSIASSOService:\n        \"\"\"\n        Getter for the SSO service.\n\n        Returns:\n            ArkSIASSOService: _description_\n        \"\"\"\n        return self.__sso_service\n\n    @property\n    def db(self) -&gt; ArkSIADBService:\n        \"\"\"\n        Getter for the DB service.\n\n        Returns:\n            ArkSIADBService: _description_\n        \"\"\"\n        return self.__db_service\n\n    @property\n    def certificates(self) -&gt; ArkSIACertificatesService:\n        \"\"\"\n        Getter for the certificates service.\n\n        Returns:\n            ArkSIACertificatesService: _description_\n        \"\"\"\n        return self.__certificates_service\n\n    @property\n    def k8s(self) -&gt; ArkSIAK8SService:\n        \"\"\"\n        Getter for the K8s service.\n\n        Returns:\n            ArkSIAK8SService: _description_\n        \"\"\"\n        return self.__k8s_service\n</code></pre>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.access","title":"<code>access</code>  <code>property</code>","text":"<p>Getter for the Access service</p> <p>Returns:</p> Name Type Description <code>ArkSIAAccessService</code> <code>ArkSIAAccessService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.certificates","title":"<code>certificates</code>  <code>property</code>","text":"<p>Getter for the certificates service.</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificatesService</code> <code>ArkSIACertificatesService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.db","title":"<code>db</code>  <code>property</code>","text":"<p>Getter for the DB service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBService</code> <code>ArkSIADBService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.k8s","title":"<code>k8s</code>  <code>property</code>","text":"<p>Getter for the K8s service.</p> <p>Returns:</p> Name Type Description <code>ArkSIAK8SService</code> <code>ArkSIAK8SService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.policies_db","title":"<code>policies_db</code>  <code>property</code>","text":"<p>Getter for the DB policies service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesService</code> <code>ArkSIADBPoliciesService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.policies_vm","title":"<code>policies_vm</code>  <code>property</code>","text":"<p>Getter for the VM policies service.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesService</code> <code>ArkSIAVMPoliciesService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.secrets_db","title":"<code>secrets_db</code>  <code>property</code>","text":"<p>Getter for the DB secrets service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretsService</code> <code>ArkSIADBSecretsService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.secrets_vm","title":"<code>secrets_vm</code>  <code>property</code>","text":"<p>Getter for the VM secrets service.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecretsService</code> <code>ArkSIADBSecretsService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.sso","title":"<code>sso</code>  <code>property</code>","text":"<p>Getter for the SSO service.</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOService</code> <code>ArkSIASSOService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.workspace_db","title":"<code>workspace_db</code>  <code>property</code>","text":"<p>Getter for the DB workspace service.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBWorkspaceService</code> <code>ArkSIADBWorkspaceService</code> <p>description</p>"},{"location":"reference/services/sia/ark_sia_api/#ark_sdk_python.services.sia.ark_sia_api.ArkSIAAPI.workspace_target_sets","title":"<code>workspace_target_sets</code>  <code>property</code>","text":"<p>Getter for the Target Sets workspace service.</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSetsWorkspaceService</code> <code>ArkSIATargetSetsWorkspaceService</code> <p>description</p>"},{"location":"reference/services/sia/access/","title":"access","text":""},{"location":"reference/services/sia/access/#ark_sdk_python.services.sia.access.ArkSIAAccessService","title":"<code>ArkSIAAccessService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>class ArkSIAAccessService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __create_connection(\n        self,\n        os_type: ArkOsType,\n        target_machine: str,\n        username: str,\n        password: Optional[str] = None,\n        private_key_path: Optional[str] = None,\n        private_key_contents: Optional[str] = None,\n    ) -&gt; Tuple[ArkConnection, Dict[str, str]]:\n        if os_type == ArkOsType.WINDOWS:\n            connection = ArkWinRMConnection()\n            connection_details = ArkConnectionDetails(\n                address=target_machine,\n                port=WINRM_HTTPS_PORT,\n                connection_type=ArkConnectionType.WinRM,\n                credentials=ArkConnectionCredentials(user=username, password=password),\n                connection_data=ArkWinRMConnectionData(),\n            )\n        else:\n            connection = ArkSSHConnection()\n            connection_details = ArkConnectionDetails(\n                address=target_machine,\n                port=SSH_PORT,\n                connection_type=ArkConnectionType.SSH,\n                credentials=ArkConnectionCredentials(\n                    user=username, password=password, private_key_filepath=private_key_path, private_key_contents=private_key_contents\n                ),\n                connection_data=ArkSSHConnectionData(),\n            )\n        connection.connect(connection_details)\n        return connection, CONNECTOR_CMDSET[os_type]\n\n    def __install_connector_on_machine(\n        self,\n        install_script: str,\n        os_type: ArkOsType,\n        target_machine: str,\n        username: str,\n        password: Optional[str] = None,\n        private_key_path: Optional[str] = None,\n        private_key_contents: Optional[str] = None,\n    ) -&gt; str:\n        connection, cmdset = self.__create_connection(os_type, target_machine, username, password, private_key_path, private_key_contents)\n        connection.run_command(ArkConnectionCommand(command=cmdset['stop-connector-service'], raise_on_error=False))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-service'], raise_on_error=False))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-files'], raise_on_error=False))\n        if os_type == ArkOsType.WINDOWS:\n            connection.run_command(ArkConnectionCommand(command=install_script, extra_command_data={'force_command_split': True}))\n        else:\n            connection.run_command(ArkConnectionCommand(command=install_script))\n        retry_count = CONNECTOR_READY_RETRY_COUNT\n        while True:\n            try:\n                connection.run_command(ArkConnectionCommand(command=cmdset['connector-active']))\n                break\n            except ArkException as ex:\n                self._logger.exception(f'Failed to check whether a connector is active [{str(ex)}]')\n                if retry_count &gt; 0:\n                    retry_count = retry_count - 1\n                    self._logger.info(\n                        f'Retrying to check if connector is active, sleeping for '\n                        f'[{CONNECTOR_RETRY_TICK_SECONDS}] and retrying, retries left [{retry_count}]'\n                    )\n                    time.sleep(CONNECTOR_RETRY_TICK_SECONDS)\n                    continue\n                raise\n        result = connection.run_command(ArkConnectionCommand(command=cmdset['read-connector-config']))\n        connector_config = json.loads(str(result.stdout).strip())\n        return connector_config['Id']\n\n    def __uninstall_connector_on_machine(\n        self,\n        os_type: ArkOsType,\n        target_machine: str,\n        username: str,\n        password: Optional[str] = None,\n        private_key_path: Optional[str] = None,\n        private_key_contents: Optional[str] = None,\n    ) -&gt; None:\n        connection, cmdset = self.__create_connection(os_type, target_machine, username, password, private_key_path, private_key_contents)\n        connection.run_command(ArkConnectionCommand(command=cmdset['stop-connector-service']))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-service']))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-files']))\n\n    def connector_setup_script(self, get_connector_setup_script: ArkSIAGetConnectorSetupScript) -&gt; ArkSIAConnectorSetupScript:\n        \"\"\"\n        Retrieves a new connector installation setup script\n\n        Args:\n            get_connector_setup_script (ArkSIAGetConnectorSetupScript): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAConnectorSetupScript: _description_\n        \"\"\"\n        self._logger.info('Retrieving new connector setup script')\n        get_connector_setup_script_dict = get_connector_setup_script.model_dump(exclude_none=True)\n        get_connector_setup_script_dict['connector_type'] = serialize_access_workspace_type(get_connector_setup_script.connector_type)\n        resp: Response = self.__client.post(CONNECTORS_SETUP_SCRIPT_API, json=get_connector_setup_script_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkSIAConnectorSetupScript.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse connector setup script response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse connector setup script response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve connector setup script [{resp.text}] - [{resp.status_code}]')\n\n    def install_connector(self, install_connector: ArkSIAInstallConnector) -&gt; str:\n        \"\"\"\n        Gets a connector installation script\n        Afterwards, installs a connector on the remote machine based on the given parameters\n        Uses WinRM on windows os type\n        Uses SSH on linux / darwin os type\n\n        Args:\n            install_connector (ArkSIAInstallConnector): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        self._logger.info(\n            f'Installing connector on machine [{install_connector.target_machine}] of type [{install_connector.connector_os}]'\n        )\n        installation_script = self.connector_setup_script(\n            ArkSIAGetConnectorSetupScript(\n                connector_os=install_connector.connector_os,\n                connector_pool_id=install_connector.connector_pool_id,\n                connector_type=install_connector.connector_type,\n            )\n        )\n        return self.__install_connector_on_machine(\n            install_script=installation_script.bash_cmd,\n            os_type=install_connector.connector_os,\n            target_machine=install_connector.target_machine,\n            username=install_connector.username,\n            password=install_connector.password.get_secret_value() if install_connector.password else None,\n            private_key_path=install_connector.private_key_path,\n            private_key_contents=(\n                install_connector.private_key_contents.get_secret_value() if install_connector.private_key_contents else None\n            ),\n        )\n\n    def uninstall_connector(self, uninstall_connector: ArkSIAUninstallConnector) -&gt; None:\n        \"\"\"\n        Uninstalls a connector on the remote machine based on the given parameters\n        Uses WinRM on windows os type\n        Uses SSH on linux / darwin os type\n\n        Args:\n            uninstall_connector (ArkSIAUninstallConnector): _description_\n        \"\"\"\n        self._logger.info(f'Uninstalling connector [{uninstall_connector.connector_id}] from machine')\n        self.__uninstall_connector_on_machine(\n            uninstall_connector.connector_os,\n            uninstall_connector.target_machine,\n            uninstall_connector.username,\n            uninstall_connector.password.get_secret_value() if uninstall_connector.password else None,\n            uninstall_connector.private_key_path,\n            uninstall_connector.private_key_contents,\n        )\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/access/#ark_sdk_python.services.sia.access.ArkSIAAccessService.connector_setup_script","title":"<code>connector_setup_script(get_connector_setup_script)</code>","text":"<p>Retrieves a new connector installation setup script</p> <p>Parameters:</p> Name Type Description Default <code>get_connector_setup_script</code> <code>ArkSIAGetConnectorSetupScript</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAConnectorSetupScript</code> <code>ArkSIAConnectorSetupScript</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>def connector_setup_script(self, get_connector_setup_script: ArkSIAGetConnectorSetupScript) -&gt; ArkSIAConnectorSetupScript:\n    \"\"\"\n    Retrieves a new connector installation setup script\n\n    Args:\n        get_connector_setup_script (ArkSIAGetConnectorSetupScript): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAConnectorSetupScript: _description_\n    \"\"\"\n    self._logger.info('Retrieving new connector setup script')\n    get_connector_setup_script_dict = get_connector_setup_script.model_dump(exclude_none=True)\n    get_connector_setup_script_dict['connector_type'] = serialize_access_workspace_type(get_connector_setup_script.connector_type)\n    resp: Response = self.__client.post(CONNECTORS_SETUP_SCRIPT_API, json=get_connector_setup_script_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkSIAConnectorSetupScript.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse connector setup script response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse connector setup script response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve connector setup script [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/access/#ark_sdk_python.services.sia.access.ArkSIAAccessService.install_connector","title":"<code>install_connector(install_connector)</code>","text":"<p>Gets a connector installation script Afterwards, installs a connector on the remote machine based on the given parameters Uses WinRM on windows os type Uses SSH on linux / darwin os type</p> <p>Parameters:</p> Name Type Description Default <code>install_connector</code> <code>ArkSIAInstallConnector</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>def install_connector(self, install_connector: ArkSIAInstallConnector) -&gt; str:\n    \"\"\"\n    Gets a connector installation script\n    Afterwards, installs a connector on the remote machine based on the given parameters\n    Uses WinRM on windows os type\n    Uses SSH on linux / darwin os type\n\n    Args:\n        install_connector (ArkSIAInstallConnector): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    self._logger.info(\n        f'Installing connector on machine [{install_connector.target_machine}] of type [{install_connector.connector_os}]'\n    )\n    installation_script = self.connector_setup_script(\n        ArkSIAGetConnectorSetupScript(\n            connector_os=install_connector.connector_os,\n            connector_pool_id=install_connector.connector_pool_id,\n            connector_type=install_connector.connector_type,\n        )\n    )\n    return self.__install_connector_on_machine(\n        install_script=installation_script.bash_cmd,\n        os_type=install_connector.connector_os,\n        target_machine=install_connector.target_machine,\n        username=install_connector.username,\n        password=install_connector.password.get_secret_value() if install_connector.password else None,\n        private_key_path=install_connector.private_key_path,\n        private_key_contents=(\n            install_connector.private_key_contents.get_secret_value() if install_connector.private_key_contents else None\n        ),\n    )\n</code></pre>"},{"location":"reference/services/sia/access/#ark_sdk_python.services.sia.access.ArkSIAAccessService.uninstall_connector","title":"<code>uninstall_connector(uninstall_connector)</code>","text":"<p>Uninstalls a connector on the remote machine based on the given parameters Uses WinRM on windows os type Uses SSH on linux / darwin os type</p> <p>Parameters:</p> Name Type Description Default <code>uninstall_connector</code> <code>ArkSIAUninstallConnector</code> <p>description</p> required Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>def uninstall_connector(self, uninstall_connector: ArkSIAUninstallConnector) -&gt; None:\n    \"\"\"\n    Uninstalls a connector on the remote machine based on the given parameters\n    Uses WinRM on windows os type\n    Uses SSH on linux / darwin os type\n\n    Args:\n        uninstall_connector (ArkSIAUninstallConnector): _description_\n    \"\"\"\n    self._logger.info(f'Uninstalling connector [{uninstall_connector.connector_id}] from machine')\n    self.__uninstall_connector_on_machine(\n        uninstall_connector.connector_os,\n        uninstall_connector.target_machine,\n        uninstall_connector.username,\n        uninstall_connector.password.get_secret_value() if uninstall_connector.password else None,\n        uninstall_connector.private_key_path,\n        uninstall_connector.private_key_contents,\n    )\n</code></pre>"},{"location":"reference/services/sia/access/ark_sia_access_service/","title":"ark_sia_access_service","text":""},{"location":"reference/services/sia/access/ark_sia_access_service/#ark_sdk_python.services.sia.access.ark_sia_access_service.ArkSIAAccessService","title":"<code>ArkSIAAccessService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>class ArkSIAAccessService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __create_connection(\n        self,\n        os_type: ArkOsType,\n        target_machine: str,\n        username: str,\n        password: Optional[str] = None,\n        private_key_path: Optional[str] = None,\n        private_key_contents: Optional[str] = None,\n    ) -&gt; Tuple[ArkConnection, Dict[str, str]]:\n        if os_type == ArkOsType.WINDOWS:\n            connection = ArkWinRMConnection()\n            connection_details = ArkConnectionDetails(\n                address=target_machine,\n                port=WINRM_HTTPS_PORT,\n                connection_type=ArkConnectionType.WinRM,\n                credentials=ArkConnectionCredentials(user=username, password=password),\n                connection_data=ArkWinRMConnectionData(),\n            )\n        else:\n            connection = ArkSSHConnection()\n            connection_details = ArkConnectionDetails(\n                address=target_machine,\n                port=SSH_PORT,\n                connection_type=ArkConnectionType.SSH,\n                credentials=ArkConnectionCredentials(\n                    user=username, password=password, private_key_filepath=private_key_path, private_key_contents=private_key_contents\n                ),\n                connection_data=ArkSSHConnectionData(),\n            )\n        connection.connect(connection_details)\n        return connection, CONNECTOR_CMDSET[os_type]\n\n    def __install_connector_on_machine(\n        self,\n        install_script: str,\n        os_type: ArkOsType,\n        target_machine: str,\n        username: str,\n        password: Optional[str] = None,\n        private_key_path: Optional[str] = None,\n        private_key_contents: Optional[str] = None,\n    ) -&gt; str:\n        connection, cmdset = self.__create_connection(os_type, target_machine, username, password, private_key_path, private_key_contents)\n        connection.run_command(ArkConnectionCommand(command=cmdset['stop-connector-service'], raise_on_error=False))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-service'], raise_on_error=False))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-files'], raise_on_error=False))\n        if os_type == ArkOsType.WINDOWS:\n            connection.run_command(ArkConnectionCommand(command=install_script, extra_command_data={'force_command_split': True}))\n        else:\n            connection.run_command(ArkConnectionCommand(command=install_script))\n        retry_count = CONNECTOR_READY_RETRY_COUNT\n        while True:\n            try:\n                connection.run_command(ArkConnectionCommand(command=cmdset['connector-active']))\n                break\n            except ArkException as ex:\n                self._logger.exception(f'Failed to check whether a connector is active [{str(ex)}]')\n                if retry_count &gt; 0:\n                    retry_count = retry_count - 1\n                    self._logger.info(\n                        f'Retrying to check if connector is active, sleeping for '\n                        f'[{CONNECTOR_RETRY_TICK_SECONDS}] and retrying, retries left [{retry_count}]'\n                    )\n                    time.sleep(CONNECTOR_RETRY_TICK_SECONDS)\n                    continue\n                raise\n        result = connection.run_command(ArkConnectionCommand(command=cmdset['read-connector-config']))\n        connector_config = json.loads(str(result.stdout).strip())\n        return connector_config['Id']\n\n    def __uninstall_connector_on_machine(\n        self,\n        os_type: ArkOsType,\n        target_machine: str,\n        username: str,\n        password: Optional[str] = None,\n        private_key_path: Optional[str] = None,\n        private_key_contents: Optional[str] = None,\n    ) -&gt; None:\n        connection, cmdset = self.__create_connection(os_type, target_machine, username, password, private_key_path, private_key_contents)\n        connection.run_command(ArkConnectionCommand(command=cmdset['stop-connector-service']))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-service']))\n        connection.run_command(ArkConnectionCommand(command=cmdset['remove-connector-files']))\n\n    def connector_setup_script(self, get_connector_setup_script: ArkSIAGetConnectorSetupScript) -&gt; ArkSIAConnectorSetupScript:\n        \"\"\"\n        Retrieves a new connector installation setup script\n\n        Args:\n            get_connector_setup_script (ArkSIAGetConnectorSetupScript): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAConnectorSetupScript: _description_\n        \"\"\"\n        self._logger.info('Retrieving new connector setup script')\n        get_connector_setup_script_dict = get_connector_setup_script.model_dump(exclude_none=True)\n        get_connector_setup_script_dict['connector_type'] = serialize_access_workspace_type(get_connector_setup_script.connector_type)\n        resp: Response = self.__client.post(CONNECTORS_SETUP_SCRIPT_API, json=get_connector_setup_script_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkSIAConnectorSetupScript.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse connector setup script response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse connector setup script response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve connector setup script [{resp.text}] - [{resp.status_code}]')\n\n    def install_connector(self, install_connector: ArkSIAInstallConnector) -&gt; str:\n        \"\"\"\n        Gets a connector installation script\n        Afterwards, installs a connector on the remote machine based on the given parameters\n        Uses WinRM on windows os type\n        Uses SSH on linux / darwin os type\n\n        Args:\n            install_connector (ArkSIAInstallConnector): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        self._logger.info(\n            f'Installing connector on machine [{install_connector.target_machine}] of type [{install_connector.connector_os}]'\n        )\n        installation_script = self.connector_setup_script(\n            ArkSIAGetConnectorSetupScript(\n                connector_os=install_connector.connector_os,\n                connector_pool_id=install_connector.connector_pool_id,\n                connector_type=install_connector.connector_type,\n            )\n        )\n        return self.__install_connector_on_machine(\n            install_script=installation_script.bash_cmd,\n            os_type=install_connector.connector_os,\n            target_machine=install_connector.target_machine,\n            username=install_connector.username,\n            password=install_connector.password.get_secret_value() if install_connector.password else None,\n            private_key_path=install_connector.private_key_path,\n            private_key_contents=(\n                install_connector.private_key_contents.get_secret_value() if install_connector.private_key_contents else None\n            ),\n        )\n\n    def uninstall_connector(self, uninstall_connector: ArkSIAUninstallConnector) -&gt; None:\n        \"\"\"\n        Uninstalls a connector on the remote machine based on the given parameters\n        Uses WinRM on windows os type\n        Uses SSH on linux / darwin os type\n\n        Args:\n            uninstall_connector (ArkSIAUninstallConnector): _description_\n        \"\"\"\n        self._logger.info(f'Uninstalling connector [{uninstall_connector.connector_id}] from machine')\n        self.__uninstall_connector_on_machine(\n            uninstall_connector.connector_os,\n            uninstall_connector.target_machine,\n            uninstall_connector.username,\n            uninstall_connector.password.get_secret_value() if uninstall_connector.password else None,\n            uninstall_connector.private_key_path,\n            uninstall_connector.private_key_contents,\n        )\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/access/ark_sia_access_service/#ark_sdk_python.services.sia.access.ark_sia_access_service.ArkSIAAccessService.connector_setup_script","title":"<code>connector_setup_script(get_connector_setup_script)</code>","text":"<p>Retrieves a new connector installation setup script</p> <p>Parameters:</p> Name Type Description Default <code>get_connector_setup_script</code> <code>ArkSIAGetConnectorSetupScript</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAConnectorSetupScript</code> <code>ArkSIAConnectorSetupScript</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>def connector_setup_script(self, get_connector_setup_script: ArkSIAGetConnectorSetupScript) -&gt; ArkSIAConnectorSetupScript:\n    \"\"\"\n    Retrieves a new connector installation setup script\n\n    Args:\n        get_connector_setup_script (ArkSIAGetConnectorSetupScript): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAConnectorSetupScript: _description_\n    \"\"\"\n    self._logger.info('Retrieving new connector setup script')\n    get_connector_setup_script_dict = get_connector_setup_script.model_dump(exclude_none=True)\n    get_connector_setup_script_dict['connector_type'] = serialize_access_workspace_type(get_connector_setup_script.connector_type)\n    resp: Response = self.__client.post(CONNECTORS_SETUP_SCRIPT_API, json=get_connector_setup_script_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkSIAConnectorSetupScript.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse connector setup script response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse connector setup script response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve connector setup script [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/access/ark_sia_access_service/#ark_sdk_python.services.sia.access.ark_sia_access_service.ArkSIAAccessService.install_connector","title":"<code>install_connector(install_connector)</code>","text":"<p>Gets a connector installation script Afterwards, installs a connector on the remote machine based on the given parameters Uses WinRM on windows os type Uses SSH on linux / darwin os type</p> <p>Parameters:</p> Name Type Description Default <code>install_connector</code> <code>ArkSIAInstallConnector</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>def install_connector(self, install_connector: ArkSIAInstallConnector) -&gt; str:\n    \"\"\"\n    Gets a connector installation script\n    Afterwards, installs a connector on the remote machine based on the given parameters\n    Uses WinRM on windows os type\n    Uses SSH on linux / darwin os type\n\n    Args:\n        install_connector (ArkSIAInstallConnector): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    self._logger.info(\n        f'Installing connector on machine [{install_connector.target_machine}] of type [{install_connector.connector_os}]'\n    )\n    installation_script = self.connector_setup_script(\n        ArkSIAGetConnectorSetupScript(\n            connector_os=install_connector.connector_os,\n            connector_pool_id=install_connector.connector_pool_id,\n            connector_type=install_connector.connector_type,\n        )\n    )\n    return self.__install_connector_on_machine(\n        install_script=installation_script.bash_cmd,\n        os_type=install_connector.connector_os,\n        target_machine=install_connector.target_machine,\n        username=install_connector.username,\n        password=install_connector.password.get_secret_value() if install_connector.password else None,\n        private_key_path=install_connector.private_key_path,\n        private_key_contents=(\n            install_connector.private_key_contents.get_secret_value() if install_connector.private_key_contents else None\n        ),\n    )\n</code></pre>"},{"location":"reference/services/sia/access/ark_sia_access_service/#ark_sdk_python.services.sia.access.ark_sia_access_service.ArkSIAAccessService.uninstall_connector","title":"<code>uninstall_connector(uninstall_connector)</code>","text":"<p>Uninstalls a connector on the remote machine based on the given parameters Uses WinRM on windows os type Uses SSH on linux / darwin os type</p> <p>Parameters:</p> Name Type Description Default <code>uninstall_connector</code> <code>ArkSIAUninstallConnector</code> <p>description</p> required Source code in <code>ark_sdk_python/services/sia/access/ark_sia_access_service.py</code> <pre><code>def uninstall_connector(self, uninstall_connector: ArkSIAUninstallConnector) -&gt; None:\n    \"\"\"\n    Uninstalls a connector on the remote machine based on the given parameters\n    Uses WinRM on windows os type\n    Uses SSH on linux / darwin os type\n\n    Args:\n        uninstall_connector (ArkSIAUninstallConnector): _description_\n    \"\"\"\n    self._logger.info(f'Uninstalling connector [{uninstall_connector.connector_id}] from machine')\n    self.__uninstall_connector_on_machine(\n        uninstall_connector.connector_os,\n        uninstall_connector.target_machine,\n        uninstall_connector.username,\n        uninstall_connector.password.get_secret_value() if uninstall_connector.password else None,\n        uninstall_connector.private_key_path,\n        uninstall_connector.private_key_contents,\n    )\n</code></pre>"},{"location":"reference/services/sia/certificates/","title":"certificates","text":""},{"location":"reference/services/sia/certificates/#ark_sdk_python.services.sia.certificates.ArkSIACertificatesService","title":"<code>ArkSIACertificatesService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>class ArkSIACertificatesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def add_certificate(self, create_certificate: ArkSIACreateCertificate) -&gt; ArkSIACertificate:\n        \"\"\"\n        Adds a new certificate through the Access Certificates Service.\n\n        Args:\n            create_certificate (ArkSIACreateCertificate): The certificate to add\n\n        Raises:\n            ArkServiceException: When the certificate could not be added\n\n        Returns:\n            ArkSIACertificate: The added certificate\n        \"\"\"\n        self._logger.info(\"Adding new certificate.\")\n        try:\n            if not create_certificate.certificate_body and not create_certificate.file:\n                raise ArkServiceException(\n                    'You need to provide at least one of the following parameters [--certificate-body or certificate --file path]'\n                )\n            if create_certificate.file:\n                with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                    cert_body = f.read()\n            else:\n                cert_body = create_certificate.certificate_body\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate - [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n        create_certificate_req = ArkSIACreateCertificateRequest(cert_body=cert_body, **create_certificate.model_dump()).model_dump()\n        resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                cert_id = resp.json()['certificate_id']\n                return self.certificate(ArkSIAGetCertificate(certificate_id=cert_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n                raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n        raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n\n    def certificate(self, get_certificate: ArkSIAGetCertificate) -&gt; ArkSIACertificate:\n        \"\"\"\n        Retrieves a certificate from the Access Certificates Service.\n\n        Args:\n            get_certificate (ArkSIAGetCertificate): The ID of the certificate to retrieve\n\n        Raises:\n            ArkServiceException: When the certificate could not be retrieved\n\n        Returns:\n            ArkSIACertificate: The retrieved certificate\n        \"\"\"\n        self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n        resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n        try:\n            return ArkSIACertificate.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    def delete_certificate(self, cert: ArkSIADeleteCertificate) -&gt; None:\n        \"\"\"\n        Deletes an existing certificate.\n\n        Args:\n            cert (ArkSIADeleteCertificate): The ID of the certificate to delete\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n        resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n\n    def update_certificate(self, update_certificate: ArkSIAUpdateCertificate) -&gt; None:\n        \"\"\"\n        Updates an existing certificate.\n\n        Args:\n            update_certificate (ArkSIAUpdateCertificate): The ID of the certificate to update\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n        try:\n            with open(update_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n        update_certificate_req = ArkSIAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.model_dump()).model_dump()\n        resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n\n    def list_certificates(self) -&gt; List[ArkSIAShortCertificate]:\n        \"\"\"\n        Lists all certificates.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            list[ArkSIACertificate]: _description_\n        \"\"\"\n        self._logger.info(\"Listing certificates.\")\n        resp = self.__client.get(CERTIFICATES_API)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n        try:\n            return [ArkSIAShortCertificate.model_validate(cert) for cert in resp.json()['certificates']['items']]\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n\n    def list_certificates_by(self, certificates_filter: ArkSIACertificatesFilter) -&gt; List[ArkSIAShortCertificate]:\n        \"\"\"\n        Lists certificates matching the specified filters.\n\n        Args:\n            certificates_filter (ArkSIACertificatesFilter): _description_\n\n        Returns:\n            List[ArkSIAShortCertificate]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n        certs = self.list_certificates()\n\n        if certificates_filter.domain_name:\n            certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n        if certificates_filter.cert_name:\n            certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n        return certs\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/certificates/#ark_sdk_python.services.sia.certificates.ArkSIACertificatesService.add_certificate","title":"<code>add_certificate(create_certificate)</code>","text":"<p>Adds a new certificate through the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>create_certificate</code> <code>ArkSIACreateCertificate</code> <p>The certificate to add</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be added</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificate</code> <code>ArkSIACertificate</code> <p>The added certificate</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def add_certificate(self, create_certificate: ArkSIACreateCertificate) -&gt; ArkSIACertificate:\n    \"\"\"\n    Adds a new certificate through the Access Certificates Service.\n\n    Args:\n        create_certificate (ArkSIACreateCertificate): The certificate to add\n\n    Raises:\n        ArkServiceException: When the certificate could not be added\n\n    Returns:\n        ArkSIACertificate: The added certificate\n    \"\"\"\n    self._logger.info(\"Adding new certificate.\")\n    try:\n        if not create_certificate.certificate_body and not create_certificate.file:\n            raise ArkServiceException(\n                'You need to provide at least one of the following parameters [--certificate-body or certificate --file path]'\n            )\n        if create_certificate.file:\n            with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        else:\n            cert_body = create_certificate.certificate_body\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate - [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n    create_certificate_req = ArkSIACreateCertificateRequest(cert_body=cert_body, **create_certificate.model_dump()).model_dump()\n    resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            cert_id = resp.json()['certificate_id']\n            return self.certificate(ArkSIAGetCertificate(certificate_id=cert_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n            raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n    raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/certificates/#ark_sdk_python.services.sia.certificates.ArkSIACertificatesService.certificate","title":"<code>certificate(get_certificate)</code>","text":"<p>Retrieves a certificate from the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>get_certificate</code> <code>ArkSIAGetCertificate</code> <p>The ID of the certificate to retrieve</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be retrieved</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificate</code> <code>ArkSIACertificate</code> <p>The retrieved certificate</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def certificate(self, get_certificate: ArkSIAGetCertificate) -&gt; ArkSIACertificate:\n    \"\"\"\n    Retrieves a certificate from the Access Certificates Service.\n\n    Args:\n        get_certificate (ArkSIAGetCertificate): The ID of the certificate to retrieve\n\n    Raises:\n        ArkServiceException: When the certificate could not be retrieved\n\n    Returns:\n        ArkSIACertificate: The retrieved certificate\n    \"\"\"\n    self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n    resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n    try:\n        return ArkSIACertificate.model_validate(resp.json())\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/certificates/#ark_sdk_python.services.sia.certificates.ArkSIACertificatesService.delete_certificate","title":"<code>delete_certificate(cert)</code>","text":"<p>Deletes an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>cert</code> <code>ArkSIADeleteCertificate</code> <p>The ID of the certificate to delete</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def delete_certificate(self, cert: ArkSIADeleteCertificate) -&gt; None:\n    \"\"\"\n    Deletes an existing certificate.\n\n    Args:\n        cert (ArkSIADeleteCertificate): The ID of the certificate to delete\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n    resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/certificates/#ark_sdk_python.services.sia.certificates.ArkSIACertificatesService.list_certificates","title":"<code>list_certificates()</code>","text":"<p>Lists all certificates.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkSIAShortCertificate]</code> <p>list[ArkSIACertificate]: description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def list_certificates(self) -&gt; List[ArkSIAShortCertificate]:\n    \"\"\"\n    Lists all certificates.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        list[ArkSIACertificate]: _description_\n    \"\"\"\n    self._logger.info(\"Listing certificates.\")\n    resp = self.__client.get(CERTIFICATES_API)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n    try:\n        return [ArkSIAShortCertificate.model_validate(cert) for cert in resp.json()['certificates']['items']]\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/certificates/#ark_sdk_python.services.sia.certificates.ArkSIACertificatesService.list_certificates_by","title":"<code>list_certificates_by(certificates_filter)</code>","text":"<p>Lists certificates matching the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>certificates_filter</code> <code>ArkSIACertificatesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIAShortCertificate]</code> <p>List[ArkSIAShortCertificate]: description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def list_certificates_by(self, certificates_filter: ArkSIACertificatesFilter) -&gt; List[ArkSIAShortCertificate]:\n    \"\"\"\n    Lists certificates matching the specified filters.\n\n    Args:\n        certificates_filter (ArkSIACertificatesFilter): _description_\n\n    Returns:\n        List[ArkSIAShortCertificate]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n    certs = self.list_certificates()\n\n    if certificates_filter.domain_name:\n        certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n    if certificates_filter.cert_name:\n        certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n    return certs\n</code></pre>"},{"location":"reference/services/sia/certificates/#ark_sdk_python.services.sia.certificates.ArkSIACertificatesService.update_certificate","title":"<code>update_certificate(update_certificate)</code>","text":"<p>Updates an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>update_certificate</code> <code>ArkSIAUpdateCertificate</code> <p>The ID of the certificate to update</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def update_certificate(self, update_certificate: ArkSIAUpdateCertificate) -&gt; None:\n    \"\"\"\n    Updates an existing certificate.\n\n    Args:\n        update_certificate (ArkSIAUpdateCertificate): The ID of the certificate to update\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n    try:\n        with open(update_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n    update_certificate_req = ArkSIAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.model_dump()).model_dump()\n    resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/","title":"ark_sia_certificates_service","text":""},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/#ark_sdk_python.services.sia.certificates.ark_sia_certificates_service.ArkSIACertificatesService","title":"<code>ArkSIACertificatesService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>class ArkSIACertificatesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def add_certificate(self, create_certificate: ArkSIACreateCertificate) -&gt; ArkSIACertificate:\n        \"\"\"\n        Adds a new certificate through the Access Certificates Service.\n\n        Args:\n            create_certificate (ArkSIACreateCertificate): The certificate to add\n\n        Raises:\n            ArkServiceException: When the certificate could not be added\n\n        Returns:\n            ArkSIACertificate: The added certificate\n        \"\"\"\n        self._logger.info(\"Adding new certificate.\")\n        try:\n            if not create_certificate.certificate_body and not create_certificate.file:\n                raise ArkServiceException(\n                    'You need to provide at least one of the following parameters [--certificate-body or certificate --file path]'\n                )\n            if create_certificate.file:\n                with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                    cert_body = f.read()\n            else:\n                cert_body = create_certificate.certificate_body\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate - [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n        create_certificate_req = ArkSIACreateCertificateRequest(cert_body=cert_body, **create_certificate.model_dump()).model_dump()\n        resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                cert_id = resp.json()['certificate_id']\n                return self.certificate(ArkSIAGetCertificate(certificate_id=cert_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n                raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n        raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n\n    def certificate(self, get_certificate: ArkSIAGetCertificate) -&gt; ArkSIACertificate:\n        \"\"\"\n        Retrieves a certificate from the Access Certificates Service.\n\n        Args:\n            get_certificate (ArkSIAGetCertificate): The ID of the certificate to retrieve\n\n        Raises:\n            ArkServiceException: When the certificate could not be retrieved\n\n        Returns:\n            ArkSIACertificate: The retrieved certificate\n        \"\"\"\n        self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n        resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n        try:\n            return ArkSIACertificate.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    def delete_certificate(self, cert: ArkSIADeleteCertificate) -&gt; None:\n        \"\"\"\n        Deletes an existing certificate.\n\n        Args:\n            cert (ArkSIADeleteCertificate): The ID of the certificate to delete\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n        resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n\n    def update_certificate(self, update_certificate: ArkSIAUpdateCertificate) -&gt; None:\n        \"\"\"\n        Updates an existing certificate.\n\n        Args:\n            update_certificate (ArkSIAUpdateCertificate): The ID of the certificate to update\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n        try:\n            with open(update_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n        update_certificate_req = ArkSIAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.model_dump()).model_dump()\n        resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n\n    def list_certificates(self) -&gt; List[ArkSIAShortCertificate]:\n        \"\"\"\n        Lists all certificates.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            list[ArkSIACertificate]: _description_\n        \"\"\"\n        self._logger.info(\"Listing certificates.\")\n        resp = self.__client.get(CERTIFICATES_API)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n        try:\n            return [ArkSIAShortCertificate.model_validate(cert) for cert in resp.json()['certificates']['items']]\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n\n    def list_certificates_by(self, certificates_filter: ArkSIACertificatesFilter) -&gt; List[ArkSIAShortCertificate]:\n        \"\"\"\n        Lists certificates matching the specified filters.\n\n        Args:\n            certificates_filter (ArkSIACertificatesFilter): _description_\n\n        Returns:\n            List[ArkSIAShortCertificate]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n        certs = self.list_certificates()\n\n        if certificates_filter.domain_name:\n            certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n        if certificates_filter.cert_name:\n            certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n        return certs\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/#ark_sdk_python.services.sia.certificates.ark_sia_certificates_service.ArkSIACertificatesService.add_certificate","title":"<code>add_certificate(create_certificate)</code>","text":"<p>Adds a new certificate through the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>create_certificate</code> <code>ArkSIACreateCertificate</code> <p>The certificate to add</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be added</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificate</code> <code>ArkSIACertificate</code> <p>The added certificate</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def add_certificate(self, create_certificate: ArkSIACreateCertificate) -&gt; ArkSIACertificate:\n    \"\"\"\n    Adds a new certificate through the Access Certificates Service.\n\n    Args:\n        create_certificate (ArkSIACreateCertificate): The certificate to add\n\n    Raises:\n        ArkServiceException: When the certificate could not be added\n\n    Returns:\n        ArkSIACertificate: The added certificate\n    \"\"\"\n    self._logger.info(\"Adding new certificate.\")\n    try:\n        if not create_certificate.certificate_body and not create_certificate.file:\n            raise ArkServiceException(\n                'You need to provide at least one of the following parameters [--certificate-body or certificate --file path]'\n            )\n        if create_certificate.file:\n            with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        else:\n            cert_body = create_certificate.certificate_body\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate - [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n    create_certificate_req = ArkSIACreateCertificateRequest(cert_body=cert_body, **create_certificate.model_dump()).model_dump()\n    resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            cert_id = resp.json()['certificate_id']\n            return self.certificate(ArkSIAGetCertificate(certificate_id=cert_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n            raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n    raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/#ark_sdk_python.services.sia.certificates.ark_sia_certificates_service.ArkSIACertificatesService.certificate","title":"<code>certificate(get_certificate)</code>","text":"<p>Retrieves a certificate from the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>get_certificate</code> <code>ArkSIAGetCertificate</code> <p>The ID of the certificate to retrieve</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be retrieved</p> <p>Returns:</p> Name Type Description <code>ArkSIACertificate</code> <code>ArkSIACertificate</code> <p>The retrieved certificate</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def certificate(self, get_certificate: ArkSIAGetCertificate) -&gt; ArkSIACertificate:\n    \"\"\"\n    Retrieves a certificate from the Access Certificates Service.\n\n    Args:\n        get_certificate (ArkSIAGetCertificate): The ID of the certificate to retrieve\n\n    Raises:\n        ArkServiceException: When the certificate could not be retrieved\n\n    Returns:\n        ArkSIACertificate: The retrieved certificate\n    \"\"\"\n    self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n    resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n    try:\n        return ArkSIACertificate.model_validate(resp.json())\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/#ark_sdk_python.services.sia.certificates.ark_sia_certificates_service.ArkSIACertificatesService.delete_certificate","title":"<code>delete_certificate(cert)</code>","text":"<p>Deletes an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>cert</code> <code>ArkSIADeleteCertificate</code> <p>The ID of the certificate to delete</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def delete_certificate(self, cert: ArkSIADeleteCertificate) -&gt; None:\n    \"\"\"\n    Deletes an existing certificate.\n\n    Args:\n        cert (ArkSIADeleteCertificate): The ID of the certificate to delete\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n    resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/#ark_sdk_python.services.sia.certificates.ark_sia_certificates_service.ArkSIACertificatesService.list_certificates","title":"<code>list_certificates()</code>","text":"<p>Lists all certificates.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkSIAShortCertificate]</code> <p>list[ArkSIACertificate]: description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def list_certificates(self) -&gt; List[ArkSIAShortCertificate]:\n    \"\"\"\n    Lists all certificates.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        list[ArkSIACertificate]: _description_\n    \"\"\"\n    self._logger.info(\"Listing certificates.\")\n    resp = self.__client.get(CERTIFICATES_API)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n    try:\n        return [ArkSIAShortCertificate.model_validate(cert) for cert in resp.json()['certificates']['items']]\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/#ark_sdk_python.services.sia.certificates.ark_sia_certificates_service.ArkSIACertificatesService.list_certificates_by","title":"<code>list_certificates_by(certificates_filter)</code>","text":"<p>Lists certificates matching the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>certificates_filter</code> <code>ArkSIACertificatesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIAShortCertificate]</code> <p>List[ArkSIAShortCertificate]: description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def list_certificates_by(self, certificates_filter: ArkSIACertificatesFilter) -&gt; List[ArkSIAShortCertificate]:\n    \"\"\"\n    Lists certificates matching the specified filters.\n\n    Args:\n        certificates_filter (ArkSIACertificatesFilter): _description_\n\n    Returns:\n        List[ArkSIAShortCertificate]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n    certs = self.list_certificates()\n\n    if certificates_filter.domain_name:\n        certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n    if certificates_filter.cert_name:\n        certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n    return certs\n</code></pre>"},{"location":"reference/services/sia/certificates/ark_sia_certificates_service/#ark_sdk_python.services.sia.certificates.ark_sia_certificates_service.ArkSIACertificatesService.update_certificate","title":"<code>update_certificate(update_certificate)</code>","text":"<p>Updates an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>update_certificate</code> <code>ArkSIAUpdateCertificate</code> <p>The ID of the certificate to update</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/certificates/ark_sia_certificates_service.py</code> <pre><code>def update_certificate(self, update_certificate: ArkSIAUpdateCertificate) -&gt; None:\n    \"\"\"\n    Updates an existing certificate.\n\n    Args:\n        update_certificate (ArkSIAUpdateCertificate): The ID of the certificate to update\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n    try:\n        with open(update_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n    update_certificate_req = ArkSIAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.model_dump()).model_dump()\n    resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/db/","title":"db","text":""},{"location":"reference/services/sia/db/#ark_sdk_python.services.sia.db.ArkSIADBService","title":"<code>ArkSIADBService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>class ArkSIADBService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__sso_service = ArkSIASSOService(self.__isp_auth)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __proxy_address(self, db_type: str):\n        claims = ArkJWTUtils.get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        return f'{claims[\"subdomain\"]}.{db_type}.{claims[\"platform_domain\"]}'\n\n    def __connection_string(self, target_address: str, target_username: Optional[str] = None) -&gt; None:\n        claims = ArkJWTUtils.get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        if target_username:\n            # Standing\n            return f'{claims[\"unique_name\"]}@{target_username}@{target_address}'\n        # Dynamic\n        return f'{claims[\"unique_name\"]}@{target_address}'\n\n    def __create_mylogin_cnf(self, username: str, address: str, password: str) -&gt; str:\n        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8')\n        temp_file.write('[client]\\n' f'user = {username}\\n' f'password = {password}\\n' f'host = {address}\\n')\n        temp_file.close()\n        os.chmod(temp_file.name, 0o600)\n        return temp_file.name\n\n    def __add_to_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        flags = 'r+'\n        change_chomd = False\n        path = f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'\n        if not os.path.exists(path):\n            flags = 'w+'\n            change_chomd = True\n        with open(path, flags, encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            for line in lines:\n                if line == pass_format:\n                    return\n            lines.append(pass_format)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(lines)\n        if change_chomd:\n            os.chmod(path, 0o600)\n\n    def __remove_from_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        if not os.path.exists(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'):\n            return\n        with open(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass', 'r+', encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            updated_lines = []\n            for line in lines:\n                if line == pass_format:\n                    continue\n                updated_lines.append(line)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(updated_lines)\n\n    def __execute(self, command_line: str) -&gt; None:\n        p = subprocess.Popen(command_line, shell=True)\n        p.communicate()\n\n    def psql(self, psql_execution: ArkSIADBPsqlExecution) -&gt; None:\n        \"\"\"\n        Executes a Postgres psql command via CyberArk's Database Proxy.\n\n        Args:\n            psql_execution (ArkSIADBPsqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"postgres\")\n        connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n        execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n        self.__add_to_pgpass(connection_string, proxy_address, password)\n        try:\n            self.__execute(execution_action)\n        finally:\n            self.__remove_from_pgpass(connection_string, proxy_address, password)\n\n    def mysql(self, mysql_execution: ArkSIADBMysqlExecution) -&gt; None:\n        \"\"\"\n        Executes a MySQL command line via CyberArk's Database Proxy.\n\n        Args:\n            mysql_execution (ArkSIADBMysqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"mysql\")\n        connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n        temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n        execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n        try:\n            self.__execute(execution_action)\n        finally:\n            os.unlink(temp_cnf_login)\n\n    def __generate_assets(\n        self,\n        asset_type: ArkSIADBAssetsType,\n        connection_method: ArkConnectionMethod,\n        response_format: ArkSIADBAssetsResponseFormat,\n        generation_hints: Optional[Dict[str, Any]] = None,\n        include_sso: Optional[bool] = None,\n        resource_type: Optional[ArkSIADBDatabaseFamilyType] = None,\n    ) -&gt; ArkSIADBGeneratedAssets:\n        body = {\n            'asset_type': asset_type,\n            'os_type': running_os().value,\n            'connection_method': connection_method.value,\n            'response_format': response_format.value,\n        }\n        if generation_hints:\n            body['generation_hints'] = generation_hints\n        if include_sso is not None:\n            body['include_sso'] = include_sso\n        if resource_type:\n            body['resource_type'] = resource_type.value\n        resp: Response = self.__client.post(\n            ASSETS_API,\n            json=body,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                if response_format == ArkSIADBAssetsResponseFormat.RAW:\n                    return resp.text\n                return ArkSIADBGeneratedAssets.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to generate assets [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to generate assets [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate assets [{resp.text}] - [{resp.status_code}]')\n\n    def generate_oracle_tnsnames(self, generate_oracle_assets: ArkSIADBOracleGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n        Args:\n            generate_oracle_assets (ArkSIADBOracleGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating oracle tns names')\n        assets_data = self.__generate_assets(\n            asset_type=ArkSIADBAssetsType.OracleTNSAssets,\n            connection_method=generate_oracle_assets.connection_method,\n            response_format=generate_oracle_assets.response_format,\n            generation_hints={'folder': generate_oracle_assets.folder},\n            include_sso=generate_oracle_assets.include_sso,\n            resource_type=ArkSIADBDatabaseFamilyType.Oracle,\n        )\n        if isinstance(assets_data, ArkSIADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        assets_data = base64.b64decode(assets_data)\n        if not os.path.exists(generate_oracle_assets.folder):\n            os.makedirs(generate_oracle_assets.folder)\n        if not generate_oracle_assets.unzip:\n            with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n                file_handle.write(assets_data)\n        else:\n            assets_bytes = BytesIO(assets_data)\n            with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n                zipf.extractall(generate_oracle_assets.folder)\n\n    def generate_proxy_fullchain(self, generate_proxy_fullchain: ArkSIADBProxyFullchainGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates the proxy fullchain certificates for full certificate validation.\n\n        Args:\n            generate_proxy_fullchain (ArkSIADBProxyFullchainGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating proxy fullchain')\n        assets_data = self.__generate_assets(\n            asset_type=ArkSIADBAssetsType.ProxyFullChain,\n            connection_method=generate_proxy_fullchain.connection_method,\n            response_format=generate_proxy_fullchain.response_format,\n        )\n        if isinstance(assets_data, ArkSIADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        if not os.path.exists(generate_proxy_fullchain.folder):\n            os.makedirs(generate_proxy_fullchain.folder)\n        with open(f'{generate_proxy_fullchain.folder}{os.path.sep}proxy_fullchain.pem', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(assets_data)\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/db/#ark_sdk_python.services.sia.db.ArkSIADBService.generate_oracle_tnsnames","title":"<code>generate_oracle_tnsnames(generate_oracle_assets)</code>","text":"<p>Generates an Oracle <code>tnsnames</code> file and, optionally, an Oracle Wallet (if permitted).</p> <p>Parameters:</p> Name Type Description Default <code>generate_oracle_assets</code> <code>ArkSIADBOracleGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def generate_oracle_tnsnames(self, generate_oracle_assets: ArkSIADBOracleGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n    Args:\n        generate_oracle_assets (ArkSIADBOracleGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating oracle tns names')\n    assets_data = self.__generate_assets(\n        asset_type=ArkSIADBAssetsType.OracleTNSAssets,\n        connection_method=generate_oracle_assets.connection_method,\n        response_format=generate_oracle_assets.response_format,\n        generation_hints={'folder': generate_oracle_assets.folder},\n        include_sso=generate_oracle_assets.include_sso,\n        resource_type=ArkSIADBDatabaseFamilyType.Oracle,\n    )\n    if isinstance(assets_data, ArkSIADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    assets_data = base64.b64decode(assets_data)\n    if not os.path.exists(generate_oracle_assets.folder):\n        os.makedirs(generate_oracle_assets.folder)\n    if not generate_oracle_assets.unzip:\n        with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n            file_handle.write(assets_data)\n    else:\n        assets_bytes = BytesIO(assets_data)\n        with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n            zipf.extractall(generate_oracle_assets.folder)\n</code></pre>"},{"location":"reference/services/sia/db/#ark_sdk_python.services.sia.db.ArkSIADBService.generate_proxy_fullchain","title":"<code>generate_proxy_fullchain(generate_proxy_fullchain)</code>","text":"<p>Generates the proxy fullchain certificates for full certificate validation.</p> <p>Parameters:</p> Name Type Description Default <code>generate_proxy_fullchain</code> <code>ArkSIADBProxyFullchainGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def generate_proxy_fullchain(self, generate_proxy_fullchain: ArkSIADBProxyFullchainGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates the proxy fullchain certificates for full certificate validation.\n\n    Args:\n        generate_proxy_fullchain (ArkSIADBProxyFullchainGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating proxy fullchain')\n    assets_data = self.__generate_assets(\n        asset_type=ArkSIADBAssetsType.ProxyFullChain,\n        connection_method=generate_proxy_fullchain.connection_method,\n        response_format=generate_proxy_fullchain.response_format,\n    )\n    if isinstance(assets_data, ArkSIADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    if not os.path.exists(generate_proxy_fullchain.folder):\n        os.makedirs(generate_proxy_fullchain.folder)\n    with open(f'{generate_proxy_fullchain.folder}{os.path.sep}proxy_fullchain.pem', 'w', encoding='utf-8') as file_handle:\n        file_handle.write(assets_data)\n</code></pre>"},{"location":"reference/services/sia/db/#ark_sdk_python.services.sia.db.ArkSIADBService.mysql","title":"<code>mysql(mysql_execution)</code>","text":"<p>Executes a MySQL command line via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>mysql_execution</code> <code>ArkSIADBMysqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def mysql(self, mysql_execution: ArkSIADBMysqlExecution) -&gt; None:\n    \"\"\"\n    Executes a MySQL command line via CyberArk's Database Proxy.\n\n    Args:\n        mysql_execution (ArkSIADBMysqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"mysql\")\n    connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n    temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n    execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n    try:\n        self.__execute(execution_action)\n    finally:\n        os.unlink(temp_cnf_login)\n</code></pre>"},{"location":"reference/services/sia/db/#ark_sdk_python.services.sia.db.ArkSIADBService.psql","title":"<code>psql(psql_execution)</code>","text":"<p>Executes a Postgres psql command via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>psql_execution</code> <code>ArkSIADBPsqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def psql(self, psql_execution: ArkSIADBPsqlExecution) -&gt; None:\n    \"\"\"\n    Executes a Postgres psql command via CyberArk's Database Proxy.\n\n    Args:\n        psql_execution (ArkSIADBPsqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"postgres\")\n    connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n    execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n    self.__add_to_pgpass(connection_string, proxy_address, password)\n    try:\n        self.__execute(execution_action)\n    finally:\n        self.__remove_from_pgpass(connection_string, proxy_address, password)\n</code></pre>"},{"location":"reference/services/sia/db/ark_sia_db_service/","title":"ark_sia_db_service","text":""},{"location":"reference/services/sia/db/ark_sia_db_service/#ark_sdk_python.services.sia.db.ark_sia_db_service.ArkSIADBService","title":"<code>ArkSIADBService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>class ArkSIADBService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__sso_service = ArkSIASSOService(self.__isp_auth)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __proxy_address(self, db_type: str):\n        claims = ArkJWTUtils.get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        return f'{claims[\"subdomain\"]}.{db_type}.{claims[\"platform_domain\"]}'\n\n    def __connection_string(self, target_address: str, target_username: Optional[str] = None) -&gt; None:\n        claims = ArkJWTUtils.get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        if target_username:\n            # Standing\n            return f'{claims[\"unique_name\"]}@{target_username}@{target_address}'\n        # Dynamic\n        return f'{claims[\"unique_name\"]}@{target_address}'\n\n    def __create_mylogin_cnf(self, username: str, address: str, password: str) -&gt; str:\n        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8')\n        temp_file.write('[client]\\n' f'user = {username}\\n' f'password = {password}\\n' f'host = {address}\\n')\n        temp_file.close()\n        os.chmod(temp_file.name, 0o600)\n        return temp_file.name\n\n    def __add_to_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        flags = 'r+'\n        change_chomd = False\n        path = f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'\n        if not os.path.exists(path):\n            flags = 'w+'\n            change_chomd = True\n        with open(path, flags, encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            for line in lines:\n                if line == pass_format:\n                    return\n            lines.append(pass_format)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(lines)\n        if change_chomd:\n            os.chmod(path, 0o600)\n\n    def __remove_from_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        if not os.path.exists(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'):\n            return\n        with open(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass', 'r+', encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            updated_lines = []\n            for line in lines:\n                if line == pass_format:\n                    continue\n                updated_lines.append(line)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(updated_lines)\n\n    def __execute(self, command_line: str) -&gt; None:\n        p = subprocess.Popen(command_line, shell=True)\n        p.communicate()\n\n    def psql(self, psql_execution: ArkSIADBPsqlExecution) -&gt; None:\n        \"\"\"\n        Executes a Postgres psql command via CyberArk's Database Proxy.\n\n        Args:\n            psql_execution (ArkSIADBPsqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"postgres\")\n        connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n        execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n        self.__add_to_pgpass(connection_string, proxy_address, password)\n        try:\n            self.__execute(execution_action)\n        finally:\n            self.__remove_from_pgpass(connection_string, proxy_address, password)\n\n    def mysql(self, mysql_execution: ArkSIADBMysqlExecution) -&gt; None:\n        \"\"\"\n        Executes a MySQL command line via CyberArk's Database Proxy.\n\n        Args:\n            mysql_execution (ArkSIADBMysqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"mysql\")\n        connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n        temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n        execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n        try:\n            self.__execute(execution_action)\n        finally:\n            os.unlink(temp_cnf_login)\n\n    def __generate_assets(\n        self,\n        asset_type: ArkSIADBAssetsType,\n        connection_method: ArkConnectionMethod,\n        response_format: ArkSIADBAssetsResponseFormat,\n        generation_hints: Optional[Dict[str, Any]] = None,\n        include_sso: Optional[bool] = None,\n        resource_type: Optional[ArkSIADBDatabaseFamilyType] = None,\n    ) -&gt; ArkSIADBGeneratedAssets:\n        body = {\n            'asset_type': asset_type,\n            'os_type': running_os().value,\n            'connection_method': connection_method.value,\n            'response_format': response_format.value,\n        }\n        if generation_hints:\n            body['generation_hints'] = generation_hints\n        if include_sso is not None:\n            body['include_sso'] = include_sso\n        if resource_type:\n            body['resource_type'] = resource_type.value\n        resp: Response = self.__client.post(\n            ASSETS_API,\n            json=body,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                if response_format == ArkSIADBAssetsResponseFormat.RAW:\n                    return resp.text\n                return ArkSIADBGeneratedAssets.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to generate assets [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to generate assets [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate assets [{resp.text}] - [{resp.status_code}]')\n\n    def generate_oracle_tnsnames(self, generate_oracle_assets: ArkSIADBOracleGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n        Args:\n            generate_oracle_assets (ArkSIADBOracleGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating oracle tns names')\n        assets_data = self.__generate_assets(\n            asset_type=ArkSIADBAssetsType.OracleTNSAssets,\n            connection_method=generate_oracle_assets.connection_method,\n            response_format=generate_oracle_assets.response_format,\n            generation_hints={'folder': generate_oracle_assets.folder},\n            include_sso=generate_oracle_assets.include_sso,\n            resource_type=ArkSIADBDatabaseFamilyType.Oracle,\n        )\n        if isinstance(assets_data, ArkSIADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        assets_data = base64.b64decode(assets_data)\n        if not os.path.exists(generate_oracle_assets.folder):\n            os.makedirs(generate_oracle_assets.folder)\n        if not generate_oracle_assets.unzip:\n            with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n                file_handle.write(assets_data)\n        else:\n            assets_bytes = BytesIO(assets_data)\n            with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n                zipf.extractall(generate_oracle_assets.folder)\n\n    def generate_proxy_fullchain(self, generate_proxy_fullchain: ArkSIADBProxyFullchainGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates the proxy fullchain certificates for full certificate validation.\n\n        Args:\n            generate_proxy_fullchain (ArkSIADBProxyFullchainGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating proxy fullchain')\n        assets_data = self.__generate_assets(\n            asset_type=ArkSIADBAssetsType.ProxyFullChain,\n            connection_method=generate_proxy_fullchain.connection_method,\n            response_format=generate_proxy_fullchain.response_format,\n        )\n        if isinstance(assets_data, ArkSIADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        if not os.path.exists(generate_proxy_fullchain.folder):\n            os.makedirs(generate_proxy_fullchain.folder)\n        with open(f'{generate_proxy_fullchain.folder}{os.path.sep}proxy_fullchain.pem', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(assets_data)\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/db/ark_sia_db_service/#ark_sdk_python.services.sia.db.ark_sia_db_service.ArkSIADBService.generate_oracle_tnsnames","title":"<code>generate_oracle_tnsnames(generate_oracle_assets)</code>","text":"<p>Generates an Oracle <code>tnsnames</code> file and, optionally, an Oracle Wallet (if permitted).</p> <p>Parameters:</p> Name Type Description Default <code>generate_oracle_assets</code> <code>ArkSIADBOracleGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def generate_oracle_tnsnames(self, generate_oracle_assets: ArkSIADBOracleGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n    Args:\n        generate_oracle_assets (ArkSIADBOracleGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating oracle tns names')\n    assets_data = self.__generate_assets(\n        asset_type=ArkSIADBAssetsType.OracleTNSAssets,\n        connection_method=generate_oracle_assets.connection_method,\n        response_format=generate_oracle_assets.response_format,\n        generation_hints={'folder': generate_oracle_assets.folder},\n        include_sso=generate_oracle_assets.include_sso,\n        resource_type=ArkSIADBDatabaseFamilyType.Oracle,\n    )\n    if isinstance(assets_data, ArkSIADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    assets_data = base64.b64decode(assets_data)\n    if not os.path.exists(generate_oracle_assets.folder):\n        os.makedirs(generate_oracle_assets.folder)\n    if not generate_oracle_assets.unzip:\n        with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n            file_handle.write(assets_data)\n    else:\n        assets_bytes = BytesIO(assets_data)\n        with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n            zipf.extractall(generate_oracle_assets.folder)\n</code></pre>"},{"location":"reference/services/sia/db/ark_sia_db_service/#ark_sdk_python.services.sia.db.ark_sia_db_service.ArkSIADBService.generate_proxy_fullchain","title":"<code>generate_proxy_fullchain(generate_proxy_fullchain)</code>","text":"<p>Generates the proxy fullchain certificates for full certificate validation.</p> <p>Parameters:</p> Name Type Description Default <code>generate_proxy_fullchain</code> <code>ArkSIADBProxyFullchainGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def generate_proxy_fullchain(self, generate_proxy_fullchain: ArkSIADBProxyFullchainGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates the proxy fullchain certificates for full certificate validation.\n\n    Args:\n        generate_proxy_fullchain (ArkSIADBProxyFullchainGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating proxy fullchain')\n    assets_data = self.__generate_assets(\n        asset_type=ArkSIADBAssetsType.ProxyFullChain,\n        connection_method=generate_proxy_fullchain.connection_method,\n        response_format=generate_proxy_fullchain.response_format,\n    )\n    if isinstance(assets_data, ArkSIADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    if not os.path.exists(generate_proxy_fullchain.folder):\n        os.makedirs(generate_proxy_fullchain.folder)\n    with open(f'{generate_proxy_fullchain.folder}{os.path.sep}proxy_fullchain.pem', 'w', encoding='utf-8') as file_handle:\n        file_handle.write(assets_data)\n</code></pre>"},{"location":"reference/services/sia/db/ark_sia_db_service/#ark_sdk_python.services.sia.db.ark_sia_db_service.ArkSIADBService.mysql","title":"<code>mysql(mysql_execution)</code>","text":"<p>Executes a MySQL command line via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>mysql_execution</code> <code>ArkSIADBMysqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def mysql(self, mysql_execution: ArkSIADBMysqlExecution) -&gt; None:\n    \"\"\"\n    Executes a MySQL command line via CyberArk's Database Proxy.\n\n    Args:\n        mysql_execution (ArkSIADBMysqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"mysql\")\n    connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n    temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n    execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n    try:\n        self.__execute(execution_action)\n    finally:\n        os.unlink(temp_cnf_login)\n</code></pre>"},{"location":"reference/services/sia/db/ark_sia_db_service/#ark_sdk_python.services.sia.db.ark_sia_db_service.ArkSIADBService.psql","title":"<code>psql(psql_execution)</code>","text":"<p>Executes a Postgres psql command via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>psql_execution</code> <code>ArkSIADBPsqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/db/ark_sia_db_service.py</code> <pre><code>def psql(self, psql_execution: ArkSIADBPsqlExecution) -&gt; None:\n    \"\"\"\n    Executes a Postgres psql command via CyberArk's Database Proxy.\n\n    Args:\n        psql_execution (ArkSIADBPsqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"postgres\")\n    connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkSIASSOGetShortLivedPassword())\n    execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n    self.__add_to_pgpass(connection_string, proxy_address, password)\n    try:\n        self.__execute(execution_action)\n    finally:\n        self.__remove_from_pgpass(connection_string, proxy_address, password)\n</code></pre>"},{"location":"reference/services/sia/k8s/","title":"k8s","text":""},{"location":"reference/services/sia/k8s/#ark_sdk_python.services.sia.k8s.ArkSIAK8SService","title":"<code>ArkSIAK8SService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/k8s/ark_sia_k8s_service.py</code> <pre><code>class ArkSIAK8SService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    @staticmethod\n    def _save_kube_config_file(folder: str, result: str) -&gt; None:\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(f'{folder}{os.path.sep}config', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result)\n\n    def generate_kubeconfig(self, generate_kubeconfig: ArkSIAK8SGenerateKubeConfig) -&gt; Optional[str]:\n        \"\"\"\n        Builds a Kube config file used to connect to a K8s cluster\n\n        Args:\n            generate_kubeconfig (ArkSIAK8SGenerateKubeConfig): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Building kube config file')\n        response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n        result = response.text\n        if generate_kubeconfig.folder:\n            ArkSIAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n            return None\n        return result\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/k8s/#ark_sdk_python.services.sia.k8s.ArkSIAK8SService.generate_kubeconfig","title":"<code>generate_kubeconfig(generate_kubeconfig)</code>","text":"<p>Builds a Kube config file used to connect to a K8s cluster</p> <p>Parameters:</p> Name Type Description Default <code>generate_kubeconfig</code> <code>ArkSIAK8SGenerateKubeConfig</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/k8s/ark_sia_k8s_service.py</code> <pre><code>def generate_kubeconfig(self, generate_kubeconfig: ArkSIAK8SGenerateKubeConfig) -&gt; Optional[str]:\n    \"\"\"\n    Builds a Kube config file used to connect to a K8s cluster\n\n    Args:\n        generate_kubeconfig (ArkSIAK8SGenerateKubeConfig): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Building kube config file')\n    response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n    result = response.text\n    if generate_kubeconfig.folder:\n        ArkSIAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n        return None\n    return result\n</code></pre>"},{"location":"reference/services/sia/k8s/ark_sia_k8s_service/","title":"ark_sia_k8s_service","text":""},{"location":"reference/services/sia/k8s/ark_sia_k8s_service/#ark_sdk_python.services.sia.k8s.ark_sia_k8s_service.ArkSIAK8SService","title":"<code>ArkSIAK8SService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/k8s/ark_sia_k8s_service.py</code> <pre><code>class ArkSIAK8SService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    @staticmethod\n    def _save_kube_config_file(folder: str, result: str) -&gt; None:\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(f'{folder}{os.path.sep}config', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result)\n\n    def generate_kubeconfig(self, generate_kubeconfig: ArkSIAK8SGenerateKubeConfig) -&gt; Optional[str]:\n        \"\"\"\n        Builds a Kube config file used to connect to a K8s cluster\n\n        Args:\n            generate_kubeconfig (ArkSIAK8SGenerateKubeConfig): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Building kube config file')\n        response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n        result = response.text\n        if generate_kubeconfig.folder:\n            ArkSIAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n            return None\n        return result\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/k8s/ark_sia_k8s_service/#ark_sdk_python.services.sia.k8s.ark_sia_k8s_service.ArkSIAK8SService.generate_kubeconfig","title":"<code>generate_kubeconfig(generate_kubeconfig)</code>","text":"<p>Builds a Kube config file used to connect to a K8s cluster</p> <p>Parameters:</p> Name Type Description Default <code>generate_kubeconfig</code> <code>ArkSIAK8SGenerateKubeConfig</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/k8s/ark_sia_k8s_service.py</code> <pre><code>def generate_kubeconfig(self, generate_kubeconfig: ArkSIAK8SGenerateKubeConfig) -&gt; Optional[str]:\n    \"\"\"\n    Builds a Kube config file used to connect to a K8s cluster\n\n    Args:\n        generate_kubeconfig (ArkSIAK8SGenerateKubeConfig): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Building kube config file')\n    response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n    result = response.text\n    if generate_kubeconfig.folder:\n        ArkSIAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n        return None\n    return result\n</code></pre>"},{"location":"reference/services/sia/policies/","title":"policies","text":""},{"location":"reference/services/sia/policies/db/","title":"db","text":""},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService","title":"<code>ArkSIADBPoliciesService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>class ArkSIADBPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkSIADBPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find db policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    def add_policy(self, add_policy: ArkSIADBAddPolicy) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Adds a new DB policy with the specified information.\n\n        Args:\n            add_policy (ArkSIADBAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.model_dump(by_alias=True, exclude_none=True)\n        resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) DB policy.\n\n        Args:\n            delete_policy (ArkSIADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkSIADBUpdatePolicy) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Updates a DB policy.\n\n        Args:\n            update_policy (ArkSIADBUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n        update_dict = json.loads(\n            update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n        )\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) DB policy.\n\n        Args:\n            update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.model_dump(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkSIADBPolicyListItem]:\n        \"\"\"\n        Lists all of the tenants's DB policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkSIADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all db policies')\n        resp: Response = self.__client.get(DB_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkSIADBPolicyListItem]).validate_python(resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkSIADBPoliciesFilter) -&gt; List[ArkSIADBPolicyListItem]:\n        \"\"\"\n        Lists DB policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkSIADBPoliciesFilter): _description_\n\n        Returns:\n            List[ArkSIADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Retrieves a DB policy by ID.\n\n        Args:\n            get_policy (ArkSIAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkSIADBPoliciesStats:\n        \"\"\"\n        Calculates policy statistics.\n\n        Returns:\n            ArkSIADBPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating db policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkSIADBPoliciesStats.model_construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.providers:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new DB policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkSIADBAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkSIADBAddPolicy) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Adds a new DB policy with the specified information.\n\n    Args:\n        add_policy (ArkSIADBAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.model_dump(by_alias=True, exclude_none=True)\n    resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkSIADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) DB policy.\n\n    Args:\n        delete_policy (ArkSIADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all of the tenants's DB policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkSIADBPolicyListItem]</code> <p>List[ArkSIADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkSIADBPolicyListItem]:\n    \"\"\"\n    Lists all of the tenants's DB policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkSIADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all db policies')\n    resp: Response = self.__client.get(DB_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return TypeAdapter(List[ArkSIADBPolicyListItem]).validate_python(resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists DB policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkSIADBPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIADBPolicyListItem]</code> <p>List[ArkSIADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkSIADBPoliciesFilter) -&gt; List[ArkSIADBPolicyListItem]:\n    \"\"\"\n    Lists DB policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkSIADBPoliciesFilter): _description_\n\n    Returns:\n        List[ArkSIADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesStats</code> <code>ArkSIADBPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkSIADBPoliciesStats:\n    \"\"\"\n    Calculates policy statistics.\n\n    Returns:\n        ArkSIADBPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating db policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkSIADBPoliciesStats.model_construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.providers:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a DB policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkSIAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Retrieves a DB policy by ID.\n\n    Args:\n        get_policy (ArkSIAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkSIADBUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkSIADBUpdatePolicy) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Updates a DB policy.\n\n    Args:\n        update_policy (ArkSIADBUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n    update_dict = json.loads(\n        update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n    )\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/#ark_sdk_python.services.sia.policies.db.ArkSIADBPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkSIAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) DB policy.\n\n    Args:\n        update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.model_dump(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/","title":"ark_sia_db_policies_service","text":""},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService","title":"<code>ArkSIADBPoliciesService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>class ArkSIADBPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkSIADBPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find db policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    def add_policy(self, add_policy: ArkSIADBAddPolicy) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Adds a new DB policy with the specified information.\n\n        Args:\n            add_policy (ArkSIADBAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.model_dump(by_alias=True, exclude_none=True)\n        resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) DB policy.\n\n        Args:\n            delete_policy (ArkSIADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkSIADBUpdatePolicy) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Updates a DB policy.\n\n        Args:\n            update_policy (ArkSIADBUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n        update_dict = json.loads(\n            update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n        )\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) DB policy.\n\n        Args:\n            update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.model_dump(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkSIADBPolicyListItem]:\n        \"\"\"\n        Lists all of the tenants's DB policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkSIADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all db policies')\n        resp: Response = self.__client.get(DB_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkSIADBPolicyListItem]).validate_python(resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkSIADBPoliciesFilter) -&gt; List[ArkSIADBPolicyListItem]:\n        \"\"\"\n        Lists DB policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkSIADBPoliciesFilter): _description_\n\n        Returns:\n            List[ArkSIADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIADBPolicy:\n        \"\"\"\n        Retrieves a DB policy by ID.\n\n        Args:\n            get_policy (ArkSIAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkSIADBPoliciesStats:\n        \"\"\"\n        Calculates policy statistics.\n\n        Returns:\n            ArkSIADBPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating db policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkSIADBPoliciesStats.model_construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.providers:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new DB policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkSIADBAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkSIADBAddPolicy) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Adds a new DB policy with the specified information.\n\n    Args:\n        add_policy (ArkSIADBAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.model_dump(by_alias=True, exclude_none=True)\n    resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkSIADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) DB policy.\n\n    Args:\n        delete_policy (ArkSIADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all of the tenants's DB policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkSIADBPolicyListItem]</code> <p>List[ArkSIADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkSIADBPolicyListItem]:\n    \"\"\"\n    Lists all of the tenants's DB policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkSIADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all db policies')\n    resp: Response = self.__client.get(DB_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return TypeAdapter(List[ArkSIADBPolicyListItem]).validate_python(resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists DB policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkSIADBPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIADBPolicyListItem]</code> <p>List[ArkSIADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkSIADBPoliciesFilter) -&gt; List[ArkSIADBPolicyListItem]:\n    \"\"\"\n    Lists DB policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkSIADBPoliciesFilter): _description_\n\n    Returns:\n        List[ArkSIADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPoliciesStats</code> <code>ArkSIADBPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkSIADBPoliciesStats:\n    \"\"\"\n    Calculates policy statistics.\n\n    Returns:\n        ArkSIADBPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating db policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkSIADBPoliciesStats.model_construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.providers:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a DB policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkSIAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Retrieves a DB policy by ID.\n\n    Args:\n        get_policy (ArkSIAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkSIADBUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkSIADBUpdatePolicy) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Updates a DB policy.\n\n    Args:\n        update_policy (ArkSIADBUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n    update_dict = json.loads(\n        update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n    )\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/db/ark_sia_db_policies_service/#ark_sdk_python.services.sia.policies.db.ark_sia_db_policies_service.ArkSIADBPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkSIAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBPolicy</code> <code>ArkSIADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/db/ark_sia_db_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIADBPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) DB policy.\n\n    Args:\n        update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.model_dump(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/","title":"vm","text":""},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService","title":"<code>ArkSIAVMPoliciesService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>class ArkSIAVMPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = list(\n            itertools.chain.from_iterable([p.items for p in list(self.list_policies_by(ArkSIAVMPoliciesFilter(name=policy_name)))])\n        )\n\n        if not policies:\n            raise ArkServiceException(f'Failed to find vm policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    @staticmethod\n    def __serialize_providers_dict(providers_data: ArkSIAVMProvidersDict) -&gt; Dict:\n        serialized_providers_data = {}\n        for k in list(providers_data.keys()):\n            serialized_providers_data[serialize_sia_vm_policies_workspace_type(k)] = providers_data[k].model_dump(by_alias=True)\n        return serialized_providers_data\n\n    @staticmethod\n    def __serialize_authorization_rules_dict(authorization_rules: List[Dict]) -&gt; None:\n        for rule in authorization_rules:\n            for k in list(rule['connectionInformation']['connectAs'].keys()):\n                for pk in list(rule['connectionInformation']['connectAs'][k].keys()):\n                    item = rule['connectionInformation']['connectAs'][k][pk]\n                    del rule['connectionInformation']['connectAs'][k][pk]\n                    rule['connectionInformation']['connectAs'][k][serialize_sia_vm_policies_protocol_type(pk)] = item\n                item = rule['connectionInformation']['connectAs'][k]\n                del rule['connectionInformation']['connectAs'][k]\n                rule['connectionInformation']['connectAs'][serialize_sia_vm_policies_workspace_type(k)] = item\n\n    def add_policy(self, add_policy: ArkSIAVMAddPolicy) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Adds a new VM policy with the specified information.\n\n        Args:\n            add_policy (ArkDPVMAAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.model_dump(by_alias=True)\n        add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n        self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n        resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) VM policy.\n\n        Args:\n            delete_policy (ArkSIADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkSIAVMUpdatePolicy) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Updates a VM policy.\n\n        Args:\n            update_policy (ArkSIAVMUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n        update_dict = json.loads(\n            update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n        )\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        if update_policy.providers_data:\n            update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n        if 'userAccessRules' in update_dict:\n            self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n        resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIAVMPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) VM policy.\n\n        Args:\n            update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.model_dump(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n\n    def __get_policies(self, params: dict) -&gt; Tuple[List[Union[ArkSIABasePolicyListItemExtended, ArkSIAVMPolicyListItem]], int]:\n        resp: Response = self.__client.get(VM_POLICIES_API, params=params)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n        try:\n            return self.__parse_policies(resp, params.get('extended', False)), json.loads(resp.text)['totalCount']\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n\n    def query_policies(self, policies_filter: ArkSIAVMQueryPolicies = None) -&gt; Iterator[ArkPolicyListItemPage]:\n        \"\"\"\n        Lists VM policies that match the specified query.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            Iterator[ArkPolicyListItemPage]: _description_\n        \"\"\"\n        if policies_filter is not None and not isinstance(policies_filter, ArkSIAVMQueryPolicies):\n            raise TypeError('policies_filter must be an instance of ArkSIAVMPoliciesFilterByQuery')\n\n        self._logger.info(f'Retrieving all vm policies that comply to the filter: {policies_filter=}')\n        params = self.__build_url_params(policies_filter=policies_filter)\n        offset = params.get('offset', 0)\n\n        iteration_count = 0\n        while True:\n            params['offset'] = offset\n            parsed_policies, total_policies = self.__get_policies(params=params)\n            yield ArkPolicyListItemPage(items=parsed_policies)\n\n            offset += len(parsed_policies)\n            if offset &gt;= total_policies or (policies_filter and policies_filter.limit):\n                break\n\n            iteration_count += 1\n            if iteration_count &gt;= MAX_ITERATIONS:\n                raise ArkException('Reached maximum number of iterations for listing policies.')\n\n    def __build_url_params(self, policies_filter: ArkSIAVMQueryPolicies = None) -&gt; Dict:\n        if not policies_filter:\n            return {}\n\n        query_params = {}\n        if policies_filter.filter_string:\n            query_params['filter'] = policies_filter.filter_string\n        if policies_filter.limit:\n            query_params['limit'] = policies_filter.limit\n        else:\n            query_params['limit'] = POLICIES_QUERY_MAX_LIMIT\n        if policies_filter.extended:\n            query_params['extended'] = policies_filter.extended\n        if policies_filter.sort:\n            query_params['sort'] = policies_filter.sort\n        if policies_filter.offset:\n            query_params['offset'] = policies_filter.offset\n        return query_params\n\n    def __parse_policies(\n        self, response: Response, is_extended: bool\n    ) -&gt; List[Union[ArkSIABasePolicyListItemExtended, ArkSIAVMPolicyListItem]]:\n        response_items = response.json()['items']\n        if is_extended:\n            for item in response_items:\n                # Inserting the provider name into the provider data for parsing reasons\n                if 'providersData' in item:\n                    for provider, provider_data in item['providersData'].items():\n                        provider_data['provider_name'] = provider\n        return TypeAdapter(List[ArkSIABasePolicyListItemExtended if is_extended else ArkSIAVMPolicyListItem]).validate_python(\n            response_items\n        )\n\n    def list_policies(self) -&gt; Iterator[ArkPolicyListItemPage]:\n        \"\"\"\n        Lists all the tenants' VM policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkSIAVMPolicyListItem]: _description_\n        \"\"\"\n        return self.query_policies()\n\n    def list_policies_by(self, policies_filter: ArkSIAVMPoliciesFilter) -&gt; Iterator[ArkPolicyListItemPage]:\n        \"\"\"\n        Lists VM policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkSIAVMPoliciesFilter): _description_\n\n        Returns:\n            Iterator[ArkPolicyListItemPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n        filter_pairs = []\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            filter_pairs = [('status', status.value, 'eq') for status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            filter_pairs.append(('policyName', policies_filter.name, 'eq'))\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            platform_pairs = [('platforms', platform.upper(), 'contains') for platform in policies_filter.providers]\n            filter_pairs.extend(platform_pairs)\n\n        final_filter = self.__build_filter_string(filter_pairs)\n        return self.query_policies(ArkSIAVMQueryPolicies(filter_string=final_filter))\n\n    def __build_filter_string(self, filter_pairs):\n        final_filter = \"\"\n        for index in range(len(filter_pairs)):\n            if index == 0:\n                final_filter = f\"({filter_pairs[index][0]} {filter_pairs[index][2]} '{filter_pairs[index][1]}')\"\n            else:\n                if filter_pairs[index][0] == 'status':\n                    final_filter = f\"({final_filter} or ({filter_pairs[index][0]} {filter_pairs[index][2]} '{filter_pairs[index][1]}'))\"\n                else:\n                    final_filter = f\"({final_filter} and ({filter_pairs[index][0]} {filter_pairs[index][2]} '{filter_pairs[index][1]}'))\"\n        return final_filter\n\n    def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Retrieves a VM policy by ID.\n\n        Args:\n            get_policy (ArkSIAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIAVMPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkSIAVMPoliciesStats:\n        \"\"\"\n        Calculates VM policy statistics.\n\n        Returns:\n            ArkSIAVMPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm policies stats')\n        policies = list(itertools.chain.from_iterable([p.items for p in list(self.list_policies())]))\n        policies_stats = ArkSIAVMPoliciesStats.model_construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.platforms:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new VM policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPVMAAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkSIAVMAddPolicy) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Adds a new VM policy with the specified information.\n\n    Args:\n        add_policy (ArkDPVMAAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.model_dump(by_alias=True)\n    add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n    self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n    resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkSIADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) VM policy.\n\n    Args:\n        delete_policy (ArkSIADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all the tenants' VM policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>Iterator[ArkPolicyListItemPage]</code> <p>List[ArkSIAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def list_policies(self) -&gt; Iterator[ArkPolicyListItemPage]:\n    \"\"\"\n    Lists all the tenants' VM policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkSIAVMPolicyListItem]: _description_\n    \"\"\"\n    return self.query_policies()\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists VM policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkSIAVMPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>Iterator[ArkPolicyListItemPage]</code> <p>Iterator[ArkPolicyListItemPage]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkSIAVMPoliciesFilter) -&gt; Iterator[ArkPolicyListItemPage]:\n    \"\"\"\n    Lists VM policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkSIAVMPoliciesFilter): _description_\n\n    Returns:\n        Iterator[ArkPolicyListItemPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n    filter_pairs = []\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        filter_pairs = [('status', status.value, 'eq') for status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        filter_pairs.append(('policyName', policies_filter.name, 'eq'))\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        platform_pairs = [('platforms', platform.upper(), 'contains') for platform in policies_filter.providers]\n        filter_pairs.extend(platform_pairs)\n\n    final_filter = self.__build_filter_string(filter_pairs)\n    return self.query_policies(ArkSIAVMQueryPolicies(filter_string=final_filter))\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates VM policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesStats</code> <code>ArkSIAVMPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkSIAVMPoliciesStats:\n    \"\"\"\n    Calculates VM policy statistics.\n\n    Returns:\n        ArkSIAVMPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm policies stats')\n    policies = list(itertools.chain.from_iterable([p.items for p in list(self.list_policies())]))\n    policies_stats = ArkSIAVMPoliciesStats.model_construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.platforms:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a VM policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkSIAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Retrieves a VM policy by ID.\n\n    Args:\n        get_policy (ArkSIAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIAVMPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.query_policies","title":"<code>query_policies(policies_filter=None)</code>","text":"<p>Lists VM policies that match the specified query.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>Iterator[ArkPolicyListItemPage]</code> <p>Iterator[ArkPolicyListItemPage]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def query_policies(self, policies_filter: ArkSIAVMQueryPolicies = None) -&gt; Iterator[ArkPolicyListItemPage]:\n    \"\"\"\n    Lists VM policies that match the specified query.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        Iterator[ArkPolicyListItemPage]: _description_\n    \"\"\"\n    if policies_filter is not None and not isinstance(policies_filter, ArkSIAVMQueryPolicies):\n        raise TypeError('policies_filter must be an instance of ArkSIAVMPoliciesFilterByQuery')\n\n    self._logger.info(f'Retrieving all vm policies that comply to the filter: {policies_filter=}')\n    params = self.__build_url_params(policies_filter=policies_filter)\n    offset = params.get('offset', 0)\n\n    iteration_count = 0\n    while True:\n        params['offset'] = offset\n        parsed_policies, total_policies = self.__get_policies(params=params)\n        yield ArkPolicyListItemPage(items=parsed_policies)\n\n        offset += len(parsed_policies)\n        if offset &gt;= total_policies or (policies_filter and policies_filter.limit):\n            break\n\n        iteration_count += 1\n        if iteration_count &gt;= MAX_ITERATIONS:\n            raise ArkException('Reached maximum number of iterations for listing policies.')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkSIAVMUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkSIAVMUpdatePolicy) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Updates a VM policy.\n\n    Args:\n        update_policy (ArkSIAVMUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n    update_dict = json.loads(\n        update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n    )\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    if update_policy.providers_data:\n        update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n    if 'userAccessRules' in update_dict:\n        self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n    resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIAVMPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/#ark_sdk_python.services.sia.policies.vm.ArkSIAVMPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkSIAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) VM policy.\n\n    Args:\n        update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.model_dump(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/","title":"ark_sia_vm_policies_service","text":""},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService","title":"<code>ArkSIAVMPoliciesService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>class ArkSIAVMPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = list(\n            itertools.chain.from_iterable([p.items for p in list(self.list_policies_by(ArkSIAVMPoliciesFilter(name=policy_name)))])\n        )\n\n        if not policies:\n            raise ArkServiceException(f'Failed to find vm policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    @staticmethod\n    def __serialize_providers_dict(providers_data: ArkSIAVMProvidersDict) -&gt; Dict:\n        serialized_providers_data = {}\n        for k in list(providers_data.keys()):\n            serialized_providers_data[serialize_sia_vm_policies_workspace_type(k)] = providers_data[k].model_dump(by_alias=True)\n        return serialized_providers_data\n\n    @staticmethod\n    def __serialize_authorization_rules_dict(authorization_rules: List[Dict]) -&gt; None:\n        for rule in authorization_rules:\n            for k in list(rule['connectionInformation']['connectAs'].keys()):\n                for pk in list(rule['connectionInformation']['connectAs'][k].keys()):\n                    item = rule['connectionInformation']['connectAs'][k][pk]\n                    del rule['connectionInformation']['connectAs'][k][pk]\n                    rule['connectionInformation']['connectAs'][k][serialize_sia_vm_policies_protocol_type(pk)] = item\n                item = rule['connectionInformation']['connectAs'][k]\n                del rule['connectionInformation']['connectAs'][k]\n                rule['connectionInformation']['connectAs'][serialize_sia_vm_policies_workspace_type(k)] = item\n\n    def add_policy(self, add_policy: ArkSIAVMAddPolicy) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Adds a new VM policy with the specified information.\n\n        Args:\n            add_policy (ArkDPVMAAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.model_dump(by_alias=True)\n        add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n        self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n        resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) VM policy.\n\n        Args:\n            delete_policy (ArkSIADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkSIAVMUpdatePolicy) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Updates a VM policy.\n\n        Args:\n            update_policy (ArkSIAVMUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n        update_dict = json.loads(\n            update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n        )\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        if update_policy.providers_data:\n            update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n        if 'userAccessRules' in update_dict:\n            self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n        resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIAVMPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) VM policy.\n\n        Args:\n            update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.model_dump(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n\n    def __get_policies(self, params: dict) -&gt; Tuple[List[Union[ArkSIABasePolicyListItemExtended, ArkSIAVMPolicyListItem]], int]:\n        resp: Response = self.__client.get(VM_POLICIES_API, params=params)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n        try:\n            return self.__parse_policies(resp, params.get('extended', False)), json.loads(resp.text)['totalCount']\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n\n    def query_policies(self, policies_filter: ArkSIAVMQueryPolicies = None) -&gt; Iterator[ArkPolicyListItemPage]:\n        \"\"\"\n        Lists VM policies that match the specified query.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            Iterator[ArkPolicyListItemPage]: _description_\n        \"\"\"\n        if policies_filter is not None and not isinstance(policies_filter, ArkSIAVMQueryPolicies):\n            raise TypeError('policies_filter must be an instance of ArkSIAVMPoliciesFilterByQuery')\n\n        self._logger.info(f'Retrieving all vm policies that comply to the filter: {policies_filter=}')\n        params = self.__build_url_params(policies_filter=policies_filter)\n        offset = params.get('offset', 0)\n\n        iteration_count = 0\n        while True:\n            params['offset'] = offset\n            parsed_policies, total_policies = self.__get_policies(params=params)\n            yield ArkPolicyListItemPage(items=parsed_policies)\n\n            offset += len(parsed_policies)\n            if offset &gt;= total_policies or (policies_filter and policies_filter.limit):\n                break\n\n            iteration_count += 1\n            if iteration_count &gt;= MAX_ITERATIONS:\n                raise ArkException('Reached maximum number of iterations for listing policies.')\n\n    def __build_url_params(self, policies_filter: ArkSIAVMQueryPolicies = None) -&gt; Dict:\n        if not policies_filter:\n            return {}\n\n        query_params = {}\n        if policies_filter.filter_string:\n            query_params['filter'] = policies_filter.filter_string\n        if policies_filter.limit:\n            query_params['limit'] = policies_filter.limit\n        else:\n            query_params['limit'] = POLICIES_QUERY_MAX_LIMIT\n        if policies_filter.extended:\n            query_params['extended'] = policies_filter.extended\n        if policies_filter.sort:\n            query_params['sort'] = policies_filter.sort\n        if policies_filter.offset:\n            query_params['offset'] = policies_filter.offset\n        return query_params\n\n    def __parse_policies(\n        self, response: Response, is_extended: bool\n    ) -&gt; List[Union[ArkSIABasePolicyListItemExtended, ArkSIAVMPolicyListItem]]:\n        response_items = response.json()['items']\n        if is_extended:\n            for item in response_items:\n                # Inserting the provider name into the provider data for parsing reasons\n                if 'providersData' in item:\n                    for provider, provider_data in item['providersData'].items():\n                        provider_data['provider_name'] = provider\n        return TypeAdapter(List[ArkSIABasePolicyListItemExtended if is_extended else ArkSIAVMPolicyListItem]).validate_python(\n            response_items\n        )\n\n    def list_policies(self) -&gt; Iterator[ArkPolicyListItemPage]:\n        \"\"\"\n        Lists all the tenants' VM policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkSIAVMPolicyListItem]: _description_\n        \"\"\"\n        return self.query_policies()\n\n    def list_policies_by(self, policies_filter: ArkSIAVMPoliciesFilter) -&gt; Iterator[ArkPolicyListItemPage]:\n        \"\"\"\n        Lists VM policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkSIAVMPoliciesFilter): _description_\n\n        Returns:\n            Iterator[ArkPolicyListItemPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n        filter_pairs = []\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            filter_pairs = [('status', status.value, 'eq') for status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            filter_pairs.append(('policyName', policies_filter.name, 'eq'))\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            platform_pairs = [('platforms', platform.upper(), 'contains') for platform in policies_filter.providers]\n            filter_pairs.extend(platform_pairs)\n\n        final_filter = self.__build_filter_string(filter_pairs)\n        return self.query_policies(ArkSIAVMQueryPolicies(filter_string=final_filter))\n\n    def __build_filter_string(self, filter_pairs):\n        final_filter = \"\"\n        for index in range(len(filter_pairs)):\n            if index == 0:\n                final_filter = f\"({filter_pairs[index][0]} {filter_pairs[index][2]} '{filter_pairs[index][1]}')\"\n            else:\n                if filter_pairs[index][0] == 'status':\n                    final_filter = f\"({final_filter} or ({filter_pairs[index][0]} {filter_pairs[index][2]} '{filter_pairs[index][1]}'))\"\n                else:\n                    final_filter = f\"({final_filter} and ({filter_pairs[index][0]} {filter_pairs[index][2]} '{filter_pairs[index][1]}'))\"\n        return final_filter\n\n    def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIAVMPolicy:\n        \"\"\"\n        Retrieves a VM policy by ID.\n\n        Args:\n            get_policy (ArkSIAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIAVMPolicy.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkSIAVMPoliciesStats:\n        \"\"\"\n        Calculates VM policy statistics.\n\n        Returns:\n            ArkSIAVMPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm policies stats')\n        policies = list(itertools.chain.from_iterable([p.items for p in list(self.list_policies())]))\n        policies_stats = ArkSIAVMPoliciesStats.model_construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.platforms:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new VM policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPVMAAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkSIAVMAddPolicy) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Adds a new VM policy with the specified information.\n\n    Args:\n        add_policy (ArkDPVMAAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.model_dump(by_alias=True)\n    add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n    self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n    resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkSIAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkSIADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkSIADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) VM policy.\n\n    Args:\n        delete_policy (ArkSIADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all the tenants' VM policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>Iterator[ArkPolicyListItemPage]</code> <p>List[ArkSIAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def list_policies(self) -&gt; Iterator[ArkPolicyListItemPage]:\n    \"\"\"\n    Lists all the tenants' VM policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkSIAVMPolicyListItem]: _description_\n    \"\"\"\n    return self.query_policies()\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists VM policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkSIAVMPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>Iterator[ArkPolicyListItemPage]</code> <p>Iterator[ArkPolicyListItemPage]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkSIAVMPoliciesFilter) -&gt; Iterator[ArkPolicyListItemPage]:\n    \"\"\"\n    Lists VM policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkSIAVMPoliciesFilter): _description_\n\n    Returns:\n        Iterator[ArkPolicyListItemPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n    filter_pairs = []\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        filter_pairs = [('status', status.value, 'eq') for status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        filter_pairs.append(('policyName', policies_filter.name, 'eq'))\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        platform_pairs = [('platforms', platform.upper(), 'contains') for platform in policies_filter.providers]\n        filter_pairs.extend(platform_pairs)\n\n    final_filter = self.__build_filter_string(filter_pairs)\n    return self.query_policies(ArkSIAVMQueryPolicies(filter_string=final_filter))\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates VM policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPoliciesStats</code> <code>ArkSIAVMPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkSIAVMPoliciesStats:\n    \"\"\"\n    Calculates VM policy statistics.\n\n    Returns:\n        ArkSIAVMPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm policies stats')\n    policies = list(itertools.chain.from_iterable([p.items for p in list(self.list_policies())]))\n    policies_stats = ArkSIAVMPoliciesStats.model_construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkSIARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.platforms:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a VM policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkSIAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkSIAGetPolicy) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Retrieves a VM policy by ID.\n\n    Args:\n        get_policy (ArkSIAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIAVMPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.query_policies","title":"<code>query_policies(policies_filter=None)</code>","text":"<p>Lists VM policies that match the specified query.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>Iterator[ArkPolicyListItemPage]</code> <p>Iterator[ArkPolicyListItemPage]: description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def query_policies(self, policies_filter: ArkSIAVMQueryPolicies = None) -&gt; Iterator[ArkPolicyListItemPage]:\n    \"\"\"\n    Lists VM policies that match the specified query.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        Iterator[ArkPolicyListItemPage]: _description_\n    \"\"\"\n    if policies_filter is not None and not isinstance(policies_filter, ArkSIAVMQueryPolicies):\n        raise TypeError('policies_filter must be an instance of ArkSIAVMPoliciesFilterByQuery')\n\n    self._logger.info(f'Retrieving all vm policies that comply to the filter: {policies_filter=}')\n    params = self.__build_url_params(policies_filter=policies_filter)\n    offset = params.get('offset', 0)\n\n    iteration_count = 0\n    while True:\n        params['offset'] = offset\n        parsed_policies, total_policies = self.__get_policies(params=params)\n        yield ArkPolicyListItemPage(items=parsed_policies)\n\n        offset += len(parsed_policies)\n        if offset &gt;= total_policies or (policies_filter and policies_filter.limit):\n            break\n\n        iteration_count += 1\n        if iteration_count &gt;= MAX_ITERATIONS:\n            raise ArkException('Reached maximum number of iterations for listing policies.')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkSIAVMUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkSIAVMUpdatePolicy) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Updates a VM policy.\n\n    Args:\n        update_policy (ArkSIAVMUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n    update_dict = json.loads(\n        update_policy.model_dump_json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'})\n    )\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    if update_policy.providers_data:\n        update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n    if 'userAccessRules' in update_dict:\n        self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n    resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIAVMPolicy.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/policies/vm/ark_sia_vm_policies_service/#ark_sdk_python.services.sia.policies.vm.ark_sia_vm_policies_service.ArkSIAVMPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkSIAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMPolicy</code> <code>ArkSIAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/policies/vm/ark_sia_vm_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkSIAUpdatePolicyStatus) -&gt; ArkSIAVMPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) VM policy.\n\n    Args:\n        update_policy_status (ArkSIAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.model_dump(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkSIAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/","title":"secrets","text":""},{"location":"reference/services/sia/secrets/db/","title":"db","text":""},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService","title":"<code>ArkSIADBSecretsService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>class ArkSIADBSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkSIADBSecretType] = None,\n        tags: Optional[List[ArkSIADBTag]] = None,\n    ) -&gt; ArkSIADBSecretMetadataList:\n        params = {}\n        if secret_type:\n            params['secret_type'] = secret_type.value\n        if tags:\n            params.update({t.key: t.value for t in tags})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBSecretMetadataList.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkSIADBAddSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Adds a new DB secret to the secret store.\n\n        Args:\n            add_secret (ArkSIADBAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        self._logger.info('Adding new db secret')\n        add_secret_dict = add_secret.model_dump(\n            exclude_none=True,\n            exclude={\n                'store_type',\n                'username',\n                'password',\n                'pam_safe',\n                'pam_account_name',\n                'iam_username',\n                'iam_account',\n                'iam_access_key_id',\n                'iam_secret_access_key',\n                'atlas_public_key',\n                'atlas_private_key',\n            },\n        )\n        if not add_secret.store_type:\n            add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n        add_secret_dict['secret_store'] = {\n            'store_type': add_secret.store_type.value,\n        }\n        if add_secret.secret_type == ArkSIADBSecretType.UsernamePassword:\n            if not add_secret.username or not add_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password type, both username and password parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'username': add_secret.username,\n                'password': add_secret.password.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkSIADBSecretType.CyberArkPAM:\n            if not add_secret.pam_account_name or not add_secret.pam_safe:\n                raise ArkServiceException(\n                    'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n                )\n            add_secret_dict['secret_link'] = {\n                'safe': add_secret.pam_safe,\n                'account_name': add_secret.pam_account_name,\n            }\n        elif add_secret.secret_type == ArkSIADBSecretType.IAMUser:\n            if (\n                not add_secret.iam_access_key_id\n                or not add_secret.iam_secret_access_key\n                or not add_secret.iam_account\n                or not add_secret.iam_username\n            ):\n                raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n            add_secret_dict['secret_data'] = {\n                'account': add_secret.iam_account,\n                'username': add_secret.iam_username,\n                'access_key_id': add_secret.iam_access_key_id.get_secret_value(),\n                'secret_access_key': add_secret.iam_secret_access_key.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkSIADBSecretType.AtlasAccessKeys:\n            if not add_secret.atlas_public_key or not add_secret.atlas_private_key:\n                raise ArkServiceException(\n                    'When specifying an atlas secret type, both private key and public key parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'public_key': add_secret.atlas_public_key,\n                'private_key': add_secret.atlas_private_key.get_secret_value(),\n            }\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json=add_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkSIADBSecretMetadata.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n\n    def update_secret(self, update_secret: ArkSIADBUpdateSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Updates a DB secret.\n\n        Args:\n            update_secret (ArkSIADBUpdateSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if update_secret.secret_name and not update_secret.secret_id:\n            update_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=update_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n        update_secret_dict = update_secret.model_dump(\n            exclude_none=True,\n            exclude={\n                'secret_id',\n                'secret_name',\n                'new_secret_name',\n                'username',\n                'password',\n                'pam_safe',\n                'pam_account_name',\n                'iam_username',\n                'iam_account',\n                'iam_access_key_id',\n                'iam_secret_access_key',\n                'atlas_public_key',\n                'atlas_private_key',\n            },\n        )\n        if update_secret.new_secret_name:\n            update_secret_dict['secret_name'] = update_secret.new_secret_name\n        if update_secret.pam_account_name or update_secret.pam_safe:\n            if not update_secret.pam_account_name or not update_secret.pam_safe:\n                raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n            update_secret_dict['secret_link'] = {\n                'safe': update_secret.pam_safe,\n                'account_name': update_secret.pam_account_name,\n            }\n        if update_secret.username or update_secret.password:\n            if not update_secret.username or not update_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password secret, both username and password name parameters must be supplied'\n                )\n            update_secret_dict['secret_data'] = {\n                'username': update_secret.username,\n                'password': update_secret.password.get_secret_value(),\n            }\n        if (\n            update_secret.iam_access_key_id\n            or update_secret.iam_secret_access_key\n            or update_secret.iam_account\n            or update_secret.iam_username\n        ):\n            if (\n                not update_secret.iam_access_key_id\n                or not update_secret.iam_secret_access_key\n                or not update_secret.iam_account\n                or not update_secret.iam_username\n            ):\n                raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n            update_secret_dict['secret_data'] = {\n                'account': update_secret.iam_account,\n                'username': update_secret.iam_username,\n                'access_key_id': update_secret.iam_access_key_id.get_secret_value(),\n                'secret_access_key': update_secret.iam_secret_access_key.get_secret_value(),\n            }\n        if update_secret.atlas_public_key or update_secret.atlas_private_key:\n            if not update_secret.atlas_public_key or not update_secret.atlas_private_key:\n                raise ArkServiceException('When specifying an atlas secret, both private key and public key parameters must be supplied')\n            update_secret_dict['secret_data'] = {\n                'public_key': update_secret.atlas_public_key,\n                'private_key': update_secret.atlas_private_key.get_secret_value(),\n            }\n\n        resp: Response = self.__client.patch(\n            SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n            json=update_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBSecretMetadata.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkSIADBDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a DB secret.\n\n        Args:\n            delete_secret (ArkSIADBDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_secret.secret_name and not delete_secret.secret_id:\n            delete_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=delete_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; ArkSIADBSecretMetadataList:\n        \"\"\"\n        Lists all tenant DB secrets.\n\n        Returns:\n            ArkSIADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info('Listing all db secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkSIADBSecretsFilter) -&gt; ArkSIADBSecretMetadataList:\n        \"\"\"\n        Lists DB secrets that match the specified filters.\n\n        Args:\n            secrets_filter (ArkSIADBSecretsFilter): _description_\n\n        Returns:\n            ArkSIADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n        secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n        # Filter by secret types\n        if secrets_filter.store_type:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n        # Filter by name\n        if secrets_filter.secret_name:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n        secrets.total_count = len(secrets.secrets)\n\n        return secrets\n\n    def enable_secret(self, enable_secret: ArkSIADBEnableSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Enables a DB secret.\n\n        Args:\n            enable_secret (ArkSIADBEnableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if enable_secret.secret_name and not enable_secret.secret_id:\n            enable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=enable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n        resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to enable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def disable_secret(self, disable_secret: ArkSIADBDisableSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Disables a DB secret.\n\n        Args:\n            disable_secret (ArkSIADBDisableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if disable_secret.secret_name and not disable_secret.secret_id:\n            disable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=disable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n        resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to disable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secret(self, get_secret: ArkSIADBGetSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Retrieves a DB secret.\n\n        Args:\n            get_secret (ArkSIADBGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if get_secret.secret_name and not get_secret.secret_id:\n            get_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=get_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBSecretMetadata.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkSIADBSecretsStats:\n        \"\"\"\n        Calculates DB secrets statistics.\n\n        Returns:\n            ArkSIADBSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkSIADBSecretsStats.model_construct()\n        secrets_stats.secrets_count = len(secrets.secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n        # Count secrets per secret type\n        secret_types: Set[ArkSIADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n        secrets_stats.secrets_count_by_secret_type = {\n            st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        # Count secrets per store type\n        store_types: Set[ArkSIADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n        secrets_stats.secrets_count_by_store_type = {\n            st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new DB secret to the secret store.</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkSIADBAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkSIADBAddSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Adds a new DB secret to the secret store.\n\n    Args:\n        add_secret (ArkSIADBAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    self._logger.info('Adding new db secret')\n    add_secret_dict = add_secret.model_dump(\n        exclude_none=True,\n        exclude={\n            'store_type',\n            'username',\n            'password',\n            'pam_safe',\n            'pam_account_name',\n            'iam_username',\n            'iam_account',\n            'iam_access_key_id',\n            'iam_secret_access_key',\n            'atlas_public_key',\n            'atlas_private_key',\n        },\n    )\n    if not add_secret.store_type:\n        add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n    add_secret_dict['secret_store'] = {\n        'store_type': add_secret.store_type.value,\n    }\n    if add_secret.secret_type == ArkSIADBSecretType.UsernamePassword:\n        if not add_secret.username or not add_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password type, both username and password parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'username': add_secret.username,\n            'password': add_secret.password.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkSIADBSecretType.CyberArkPAM:\n        if not add_secret.pam_account_name or not add_secret.pam_safe:\n            raise ArkServiceException(\n                'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n            )\n        add_secret_dict['secret_link'] = {\n            'safe': add_secret.pam_safe,\n            'account_name': add_secret.pam_account_name,\n        }\n    elif add_secret.secret_type == ArkSIADBSecretType.IAMUser:\n        if (\n            not add_secret.iam_access_key_id\n            or not add_secret.iam_secret_access_key\n            or not add_secret.iam_account\n            or not add_secret.iam_username\n        ):\n            raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n        add_secret_dict['secret_data'] = {\n            'account': add_secret.iam_account,\n            'username': add_secret.iam_username,\n            'access_key_id': add_secret.iam_access_key_id.get_secret_value(),\n            'secret_access_key': add_secret.iam_secret_access_key.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkSIADBSecretType.AtlasAccessKeys:\n        if not add_secret.atlas_public_key or not add_secret.atlas_private_key:\n            raise ArkServiceException(\n                'When specifying an atlas secret type, both private key and public key parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'public_key': add_secret.atlas_public_key,\n            'private_key': add_secret.atlas_private_key.get_secret_value(),\n        }\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json=add_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkSIADBSecretMetadata.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkSIADBDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkSIADBDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a DB secret.\n\n    Args:\n        delete_secret (ArkSIADBDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_secret.secret_name and not delete_secret.secret_id:\n        delete_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=delete_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.disable_secret","title":"<code>disable_secret(disable_secret)</code>","text":"<p>Disables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>disable_secret</code> <code>ArkSIADBDisableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def disable_secret(self, disable_secret: ArkSIADBDisableSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Disables a DB secret.\n\n    Args:\n        disable_secret (ArkSIADBDisableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if disable_secret.secret_name and not disable_secret.secret_id:\n        disable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=disable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n    resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to disable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.enable_secret","title":"<code>enable_secret(enable_secret)</code>","text":"<p>Enables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>enable_secret</code> <code>ArkSIADBEnableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def enable_secret(self, enable_secret: ArkSIADBEnableSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Enables a DB secret.\n\n    Args:\n        enable_secret (ArkSIADBEnableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if enable_secret.secret_name and not enable_secret.secret_id:\n        enable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=enable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n    resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to enable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant DB secrets.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadataList</code> <code>ArkSIADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; ArkSIADBSecretMetadataList:\n    \"\"\"\n    Lists all tenant DB secrets.\n\n    Returns:\n        ArkSIADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info('Listing all db secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists DB secrets that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkSIADBSecretsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadataList</code> <code>ArkSIADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkSIADBSecretsFilter) -&gt; ArkSIADBSecretMetadataList:\n    \"\"\"\n    Lists DB secrets that match the specified filters.\n\n    Args:\n        secrets_filter (ArkSIADBSecretsFilter): _description_\n\n    Returns:\n        ArkSIADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n    secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n    # Filter by secret types\n    if secrets_filter.store_type:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n    # Filter by name\n    if secrets_filter.secret_name:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n    secrets.total_count = len(secrets.secrets)\n\n    return secrets\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkSIADBGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkSIADBGetSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Retrieves a DB secret.\n\n    Args:\n        get_secret (ArkSIADBGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if get_secret.secret_name and not get_secret.secret_id:\n        get_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=get_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBSecretMetadata.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates DB secrets statistics.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretsStats</code> <code>ArkSIADBSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkSIADBSecretsStats:\n    \"\"\"\n    Calculates DB secrets statistics.\n\n    Returns:\n        ArkSIADBSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkSIADBSecretsStats.model_construct()\n    secrets_stats.secrets_count = len(secrets.secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n    # Count secrets per secret type\n    secret_types: Set[ArkSIADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n    secrets_stats.secrets_count_by_secret_type = {\n        st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    # Count secrets per store type\n    store_types: Set[ArkSIADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n    secrets_stats.secrets_count_by_store_type = {\n        st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/sia/secrets/db/#ark_sdk_python.services.sia.secrets.db.ArkSIADBSecretsService.update_secret","title":"<code>update_secret(update_secret)</code>","text":"<p>Updates a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>update_secret</code> <code>ArkSIADBUpdateSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def update_secret(self, update_secret: ArkSIADBUpdateSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Updates a DB secret.\n\n    Args:\n        update_secret (ArkSIADBUpdateSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if update_secret.secret_name and not update_secret.secret_id:\n        update_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=update_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n    update_secret_dict = update_secret.model_dump(\n        exclude_none=True,\n        exclude={\n            'secret_id',\n            'secret_name',\n            'new_secret_name',\n            'username',\n            'password',\n            'pam_safe',\n            'pam_account_name',\n            'iam_username',\n            'iam_account',\n            'iam_access_key_id',\n            'iam_secret_access_key',\n            'atlas_public_key',\n            'atlas_private_key',\n        },\n    )\n    if update_secret.new_secret_name:\n        update_secret_dict['secret_name'] = update_secret.new_secret_name\n    if update_secret.pam_account_name or update_secret.pam_safe:\n        if not update_secret.pam_account_name or not update_secret.pam_safe:\n            raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n        update_secret_dict['secret_link'] = {\n            'safe': update_secret.pam_safe,\n            'account_name': update_secret.pam_account_name,\n        }\n    if update_secret.username or update_secret.password:\n        if not update_secret.username or not update_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password secret, both username and password name parameters must be supplied'\n            )\n        update_secret_dict['secret_data'] = {\n            'username': update_secret.username,\n            'password': update_secret.password.get_secret_value(),\n        }\n    if (\n        update_secret.iam_access_key_id\n        or update_secret.iam_secret_access_key\n        or update_secret.iam_account\n        or update_secret.iam_username\n    ):\n        if (\n            not update_secret.iam_access_key_id\n            or not update_secret.iam_secret_access_key\n            or not update_secret.iam_account\n            or not update_secret.iam_username\n        ):\n            raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n        update_secret_dict['secret_data'] = {\n            'account': update_secret.iam_account,\n            'username': update_secret.iam_username,\n            'access_key_id': update_secret.iam_access_key_id.get_secret_value(),\n            'secret_access_key': update_secret.iam_secret_access_key.get_secret_value(),\n        }\n    if update_secret.atlas_public_key or update_secret.atlas_private_key:\n        if not update_secret.atlas_public_key or not update_secret.atlas_private_key:\n            raise ArkServiceException('When specifying an atlas secret, both private key and public key parameters must be supplied')\n        update_secret_dict['secret_data'] = {\n            'public_key': update_secret.atlas_public_key,\n            'private_key': update_secret.atlas_private_key.get_secret_value(),\n        }\n\n    resp: Response = self.__client.patch(\n        SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n        json=update_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBSecretMetadata.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/","title":"ark_sia_db_secrets_service","text":""},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService","title":"<code>ArkSIADBSecretsService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>class ArkSIADBSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkSIADBSecretType] = None,\n        tags: Optional[List[ArkSIADBTag]] = None,\n    ) -&gt; ArkSIADBSecretMetadataList:\n        params = {}\n        if secret_type:\n            params['secret_type'] = secret_type.value\n        if tags:\n            params.update({t.key: t.value for t in tags})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBSecretMetadataList.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkSIADBAddSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Adds a new DB secret to the secret store.\n\n        Args:\n            add_secret (ArkSIADBAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        self._logger.info('Adding new db secret')\n        add_secret_dict = add_secret.model_dump(\n            exclude_none=True,\n            exclude={\n                'store_type',\n                'username',\n                'password',\n                'pam_safe',\n                'pam_account_name',\n                'iam_username',\n                'iam_account',\n                'iam_access_key_id',\n                'iam_secret_access_key',\n                'atlas_public_key',\n                'atlas_private_key',\n            },\n        )\n        if not add_secret.store_type:\n            add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n        add_secret_dict['secret_store'] = {\n            'store_type': add_secret.store_type.value,\n        }\n        if add_secret.secret_type == ArkSIADBSecretType.UsernamePassword:\n            if not add_secret.username or not add_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password type, both username and password parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'username': add_secret.username,\n                'password': add_secret.password.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkSIADBSecretType.CyberArkPAM:\n            if not add_secret.pam_account_name or not add_secret.pam_safe:\n                raise ArkServiceException(\n                    'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n                )\n            add_secret_dict['secret_link'] = {\n                'safe': add_secret.pam_safe,\n                'account_name': add_secret.pam_account_name,\n            }\n        elif add_secret.secret_type == ArkSIADBSecretType.IAMUser:\n            if (\n                not add_secret.iam_access_key_id\n                or not add_secret.iam_secret_access_key\n                or not add_secret.iam_account\n                or not add_secret.iam_username\n            ):\n                raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n            add_secret_dict['secret_data'] = {\n                'account': add_secret.iam_account,\n                'username': add_secret.iam_username,\n                'access_key_id': add_secret.iam_access_key_id.get_secret_value(),\n                'secret_access_key': add_secret.iam_secret_access_key.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkSIADBSecretType.AtlasAccessKeys:\n            if not add_secret.atlas_public_key or not add_secret.atlas_private_key:\n                raise ArkServiceException(\n                    'When specifying an atlas secret type, both private key and public key parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'public_key': add_secret.atlas_public_key,\n                'private_key': add_secret.atlas_private_key.get_secret_value(),\n            }\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json=add_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkSIADBSecretMetadata.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n\n    def update_secret(self, update_secret: ArkSIADBUpdateSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Updates a DB secret.\n\n        Args:\n            update_secret (ArkSIADBUpdateSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if update_secret.secret_name and not update_secret.secret_id:\n            update_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=update_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n        update_secret_dict = update_secret.model_dump(\n            exclude_none=True,\n            exclude={\n                'secret_id',\n                'secret_name',\n                'new_secret_name',\n                'username',\n                'password',\n                'pam_safe',\n                'pam_account_name',\n                'iam_username',\n                'iam_account',\n                'iam_access_key_id',\n                'iam_secret_access_key',\n                'atlas_public_key',\n                'atlas_private_key',\n            },\n        )\n        if update_secret.new_secret_name:\n            update_secret_dict['secret_name'] = update_secret.new_secret_name\n        if update_secret.pam_account_name or update_secret.pam_safe:\n            if not update_secret.pam_account_name or not update_secret.pam_safe:\n                raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n            update_secret_dict['secret_link'] = {\n                'safe': update_secret.pam_safe,\n                'account_name': update_secret.pam_account_name,\n            }\n        if update_secret.username or update_secret.password:\n            if not update_secret.username or not update_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password secret, both username and password name parameters must be supplied'\n                )\n            update_secret_dict['secret_data'] = {\n                'username': update_secret.username,\n                'password': update_secret.password.get_secret_value(),\n            }\n        if (\n            update_secret.iam_access_key_id\n            or update_secret.iam_secret_access_key\n            or update_secret.iam_account\n            or update_secret.iam_username\n        ):\n            if (\n                not update_secret.iam_access_key_id\n                or not update_secret.iam_secret_access_key\n                or not update_secret.iam_account\n                or not update_secret.iam_username\n            ):\n                raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n            update_secret_dict['secret_data'] = {\n                'account': update_secret.iam_account,\n                'username': update_secret.iam_username,\n                'access_key_id': update_secret.iam_access_key_id.get_secret_value(),\n                'secret_access_key': update_secret.iam_secret_access_key.get_secret_value(),\n            }\n        if update_secret.atlas_public_key or update_secret.atlas_private_key:\n            if not update_secret.atlas_public_key or not update_secret.atlas_private_key:\n                raise ArkServiceException('When specifying an atlas secret, both private key and public key parameters must be supplied')\n            update_secret_dict['secret_data'] = {\n                'public_key': update_secret.atlas_public_key,\n                'private_key': update_secret.atlas_private_key.get_secret_value(),\n            }\n\n        resp: Response = self.__client.patch(\n            SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n            json=update_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBSecretMetadata.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkSIADBDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a DB secret.\n\n        Args:\n            delete_secret (ArkSIADBDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_secret.secret_name and not delete_secret.secret_id:\n            delete_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=delete_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; ArkSIADBSecretMetadataList:\n        \"\"\"\n        Lists all tenant DB secrets.\n\n        Returns:\n            ArkSIADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info('Listing all db secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkSIADBSecretsFilter) -&gt; ArkSIADBSecretMetadataList:\n        \"\"\"\n        Lists DB secrets that match the specified filters.\n\n        Args:\n            secrets_filter (ArkSIADBSecretsFilter): _description_\n\n        Returns:\n            ArkSIADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n        secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n        # Filter by secret types\n        if secrets_filter.store_type:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n        # Filter by name\n        if secrets_filter.secret_name:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n        secrets.total_count = len(secrets.secrets)\n\n        return secrets\n\n    def enable_secret(self, enable_secret: ArkSIADBEnableSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Enables a DB secret.\n\n        Args:\n            enable_secret (ArkSIADBEnableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if enable_secret.secret_name and not enable_secret.secret_id:\n            enable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=enable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n        resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to enable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def disable_secret(self, disable_secret: ArkSIADBDisableSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Disables a DB secret.\n\n        Args:\n            disable_secret (ArkSIADBDisableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if disable_secret.secret_name and not disable_secret.secret_id:\n            disable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=disable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n        resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to disable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secret(self, get_secret: ArkSIADBGetSecret) -&gt; ArkSIADBSecretMetadata:\n        \"\"\"\n        Retrieves a DB secret.\n\n        Args:\n            get_secret (ArkSIADBGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBSecretMetadata: _description_\n        \"\"\"\n        if get_secret.secret_name and not get_secret.secret_id:\n            get_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkSIADBSecretsFilter(secret_name=get_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBSecretMetadata.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkSIADBSecretsStats:\n        \"\"\"\n        Calculates DB secrets statistics.\n\n        Returns:\n            ArkSIADBSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkSIADBSecretsStats.model_construct()\n        secrets_stats.secrets_count = len(secrets.secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n        # Count secrets per secret type\n        secret_types: Set[ArkSIADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n        secrets_stats.secrets_count_by_secret_type = {\n            st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        # Count secrets per store type\n        store_types: Set[ArkSIADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n        secrets_stats.secrets_count_by_store_type = {\n            st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new DB secret to the secret store.</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkSIADBAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkSIADBAddSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Adds a new DB secret to the secret store.\n\n    Args:\n        add_secret (ArkSIADBAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    self._logger.info('Adding new db secret')\n    add_secret_dict = add_secret.model_dump(\n        exclude_none=True,\n        exclude={\n            'store_type',\n            'username',\n            'password',\n            'pam_safe',\n            'pam_account_name',\n            'iam_username',\n            'iam_account',\n            'iam_access_key_id',\n            'iam_secret_access_key',\n            'atlas_public_key',\n            'atlas_private_key',\n        },\n    )\n    if not add_secret.store_type:\n        add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n    add_secret_dict['secret_store'] = {\n        'store_type': add_secret.store_type.value,\n    }\n    if add_secret.secret_type == ArkSIADBSecretType.UsernamePassword:\n        if not add_secret.username or not add_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password type, both username and password parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'username': add_secret.username,\n            'password': add_secret.password.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkSIADBSecretType.CyberArkPAM:\n        if not add_secret.pam_account_name or not add_secret.pam_safe:\n            raise ArkServiceException(\n                'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n            )\n        add_secret_dict['secret_link'] = {\n            'safe': add_secret.pam_safe,\n            'account_name': add_secret.pam_account_name,\n        }\n    elif add_secret.secret_type == ArkSIADBSecretType.IAMUser:\n        if (\n            not add_secret.iam_access_key_id\n            or not add_secret.iam_secret_access_key\n            or not add_secret.iam_account\n            or not add_secret.iam_username\n        ):\n            raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n        add_secret_dict['secret_data'] = {\n            'account': add_secret.iam_account,\n            'username': add_secret.iam_username,\n            'access_key_id': add_secret.iam_access_key_id.get_secret_value(),\n            'secret_access_key': add_secret.iam_secret_access_key.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkSIADBSecretType.AtlasAccessKeys:\n        if not add_secret.atlas_public_key or not add_secret.atlas_private_key:\n            raise ArkServiceException(\n                'When specifying an atlas secret type, both private key and public key parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'public_key': add_secret.atlas_public_key,\n            'private_key': add_secret.atlas_private_key.get_secret_value(),\n        }\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json=add_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkSIADBSecretMetadata.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkSIADBDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkSIADBDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a DB secret.\n\n    Args:\n        delete_secret (ArkSIADBDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_secret.secret_name and not delete_secret.secret_id:\n        delete_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=delete_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.disable_secret","title":"<code>disable_secret(disable_secret)</code>","text":"<p>Disables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>disable_secret</code> <code>ArkSIADBDisableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def disable_secret(self, disable_secret: ArkSIADBDisableSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Disables a DB secret.\n\n    Args:\n        disable_secret (ArkSIADBDisableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if disable_secret.secret_name and not disable_secret.secret_id:\n        disable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=disable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n    resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to disable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.enable_secret","title":"<code>enable_secret(enable_secret)</code>","text":"<p>Enables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>enable_secret</code> <code>ArkSIADBEnableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def enable_secret(self, enable_secret: ArkSIADBEnableSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Enables a DB secret.\n\n    Args:\n        enable_secret (ArkSIADBEnableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if enable_secret.secret_name and not enable_secret.secret_id:\n        enable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=enable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n    resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to enable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant DB secrets.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadataList</code> <code>ArkSIADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; ArkSIADBSecretMetadataList:\n    \"\"\"\n    Lists all tenant DB secrets.\n\n    Returns:\n        ArkSIADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info('Listing all db secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists DB secrets that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkSIADBSecretsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadataList</code> <code>ArkSIADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkSIADBSecretsFilter) -&gt; ArkSIADBSecretMetadataList:\n    \"\"\"\n    Lists DB secrets that match the specified filters.\n\n    Args:\n        secrets_filter (ArkSIADBSecretsFilter): _description_\n\n    Returns:\n        ArkSIADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n    secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n    # Filter by secret types\n    if secrets_filter.store_type:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n    # Filter by name\n    if secrets_filter.secret_name:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n    secrets.total_count = len(secrets.secrets)\n\n    return secrets\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkSIADBGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkSIADBGetSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Retrieves a DB secret.\n\n    Args:\n        get_secret (ArkSIADBGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if get_secret.secret_name and not get_secret.secret_id:\n        get_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=get_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBSecretMetadata.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates DB secrets statistics.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretsStats</code> <code>ArkSIADBSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkSIADBSecretsStats:\n    \"\"\"\n    Calculates DB secrets statistics.\n\n    Returns:\n        ArkSIADBSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkSIADBSecretsStats.model_construct()\n    secrets_stats.secrets_count = len(secrets.secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n    # Count secrets per secret type\n    secret_types: Set[ArkSIADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n    secrets_stats.secrets_count_by_secret_type = {\n        st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    # Count secrets per store type\n    store_types: Set[ArkSIADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n    secrets_stats.secrets_count_by_store_type = {\n        st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/sia/secrets/db/ark_sia_db_secrets_service/#ark_sdk_python.services.sia.secrets.db.ark_sia_db_secrets_service.ArkSIADBSecretsService.update_secret","title":"<code>update_secret(update_secret)</code>","text":"<p>Updates a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>update_secret</code> <code>ArkSIADBUpdateSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBSecretMetadata</code> <code>ArkSIADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/db/ark_sia_db_secrets_service.py</code> <pre><code>def update_secret(self, update_secret: ArkSIADBUpdateSecret) -&gt; ArkSIADBSecretMetadata:\n    \"\"\"\n    Updates a DB secret.\n\n    Args:\n        update_secret (ArkSIADBUpdateSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBSecretMetadata: _description_\n    \"\"\"\n    if update_secret.secret_name and not update_secret.secret_id:\n        update_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkSIADBSecretsFilter(secret_name=update_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n    update_secret_dict = update_secret.model_dump(\n        exclude_none=True,\n        exclude={\n            'secret_id',\n            'secret_name',\n            'new_secret_name',\n            'username',\n            'password',\n            'pam_safe',\n            'pam_account_name',\n            'iam_username',\n            'iam_account',\n            'iam_access_key_id',\n            'iam_secret_access_key',\n            'atlas_public_key',\n            'atlas_private_key',\n        },\n    )\n    if update_secret.new_secret_name:\n        update_secret_dict['secret_name'] = update_secret.new_secret_name\n    if update_secret.pam_account_name or update_secret.pam_safe:\n        if not update_secret.pam_account_name or not update_secret.pam_safe:\n            raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n        update_secret_dict['secret_link'] = {\n            'safe': update_secret.pam_safe,\n            'account_name': update_secret.pam_account_name,\n        }\n    if update_secret.username or update_secret.password:\n        if not update_secret.username or not update_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password secret, both username and password name parameters must be supplied'\n            )\n        update_secret_dict['secret_data'] = {\n            'username': update_secret.username,\n            'password': update_secret.password.get_secret_value(),\n        }\n    if (\n        update_secret.iam_access_key_id\n        or update_secret.iam_secret_access_key\n        or update_secret.iam_account\n        or update_secret.iam_username\n    ):\n        if (\n            not update_secret.iam_access_key_id\n            or not update_secret.iam_secret_access_key\n            or not update_secret.iam_account\n            or not update_secret.iam_username\n        ):\n            raise ArkServiceException('When specifying a iam user secret type, all iam parameters must be supplied')\n        update_secret_dict['secret_data'] = {\n            'account': update_secret.iam_account,\n            'username': update_secret.iam_username,\n            'access_key_id': update_secret.iam_access_key_id.get_secret_value(),\n            'secret_access_key': update_secret.iam_secret_access_key.get_secret_value(),\n        }\n    if update_secret.atlas_public_key or update_secret.atlas_private_key:\n        if not update_secret.atlas_public_key or not update_secret.atlas_private_key:\n            raise ArkServiceException('When specifying an atlas secret, both private key and public key parameters must be supplied')\n        update_secret_dict['secret_data'] = {\n            'public_key': update_secret.atlas_public_key,\n            'private_key': update_secret.atlas_private_key.get_secret_value(),\n        }\n\n    resp: Response = self.__client.patch(\n        SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n        json=update_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBSecretMetadata.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/","title":"vm","text":""},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService","title":"<code>ArkSIAVMSecretsService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>class ArkSIAVMSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __deduce_secret_data(self, secret_input: Union[ArkSIAVMAddSecret, ArkSIAVMChangeSecret]) -&gt; str:\n        # Construct the secret data from the type\n        if secret_input.secret_type == ArkSIAVMSecretType.ProvisionerUser:\n            if not secret_input.provisioner_username or not secret_input.provisioner_password:\n                raise ArkServiceException('Provisioner user secret type requires both the username and the password to be supplied')\n            secret_data = json.dumps(\n                {'username': secret_input.provisioner_username, 'password': secret_input.provisioner_password.get_secret_value()}\n            )\n        else:\n            if not secret_input.pcloud_account_name or not secret_input.pcloud_account_safe:\n                raise ArkServiceException('PCloud account secret type requires both the safe and the account name to be supplied')\n            secret_data = json.dumps({'safe': secret_input.pcloud_account_safe, 'account_name': secret_input.pcloud_account_name})\n        return secret_data\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkSIAVMSecretType] = ArkSIAVMSecretType.ProvisionerUser,\n        secret_details: Optional[Dict[str, Any]] = None,\n    ) -&gt; List[ArkSIAVMSecretInfo]:\n        params = {'secret_type': ','.join(st for st in ArkSIAVMSecretType)}\n        if secret_details:\n            params.update(secret_details)\n        if secret_type:\n            params.update({\"secret_type\": secret_type.value})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkSIAVMSecretInfo]).validate_python(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkSIAVMAddSecret) -&gt; ArkSIAVMSecret:\n        \"\"\"\n        Adds a new vm secret to the secret store\n\n        Args:\n            add_secret (ArkSIAVMAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMSecret: _description_\n        \"\"\"\n        self._logger.info('Adding new vm secret')\n        secret_data = self.__deduce_secret_data(add_secret)\n        add_secret.secret_details = add_secret.secret_details or {}\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json={\n                **add_secret.model_dump(include={'secret_name', 'secret_details', 'secret_type'}),\n                'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n                'is_active': not add_secret.is_disabled,\n            },\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkSIAVMSecret.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add vm secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def change_secret(self, change_secret: ArkSIAVMChangeSecret) -&gt; ArkSIAVMSecret:\n        \"\"\"\n        Changes an existing vm secret with either data or metadata\n\n        Args:\n            change_secret (ArkSIAVMChangeSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMSecret: _description_\n        \"\"\"\n        self._logger.info(f'Changing existing vm secret with id [{change_secret.secret_id}]')\n        secret_data = None\n        try:\n            secret_data = self.__deduce_secret_data(change_secret)\n        except ArkServiceException:\n            pass\n        if not secret_data and not change_secret.secret_details and not change_secret.secret_name and change_secret.is_disabled is None:\n            raise ArkServiceException('At least one change needs to be supplied')\n        resp: Response = self.__client.post(\n            SECRET_ROUTE.format(secret_id=change_secret.secret_id),\n            json={\n                'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n                'secret_details': change_secret.secret_details,\n                'is_active': True if change_secret.is_disabled is None or not change_secret.is_disabled else False,\n                'secret_name': change_secret.secret_name,\n            },\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.secret(ArkSIAVMGetSecret(secret_id=change_secret.secret_id))\n        raise ArkServiceException(f'Failed to change vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkSIAVMDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a vm secret by id if exists\n\n        Args:\n            delete_secret (ArkSIAVMDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting vm secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; List[ArkSIAVMSecretInfo]:\n        \"\"\"\n        Lists all tenant vm secrets\n\n        Returns:\n            List[ArkSIASecretInfo]: _description_\n        \"\"\"\n        self._logger.info('Listing all vm secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkSIAVMSecretsFilter) -&gt; List[ArkSIAVMSecretInfo]:\n        \"\"\"\n        Lists vm secrets by given filters\n\n        Args:\n            secrets_filter (ArkSIASecretsFilter): _description_\n\n        Returns:\n            List[ArkSIASecretInfo]: _description_\n        \"\"\"\n        self._logger.info(f'Listing vm secrets by filters [{secrets_filter}]')\n        secret_type = None\n        secret_details = secrets_filter.secret_details\n        if secrets_filter.secret_types and len(secrets_filter.secret_types) == 1:\n            secret_type = secrets_filter.secret_types[0]\n        secrets = self.__list_secrets_with_filters(secret_type, secret_details)\n\n        # Filter by secret types\n        if secrets_filter.secret_types and len(secrets_filter.secret_types) &gt; 1:\n            secrets = [s for s in secrets if s.secret_type in secrets_filter.secret_types]\n\n        # Filter by name\n        if secrets_filter.name:\n            secrets = [s for s in secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets = [s for s in secrets if s.is_active == secrets_filter.is_active]\n\n        return secrets\n\n    def secret(self, get_secret: ArkSIAVMGetSecret) -&gt; ArkSIAVMSecret:\n        \"\"\"\n        Retrieves a vm secret by id\n\n        Args:\n            get_secret (ArkSIAVMGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMSecret: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIAVMSecret.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkSIAVMSecretsStats:\n        \"\"\"\n        Calculates vm secrets statistics\n\n        Returns:\n            ArkSIAVMSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkSIAVMSecretsStats.model_construct()\n        secrets_stats.secrets_count = len(secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets if not s.is_active])\n\n        # Count secrets per type\n        secret_types: Set[ArkSIAVMSecretType] = {s.secret_type for s in secrets if s.secret_type}\n        secrets_stats.secrets_count_by_type = {\n            st: len([s for s in secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new vm secret to the secret store</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkSIAVMAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecret</code> <code>ArkSIAVMSecret</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkSIAVMAddSecret) -&gt; ArkSIAVMSecret:\n    \"\"\"\n    Adds a new vm secret to the secret store\n\n    Args:\n        add_secret (ArkSIAVMAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMSecret: _description_\n    \"\"\"\n    self._logger.info('Adding new vm secret')\n    secret_data = self.__deduce_secret_data(add_secret)\n    add_secret.secret_details = add_secret.secret_details or {}\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json={\n            **add_secret.model_dump(include={'secret_name', 'secret_details', 'secret_type'}),\n            'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n            'is_active': not add_secret.is_disabled,\n        },\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkSIAVMSecret.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add vm secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService.change_secret","title":"<code>change_secret(change_secret)</code>","text":"<p>Changes an existing vm secret with either data or metadata</p> <p>Parameters:</p> Name Type Description Default <code>change_secret</code> <code>ArkSIAVMChangeSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecret</code> <code>ArkSIAVMSecret</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def change_secret(self, change_secret: ArkSIAVMChangeSecret) -&gt; ArkSIAVMSecret:\n    \"\"\"\n    Changes an existing vm secret with either data or metadata\n\n    Args:\n        change_secret (ArkSIAVMChangeSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMSecret: _description_\n    \"\"\"\n    self._logger.info(f'Changing existing vm secret with id [{change_secret.secret_id}]')\n    secret_data = None\n    try:\n        secret_data = self.__deduce_secret_data(change_secret)\n    except ArkServiceException:\n        pass\n    if not secret_data and not change_secret.secret_details and not change_secret.secret_name and change_secret.is_disabled is None:\n        raise ArkServiceException('At least one change needs to be supplied')\n    resp: Response = self.__client.post(\n        SECRET_ROUTE.format(secret_id=change_secret.secret_id),\n        json={\n            'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n            'secret_details': change_secret.secret_details,\n            'is_active': True if change_secret.is_disabled is None or not change_secret.is_disabled else False,\n            'secret_name': change_secret.secret_name,\n        },\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.secret(ArkSIAVMGetSecret(secret_id=change_secret.secret_id))\n    raise ArkServiceException(f'Failed to change vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a vm secret by id if exists</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkSIAVMDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkSIAVMDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a vm secret by id if exists\n\n    Args:\n        delete_secret (ArkSIAVMDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting vm secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant vm secrets</p> <p>Returns:</p> Type Description <code>List[ArkSIAVMSecretInfo]</code> <p>List[ArkSIASecretInfo]: description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; List[ArkSIAVMSecretInfo]:\n    \"\"\"\n    Lists all tenant vm secrets\n\n    Returns:\n        List[ArkSIASecretInfo]: _description_\n    \"\"\"\n    self._logger.info('Listing all vm secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists vm secrets by given filters</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkSIASecretsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIAVMSecretInfo]</code> <p>List[ArkSIASecretInfo]: description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkSIAVMSecretsFilter) -&gt; List[ArkSIAVMSecretInfo]:\n    \"\"\"\n    Lists vm secrets by given filters\n\n    Args:\n        secrets_filter (ArkSIASecretsFilter): _description_\n\n    Returns:\n        List[ArkSIASecretInfo]: _description_\n    \"\"\"\n    self._logger.info(f'Listing vm secrets by filters [{secrets_filter}]')\n    secret_type = None\n    secret_details = secrets_filter.secret_details\n    if secrets_filter.secret_types and len(secrets_filter.secret_types) == 1:\n        secret_type = secrets_filter.secret_types[0]\n    secrets = self.__list_secrets_with_filters(secret_type, secret_details)\n\n    # Filter by secret types\n    if secrets_filter.secret_types and len(secrets_filter.secret_types) &gt; 1:\n        secrets = [s for s in secrets if s.secret_type in secrets_filter.secret_types]\n\n    # Filter by name\n    if secrets_filter.name:\n        secrets = [s for s in secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets = [s for s in secrets if s.is_active == secrets_filter.is_active]\n\n    return secrets\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a vm secret by id</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkSIAVMGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecret</code> <code>ArkSIAVMSecret</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkSIAVMGetSecret) -&gt; ArkSIAVMSecret:\n    \"\"\"\n    Retrieves a vm secret by id\n\n    Args:\n        get_secret (ArkSIAVMGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMSecret: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIAVMSecret.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/#ark_sdk_python.services.sia.secrets.vm.ArkSIAVMSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates vm secrets statistics</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecretsStats</code> <code>ArkSIAVMSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkSIAVMSecretsStats:\n    \"\"\"\n    Calculates vm secrets statistics\n\n    Returns:\n        ArkSIAVMSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkSIAVMSecretsStats.model_construct()\n    secrets_stats.secrets_count = len(secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets if not s.is_active])\n\n    # Count secrets per type\n    secret_types: Set[ArkSIAVMSecretType] = {s.secret_type for s in secrets if s.secret_type}\n    secrets_stats.secrets_count_by_type = {\n        st: len([s for s in secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/","title":"ark_sia_vm_secrets_service","text":""},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService","title":"<code>ArkSIAVMSecretsService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>class ArkSIAVMSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __deduce_secret_data(self, secret_input: Union[ArkSIAVMAddSecret, ArkSIAVMChangeSecret]) -&gt; str:\n        # Construct the secret data from the type\n        if secret_input.secret_type == ArkSIAVMSecretType.ProvisionerUser:\n            if not secret_input.provisioner_username or not secret_input.provisioner_password:\n                raise ArkServiceException('Provisioner user secret type requires both the username and the password to be supplied')\n            secret_data = json.dumps(\n                {'username': secret_input.provisioner_username, 'password': secret_input.provisioner_password.get_secret_value()}\n            )\n        else:\n            if not secret_input.pcloud_account_name or not secret_input.pcloud_account_safe:\n                raise ArkServiceException('PCloud account secret type requires both the safe and the account name to be supplied')\n            secret_data = json.dumps({'safe': secret_input.pcloud_account_safe, 'account_name': secret_input.pcloud_account_name})\n        return secret_data\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkSIAVMSecretType] = ArkSIAVMSecretType.ProvisionerUser,\n        secret_details: Optional[Dict[str, Any]] = None,\n    ) -&gt; List[ArkSIAVMSecretInfo]:\n        params = {'secret_type': ','.join(st for st in ArkSIAVMSecretType)}\n        if secret_details:\n            params.update(secret_details)\n        if secret_type:\n            params.update({\"secret_type\": secret_type.value})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return TypeAdapter(List[ArkSIAVMSecretInfo]).validate_python(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkSIAVMAddSecret) -&gt; ArkSIAVMSecret:\n        \"\"\"\n        Adds a new vm secret to the secret store\n\n        Args:\n            add_secret (ArkSIAVMAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMSecret: _description_\n        \"\"\"\n        self._logger.info('Adding new vm secret')\n        secret_data = self.__deduce_secret_data(add_secret)\n        add_secret.secret_details = add_secret.secret_details or {}\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json={\n                **add_secret.model_dump(include={'secret_name', 'secret_details', 'secret_type'}),\n                'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n                'is_active': not add_secret.is_disabled,\n            },\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkSIAVMSecret.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add vm secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def change_secret(self, change_secret: ArkSIAVMChangeSecret) -&gt; ArkSIAVMSecret:\n        \"\"\"\n        Changes an existing vm secret with either data or metadata\n\n        Args:\n            change_secret (ArkSIAVMChangeSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMSecret: _description_\n        \"\"\"\n        self._logger.info(f'Changing existing vm secret with id [{change_secret.secret_id}]')\n        secret_data = None\n        try:\n            secret_data = self.__deduce_secret_data(change_secret)\n        except ArkServiceException:\n            pass\n        if not secret_data and not change_secret.secret_details and not change_secret.secret_name and change_secret.is_disabled is None:\n            raise ArkServiceException('At least one change needs to be supplied')\n        resp: Response = self.__client.post(\n            SECRET_ROUTE.format(secret_id=change_secret.secret_id),\n            json={\n                'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n                'secret_details': change_secret.secret_details,\n                'is_active': True if change_secret.is_disabled is None or not change_secret.is_disabled else False,\n                'secret_name': change_secret.secret_name,\n            },\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.secret(ArkSIAVMGetSecret(secret_id=change_secret.secret_id))\n        raise ArkServiceException(f'Failed to change vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkSIAVMDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a vm secret by id if exists\n\n        Args:\n            delete_secret (ArkSIAVMDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting vm secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; List[ArkSIAVMSecretInfo]:\n        \"\"\"\n        Lists all tenant vm secrets\n\n        Returns:\n            List[ArkSIASecretInfo]: _description_\n        \"\"\"\n        self._logger.info('Listing all vm secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkSIAVMSecretsFilter) -&gt; List[ArkSIAVMSecretInfo]:\n        \"\"\"\n        Lists vm secrets by given filters\n\n        Args:\n            secrets_filter (ArkSIASecretsFilter): _description_\n\n        Returns:\n            List[ArkSIASecretInfo]: _description_\n        \"\"\"\n        self._logger.info(f'Listing vm secrets by filters [{secrets_filter}]')\n        secret_type = None\n        secret_details = secrets_filter.secret_details\n        if secrets_filter.secret_types and len(secrets_filter.secret_types) == 1:\n            secret_type = secrets_filter.secret_types[0]\n        secrets = self.__list_secrets_with_filters(secret_type, secret_details)\n\n        # Filter by secret types\n        if secrets_filter.secret_types and len(secrets_filter.secret_types) &gt; 1:\n            secrets = [s for s in secrets if s.secret_type in secrets_filter.secret_types]\n\n        # Filter by name\n        if secrets_filter.name:\n            secrets = [s for s in secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets = [s for s in secrets if s.is_active == secrets_filter.is_active]\n\n        return secrets\n\n    def secret(self, get_secret: ArkSIAVMGetSecret) -&gt; ArkSIAVMSecret:\n        \"\"\"\n        Retrieves a vm secret by id\n\n        Args:\n            get_secret (ArkSIAVMGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIAVMSecret: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIAVMSecret.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkSIAVMSecretsStats:\n        \"\"\"\n        Calculates vm secrets statistics\n\n        Returns:\n            ArkSIAVMSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkSIAVMSecretsStats.model_construct()\n        secrets_stats.secrets_count = len(secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets if not s.is_active])\n\n        # Count secrets per type\n        secret_types: Set[ArkSIAVMSecretType] = {s.secret_type for s in secrets if s.secret_type}\n        secrets_stats.secrets_count_by_type = {\n            st: len([s for s in secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new vm secret to the secret store</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkSIAVMAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecret</code> <code>ArkSIAVMSecret</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkSIAVMAddSecret) -&gt; ArkSIAVMSecret:\n    \"\"\"\n    Adds a new vm secret to the secret store\n\n    Args:\n        add_secret (ArkSIAVMAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMSecret: _description_\n    \"\"\"\n    self._logger.info('Adding new vm secret')\n    secret_data = self.__deduce_secret_data(add_secret)\n    add_secret.secret_details = add_secret.secret_details or {}\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json={\n            **add_secret.model_dump(include={'secret_name', 'secret_details', 'secret_type'}),\n            'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n            'is_active': not add_secret.is_disabled,\n        },\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkSIAVMSecret.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add vm secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService.change_secret","title":"<code>change_secret(change_secret)</code>","text":"<p>Changes an existing vm secret with either data or metadata</p> <p>Parameters:</p> Name Type Description Default <code>change_secret</code> <code>ArkSIAVMChangeSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecret</code> <code>ArkSIAVMSecret</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def change_secret(self, change_secret: ArkSIAVMChangeSecret) -&gt; ArkSIAVMSecret:\n    \"\"\"\n    Changes an existing vm secret with either data or metadata\n\n    Args:\n        change_secret (ArkSIAVMChangeSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMSecret: _description_\n    \"\"\"\n    self._logger.info(f'Changing existing vm secret with id [{change_secret.secret_id}]')\n    secret_data = None\n    try:\n        secret_data = self.__deduce_secret_data(change_secret)\n    except ArkServiceException:\n        pass\n    if not secret_data and not change_secret.secret_details and not change_secret.secret_name and change_secret.is_disabled is None:\n        raise ArkServiceException('At least one change needs to be supplied')\n    resp: Response = self.__client.post(\n        SECRET_ROUTE.format(secret_id=change_secret.secret_id),\n        json={\n            'secret': {'secret_data': secret_data, 'tenant_encrypted': False},\n            'secret_details': change_secret.secret_details,\n            'is_active': True if change_secret.is_disabled is None or not change_secret.is_disabled else False,\n            'secret_name': change_secret.secret_name,\n        },\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.secret(ArkSIAVMGetSecret(secret_id=change_secret.secret_id))\n    raise ArkServiceException(f'Failed to change vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a vm secret by id if exists</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkSIAVMDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkSIAVMDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a vm secret by id if exists\n\n    Args:\n        delete_secret (ArkSIAVMDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting vm secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant vm secrets</p> <p>Returns:</p> Type Description <code>List[ArkSIAVMSecretInfo]</code> <p>List[ArkSIASecretInfo]: description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; List[ArkSIAVMSecretInfo]:\n    \"\"\"\n    Lists all tenant vm secrets\n\n    Returns:\n        List[ArkSIASecretInfo]: _description_\n    \"\"\"\n    self._logger.info('Listing all vm secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists vm secrets by given filters</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkSIASecretsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIAVMSecretInfo]</code> <p>List[ArkSIASecretInfo]: description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkSIAVMSecretsFilter) -&gt; List[ArkSIAVMSecretInfo]:\n    \"\"\"\n    Lists vm secrets by given filters\n\n    Args:\n        secrets_filter (ArkSIASecretsFilter): _description_\n\n    Returns:\n        List[ArkSIASecretInfo]: _description_\n    \"\"\"\n    self._logger.info(f'Listing vm secrets by filters [{secrets_filter}]')\n    secret_type = None\n    secret_details = secrets_filter.secret_details\n    if secrets_filter.secret_types and len(secrets_filter.secret_types) == 1:\n        secret_type = secrets_filter.secret_types[0]\n    secrets = self.__list_secrets_with_filters(secret_type, secret_details)\n\n    # Filter by secret types\n    if secrets_filter.secret_types and len(secrets_filter.secret_types) &gt; 1:\n        secrets = [s for s in secrets if s.secret_type in secrets_filter.secret_types]\n\n    # Filter by name\n    if secrets_filter.name:\n        secrets = [s for s in secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets = [s for s in secrets if s.is_active == secrets_filter.is_active]\n\n    return secrets\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a vm secret by id</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkSIAVMGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecret</code> <code>ArkSIAVMSecret</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkSIAVMGetSecret) -&gt; ArkSIAVMSecret:\n    \"\"\"\n    Retrieves a vm secret by id\n\n    Args:\n        get_secret (ArkSIAVMGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIAVMSecret: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIAVMSecret.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/secrets/vm/ark_sia_vm_secrets_service/#ark_sdk_python.services.sia.secrets.vm.ark_sia_vm_secrets_service.ArkSIAVMSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates vm secrets statistics</p> <p>Returns:</p> Name Type Description <code>ArkSIAVMSecretsStats</code> <code>ArkSIAVMSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/secrets/vm/ark_sia_vm_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkSIAVMSecretsStats:\n    \"\"\"\n    Calculates vm secrets statistics\n\n    Returns:\n        ArkSIAVMSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkSIAVMSecretsStats.model_construct()\n    secrets_stats.secrets_count = len(secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets if not s.is_active])\n\n    # Count secrets per type\n    secret_types: Set[ArkSIAVMSecretType] = {s.secret_type for s in secrets if s.secret_type}\n    secrets_stats.secrets_count_by_type = {\n        st: len([s for s in secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/sia/sso/","title":"sso","text":""},{"location":"reference/services/sia/sso/#ark_sdk_python.services.sia.sso.ArkSIASSOService","title":"<code>ArkSIASSOService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>class ArkSIASSOService(ArkService):\n\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__cache_keyring = ArkKeyring(self.service_config().service_name)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __load_from_cache(self, token_type: str) -&gt; Optional[ArkSIASSOAcquireTokenResponse]:\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        token = self.__cache_keyring.load_token(\n            ArkProfileLoader.load_default_profile(),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_sia_sso_short_lived_{token_type}',\n        )\n        if token:\n            return ArkSIASSOAcquireTokenResponse.model_validate_json(token.token.get_secret_value())\n        return None\n\n    def __save_to_cache(self, result: ArkSIASSOAcquireTokenResponse, token_type: str) -&gt; None:\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        expires_in = datetime.now() + (parse(result.metadata['expires_at']) - parse(result.metadata['created_at']))\n        self.__cache_keyring.save_token(\n            ArkProfileLoader.load_default_profile(),\n            ArkToken(\n                token=result.model_dump_json(),\n                token_type=ArkTokenType.Token,\n                expires_in=expires_in,\n            ),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_sia_sso_short_lived_{token_type}',\n        )\n\n    def __expand_folder(self, folder: str) -&gt; str:\n        folder_path = os.path.expanduser(folder)\n        if not folder_path.endswith('/'):\n            folder_path += '/'\n        return folder_path\n\n    def __output_client_certificate(\n        self, folder: str, output_format: ArkSIASSOShortLiveClientCertificateFormat, result: ArkSIASSOAcquireTokenResponse\n    ) -&gt; None:\n        folder_path = self.__expand_folder(folder)\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        base_name = claims[\"unique_name\"].split('@')[0]\n        client_certificate = result.token['client_certificate']\n        private_key = result.token['private_key']\n\n        if output_format == ArkSIASSOShortLiveClientCertificateFormat.RAW:\n            ArkArgsFormatter.print_normal(f'client-certificate-data: {client_certificate}')\n            ArkArgsFormatter.print_normal(f'client-key-data: {private_key}')\n        elif output_format == ArkSIASSOShortLiveClientCertificateFormat.BASE64:\n            ArkArgsFormatter.print_normal(\n                f'client-certificate-data: {base64.b64encode(client_certificate.encode(\"utf-8\")).decode(\"utf-8\")}'\n            )\n            ArkArgsFormatter.print_normal(f'client-key-data: {base64.b64encode(private_key.encode(\"utf-8\")).decode(\"utf-8\")}')\n        elif output_format == ArkSIASSOShortLiveClientCertificateFormat.FILE:\n            if not folder_path:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkSIASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder_path):\n                os.makedirs(folder_path)\n            with open(f'{folder_path}{os.path.sep}{base_name}_client_cert.crt', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n            with open(f'{folder_path}{os.path.sep}{base_name}_client_key.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(private_key)\n        elif output_format == ArkSIASSOShortLiveClientCertificateFormat.SINGLE_FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkSIASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder_path):\n                os.makedirs(folder_path)\n            with open(f'{folder_path}{os.path.sep}{base_name}_client_cert.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n                file_handle.write('\\n')\n                file_handle.write(private_key)\n        else:\n            raise ArkServiceException(f'Unknown format {output_format}')\n\n    def __save_oracle_sso_wallet(self, folder: str, unzip_wallet: bool, result: ArkSIASSOAcquireTokenResponse) -&gt; None:\n        folder_path = self.__expand_folder(folder)\n        result.token['wallet'] = base64.b64decode(result.token['wallet'])\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        if not unzip_wallet:\n            claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n            base_name = claims[\"unique_name\"].split('@')[0]\n            with open(f'{folder_path}{os.path.sep}{base_name}_wallet.zip', 'wb') as file_handle:\n                file_handle.write(result.token['wallet'])\n        else:\n            wallet_bytes = BytesIO(result.token['wallet'])\n            with zipfile.ZipFile(wallet_bytes, 'r') as zipf:\n                zipf.extractall(folder_path)\n\n    def __save_oracle_pem_wallet(self, folder: str, result: ArkSIASSOAcquireTokenResponse) -&gt; None:\n        folder_path = self.__expand_folder(folder)\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        base_name = claims[\"unique_name\"].split('@')[0]\n        pem_wallet = base64.b64decode(result.token['pem_wallet']).decode('utf-8')\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        with open(f'{folder_path}{os.path.sep}{base_name}_ewallet.pem', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(pem_wallet)\n\n    def __save_rdp_file(self, get_short_lived_rdp_file: ArkSIASSOGetShortLivedRDPFile, result: ArkSIASSOAcquireTokenResponse) -&gt; None:\n        folder_path = self.__expand_folder(get_short_lived_rdp_file.folder)\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        filename: str = f'sia _a {get_short_lived_rdp_file.target_address}'\n        if get_short_lived_rdp_file.target_domain:\n            filename += f' _d {get_short_lived_rdp_file.target_domain}'\n        with open(f'{folder_path}{filename}.rdp', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result.token['text'])\n\n    def short_lived_password(self, get_short_lived_password: ArkSIASSOGetShortLivedPassword) -&gt; str:\n        \"\"\"\n        Generates a short-lived password used to connect to SIA services.\n\n        Args:\n            get_short_lived_password (ArkSIASSOGetShortLivedPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived password token')\n        if get_short_lived_password.allow_caching:\n            result = self.__load_from_cache('password')\n            if result:\n                return result.token['key']\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'password',\n                'service': 'DPA-DB',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'key' in result.token:\n            if get_short_lived_password.allow_caching:\n                self.__save_to_cache(result, 'password')\n            return result.token['key']\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkSIASSOGetShortLivedClientCertificate) -&gt; None:\n        \"\"\"\n        Generates a short-lived client certificate used to connect to DPA services.\n\n        Args:\n            get_short_lived_client_certificate (ArkSIASSOGetShortLivedClientCertificate): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived client certificate')\n        if get_short_lived_client_certificate.allow_caching:\n            result = self.__load_from_cache('client_certificate')\n            if result:\n                self.__output_client_certificate(\n                    get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n                )\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'client_certificate',\n                'service': get_short_lived_client_certificate.service,\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'client_certificate' in result.token and 'private_key' in result.token:\n            if get_short_lived_client_certificate.allow_caching:\n                self.__save_to_cache(result, 'client_certificate')\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkSIASSOGetShortLivedOracleWallet) -&gt; None:\n        \"\"\"\n        Generates a short-lived Oracle Wallet used to connect via SIA to Oracle databases.\n\n        Args:\n            get_short_lived_oracle_wallet (ArkSIASSOGetShortLivedOracleWallet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived oracle wallet')\n        if get_short_lived_oracle_wallet.allow_caching:\n            result = self.__load_from_cache('oracle_wallet')\n            if result:\n                if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n                    self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n                if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n                    self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'oracle_wallet',\n                'service': 'DPA-DB',\n                'token_parameters': {\n                    'walletType': get_short_lived_oracle_wallet.wallet_type.value,\n                },\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n        elif 'pem_wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, result)\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkSIASSOGetShortLivedRDPFile) -&gt; None:\n        \"\"\"\n        Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n        Args:\n            get_short_lived_rdp_file (ArkSIASSOGetShortLivedRDPFile): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating short lived rdp file')\n        if get_short_lived_rdp_file.allow_caching:\n            result = self.__load_from_cache('rdp_file')\n            if result:\n                self.__save_rdp_file(get_short_lived_rdp_file, result)\n        token_parameters: Dict[str, Any] = {\n            'targetAddress': get_short_lived_rdp_file.target_address,\n            'targetDomain': get_short_lived_rdp_file.target_domain,\n            'targetUser': get_short_lived_rdp_file.target_user,\n            'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n        }\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'rdp_file',\n                'service': 'DPA-RDP',\n                'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n                'token_response_format': 'extended',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'text' in result.token:\n            if get_short_lived_rdp_file.allow_caching:\n                self.__save_to_cache(result, 'rdp_file')\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n            return\n        raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_token_info(self, get_token_info: ArkSIASSOGetTokenInfo) -&gt; ArkSIASSOTokenInfo:\n        \"\"\"\n        Gets a short lived token metadata for the given type and service.\n\n        Args:\n            get_token_info (ArkSIASSOGetTokenInfo): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIASSOTokenInfo: __description__\n        \"\"\"\n        self._logger.info('Getting short lived token info')\n        response: Response = self.__client.get(\n            SSO_TOKEN_INFO_URL,\n            params=get_token_info.model_dump(),\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get short lived token info - [{response.status_code}] - [{response.text}]')\n        try:\n            return ArkSIASSOTokenInfo.model_validate_json(response.text)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n\n    def short_lived_ssh_key(self, get_ssh_key: ArkSIASSOGetSSHKey) -&gt; str:\n        \"\"\"\n        Gets a short lived ssh sso key.\n\n        Args:\n            get_ssh_key (ArkSIASSOGetSSHKey): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIASSOTokenInfo: __description__\n        \"\"\"\n        self._logger.info('Getting short lived token info')\n        response: Response = self.__client.get(SSH_SSO_KEY_URL)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get short lived ssh sso key - [{response.status_code}] - [{response.text}]')\n        try:\n            folder_path = get_ssh_key.folder or DEFAULT_SSH_FOLDER_PATH\n            folder_path = self.__expand_folder(folder_path)\n            if not folder_path:\n                raise ArkServiceException('Folder parameter is required')\n            if not os.path.exists(folder_path):\n                os.makedirs(folder_path)\n            claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n            base_name = f'sia_ssh_key_{claims[\"unique_name\"].split(\"@\")[0]}.pem'\n            full_path = os.path.normpath(f'{folder_path}{os.path.sep}{base_name}')\n            with open(full_path, 'w', encoding='utf-8') as file_handle:\n                file_handle.write(response.text)\n            return full_path\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/sso/#ark_sdk_python.services.sia.sso.ArkSIASSOService.short_lived_client_certificate","title":"<code>short_lived_client_certificate(get_short_lived_client_certificate)</code>","text":"<p>Generates a short-lived client certificate used to connect to DPA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_client_certificate</code> <code>ArkSIASSOGetShortLivedClientCertificate</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkSIASSOGetShortLivedClientCertificate) -&gt; None:\n    \"\"\"\n    Generates a short-lived client certificate used to connect to DPA services.\n\n    Args:\n        get_short_lived_client_certificate (ArkSIASSOGetShortLivedClientCertificate): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived client certificate')\n    if get_short_lived_client_certificate.allow_caching:\n        result = self.__load_from_cache('client_certificate')\n        if result:\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'client_certificate',\n            'service': get_short_lived_client_certificate.service,\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'client_certificate' in result.token and 'private_key' in result.token:\n        if get_short_lived_client_certificate.allow_caching:\n            self.__save_to_cache(result, 'client_certificate')\n        self.__output_client_certificate(\n            get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n        )\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/#ark_sdk_python.services.sia.sso.ArkSIASSOService.short_lived_oracle_wallet","title":"<code>short_lived_oracle_wallet(get_short_lived_oracle_wallet)</code>","text":"<p>Generates a short-lived Oracle Wallet used to connect via SIA to Oracle databases.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_oracle_wallet</code> <code>ArkSIASSOGetShortLivedOracleWallet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkSIASSOGetShortLivedOracleWallet) -&gt; None:\n    \"\"\"\n    Generates a short-lived Oracle Wallet used to connect via SIA to Oracle databases.\n\n    Args:\n        get_short_lived_oracle_wallet (ArkSIASSOGetShortLivedOracleWallet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived oracle wallet')\n    if get_short_lived_oracle_wallet.allow_caching:\n        result = self.__load_from_cache('oracle_wallet')\n        if result:\n            if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n                self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n                self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'oracle_wallet',\n            'service': 'DPA-DB',\n            'token_parameters': {\n                'walletType': get_short_lived_oracle_wallet.wallet_type.value,\n            },\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        return\n    elif 'pem_wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, result)\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/#ark_sdk_python.services.sia.sso.ArkSIASSOService.short_lived_password","title":"<code>short_lived_password(get_short_lived_password)</code>","text":"<p>Generates a short-lived password used to connect to SIA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_password</code> <code>ArkSIASSOGetShortLivedPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_password(self, get_short_lived_password: ArkSIASSOGetShortLivedPassword) -&gt; str:\n    \"\"\"\n    Generates a short-lived password used to connect to SIA services.\n\n    Args:\n        get_short_lived_password (ArkSIASSOGetShortLivedPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived password token')\n    if get_short_lived_password.allow_caching:\n        result = self.__load_from_cache('password')\n        if result:\n            return result.token['key']\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'password',\n            'service': 'DPA-DB',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'key' in result.token:\n        if get_short_lived_password.allow_caching:\n            self.__save_to_cache(result, 'password')\n        return result.token['key']\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/#ark_sdk_python.services.sia.sso.ArkSIASSOService.short_lived_rdp_file","title":"<code>short_lived_rdp_file(get_short_lived_rdp_file)</code>","text":"<p>Generates a short-lived RDP file used to connect via RDP to Windows machines.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_rdp_file</code> <code>ArkSIASSOGetShortLivedRDPFile</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkSIASSOGetShortLivedRDPFile) -&gt; None:\n    \"\"\"\n    Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n    Args:\n        get_short_lived_rdp_file (ArkSIASSOGetShortLivedRDPFile): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating short lived rdp file')\n    if get_short_lived_rdp_file.allow_caching:\n        result = self.__load_from_cache('rdp_file')\n        if result:\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n    token_parameters: Dict[str, Any] = {\n        'targetAddress': get_short_lived_rdp_file.target_address,\n        'targetDomain': get_short_lived_rdp_file.target_domain,\n        'targetUser': get_short_lived_rdp_file.target_user,\n        'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n    }\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'rdp_file',\n            'service': 'DPA-RDP',\n            'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n            'token_response_format': 'extended',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'text' in result.token:\n        if get_short_lived_rdp_file.allow_caching:\n            self.__save_to_cache(result, 'rdp_file')\n        self.__save_rdp_file(get_short_lived_rdp_file, result)\n        return\n    raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/#ark_sdk_python.services.sia.sso.ArkSIASSOService.short_lived_ssh_key","title":"<code>short_lived_ssh_key(get_ssh_key)</code>","text":"<p>Gets a short lived ssh sso key.</p> <p>Parameters:</p> Name Type Description Default <code>get_ssh_key</code> <code>ArkSIASSOGetSSHKey</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOTokenInfo</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_ssh_key(self, get_ssh_key: ArkSIASSOGetSSHKey) -&gt; str:\n    \"\"\"\n    Gets a short lived ssh sso key.\n\n    Args:\n        get_ssh_key (ArkSIASSOGetSSHKey): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIASSOTokenInfo: __description__\n    \"\"\"\n    self._logger.info('Getting short lived token info')\n    response: Response = self.__client.get(SSH_SSO_KEY_URL)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to get short lived ssh sso key - [{response.status_code}] - [{response.text}]')\n    try:\n        folder_path = get_ssh_key.folder or DEFAULT_SSH_FOLDER_PATH\n        folder_path = self.__expand_folder(folder_path)\n        if not folder_path:\n            raise ArkServiceException('Folder parameter is required')\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        base_name = f'sia_ssh_key_{claims[\"unique_name\"].split(\"@\")[0]}.pem'\n        full_path = os.path.normpath(f'{folder_path}{os.path.sep}{base_name}')\n        with open(full_path, 'w', encoding='utf-8') as file_handle:\n            file_handle.write(response.text)\n        return full_path\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/sso/#ark_sdk_python.services.sia.sso.ArkSIASSOService.short_lived_token_info","title":"<code>short_lived_token_info(get_token_info)</code>","text":"<p>Gets a short lived token metadata for the given type and service.</p> <p>Parameters:</p> Name Type Description Default <code>get_token_info</code> <code>ArkSIASSOGetTokenInfo</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOTokenInfo</code> <code>ArkSIASSOTokenInfo</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_token_info(self, get_token_info: ArkSIASSOGetTokenInfo) -&gt; ArkSIASSOTokenInfo:\n    \"\"\"\n    Gets a short lived token metadata for the given type and service.\n\n    Args:\n        get_token_info (ArkSIASSOGetTokenInfo): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIASSOTokenInfo: __description__\n    \"\"\"\n    self._logger.info('Getting short lived token info')\n    response: Response = self.__client.get(\n        SSO_TOKEN_INFO_URL,\n        params=get_token_info.model_dump(),\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to get short lived token info - [{response.status_code}] - [{response.text}]')\n    try:\n        return ArkSIASSOTokenInfo.model_validate_json(response.text)\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/sso/ark_sia_sso_service/","title":"ark_sia_sso_service","text":""},{"location":"reference/services/sia/sso/ark_sia_sso_service/#ark_sdk_python.services.sia.sso.ark_sia_sso_service.ArkSIASSOService","title":"<code>ArkSIASSOService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>class ArkSIASSOService(ArkService):\n\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__cache_keyring = ArkKeyring(self.service_config().service_name)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __load_from_cache(self, token_type: str) -&gt; Optional[ArkSIASSOAcquireTokenResponse]:\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        token = self.__cache_keyring.load_token(\n            ArkProfileLoader.load_default_profile(),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_sia_sso_short_lived_{token_type}',\n        )\n        if token:\n            return ArkSIASSOAcquireTokenResponse.model_validate_json(token.token.get_secret_value())\n        return None\n\n    def __save_to_cache(self, result: ArkSIASSOAcquireTokenResponse, token_type: str) -&gt; None:\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        expires_in = datetime.now() + (parse(result.metadata['expires_at']) - parse(result.metadata['created_at']))\n        self.__cache_keyring.save_token(\n            ArkProfileLoader.load_default_profile(),\n            ArkToken(\n                token=result.model_dump_json(),\n                token_type=ArkTokenType.Token,\n                expires_in=expires_in,\n            ),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_sia_sso_short_lived_{token_type}',\n        )\n\n    def __expand_folder(self, folder: str) -&gt; str:\n        folder_path = os.path.expanduser(folder)\n        if not folder_path.endswith('/'):\n            folder_path += '/'\n        return folder_path\n\n    def __output_client_certificate(\n        self, folder: str, output_format: ArkSIASSOShortLiveClientCertificateFormat, result: ArkSIASSOAcquireTokenResponse\n    ) -&gt; None:\n        folder_path = self.__expand_folder(folder)\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        base_name = claims[\"unique_name\"].split('@')[0]\n        client_certificate = result.token['client_certificate']\n        private_key = result.token['private_key']\n\n        if output_format == ArkSIASSOShortLiveClientCertificateFormat.RAW:\n            ArkArgsFormatter.print_normal(f'client-certificate-data: {client_certificate}')\n            ArkArgsFormatter.print_normal(f'client-key-data: {private_key}')\n        elif output_format == ArkSIASSOShortLiveClientCertificateFormat.BASE64:\n            ArkArgsFormatter.print_normal(\n                f'client-certificate-data: {base64.b64encode(client_certificate.encode(\"utf-8\")).decode(\"utf-8\")}'\n            )\n            ArkArgsFormatter.print_normal(f'client-key-data: {base64.b64encode(private_key.encode(\"utf-8\")).decode(\"utf-8\")}')\n        elif output_format == ArkSIASSOShortLiveClientCertificateFormat.FILE:\n            if not folder_path:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkSIASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder_path):\n                os.makedirs(folder_path)\n            with open(f'{folder_path}{os.path.sep}{base_name}_client_cert.crt', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n            with open(f'{folder_path}{os.path.sep}{base_name}_client_key.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(private_key)\n        elif output_format == ArkSIASSOShortLiveClientCertificateFormat.SINGLE_FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkSIASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder_path):\n                os.makedirs(folder_path)\n            with open(f'{folder_path}{os.path.sep}{base_name}_client_cert.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n                file_handle.write('\\n')\n                file_handle.write(private_key)\n        else:\n            raise ArkServiceException(f'Unknown format {output_format}')\n\n    def __save_oracle_sso_wallet(self, folder: str, unzip_wallet: bool, result: ArkSIASSOAcquireTokenResponse) -&gt; None:\n        folder_path = self.__expand_folder(folder)\n        result.token['wallet'] = base64.b64decode(result.token['wallet'])\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        if not unzip_wallet:\n            claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n            base_name = claims[\"unique_name\"].split('@')[0]\n            with open(f'{folder_path}{os.path.sep}{base_name}_wallet.zip', 'wb') as file_handle:\n                file_handle.write(result.token['wallet'])\n        else:\n            wallet_bytes = BytesIO(result.token['wallet'])\n            with zipfile.ZipFile(wallet_bytes, 'r') as zipf:\n                zipf.extractall(folder_path)\n\n    def __save_oracle_pem_wallet(self, folder: str, result: ArkSIASSOAcquireTokenResponse) -&gt; None:\n        folder_path = self.__expand_folder(folder)\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        base_name = claims[\"unique_name\"].split('@')[0]\n        pem_wallet = base64.b64decode(result.token['pem_wallet']).decode('utf-8')\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        with open(f'{folder_path}{os.path.sep}{base_name}_ewallet.pem', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(pem_wallet)\n\n    def __save_rdp_file(self, get_short_lived_rdp_file: ArkSIASSOGetShortLivedRDPFile, result: ArkSIASSOAcquireTokenResponse) -&gt; None:\n        folder_path = self.__expand_folder(get_short_lived_rdp_file.folder)\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        filename: str = f'sia _a {get_short_lived_rdp_file.target_address}'\n        if get_short_lived_rdp_file.target_domain:\n            filename += f' _d {get_short_lived_rdp_file.target_domain}'\n        with open(f'{folder_path}{filename}.rdp', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result.token['text'])\n\n    def short_lived_password(self, get_short_lived_password: ArkSIASSOGetShortLivedPassword) -&gt; str:\n        \"\"\"\n        Generates a short-lived password used to connect to SIA services.\n\n        Args:\n            get_short_lived_password (ArkSIASSOGetShortLivedPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived password token')\n        if get_short_lived_password.allow_caching:\n            result = self.__load_from_cache('password')\n            if result:\n                return result.token['key']\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'password',\n                'service': 'DPA-DB',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'key' in result.token:\n            if get_short_lived_password.allow_caching:\n                self.__save_to_cache(result, 'password')\n            return result.token['key']\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkSIASSOGetShortLivedClientCertificate) -&gt; None:\n        \"\"\"\n        Generates a short-lived client certificate used to connect to DPA services.\n\n        Args:\n            get_short_lived_client_certificate (ArkSIASSOGetShortLivedClientCertificate): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived client certificate')\n        if get_short_lived_client_certificate.allow_caching:\n            result = self.__load_from_cache('client_certificate')\n            if result:\n                self.__output_client_certificate(\n                    get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n                )\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'client_certificate',\n                'service': get_short_lived_client_certificate.service,\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'client_certificate' in result.token and 'private_key' in result.token:\n            if get_short_lived_client_certificate.allow_caching:\n                self.__save_to_cache(result, 'client_certificate')\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkSIASSOGetShortLivedOracleWallet) -&gt; None:\n        \"\"\"\n        Generates a short-lived Oracle Wallet used to connect via SIA to Oracle databases.\n\n        Args:\n            get_short_lived_oracle_wallet (ArkSIASSOGetShortLivedOracleWallet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived oracle wallet')\n        if get_short_lived_oracle_wallet.allow_caching:\n            result = self.__load_from_cache('oracle_wallet')\n            if result:\n                if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n                    self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n                if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n                    self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'oracle_wallet',\n                'service': 'DPA-DB',\n                'token_parameters': {\n                    'walletType': get_short_lived_oracle_wallet.wallet_type.value,\n                },\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n        elif 'pem_wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, result)\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkSIASSOGetShortLivedRDPFile) -&gt; None:\n        \"\"\"\n        Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n        Args:\n            get_short_lived_rdp_file (ArkSIASSOGetShortLivedRDPFile): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating short lived rdp file')\n        if get_short_lived_rdp_file.allow_caching:\n            result = self.__load_from_cache('rdp_file')\n            if result:\n                self.__save_rdp_file(get_short_lived_rdp_file, result)\n        token_parameters: Dict[str, Any] = {\n            'targetAddress': get_short_lived_rdp_file.target_address,\n            'targetDomain': get_short_lived_rdp_file.target_domain,\n            'targetUser': get_short_lived_rdp_file.target_user,\n            'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n        }\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'rdp_file',\n                'service': 'DPA-RDP',\n                'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n                'token_response_format': 'extended',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n        result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n        if 'text' in result.token:\n            if get_short_lived_rdp_file.allow_caching:\n                self.__save_to_cache(result, 'rdp_file')\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n            return\n        raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_token_info(self, get_token_info: ArkSIASSOGetTokenInfo) -&gt; ArkSIASSOTokenInfo:\n        \"\"\"\n        Gets a short lived token metadata for the given type and service.\n\n        Args:\n            get_token_info (ArkSIASSOGetTokenInfo): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIASSOTokenInfo: __description__\n        \"\"\"\n        self._logger.info('Getting short lived token info')\n        response: Response = self.__client.get(\n            SSO_TOKEN_INFO_URL,\n            params=get_token_info.model_dump(),\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get short lived token info - [{response.status_code}] - [{response.text}]')\n        try:\n            return ArkSIASSOTokenInfo.model_validate_json(response.text)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n\n    def short_lived_ssh_key(self, get_ssh_key: ArkSIASSOGetSSHKey) -&gt; str:\n        \"\"\"\n        Gets a short lived ssh sso key.\n\n        Args:\n            get_ssh_key (ArkSIASSOGetSSHKey): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIASSOTokenInfo: __description__\n        \"\"\"\n        self._logger.info('Getting short lived token info')\n        response: Response = self.__client.get(SSH_SSO_KEY_URL)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to get short lived ssh sso key - [{response.status_code}] - [{response.text}]')\n        try:\n            folder_path = get_ssh_key.folder or DEFAULT_SSH_FOLDER_PATH\n            folder_path = self.__expand_folder(folder_path)\n            if not folder_path:\n                raise ArkServiceException('Folder parameter is required')\n            if not os.path.exists(folder_path):\n                os.makedirs(folder_path)\n            claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n            base_name = f'sia_ssh_key_{claims[\"unique_name\"].split(\"@\")[0]}.pem'\n            full_path = os.path.normpath(f'{folder_path}{os.path.sep}{base_name}')\n            with open(full_path, 'w', encoding='utf-8') as file_handle:\n                file_handle.write(response.text)\n            return full_path\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n            raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/sso/ark_sia_sso_service/#ark_sdk_python.services.sia.sso.ark_sia_sso_service.ArkSIASSOService.short_lived_client_certificate","title":"<code>short_lived_client_certificate(get_short_lived_client_certificate)</code>","text":"<p>Generates a short-lived client certificate used to connect to DPA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_client_certificate</code> <code>ArkSIASSOGetShortLivedClientCertificate</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkSIASSOGetShortLivedClientCertificate) -&gt; None:\n    \"\"\"\n    Generates a short-lived client certificate used to connect to DPA services.\n\n    Args:\n        get_short_lived_client_certificate (ArkSIASSOGetShortLivedClientCertificate): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived client certificate')\n    if get_short_lived_client_certificate.allow_caching:\n        result = self.__load_from_cache('client_certificate')\n        if result:\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'client_certificate',\n            'service': get_short_lived_client_certificate.service,\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'client_certificate' in result.token and 'private_key' in result.token:\n        if get_short_lived_client_certificate.allow_caching:\n            self.__save_to_cache(result, 'client_certificate')\n        self.__output_client_certificate(\n            get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n        )\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/ark_sia_sso_service/#ark_sdk_python.services.sia.sso.ark_sia_sso_service.ArkSIASSOService.short_lived_oracle_wallet","title":"<code>short_lived_oracle_wallet(get_short_lived_oracle_wallet)</code>","text":"<p>Generates a short-lived Oracle Wallet used to connect via SIA to Oracle databases.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_oracle_wallet</code> <code>ArkSIASSOGetShortLivedOracleWallet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkSIASSOGetShortLivedOracleWallet) -&gt; None:\n    \"\"\"\n    Generates a short-lived Oracle Wallet used to connect via SIA to Oracle databases.\n\n    Args:\n        get_short_lived_oracle_wallet (ArkSIASSOGetShortLivedOracleWallet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived oracle wallet')\n    if get_short_lived_oracle_wallet.allow_caching:\n        result = self.__load_from_cache('oracle_wallet')\n        if result:\n            if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n                self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            if get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n                self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'oracle_wallet',\n            'service': 'DPA-DB',\n            'token_parameters': {\n                'walletType': get_short_lived_oracle_wallet.wallet_type.value,\n            },\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.SSO:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_sso_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        return\n    elif 'pem_wallet' in result.token and get_short_lived_oracle_wallet.wallet_type == ArkSIASSOShortLivedOracleWalletType.PEM:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_pem_wallet(get_short_lived_oracle_wallet.folder, result)\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/ark_sia_sso_service/#ark_sdk_python.services.sia.sso.ark_sia_sso_service.ArkSIASSOService.short_lived_password","title":"<code>short_lived_password(get_short_lived_password)</code>","text":"<p>Generates a short-lived password used to connect to SIA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_password</code> <code>ArkSIASSOGetShortLivedPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_password(self, get_short_lived_password: ArkSIASSOGetShortLivedPassword) -&gt; str:\n    \"\"\"\n    Generates a short-lived password used to connect to SIA services.\n\n    Args:\n        get_short_lived_password (ArkSIASSOGetShortLivedPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived password token')\n    if get_short_lived_password.allow_caching:\n        result = self.__load_from_cache('password')\n        if result:\n            return result.token['key']\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'password',\n            'service': 'DPA-DB',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'key' in result.token:\n        if get_short_lived_password.allow_caching:\n            self.__save_to_cache(result, 'password')\n        return result.token['key']\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/ark_sia_sso_service/#ark_sdk_python.services.sia.sso.ark_sia_sso_service.ArkSIASSOService.short_lived_rdp_file","title":"<code>short_lived_rdp_file(get_short_lived_rdp_file)</code>","text":"<p>Generates a short-lived RDP file used to connect via RDP to Windows machines.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_rdp_file</code> <code>ArkSIASSOGetShortLivedRDPFile</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkSIASSOGetShortLivedRDPFile) -&gt; None:\n    \"\"\"\n    Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n    Args:\n        get_short_lived_rdp_file (ArkSIASSOGetShortLivedRDPFile): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating short lived rdp file')\n    if get_short_lived_rdp_file.allow_caching:\n        result = self.__load_from_cache('rdp_file')\n        if result:\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n    token_parameters: Dict[str, Any] = {\n        'targetAddress': get_short_lived_rdp_file.target_address,\n        'targetDomain': get_short_lived_rdp_file.target_domain,\n        'targetUser': get_short_lived_rdp_file.target_user,\n        'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n    }\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'rdp_file',\n            'service': 'DPA-RDP',\n            'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n            'token_response_format': 'extended',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n    result: ArkSIASSOAcquireTokenResponse = ArkSIASSOAcquireTokenResponse.model_validate(response.json())\n    if 'text' in result.token:\n        if get_short_lived_rdp_file.allow_caching:\n            self.__save_to_cache(result, 'rdp_file')\n        self.__save_rdp_file(get_short_lived_rdp_file, result)\n        return\n    raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/sia/sso/ark_sia_sso_service/#ark_sdk_python.services.sia.sso.ark_sia_sso_service.ArkSIASSOService.short_lived_ssh_key","title":"<code>short_lived_ssh_key(get_ssh_key)</code>","text":"<p>Gets a short lived ssh sso key.</p> <p>Parameters:</p> Name Type Description Default <code>get_ssh_key</code> <code>ArkSIASSOGetSSHKey</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOTokenInfo</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_ssh_key(self, get_ssh_key: ArkSIASSOGetSSHKey) -&gt; str:\n    \"\"\"\n    Gets a short lived ssh sso key.\n\n    Args:\n        get_ssh_key (ArkSIASSOGetSSHKey): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIASSOTokenInfo: __description__\n    \"\"\"\n    self._logger.info('Getting short lived token info')\n    response: Response = self.__client.get(SSH_SSO_KEY_URL)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to get short lived ssh sso key - [{response.status_code}] - [{response.text}]')\n    try:\n        folder_path = get_ssh_key.folder or DEFAULT_SSH_FOLDER_PATH\n        folder_path = self.__expand_folder(folder_path)\n        if not folder_path:\n            raise ArkServiceException('Folder parameter is required')\n        if not os.path.exists(folder_path):\n            os.makedirs(folder_path)\n        claims = ArkJWTUtils.get_unverified_claims(self.__client.session_token)\n        base_name = f'sia_ssh_key_{claims[\"unique_name\"].split(\"@\")[0]}.pem'\n        full_path = os.path.normpath(f'{folder_path}{os.path.sep}{base_name}')\n        with open(full_path, 'w', encoding='utf-8') as file_handle:\n            file_handle.write(response.text)\n        return full_path\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/sso/ark_sia_sso_service/#ark_sdk_python.services.sia.sso.ark_sia_sso_service.ArkSIASSOService.short_lived_token_info","title":"<code>short_lived_token_info(get_token_info)</code>","text":"<p>Gets a short lived token metadata for the given type and service.</p> <p>Parameters:</p> Name Type Description Default <code>get_token_info</code> <code>ArkSIASSOGetTokenInfo</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIASSOTokenInfo</code> <code>ArkSIASSOTokenInfo</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/sso/ark_sia_sso_service.py</code> <pre><code>def short_lived_token_info(self, get_token_info: ArkSIASSOGetTokenInfo) -&gt; ArkSIASSOTokenInfo:\n    \"\"\"\n    Gets a short lived token metadata for the given type and service.\n\n    Args:\n        get_token_info (ArkSIASSOGetTokenInfo): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIASSOTokenInfo: __description__\n    \"\"\"\n    self._logger.info('Getting short lived token info')\n    response: Response = self.__client.get(\n        SSO_TOKEN_INFO_URL,\n        params=get_token_info.model_dump(),\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to get short lived token info - [{response.status_code}] - [{response.text}]')\n    try:\n        return ArkSIASSOTokenInfo.model_validate_json(response.text)\n    except (ValidationError, JSONDecodeError, KeyError) as ex:\n        self._logger.exception(f'Failed to parse get short lived token info response [{str(ex)}] - [{response.text}]')\n        raise ArkServiceException(f'Failed to parse get short lived token info response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/sia/workspaces/","title":"workspaces","text":""},{"location":"reference/services/sia/workspaces/db/","title":"db","text":""},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService","title":"<code>ArkSIADBWorkspaceService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>class ArkSIADBWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __list_databases_with_filters(\n        self, provider_family: Optional[ArkSIADBDatabaseFamilyType] = None, tags: Optional[List[ArkSIADBTag]] = None\n    ) -&gt; ArkSIADBDatabaseInfoList:\n        params = {}\n        if provider_family:\n            params['provider-family'] = provider_family.value\n        if tags:\n            for tag in tags:\n                params[f'key.{tag.key}'] = tag.value\n        resp: Response = self.__client.get(RESOURCES_API, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBDatabaseInfoList.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list databases response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list databases response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list databases [{resp.text}] - [{resp.status_code}]')\n\n    def add_database(self, add_database: ArkSIADBAddDatabase) -&gt; ArkSIADBDatabase:\n        \"\"\"\n        Adds a new database.\n\n        Args:\n            add_database (ArkSIADBAddDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabase: _description_\n        \"\"\"\n        self._logger.info(f'Adding database [{add_database.name}]')\n        if not add_database.port:\n            add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n        add_database_dict = add_database.model_dump(exclude_none=True)\n        add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n        resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                database_id = resp.json()['target_id']\n                return self.database(ArkSIADBGetDatabase(id=database_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n\n    def delete_database(self, delete_database: ArkSIADBDeleteDatabase) -&gt; None:\n        \"\"\"\n        Deletes a database.\n\n        Args:\n            delete_database (ArkSIADBDeleteDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_database.name and not delete_database.id:\n            delete_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=delete_database.name))\n        self._logger.info(f'Deleting database [{delete_database.id}]')\n        resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n\n    def update_database(self, update_database: ArkSIADBUpdateDatabase) -&gt; ArkSIADBDatabase:\n        \"\"\"\n        Updates a database.\n\n        Args:\n            update_database (ArkSIADBUpdateDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabase: _description_\n        \"\"\"\n        if update_database.name and not update_database.id:\n            databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name))\n            if not databases.items or len(databases.items) != 1:\n                raise ArkServiceException(f'Failed to update database - name [{update_database.name}] not found')\n            update_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name)).items[0].id\n        self._logger.info(f'Updating database [{update_database.id}]')\n        update_database_dict = update_database.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_database.new_name:\n            update_database_dict[\"name\"] = update_database.new_name\n        resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return self.database(ArkSIADBGetDatabase(id=update_database.id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n\n    def list_databases(self) -&gt; ArkSIADBDatabaseInfoList:\n        \"\"\"\n        Lists all databases.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info('Listing all databases')\n        return self.__list_databases_with_filters()\n\n    def list_databases_by(self, databases_filter: ArkSIADBDatabasesFilter) -&gt; ArkSIADBDatabaseInfoList:\n        \"\"\"\n        Lists databases that match the specified filters.\n\n        Args:\n            databases_filter (ArkSIADBDatabasesFilter): _description_\n\n        Returns:\n            ArkSIADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info(f'Listing databases by filters [{databases_filter}]')\n        databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n        if databases_filter.name:\n            databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n        if databases_filter.provider_engine:\n            databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n        if databases_filter.provider_workspace:\n            databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n        if databases_filter.auth_methods:\n            databases.items = [d for d in databases.items if d.configured_auth_method_type in databases_filter.auth_methods]\n        if databases_filter.db_warnings_filter:\n            if databases_filter.db_warnings_filter in (\n                ArkSIADBWarning.AnyError,\n                ArkSIADBWarning.NoCertificates,\n            ):\n                databases.items = [d for d in databases.items if not d.certificate]\n            if databases_filter.db_warnings_filter in (\n                ArkSIADBWarning.AnyError,\n                ArkSIADBWarning.NoSecrets,\n            ):\n                databases.items = [d for d in databases.items if not d.secret_id]\n        databases.total_count = len(databases.items)\n        return databases\n\n    def database(self, get_database: ArkSIADBGetDatabase) -&gt; ArkSIADBDatabase:\n        \"\"\"\n        Gets a specific database.\n\n        Args:\n            get_database (ArkSIADBGetDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabase: _description_\n        \"\"\"\n        if get_database.name and not get_database.id:\n            databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name))\n            if not databases.items or len(databases.items) != 1:\n                raise ArkServiceException(f'Failed to get database - name [{get_database.name}] not found')\n            get_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name)).items[0].id\n        self._logger.info(f'Getting database [{get_database.id}]')\n        resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBDatabase.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n\n    def databases_stats(self) -&gt; ArkSIADBDatabasesStats:\n        \"\"\"\n        Calculate statistics about the tenant's databases.\n\n        Returns:\n            ArkSIADBDatabasesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating databases stats')\n        databases = self.list_databases()\n        databases_stats = ArkSIADBDatabasesStats.model_construct()\n        databases_stats.databases_count = len(databases.items)\n\n        # Get databases per engine\n        engines_types: Set[ArkSIADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n        databases_stats.databases_count_by_engine = {\n            et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n        }\n\n        # Get databases per workspace\n        workspaces_types: Set[ArkSIADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n        databases_stats.databases_count_by_workspace = {\n            wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n        }\n\n        # Get databases per family\n        family_types: Set[ArkSIADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n        databases_stats.databases_count_by_family = {\n            ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n        }\n\n        # Get databases per auth method\n        auth_method_types: Set[ArkSIADBAuthMethodType] = {d.configured_auth_method_type for d in databases.items}\n        databases_stats.databases_count_by_auth_method = {\n            am: len([d for d in databases.items if d.configured_auth_method_type == am]) for am in auth_method_types\n        }\n\n        # Get databases per db warning\n        databases_stats.databases_count_by_warning = {\n            ArkSIADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n            ArkSIADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n        }\n\n        return databases_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService.add_database","title":"<code>add_database(add_database)</code>","text":"<p>Adds a new database.</p> <p>Parameters:</p> Name Type Description Default <code>add_database</code> <code>ArkSIADBAddDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabase</code> <code>ArkSIADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def add_database(self, add_database: ArkSIADBAddDatabase) -&gt; ArkSIADBDatabase:\n    \"\"\"\n    Adds a new database.\n\n    Args:\n        add_database (ArkSIADBAddDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabase: _description_\n    \"\"\"\n    self._logger.info(f'Adding database [{add_database.name}]')\n    if not add_database.port:\n        add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n    add_database_dict = add_database.model_dump(exclude_none=True)\n    add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n    resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            database_id = resp.json()['target_id']\n            return self.database(ArkSIADBGetDatabase(id=database_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService.database","title":"<code>database(get_database)</code>","text":"<p>Gets a specific database.</p> <p>Parameters:</p> Name Type Description Default <code>get_database</code> <code>ArkSIADBGetDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabase</code> <code>ArkSIADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def database(self, get_database: ArkSIADBGetDatabase) -&gt; ArkSIADBDatabase:\n    \"\"\"\n    Gets a specific database.\n\n    Args:\n        get_database (ArkSIADBGetDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabase: _description_\n    \"\"\"\n    if get_database.name and not get_database.id:\n        databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name))\n        if not databases.items or len(databases.items) != 1:\n            raise ArkServiceException(f'Failed to get database - name [{get_database.name}] not found')\n        get_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name)).items[0].id\n    self._logger.info(f'Getting database [{get_database.id}]')\n    resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBDatabase.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService.databases_stats","title":"<code>databases_stats()</code>","text":"<p>Calculate statistics about the tenant's databases.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabasesStats</code> <code>ArkSIADBDatabasesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def databases_stats(self) -&gt; ArkSIADBDatabasesStats:\n    \"\"\"\n    Calculate statistics about the tenant's databases.\n\n    Returns:\n        ArkSIADBDatabasesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating databases stats')\n    databases = self.list_databases()\n    databases_stats = ArkSIADBDatabasesStats.model_construct()\n    databases_stats.databases_count = len(databases.items)\n\n    # Get databases per engine\n    engines_types: Set[ArkSIADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n    databases_stats.databases_count_by_engine = {\n        et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n    }\n\n    # Get databases per workspace\n    workspaces_types: Set[ArkSIADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n    databases_stats.databases_count_by_workspace = {\n        wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n    }\n\n    # Get databases per family\n    family_types: Set[ArkSIADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n    databases_stats.databases_count_by_family = {\n        ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n    }\n\n    # Get databases per auth method\n    auth_method_types: Set[ArkSIADBAuthMethodType] = {d.configured_auth_method_type for d in databases.items}\n    databases_stats.databases_count_by_auth_method = {\n        am: len([d for d in databases.items if d.configured_auth_method_type == am]) for am in auth_method_types\n    }\n\n    # Get databases per db warning\n    databases_stats.databases_count_by_warning = {\n        ArkSIADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n        ArkSIADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n    }\n\n    return databases_stats\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService.delete_database","title":"<code>delete_database(delete_database)</code>","text":"<p>Deletes a database.</p> <p>Parameters:</p> Name Type Description Default <code>delete_database</code> <code>ArkSIADBDeleteDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def delete_database(self, delete_database: ArkSIADBDeleteDatabase) -&gt; None:\n    \"\"\"\n    Deletes a database.\n\n    Args:\n        delete_database (ArkSIADBDeleteDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_database.name and not delete_database.id:\n        delete_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=delete_database.name))\n    self._logger.info(f'Deleting database [{delete_database.id}]')\n    resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService.list_databases","title":"<code>list_databases()</code>","text":"<p>Lists all databases.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabaseInfoList</code> <code>ArkSIADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def list_databases(self) -&gt; ArkSIADBDatabaseInfoList:\n    \"\"\"\n    Lists all databases.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info('Listing all databases')\n    return self.__list_databases_with_filters()\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService.list_databases_by","title":"<code>list_databases_by(databases_filter)</code>","text":"<p>Lists databases that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>databases_filter</code> <code>ArkSIADBDatabasesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkSIADBDatabaseInfoList</code> <code>ArkSIADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def list_databases_by(self, databases_filter: ArkSIADBDatabasesFilter) -&gt; ArkSIADBDatabaseInfoList:\n    \"\"\"\n    Lists databases that match the specified filters.\n\n    Args:\n        databases_filter (ArkSIADBDatabasesFilter): _description_\n\n    Returns:\n        ArkSIADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info(f'Listing databases by filters [{databases_filter}]')\n    databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n    if databases_filter.name:\n        databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n    if databases_filter.provider_engine:\n        databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n    if databases_filter.provider_workspace:\n        databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n    if databases_filter.auth_methods:\n        databases.items = [d for d in databases.items if d.configured_auth_method_type in databases_filter.auth_methods]\n    if databases_filter.db_warnings_filter:\n        if databases_filter.db_warnings_filter in (\n            ArkSIADBWarning.AnyError,\n            ArkSIADBWarning.NoCertificates,\n        ):\n            databases.items = [d for d in databases.items if not d.certificate]\n        if databases_filter.db_warnings_filter in (\n            ArkSIADBWarning.AnyError,\n            ArkSIADBWarning.NoSecrets,\n        ):\n            databases.items = [d for d in databases.items if not d.secret_id]\n    databases.total_count = len(databases.items)\n    return databases\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/#ark_sdk_python.services.sia.workspaces.db.ArkSIADBWorkspaceService.update_database","title":"<code>update_database(update_database)</code>","text":"<p>Updates a database.</p> <p>Parameters:</p> Name Type Description Default <code>update_database</code> <code>ArkSIADBUpdateDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabase</code> <code>ArkSIADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def update_database(self, update_database: ArkSIADBUpdateDatabase) -&gt; ArkSIADBDatabase:\n    \"\"\"\n    Updates a database.\n\n    Args:\n        update_database (ArkSIADBUpdateDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabase: _description_\n    \"\"\"\n    if update_database.name and not update_database.id:\n        databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name))\n        if not databases.items or len(databases.items) != 1:\n            raise ArkServiceException(f'Failed to update database - name [{update_database.name}] not found')\n        update_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name)).items[0].id\n    self._logger.info(f'Updating database [{update_database.id}]')\n    update_database_dict = update_database.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_database.new_name:\n        update_database_dict[\"name\"] = update_database.new_name\n    resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return self.database(ArkSIADBGetDatabase(id=update_database.id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/","title":"ark_sia_db_workspace_service","text":""},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService","title":"<code>ArkSIADBWorkspaceService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>class ArkSIADBWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __list_databases_with_filters(\n        self, provider_family: Optional[ArkSIADBDatabaseFamilyType] = None, tags: Optional[List[ArkSIADBTag]] = None\n    ) -&gt; ArkSIADBDatabaseInfoList:\n        params = {}\n        if provider_family:\n            params['provider-family'] = provider_family.value\n        if tags:\n            for tag in tags:\n                params[f'key.{tag.key}'] = tag.value\n        resp: Response = self.__client.get(RESOURCES_API, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBDatabaseInfoList.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list databases response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list databases response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list databases [{resp.text}] - [{resp.status_code}]')\n\n    def add_database(self, add_database: ArkSIADBAddDatabase) -&gt; ArkSIADBDatabase:\n        \"\"\"\n        Adds a new database.\n\n        Args:\n            add_database (ArkSIADBAddDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabase: _description_\n        \"\"\"\n        self._logger.info(f'Adding database [{add_database.name}]')\n        if not add_database.port:\n            add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n        add_database_dict = add_database.model_dump(exclude_none=True)\n        add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n        resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                database_id = resp.json()['target_id']\n                return self.database(ArkSIADBGetDatabase(id=database_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n\n    def delete_database(self, delete_database: ArkSIADBDeleteDatabase) -&gt; None:\n        \"\"\"\n        Deletes a database.\n\n        Args:\n            delete_database (ArkSIADBDeleteDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_database.name and not delete_database.id:\n            delete_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=delete_database.name))\n        self._logger.info(f'Deleting database [{delete_database.id}]')\n        resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n\n    def update_database(self, update_database: ArkSIADBUpdateDatabase) -&gt; ArkSIADBDatabase:\n        \"\"\"\n        Updates a database.\n\n        Args:\n            update_database (ArkSIADBUpdateDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabase: _description_\n        \"\"\"\n        if update_database.name and not update_database.id:\n            databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name))\n            if not databases.items or len(databases.items) != 1:\n                raise ArkServiceException(f'Failed to update database - name [{update_database.name}] not found')\n            update_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name)).items[0].id\n        self._logger.info(f'Updating database [{update_database.id}]')\n        update_database_dict = update_database.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_database.new_name:\n            update_database_dict[\"name\"] = update_database.new_name\n        resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return self.database(ArkSIADBGetDatabase(id=update_database.id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n\n    def list_databases(self) -&gt; ArkSIADBDatabaseInfoList:\n        \"\"\"\n        Lists all databases.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info('Listing all databases')\n        return self.__list_databases_with_filters()\n\n    def list_databases_by(self, databases_filter: ArkSIADBDatabasesFilter) -&gt; ArkSIADBDatabaseInfoList:\n        \"\"\"\n        Lists databases that match the specified filters.\n\n        Args:\n            databases_filter (ArkSIADBDatabasesFilter): _description_\n\n        Returns:\n            ArkSIADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info(f'Listing databases by filters [{databases_filter}]')\n        databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n        if databases_filter.name:\n            databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n        if databases_filter.provider_engine:\n            databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n        if databases_filter.provider_workspace:\n            databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n        if databases_filter.auth_methods:\n            databases.items = [d for d in databases.items if d.configured_auth_method_type in databases_filter.auth_methods]\n        if databases_filter.db_warnings_filter:\n            if databases_filter.db_warnings_filter in (\n                ArkSIADBWarning.AnyError,\n                ArkSIADBWarning.NoCertificates,\n            ):\n                databases.items = [d for d in databases.items if not d.certificate]\n            if databases_filter.db_warnings_filter in (\n                ArkSIADBWarning.AnyError,\n                ArkSIADBWarning.NoSecrets,\n            ):\n                databases.items = [d for d in databases.items if not d.secret_id]\n        databases.total_count = len(databases.items)\n        return databases\n\n    def database(self, get_database: ArkSIADBGetDatabase) -&gt; ArkSIADBDatabase:\n        \"\"\"\n        Gets a specific database.\n\n        Args:\n            get_database (ArkSIADBGetDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIADBDatabase: _description_\n        \"\"\"\n        if get_database.name and not get_database.id:\n            databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name))\n            if not databases.items or len(databases.items) != 1:\n                raise ArkServiceException(f'Failed to get database - name [{get_database.name}] not found')\n            get_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name)).items[0].id\n        self._logger.info(f'Getting database [{get_database.id}]')\n        resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIADBDatabase.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n\n    def databases_stats(self) -&gt; ArkSIADBDatabasesStats:\n        \"\"\"\n        Calculate statistics about the tenant's databases.\n\n        Returns:\n            ArkSIADBDatabasesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating databases stats')\n        databases = self.list_databases()\n        databases_stats = ArkSIADBDatabasesStats.model_construct()\n        databases_stats.databases_count = len(databases.items)\n\n        # Get databases per engine\n        engines_types: Set[ArkSIADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n        databases_stats.databases_count_by_engine = {\n            et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n        }\n\n        # Get databases per workspace\n        workspaces_types: Set[ArkSIADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n        databases_stats.databases_count_by_workspace = {\n            wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n        }\n\n        # Get databases per family\n        family_types: Set[ArkSIADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n        databases_stats.databases_count_by_family = {\n            ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n        }\n\n        # Get databases per auth method\n        auth_method_types: Set[ArkSIADBAuthMethodType] = {d.configured_auth_method_type for d in databases.items}\n        databases_stats.databases_count_by_auth_method = {\n            am: len([d for d in databases.items if d.configured_auth_method_type == am]) for am in auth_method_types\n        }\n\n        # Get databases per db warning\n        databases_stats.databases_count_by_warning = {\n            ArkSIADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n            ArkSIADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n        }\n\n        return databases_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService.add_database","title":"<code>add_database(add_database)</code>","text":"<p>Adds a new database.</p> <p>Parameters:</p> Name Type Description Default <code>add_database</code> <code>ArkSIADBAddDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabase</code> <code>ArkSIADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def add_database(self, add_database: ArkSIADBAddDatabase) -&gt; ArkSIADBDatabase:\n    \"\"\"\n    Adds a new database.\n\n    Args:\n        add_database (ArkSIADBAddDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabase: _description_\n    \"\"\"\n    self._logger.info(f'Adding database [{add_database.name}]')\n    if not add_database.port:\n        add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n    add_database_dict = add_database.model_dump(exclude_none=True)\n    add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n    resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            database_id = resp.json()['target_id']\n            return self.database(ArkSIADBGetDatabase(id=database_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService.database","title":"<code>database(get_database)</code>","text":"<p>Gets a specific database.</p> <p>Parameters:</p> Name Type Description Default <code>get_database</code> <code>ArkSIADBGetDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabase</code> <code>ArkSIADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def database(self, get_database: ArkSIADBGetDatabase) -&gt; ArkSIADBDatabase:\n    \"\"\"\n    Gets a specific database.\n\n    Args:\n        get_database (ArkSIADBGetDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabase: _description_\n    \"\"\"\n    if get_database.name and not get_database.id:\n        databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name))\n        if not databases.items or len(databases.items) != 1:\n            raise ArkServiceException(f'Failed to get database - name [{get_database.name}] not found')\n        get_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=get_database.name)).items[0].id\n    self._logger.info(f'Getting database [{get_database.id}]')\n    resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIADBDatabase.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService.databases_stats","title":"<code>databases_stats()</code>","text":"<p>Calculate statistics about the tenant's databases.</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabasesStats</code> <code>ArkSIADBDatabasesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def databases_stats(self) -&gt; ArkSIADBDatabasesStats:\n    \"\"\"\n    Calculate statistics about the tenant's databases.\n\n    Returns:\n        ArkSIADBDatabasesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating databases stats')\n    databases = self.list_databases()\n    databases_stats = ArkSIADBDatabasesStats.model_construct()\n    databases_stats.databases_count = len(databases.items)\n\n    # Get databases per engine\n    engines_types: Set[ArkSIADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n    databases_stats.databases_count_by_engine = {\n        et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n    }\n\n    # Get databases per workspace\n    workspaces_types: Set[ArkSIADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n    databases_stats.databases_count_by_workspace = {\n        wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n    }\n\n    # Get databases per family\n    family_types: Set[ArkSIADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n    databases_stats.databases_count_by_family = {\n        ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n    }\n\n    # Get databases per auth method\n    auth_method_types: Set[ArkSIADBAuthMethodType] = {d.configured_auth_method_type for d in databases.items}\n    databases_stats.databases_count_by_auth_method = {\n        am: len([d for d in databases.items if d.configured_auth_method_type == am]) for am in auth_method_types\n    }\n\n    # Get databases per db warning\n    databases_stats.databases_count_by_warning = {\n        ArkSIADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n        ArkSIADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n    }\n\n    return databases_stats\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService.delete_database","title":"<code>delete_database(delete_database)</code>","text":"<p>Deletes a database.</p> <p>Parameters:</p> Name Type Description Default <code>delete_database</code> <code>ArkSIADBDeleteDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def delete_database(self, delete_database: ArkSIADBDeleteDatabase) -&gt; None:\n    \"\"\"\n    Deletes a database.\n\n    Args:\n        delete_database (ArkSIADBDeleteDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_database.name and not delete_database.id:\n        delete_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=delete_database.name))\n    self._logger.info(f'Deleting database [{delete_database.id}]')\n    resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService.list_databases","title":"<code>list_databases()</code>","text":"<p>Lists all databases.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabaseInfoList</code> <code>ArkSIADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def list_databases(self) -&gt; ArkSIADBDatabaseInfoList:\n    \"\"\"\n    Lists all databases.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info('Listing all databases')\n    return self.__list_databases_with_filters()\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService.list_databases_by","title":"<code>list_databases_by(databases_filter)</code>","text":"<p>Lists databases that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>databases_filter</code> <code>ArkSIADBDatabasesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkSIADBDatabaseInfoList</code> <code>ArkSIADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def list_databases_by(self, databases_filter: ArkSIADBDatabasesFilter) -&gt; ArkSIADBDatabaseInfoList:\n    \"\"\"\n    Lists databases that match the specified filters.\n\n    Args:\n        databases_filter (ArkSIADBDatabasesFilter): _description_\n\n    Returns:\n        ArkSIADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info(f'Listing databases by filters [{databases_filter}]')\n    databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n    if databases_filter.name:\n        databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n    if databases_filter.provider_engine:\n        databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n    if databases_filter.provider_workspace:\n        databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n    if databases_filter.auth_methods:\n        databases.items = [d for d in databases.items if d.configured_auth_method_type in databases_filter.auth_methods]\n    if databases_filter.db_warnings_filter:\n        if databases_filter.db_warnings_filter in (\n            ArkSIADBWarning.AnyError,\n            ArkSIADBWarning.NoCertificates,\n        ):\n            databases.items = [d for d in databases.items if not d.certificate]\n        if databases_filter.db_warnings_filter in (\n            ArkSIADBWarning.AnyError,\n            ArkSIADBWarning.NoSecrets,\n        ):\n            databases.items = [d for d in databases.items if not d.secret_id]\n    databases.total_count = len(databases.items)\n    return databases\n</code></pre>"},{"location":"reference/services/sia/workspaces/db/ark_sia_db_workspace_service/#ark_sdk_python.services.sia.workspaces.db.ark_sia_db_workspace_service.ArkSIADBWorkspaceService.update_database","title":"<code>update_database(update_database)</code>","text":"<p>Updates a database.</p> <p>Parameters:</p> Name Type Description Default <code>update_database</code> <code>ArkSIADBUpdateDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIADBDatabase</code> <code>ArkSIADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/db/ark_sia_db_workspace_service.py</code> <pre><code>def update_database(self, update_database: ArkSIADBUpdateDatabase) -&gt; ArkSIADBDatabase:\n    \"\"\"\n    Updates a database.\n\n    Args:\n        update_database (ArkSIADBUpdateDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIADBDatabase: _description_\n    \"\"\"\n    if update_database.name and not update_database.id:\n        databases = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name))\n        if not databases.items or len(databases.items) != 1:\n            raise ArkServiceException(f'Failed to update database - name [{update_database.name}] not found')\n        update_database.id = self.list_databases_by(ArkSIADBDatabasesFilter(name=update_database.name)).items[0].id\n    self._logger.info(f'Updating database [{update_database.id}]')\n    update_database_dict = update_database.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_database.new_name:\n        update_database_dict[\"name\"] = update_database.new_name\n    resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return self.database(ArkSIADBGetDatabase(id=update_database.id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/","title":"targetsets","text":""},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService","title":"<code>ArkSIATargetSetsWorkspaceService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>class ArkSIATargetSetsWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def add_target_set(self, add_target_set: ArkSIAAddTargetSet) -&gt; ArkSIATargetSet:\n        \"\"\"\n        Add a new target set\n\n        Args:\n            add_target_set (ArkSIAAddTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIATargetSet: _description_\n        \"\"\"\n        self._logger.info(f'Adding target set [{add_target_set.name}]')\n        add_target_set_dict = add_target_set.model_dump()\n        resp: Response = self.__client.post(TARGET_SETS_API, json=add_target_set_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                add_target_set_dict.update(resp.json()['target_set'])\n                return ArkSIATargetSet(**add_target_set_dict)\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add target set [{resp.text}] - [{resp.status_code}]')\n\n    def bulk_add_target_sets(self, bulk_add_target_sets: ArkSIABulkAddTargetSetsItem) -&gt; ArkSIABulkTargetSetResponse:\n        \"\"\"\n        Bulk add new target sets\n\n        Args:\n            bulk_add_target_sets (ArkSIABulkAddTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIABulkTargetSetResponse: _description_\n        \"\"\"\n        self._logger.info(f'Bulk adding target sets [{bulk_add_target_sets}]')\n        resp: Response = self.__client.post(BULK_TARGET_SETS_API, json=bulk_add_target_sets.model_dump())\n        if resp.status_code == HTTPStatus.MULTI_STATUS:\n            try:\n                return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse bulk add target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse bulk add target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to bulk add target sets [{resp.text}] - [{resp.status_code}]')\n\n    def delete_target_set(self, delete_target_set: ArkSIADeleteTargetSet) -&gt; None:\n        \"\"\"\n        Delete an existing target set\n\n        Args:\n            delete_target_set (ArkSIADeleteTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting target set [{delete_target_set.name}]')\n        resp: Response = self.__client.delete(TARGET_SET_API.format(target_name=delete_target_set.name))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete target set [{resp.text}] - [{resp.status_code}]')\n\n    def bulk_delete_target_sets(self, bulk_delete_target_sets: ArkSIABulkDeleteTargetSets) -&gt; ArkSIABulkTargetSetResponse:\n        \"\"\"\n        Bulk deletes existing target sets\n\n        Args:\n            bulk_delete_target_sets (ArkSIABulkDeleteTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIABulkTargetSetResponse: _description_\n        \"\"\"\n        self._logger.info(f'Bulk deleting target sets [{bulk_delete_target_sets}]')\n        resp: Response = self.__client.delete(BULK_TARGET_SETS_API, json=bulk_delete_target_sets.target_sets)\n        if resp.status_code == HTTPStatus.MULTI_STATUS:\n            try:\n                return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse bulk delete target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse bulk delete target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to bulk delete target sets [{resp.text}] - [{resp.status_code}]')\n\n    def update_target_set(self, update_target_set: ArkSIAUpdateTargetSet) -&gt; ArkSIATargetSet:\n        \"\"\"\n        Update an existing target set\n\n        Args:\n            update_target_set (ArkSIAUpdateTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIATargetSet: _description_\n        \"\"\"\n        self._logger.info(f'Updating target set [{update_target_set.name}]')\n        update_target_set_dict = update_target_set.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_target_set.new_name:\n            update_target_set_dict[\"name\"] = update_target_set.new_name\n        resp: Response = self.__client.put(TARGET_SET_API.format(target_name=update_target_set.name), json=update_target_set_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                update_target_set_dict.update(resp.json()['target_set'])\n                return ArkSIATargetSet(**update_target_set_dict)\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update target set [{resp.text}] - [{resp.status_code}]')\n\n    def list_target_sets(self) -&gt; List[ArkSIATargetSet]:\n        \"\"\"\n        List all target sets\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkSIATargetSet]: _description_\n        \"\"\"\n        self._logger.info('Listing all target sets')\n        resp: Response = self.__client.get(TARGET_SETS_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return [ArkSIATargetSet.model_validate(ts) for ts in resp.json()['target_sets']]\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list target sets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list target sets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list target sets [{resp.text}] - [{resp.status_code}]')\n\n    def list_target_sets_by(self, target_sets_filter: ArkSIATargetSetsFilter) -&gt; List[ArkSIATargetSet]:\n        \"\"\"\n        List target sets by given filters\n\n        Args:\n            target_sets_filter (ArkSIATargetSetsFilter): _description_\n\n        Returns:\n            List[ArkSIATargetSet]: _description_\n        \"\"\"\n        self._logger.info(f'Listing target sets by filters [{target_sets_filter}]')\n        target_sets = self.list_target_sets()\n        if target_sets_filter.name:\n            target_sets = [t for t in target_sets if fnmatch(t.name, target_sets_filter.name)]\n        if target_sets_filter.secret_type:\n            target_sets = [t for t in target_sets if t.secret_type and t.secret_type == target_sets_filter.secret_type]\n        return target_sets\n\n    def target_set(self, get_target_set: ArkSIAGetTargetSet) -&gt; ArkSIATargetSet:\n        \"\"\"\n        Get specific target set\n\n        Args:\n            get_target_set (ArkSIAGetTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIATargetSet: _description_\n        \"\"\"\n        self._logger.info(f'Getting target set [{get_target_set.name}]')\n        resp: Response = self.__client.get(TARGET_SET_API.format(target_name=get_target_set.name))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIATargetSet(**resp.json()['target_set'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get target set [{resp.text}] - [{resp.status_code}]')\n\n    def target_sets_stats(self) -&gt; ArkSIATargetSetsStats:\n        \"\"\"\n        Calculate stats about the target sets of the tenant\n\n        Returns:\n            ArkSIATargetSetsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating target sets stats')\n        target_sets = self.list_target_sets()\n        target_sets_stats = ArkSIATargetSetsStats.model_construct()\n        target_sets_stats.target_sets_count = len(target_sets)\n\n        # Get target_sets per secret type\n        secret_types: Set[ArkSIAVMSecretType] = {d.secret_type for d in target_sets if d.secret_type}\n        target_sets_stats.target_sets_count_per_secret_type = {\n            st: len([d for d in target_sets if d.secret_type and d.secret_type == st]) for st in secret_types\n        }\n\n        return target_sets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.add_target_set","title":"<code>add_target_set(add_target_set)</code>","text":"<p>Add a new target set</p> <p>Parameters:</p> Name Type Description Default <code>add_target_set</code> <code>ArkSIAAddTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSet</code> <code>ArkSIATargetSet</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def add_target_set(self, add_target_set: ArkSIAAddTargetSet) -&gt; ArkSIATargetSet:\n    \"\"\"\n    Add a new target set\n\n    Args:\n        add_target_set (ArkSIAAddTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIATargetSet: _description_\n    \"\"\"\n    self._logger.info(f'Adding target set [{add_target_set.name}]')\n    add_target_set_dict = add_target_set.model_dump()\n    resp: Response = self.__client.post(TARGET_SETS_API, json=add_target_set_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            add_target_set_dict.update(resp.json()['target_set'])\n            return ArkSIATargetSet(**add_target_set_dict)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.bulk_add_target_sets","title":"<code>bulk_add_target_sets(bulk_add_target_sets)</code>","text":"<p>Bulk add new target sets</p> <p>Parameters:</p> Name Type Description Default <code>bulk_add_target_sets</code> <code>ArkSIABulkAddTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIABulkTargetSetResponse</code> <code>ArkSIABulkTargetSetResponse</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def bulk_add_target_sets(self, bulk_add_target_sets: ArkSIABulkAddTargetSetsItem) -&gt; ArkSIABulkTargetSetResponse:\n    \"\"\"\n    Bulk add new target sets\n\n    Args:\n        bulk_add_target_sets (ArkSIABulkAddTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIABulkTargetSetResponse: _description_\n    \"\"\"\n    self._logger.info(f'Bulk adding target sets [{bulk_add_target_sets}]')\n    resp: Response = self.__client.post(BULK_TARGET_SETS_API, json=bulk_add_target_sets.model_dump())\n    if resp.status_code == HTTPStatus.MULTI_STATUS:\n        try:\n            return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse bulk add target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse bulk add target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to bulk add target sets [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.bulk_delete_target_sets","title":"<code>bulk_delete_target_sets(bulk_delete_target_sets)</code>","text":"<p>Bulk deletes existing target sets</p> <p>Parameters:</p> Name Type Description Default <code>bulk_delete_target_sets</code> <code>ArkSIABulkDeleteTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIABulkTargetSetResponse</code> <code>ArkSIABulkTargetSetResponse</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def bulk_delete_target_sets(self, bulk_delete_target_sets: ArkSIABulkDeleteTargetSets) -&gt; ArkSIABulkTargetSetResponse:\n    \"\"\"\n    Bulk deletes existing target sets\n\n    Args:\n        bulk_delete_target_sets (ArkSIABulkDeleteTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIABulkTargetSetResponse: _description_\n    \"\"\"\n    self._logger.info(f'Bulk deleting target sets [{bulk_delete_target_sets}]')\n    resp: Response = self.__client.delete(BULK_TARGET_SETS_API, json=bulk_delete_target_sets.target_sets)\n    if resp.status_code == HTTPStatus.MULTI_STATUS:\n        try:\n            return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse bulk delete target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse bulk delete target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to bulk delete target sets [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.delete_target_set","title":"<code>delete_target_set(delete_target_set)</code>","text":"<p>Delete an existing target set</p> <p>Parameters:</p> Name Type Description Default <code>delete_target_set</code> <code>ArkSIADeleteTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def delete_target_set(self, delete_target_set: ArkSIADeleteTargetSet) -&gt; None:\n    \"\"\"\n    Delete an existing target set\n\n    Args:\n        delete_target_set (ArkSIADeleteTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting target set [{delete_target_set.name}]')\n    resp: Response = self.__client.delete(TARGET_SET_API.format(target_name=delete_target_set.name))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.list_target_sets","title":"<code>list_target_sets()</code>","text":"<p>List all target sets</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkSIATargetSet]</code> <p>List[ArkSIATargetSet]: description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def list_target_sets(self) -&gt; List[ArkSIATargetSet]:\n    \"\"\"\n    List all target sets\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkSIATargetSet]: _description_\n    \"\"\"\n    self._logger.info('Listing all target sets')\n    resp: Response = self.__client.get(TARGET_SETS_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return [ArkSIATargetSet.model_validate(ts) for ts in resp.json()['target_sets']]\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list target sets response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list target sets response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list target sets [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.list_target_sets_by","title":"<code>list_target_sets_by(target_sets_filter)</code>","text":"<p>List target sets by given filters</p> <p>Parameters:</p> Name Type Description Default <code>target_sets_filter</code> <code>ArkSIATargetSetsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIATargetSet]</code> <p>List[ArkSIATargetSet]: description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def list_target_sets_by(self, target_sets_filter: ArkSIATargetSetsFilter) -&gt; List[ArkSIATargetSet]:\n    \"\"\"\n    List target sets by given filters\n\n    Args:\n        target_sets_filter (ArkSIATargetSetsFilter): _description_\n\n    Returns:\n        List[ArkSIATargetSet]: _description_\n    \"\"\"\n    self._logger.info(f'Listing target sets by filters [{target_sets_filter}]')\n    target_sets = self.list_target_sets()\n    if target_sets_filter.name:\n        target_sets = [t for t in target_sets if fnmatch(t.name, target_sets_filter.name)]\n    if target_sets_filter.secret_type:\n        target_sets = [t for t in target_sets if t.secret_type and t.secret_type == target_sets_filter.secret_type]\n    return target_sets\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.target_set","title":"<code>target_set(get_target_set)</code>","text":"<p>Get specific target set</p> <p>Parameters:</p> Name Type Description Default <code>get_target_set</code> <code>ArkSIAGetTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSet</code> <code>ArkSIATargetSet</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def target_set(self, get_target_set: ArkSIAGetTargetSet) -&gt; ArkSIATargetSet:\n    \"\"\"\n    Get specific target set\n\n    Args:\n        get_target_set (ArkSIAGetTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIATargetSet: _description_\n    \"\"\"\n    self._logger.info(f'Getting target set [{get_target_set.name}]')\n    resp: Response = self.__client.get(TARGET_SET_API.format(target_name=get_target_set.name))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIATargetSet(**resp.json()['target_set'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.target_sets_stats","title":"<code>target_sets_stats()</code>","text":"<p>Calculate stats about the target sets of the tenant</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSetsStats</code> <code>ArkSIATargetSetsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def target_sets_stats(self) -&gt; ArkSIATargetSetsStats:\n    \"\"\"\n    Calculate stats about the target sets of the tenant\n\n    Returns:\n        ArkSIATargetSetsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating target sets stats')\n    target_sets = self.list_target_sets()\n    target_sets_stats = ArkSIATargetSetsStats.model_construct()\n    target_sets_stats.target_sets_count = len(target_sets)\n\n    # Get target_sets per secret type\n    secret_types: Set[ArkSIAVMSecretType] = {d.secret_type for d in target_sets if d.secret_type}\n    target_sets_stats.target_sets_count_per_secret_type = {\n        st: len([d for d in target_sets if d.secret_type and d.secret_type == st]) for st in secret_types\n    }\n\n    return target_sets_stats\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/#ark_sdk_python.services.sia.workspaces.targetsets.ArkSIATargetSetsWorkspaceService.update_target_set","title":"<code>update_target_set(update_target_set)</code>","text":"<p>Update an existing target set</p> <p>Parameters:</p> Name Type Description Default <code>update_target_set</code> <code>ArkSIAUpdateTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSet</code> <code>ArkSIATargetSet</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def update_target_set(self, update_target_set: ArkSIAUpdateTargetSet) -&gt; ArkSIATargetSet:\n    \"\"\"\n    Update an existing target set\n\n    Args:\n        update_target_set (ArkSIAUpdateTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIATargetSet: _description_\n    \"\"\"\n    self._logger.info(f'Updating target set [{update_target_set.name}]')\n    update_target_set_dict = update_target_set.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_target_set.new_name:\n        update_target_set_dict[\"name\"] = update_target_set.new_name\n    resp: Response = self.__client.put(TARGET_SET_API.format(target_name=update_target_set.name), json=update_target_set_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            update_target_set_dict.update(resp.json()['target_set'])\n            return ArkSIATargetSet(**update_target_set_dict)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/","title":"ark_sia_target_sets_workspace_service","text":""},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService","title":"<code>ArkSIATargetSetsWorkspaceService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>class ArkSIATargetSetsWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='dpa',\n            refresh_connection_callback=self.__refresh_sia_auth,\n        )\n\n    def __refresh_sia_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def add_target_set(self, add_target_set: ArkSIAAddTargetSet) -&gt; ArkSIATargetSet:\n        \"\"\"\n        Add a new target set\n\n        Args:\n            add_target_set (ArkSIAAddTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIATargetSet: _description_\n        \"\"\"\n        self._logger.info(f'Adding target set [{add_target_set.name}]')\n        add_target_set_dict = add_target_set.model_dump()\n        resp: Response = self.__client.post(TARGET_SETS_API, json=add_target_set_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                add_target_set_dict.update(resp.json()['target_set'])\n                return ArkSIATargetSet(**add_target_set_dict)\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add target set [{resp.text}] - [{resp.status_code}]')\n\n    def bulk_add_target_sets(self, bulk_add_target_sets: ArkSIABulkAddTargetSetsItem) -&gt; ArkSIABulkTargetSetResponse:\n        \"\"\"\n        Bulk add new target sets\n\n        Args:\n            bulk_add_target_sets (ArkSIABulkAddTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIABulkTargetSetResponse: _description_\n        \"\"\"\n        self._logger.info(f'Bulk adding target sets [{bulk_add_target_sets}]')\n        resp: Response = self.__client.post(BULK_TARGET_SETS_API, json=bulk_add_target_sets.model_dump())\n        if resp.status_code == HTTPStatus.MULTI_STATUS:\n            try:\n                return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse bulk add target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse bulk add target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to bulk add target sets [{resp.text}] - [{resp.status_code}]')\n\n    def delete_target_set(self, delete_target_set: ArkSIADeleteTargetSet) -&gt; None:\n        \"\"\"\n        Delete an existing target set\n\n        Args:\n            delete_target_set (ArkSIADeleteTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f'Deleting target set [{delete_target_set.name}]')\n        resp: Response = self.__client.delete(TARGET_SET_API.format(target_name=delete_target_set.name))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete target set [{resp.text}] - [{resp.status_code}]')\n\n    def bulk_delete_target_sets(self, bulk_delete_target_sets: ArkSIABulkDeleteTargetSets) -&gt; ArkSIABulkTargetSetResponse:\n        \"\"\"\n        Bulk deletes existing target sets\n\n        Args:\n            bulk_delete_target_sets (ArkSIABulkDeleteTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIABulkTargetSetResponse: _description_\n        \"\"\"\n        self._logger.info(f'Bulk deleting target sets [{bulk_delete_target_sets}]')\n        resp: Response = self.__client.delete(BULK_TARGET_SETS_API, json=bulk_delete_target_sets.target_sets)\n        if resp.status_code == HTTPStatus.MULTI_STATUS:\n            try:\n                return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse bulk delete target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse bulk delete target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to bulk delete target sets [{resp.text}] - [{resp.status_code}]')\n\n    def update_target_set(self, update_target_set: ArkSIAUpdateTargetSet) -&gt; ArkSIATargetSet:\n        \"\"\"\n        Update an existing target set\n\n        Args:\n            update_target_set (ArkSIAUpdateTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIATargetSet: _description_\n        \"\"\"\n        self._logger.info(f'Updating target set [{update_target_set.name}]')\n        update_target_set_dict = update_target_set.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_target_set.new_name:\n            update_target_set_dict[\"name\"] = update_target_set.new_name\n        resp: Response = self.__client.put(TARGET_SET_API.format(target_name=update_target_set.name), json=update_target_set_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                update_target_set_dict.update(resp.json()['target_set'])\n                return ArkSIATargetSet(**update_target_set_dict)\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update target set [{resp.text}] - [{resp.status_code}]')\n\n    def list_target_sets(self) -&gt; List[ArkSIATargetSet]:\n        \"\"\"\n        List all target sets\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkSIATargetSet]: _description_\n        \"\"\"\n        self._logger.info('Listing all target sets')\n        resp: Response = self.__client.get(TARGET_SETS_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return [ArkSIATargetSet.model_validate(ts) for ts in resp.json()['target_sets']]\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list target sets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list target sets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list target sets [{resp.text}] - [{resp.status_code}]')\n\n    def list_target_sets_by(self, target_sets_filter: ArkSIATargetSetsFilter) -&gt; List[ArkSIATargetSet]:\n        \"\"\"\n        List target sets by given filters\n\n        Args:\n            target_sets_filter (ArkSIATargetSetsFilter): _description_\n\n        Returns:\n            List[ArkSIATargetSet]: _description_\n        \"\"\"\n        self._logger.info(f'Listing target sets by filters [{target_sets_filter}]')\n        target_sets = self.list_target_sets()\n        if target_sets_filter.name:\n            target_sets = [t for t in target_sets if fnmatch(t.name, target_sets_filter.name)]\n        if target_sets_filter.secret_type:\n            target_sets = [t for t in target_sets if t.secret_type and t.secret_type == target_sets_filter.secret_type]\n        return target_sets\n\n    def target_set(self, get_target_set: ArkSIAGetTargetSet) -&gt; ArkSIATargetSet:\n        \"\"\"\n        Get specific target set\n\n        Args:\n            get_target_set (ArkSIAGetTargetSet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSIATargetSet: _description_\n        \"\"\"\n        self._logger.info(f'Getting target set [{get_target_set.name}]')\n        resp: Response = self.__client.get(TARGET_SET_API.format(target_name=get_target_set.name))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkSIATargetSet(**resp.json()['target_set'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse target set response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse target set response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get target set [{resp.text}] - [{resp.status_code}]')\n\n    def target_sets_stats(self) -&gt; ArkSIATargetSetsStats:\n        \"\"\"\n        Calculate stats about the target sets of the tenant\n\n        Returns:\n            ArkSIATargetSetsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating target sets stats')\n        target_sets = self.list_target_sets()\n        target_sets_stats = ArkSIATargetSetsStats.model_construct()\n        target_sets_stats.target_sets_count = len(target_sets)\n\n        # Get target_sets per secret type\n        secret_types: Set[ArkSIAVMSecretType] = {d.secret_type for d in target_sets if d.secret_type}\n        target_sets_stats.target_sets_count_per_secret_type = {\n            st: len([d for d in target_sets if d.secret_type and d.secret_type == st]) for st in secret_types\n        }\n\n        return target_sets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.add_target_set","title":"<code>add_target_set(add_target_set)</code>","text":"<p>Add a new target set</p> <p>Parameters:</p> Name Type Description Default <code>add_target_set</code> <code>ArkSIAAddTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSet</code> <code>ArkSIATargetSet</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def add_target_set(self, add_target_set: ArkSIAAddTargetSet) -&gt; ArkSIATargetSet:\n    \"\"\"\n    Add a new target set\n\n    Args:\n        add_target_set (ArkSIAAddTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIATargetSet: _description_\n    \"\"\"\n    self._logger.info(f'Adding target set [{add_target_set.name}]')\n    add_target_set_dict = add_target_set.model_dump()\n    resp: Response = self.__client.post(TARGET_SETS_API, json=add_target_set_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            add_target_set_dict.update(resp.json()['target_set'])\n            return ArkSIATargetSet(**add_target_set_dict)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.bulk_add_target_sets","title":"<code>bulk_add_target_sets(bulk_add_target_sets)</code>","text":"<p>Bulk add new target sets</p> <p>Parameters:</p> Name Type Description Default <code>bulk_add_target_sets</code> <code>ArkSIABulkAddTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIABulkTargetSetResponse</code> <code>ArkSIABulkTargetSetResponse</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def bulk_add_target_sets(self, bulk_add_target_sets: ArkSIABulkAddTargetSetsItem) -&gt; ArkSIABulkTargetSetResponse:\n    \"\"\"\n    Bulk add new target sets\n\n    Args:\n        bulk_add_target_sets (ArkSIABulkAddTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIABulkTargetSetResponse: _description_\n    \"\"\"\n    self._logger.info(f'Bulk adding target sets [{bulk_add_target_sets}]')\n    resp: Response = self.__client.post(BULK_TARGET_SETS_API, json=bulk_add_target_sets.model_dump())\n    if resp.status_code == HTTPStatus.MULTI_STATUS:\n        try:\n            return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse bulk add target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse bulk add target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to bulk add target sets [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.bulk_delete_target_sets","title":"<code>bulk_delete_target_sets(bulk_delete_target_sets)</code>","text":"<p>Bulk deletes existing target sets</p> <p>Parameters:</p> Name Type Description Default <code>bulk_delete_target_sets</code> <code>ArkSIABulkDeleteTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIABulkTargetSetResponse</code> <code>ArkSIABulkTargetSetResponse</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def bulk_delete_target_sets(self, bulk_delete_target_sets: ArkSIABulkDeleteTargetSets) -&gt; ArkSIABulkTargetSetResponse:\n    \"\"\"\n    Bulk deletes existing target sets\n\n    Args:\n        bulk_delete_target_sets (ArkSIABulkDeleteTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIABulkTargetSetResponse: _description_\n    \"\"\"\n    self._logger.info(f'Bulk deleting target sets [{bulk_delete_target_sets}]')\n    resp: Response = self.__client.delete(BULK_TARGET_SETS_API, json=bulk_delete_target_sets.target_sets)\n    if resp.status_code == HTTPStatus.MULTI_STATUS:\n        try:\n            return ArkSIABulkTargetSetResponse.model_validate(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse bulk delete target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse bulk delete target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to bulk delete target sets [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.delete_target_set","title":"<code>delete_target_set(delete_target_set)</code>","text":"<p>Delete an existing target set</p> <p>Parameters:</p> Name Type Description Default <code>delete_target_set</code> <code>ArkSIADeleteTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def delete_target_set(self, delete_target_set: ArkSIADeleteTargetSet) -&gt; None:\n    \"\"\"\n    Delete an existing target set\n\n    Args:\n        delete_target_set (ArkSIADeleteTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f'Deleting target set [{delete_target_set.name}]')\n    resp: Response = self.__client.delete(TARGET_SET_API.format(target_name=delete_target_set.name))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.list_target_sets","title":"<code>list_target_sets()</code>","text":"<p>List all target sets</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkSIATargetSet]</code> <p>List[ArkSIATargetSet]: description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def list_target_sets(self) -&gt; List[ArkSIATargetSet]:\n    \"\"\"\n    List all target sets\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkSIATargetSet]: _description_\n    \"\"\"\n    self._logger.info('Listing all target sets')\n    resp: Response = self.__client.get(TARGET_SETS_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return [ArkSIATargetSet.model_validate(ts) for ts in resp.json()['target_sets']]\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list target sets response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list target sets response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list target sets [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.list_target_sets_by","title":"<code>list_target_sets_by(target_sets_filter)</code>","text":"<p>List target sets by given filters</p> <p>Parameters:</p> Name Type Description Default <code>target_sets_filter</code> <code>ArkSIATargetSetsFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkSIATargetSet]</code> <p>List[ArkSIATargetSet]: description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def list_target_sets_by(self, target_sets_filter: ArkSIATargetSetsFilter) -&gt; List[ArkSIATargetSet]:\n    \"\"\"\n    List target sets by given filters\n\n    Args:\n        target_sets_filter (ArkSIATargetSetsFilter): _description_\n\n    Returns:\n        List[ArkSIATargetSet]: _description_\n    \"\"\"\n    self._logger.info(f'Listing target sets by filters [{target_sets_filter}]')\n    target_sets = self.list_target_sets()\n    if target_sets_filter.name:\n        target_sets = [t for t in target_sets if fnmatch(t.name, target_sets_filter.name)]\n    if target_sets_filter.secret_type:\n        target_sets = [t for t in target_sets if t.secret_type and t.secret_type == target_sets_filter.secret_type]\n    return target_sets\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.target_set","title":"<code>target_set(get_target_set)</code>","text":"<p>Get specific target set</p> <p>Parameters:</p> Name Type Description Default <code>get_target_set</code> <code>ArkSIAGetTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSet</code> <code>ArkSIATargetSet</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def target_set(self, get_target_set: ArkSIAGetTargetSet) -&gt; ArkSIATargetSet:\n    \"\"\"\n    Get specific target set\n\n    Args:\n        get_target_set (ArkSIAGetTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIATargetSet: _description_\n    \"\"\"\n    self._logger.info(f'Getting target set [{get_target_set.name}]')\n    resp: Response = self.__client.get(TARGET_SET_API.format(target_name=get_target_set.name))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkSIATargetSet(**resp.json()['target_set'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.target_sets_stats","title":"<code>target_sets_stats()</code>","text":"<p>Calculate stats about the target sets of the tenant</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSetsStats</code> <code>ArkSIATargetSetsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def target_sets_stats(self) -&gt; ArkSIATargetSetsStats:\n    \"\"\"\n    Calculate stats about the target sets of the tenant\n\n    Returns:\n        ArkSIATargetSetsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating target sets stats')\n    target_sets = self.list_target_sets()\n    target_sets_stats = ArkSIATargetSetsStats.model_construct()\n    target_sets_stats.target_sets_count = len(target_sets)\n\n    # Get target_sets per secret type\n    secret_types: Set[ArkSIAVMSecretType] = {d.secret_type for d in target_sets if d.secret_type}\n    target_sets_stats.target_sets_count_per_secret_type = {\n        st: len([d for d in target_sets if d.secret_type and d.secret_type == st]) for st in secret_types\n    }\n\n    return target_sets_stats\n</code></pre>"},{"location":"reference/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service/#ark_sdk_python.services.sia.workspaces.targetsets.ark_sia_target_sets_workspace_service.ArkSIATargetSetsWorkspaceService.update_target_set","title":"<code>update_target_set(update_target_set)</code>","text":"<p>Update an existing target set</p> <p>Parameters:</p> Name Type Description Default <code>update_target_set</code> <code>ArkSIAUpdateTargetSet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSIATargetSet</code> <code>ArkSIATargetSet</code> <p>description</p> Source code in <code>ark_sdk_python/services/sia/workspaces/targetsets/ark_sia_target_sets_workspace_service.py</code> <pre><code>def update_target_set(self, update_target_set: ArkSIAUpdateTargetSet) -&gt; ArkSIATargetSet:\n    \"\"\"\n    Update an existing target set\n\n    Args:\n        update_target_set (ArkSIAUpdateTargetSet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSIATargetSet: _description_\n    \"\"\"\n    self._logger.info(f'Updating target set [{update_target_set.name}]')\n    update_target_set_dict = update_target_set.model_dump(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_target_set.new_name:\n        update_target_set_dict[\"name\"] = update_target_set.new_name\n    resp: Response = self.__client.put(TARGET_SET_API.format(target_name=update_target_set.name), json=update_target_set_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            update_target_set_dict.update(resp.json()['target_set'])\n            return ArkSIATargetSet(**update_target_set_dict)\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update target set response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update target set response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update target set [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sm/","title":"sm","text":""},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService","title":"<code>ArkSMService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>class ArkSMService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='sessionmonitoring',\n            refresh_connection_callback=self.__refresh_sm_auth,\n        )\n\n    def __refresh_sm_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __search_params_from_filter(self, sessions_filter: ArkSMSessionsFilter):\n        return {'search': sessions_filter.search}\n\n    def __call_sessions_api(self, params: Optional[dict] = None) -&gt; ArkSMSessions:\n        params_dict = {}\n        if params:\n            params_dict['params'] = params\n        resp = self.__client.get(SESSIONS_API_URL, **params_dict)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}] {params=}')\n        return ArkSMSessions.model_validate(resp.json())\n\n    def __call_activities_api(self, session_id: str, params: Optional[dict] = None) -&gt; ArkSMSessionActivities:\n        endpoint = SESSION_ACTIVITIES_API_URL.format(session_id=session_id)\n        resp = self.__client.get(endpoint, params=params)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list activities [{resp.text}]')\n        return ArkSMSessionActivities.model_validate(resp.json())\n\n    def __list_sessions(self, params: Optional[Dict] = None) -&gt; Iterator[ArkSMPage]:\n        params = params or {}\n        sessions: ArkSMSessions = self.__call_sessions_api(params)\n        offset = 0\n        while sessions.returned_count &gt; 0:\n            yield ArkSMPage(items=sessions.sessions)\n            offset += sessions.returned_count\n            params['offset'] = offset\n            sessions = self.__call_sessions_api(params)\n\n    def __list_activities(self, session_id: str, params: Optional[Dict] = None) -&gt; Iterator[ArkSMActivitiesPage]:\n        params = params or {}\n        activities: ArkSMSessionActivities = self.__call_activities_api(session_id=session_id, params=params)\n        offset = 0\n        while activities.returned_count &gt; 0:\n            yield ArkSMActivitiesPage(items=activities.activities)\n            offset += activities.returned_count\n            params['offset'] = offset\n            activities = self.__call_activities_api(session_id=session_id, params=params)\n\n    def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions done on the last 24 hours\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all session')\n        yield from self.__list_sessions()\n\n    def count_sessions(self) -&gt; int:\n        \"\"\"\n        Counts all sessions done on the last 24 hours\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api().filtered_count\n\n    def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing sessions by filter: {sessions_filter.search}')\n        yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n\n    def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n        \"\"\"\n        Counts all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n\n    def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n        \"\"\"\n        Retrieves a session by id\n\n        Args:\n            get_session (ArkSMGetSession): _description_\n\n        Raises:\n            ArkServiceException: _description_\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSMSession: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n        resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n        session = resp.json()\n        if len(session) == 0:\n            raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n        return ArkSMSession.model_validate(session)\n\n    def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n        yield from self.__list_activities(session_id=get_session_activities.session_id)\n\n    def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n        \"\"\"\n        Count all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n        return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n\n    def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n        for page in self.__list_activities(session_id=session_activities_filter.session_id):\n            yield ArkSMActivitiesPage(\n                items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n            )\n\n    def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n        \"\"\"\n        Count all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        count = 0\n        self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n        for page in self.list_session_activities_by(session_activities_filter):\n            count += len(page.items)\n        return count\n\n    def sessions_stats(self) -&gt; ArkSMSessionsStats:\n        \"\"\"\n        Returns statistics about the sessions in the last 30 days\n\n        Returns:\n            ArkSMSessionsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating sessions stats for the last 30 days')\n        start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n        sessions = list(\n            itertools.chain.from_iterable(\n                [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n            )\n        )\n        sessions_stats = ArkSMSessionsStats.model_construct()\n        sessions_stats.sessions_count = len(sessions)\n        sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n        # Get sessions per application code\n        app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n        sessions_stats.sessions_count_per_application_code = {\n            ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n        }\n\n        # Get sessions per platform\n        platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n        sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n        # Get sessions per protocol\n        protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n        sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n        # Get sessions per status\n        statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n        sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n        return sessions_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_session_activities","title":"<code>count_session_activities(get_session_activities)</code>","text":"<p>Count all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n    \"\"\"\n    Count all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n    return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_session_activities_by","title":"<code>count_session_activities_by(session_activities_filter)</code>","text":"<p>Count all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n    \"\"\"\n    Count all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    count = 0\n    self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n    for page in self.list_session_activities_by(session_activities_filter):\n        count += len(page.items)\n    return count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_sessions","title":"<code>count_sessions()</code>","text":"<p>Counts all sessions done on the last 24 hours</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions(self) -&gt; int:\n    \"\"\"\n    Counts all sessions done on the last 24 hours\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api().filtered_count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_sessions_by","title":"<code>count_sessions_by(sessions_filter)</code>","text":"<p>Counts all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n    \"\"\"\n    Counts all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_session_activities","title":"<code>list_session_activities(get_session_activities)</code>","text":"<p>Lists all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n    yield from self.__list_activities(session_id=get_session_activities.session_id)\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_session_activities_by","title":"<code>list_session_activities_by(session_activities_filter)</code>","text":"<p>Lists all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n    for page in self.__list_activities(session_id=session_activities_filter.session_id):\n        yield ArkSMActivitiesPage(\n            items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n        )\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_sessions","title":"<code>list_sessions()</code>","text":"<p>Lists all sessions done on the last 24 hours</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions done on the last 24 hours\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all session')\n    yield from self.__list_sessions()\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_sessions_by","title":"<code>list_sessions_by(sessions_filter)</code>","text":"<p>Lists all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing sessions by filter: {sessions_filter.search}')\n    yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.session","title":"<code>session(get_session)</code>","text":"<p>Retrieves a session by id</p> <p>Parameters:</p> Name Type Description Default <code>get_session</code> <code>ArkSMGetSession</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSMSession</code> <code>ArkSMSession</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n    \"\"\"\n    Retrieves a session by id\n\n    Args:\n        get_session (ArkSMGetSession): _description_\n\n    Raises:\n        ArkServiceException: _description_\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSMSession: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n    resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n    session = resp.json()\n    if len(session) == 0:\n        raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n    return ArkSMSession.model_validate(session)\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.sessions_stats","title":"<code>sessions_stats()</code>","text":"<p>Returns statistics about the sessions in the last 30 days</p> <p>Returns:</p> Name Type Description <code>ArkSMSessionsStats</code> <code>ArkSMSessionsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def sessions_stats(self) -&gt; ArkSMSessionsStats:\n    \"\"\"\n    Returns statistics about the sessions in the last 30 days\n\n    Returns:\n        ArkSMSessionsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating sessions stats for the last 30 days')\n    start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n    sessions = list(\n        itertools.chain.from_iterable(\n            [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n        )\n    )\n    sessions_stats = ArkSMSessionsStats.model_construct()\n    sessions_stats.sessions_count = len(sessions)\n    sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n    # Get sessions per application code\n    app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n    sessions_stats.sessions_count_per_application_code = {\n        ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n    }\n\n    # Get sessions per platform\n    platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n    sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n    # Get sessions per protocol\n    protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n    sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n    # Get sessions per status\n    statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n    sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n    return sessions_stats\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/","title":"ark_sm_service","text":""},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService","title":"<code>ArkSMService</code>","text":"<p>               Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>class ArkSMService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(\n            isp_auth=self.__isp_auth,\n            service_name='sessionmonitoring',\n            refresh_connection_callback=self.__refresh_sm_auth,\n        )\n\n    def __refresh_sm_auth(self, client: ArkISPServiceClient) -&gt; None:\n        ArkISPServiceClient.refresh_client(client, self.__isp_auth)\n\n    def __search_params_from_filter(self, sessions_filter: ArkSMSessionsFilter):\n        return {'search': sessions_filter.search}\n\n    def __call_sessions_api(self, params: Optional[dict] = None) -&gt; ArkSMSessions:\n        params_dict = {}\n        if params:\n            params_dict['params'] = params\n        resp = self.__client.get(SESSIONS_API_URL, **params_dict)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}] {params=}')\n        return ArkSMSessions.model_validate(resp.json())\n\n    def __call_activities_api(self, session_id: str, params: Optional[dict] = None) -&gt; ArkSMSessionActivities:\n        endpoint = SESSION_ACTIVITIES_API_URL.format(session_id=session_id)\n        resp = self.__client.get(endpoint, params=params)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list activities [{resp.text}]')\n        return ArkSMSessionActivities.model_validate(resp.json())\n\n    def __list_sessions(self, params: Optional[Dict] = None) -&gt; Iterator[ArkSMPage]:\n        params = params or {}\n        sessions: ArkSMSessions = self.__call_sessions_api(params)\n        offset = 0\n        while sessions.returned_count &gt; 0:\n            yield ArkSMPage(items=sessions.sessions)\n            offset += sessions.returned_count\n            params['offset'] = offset\n            sessions = self.__call_sessions_api(params)\n\n    def __list_activities(self, session_id: str, params: Optional[Dict] = None) -&gt; Iterator[ArkSMActivitiesPage]:\n        params = params or {}\n        activities: ArkSMSessionActivities = self.__call_activities_api(session_id=session_id, params=params)\n        offset = 0\n        while activities.returned_count &gt; 0:\n            yield ArkSMActivitiesPage(items=activities.activities)\n            offset += activities.returned_count\n            params['offset'] = offset\n            activities = self.__call_activities_api(session_id=session_id, params=params)\n\n    def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions done on the last 24 hours\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all session')\n        yield from self.__list_sessions()\n\n    def count_sessions(self) -&gt; int:\n        \"\"\"\n        Counts all sessions done on the last 24 hours\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api().filtered_count\n\n    def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info(f'Listing sessions by filter: {sessions_filter.search}')\n        yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n\n    def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n        \"\"\"\n        Counts all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n\n    def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n        \"\"\"\n        Retrieves a session by id\n\n        Args:\n            get_session (ArkSMGetSession): _description_\n\n        Raises:\n            ArkServiceException: _description_\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSMSession: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n        resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n        session = resp.json()\n        if len(session) == 0:\n            raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n        return ArkSMSession.model_validate(session)\n\n    def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n        yield from self.__list_activities(session_id=get_session_activities.session_id)\n\n    def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n        \"\"\"\n        Count all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n        return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n\n    def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n        for page in self.__list_activities(session_id=session_activities_filter.session_id):\n            yield ArkSMActivitiesPage(\n                items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n            )\n\n    def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n        \"\"\"\n        Count all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        count = 0\n        self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n        for page in self.list_session_activities_by(session_activities_filter):\n            count += len(page.items)\n        return count\n\n    def sessions_stats(self) -&gt; ArkSMSessionsStats:\n        \"\"\"\n        Returns statistics about the sessions in the last 30 days\n\n        Returns:\n            ArkSMSessionsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating sessions stats for the last 30 days')\n        start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n        sessions = list(\n            itertools.chain.from_iterable(\n                [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n            )\n        )\n        sessions_stats = ArkSMSessionsStats.model_construct()\n        sessions_stats.sessions_count = len(sessions)\n        sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n        # Get sessions per application code\n        app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n        sessions_stats.sessions_count_per_application_code = {\n            ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n        }\n\n        # Get sessions per platform\n        platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n        sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n        # Get sessions per protocol\n        protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n        sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n        # Get sessions per status\n        statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n        sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n        return sessions_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_session_activities","title":"<code>count_session_activities(get_session_activities)</code>","text":"<p>Count all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n    \"\"\"\n    Count all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n    return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_session_activities_by","title":"<code>count_session_activities_by(session_activities_filter)</code>","text":"<p>Count all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n    \"\"\"\n    Count all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    count = 0\n    self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n    for page in self.list_session_activities_by(session_activities_filter):\n        count += len(page.items)\n    return count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_sessions","title":"<code>count_sessions()</code>","text":"<p>Counts all sessions done on the last 24 hours</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions(self) -&gt; int:\n    \"\"\"\n    Counts all sessions done on the last 24 hours\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api().filtered_count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_sessions_by","title":"<code>count_sessions_by(sessions_filter)</code>","text":"<p>Counts all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n    \"\"\"\n    Counts all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_session_activities","title":"<code>list_session_activities(get_session_activities)</code>","text":"<p>Lists all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n    yield from self.__list_activities(session_id=get_session_activities.session_id)\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_session_activities_by","title":"<code>list_session_activities_by(session_activities_filter)</code>","text":"<p>Lists all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n    for page in self.__list_activities(session_id=session_activities_filter.session_id):\n        yield ArkSMActivitiesPage(\n            items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n        )\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_sessions","title":"<code>list_sessions()</code>","text":"<p>Lists all sessions done on the last 24 hours</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions done on the last 24 hours\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all session')\n    yield from self.__list_sessions()\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_sessions_by","title":"<code>list_sessions_by(sessions_filter)</code>","text":"<p>Lists all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info(f'Listing sessions by filter: {sessions_filter.search}')\n    yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.session","title":"<code>session(get_session)</code>","text":"<p>Retrieves a session by id</p> <p>Parameters:</p> Name Type Description Default <code>get_session</code> <code>ArkSMGetSession</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSMSession</code> <code>ArkSMSession</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n    \"\"\"\n    Retrieves a session by id\n\n    Args:\n        get_session (ArkSMGetSession): _description_\n\n    Raises:\n        ArkServiceException: _description_\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSMSession: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n    resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n    session = resp.json()\n    if len(session) == 0:\n        raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n    return ArkSMSession.model_validate(session)\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.sessions_stats","title":"<code>sessions_stats()</code>","text":"<p>Returns statistics about the sessions in the last 30 days</p> <p>Returns:</p> Name Type Description <code>ArkSMSessionsStats</code> <code>ArkSMSessionsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def sessions_stats(self) -&gt; ArkSMSessionsStats:\n    \"\"\"\n    Returns statistics about the sessions in the last 30 days\n\n    Returns:\n        ArkSMSessionsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating sessions stats for the last 30 days')\n    start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n    sessions = list(\n        itertools.chain.from_iterable(\n            [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n        )\n    )\n    sessions_stats = ArkSMSessionsStats.model_construct()\n    sessions_stats.sessions_count = len(sessions)\n    sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n    # Get sessions per application code\n    app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n    sessions_stats.sessions_count_per_application_code = {\n        ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n    }\n\n    # Get sessions per platform\n    platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n    sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n    # Get sessions per protocol\n    protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n    sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n    # Get sessions per status\n    statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n    sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n    return sessions_stats\n</code></pre>"},{"location":"sdk/async_requests/","title":"Async requests","text":"<p>To support async requests, relevant methods return an ArkAsyncRequest type with the following interfaces:</p> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request is finished or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request failed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request has timed out\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls for the async request until it is finished\n    Progress callbacks may also be used to be notified whats the async request status\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre> <p>You can call these methods for polling the service to check the request's status. </p> <p>Async requests also inherits the ArkPollableModel type, which contains information about whether or not to poll the request and how long to wait until the request times out. Additionally, when the request's authenticator can be refreshed, it is refreshed during the polling cycle.</p>"},{"location":"sdk/async_requests/#predefined-pollers","title":"Predefined pollers","text":"<p>These predefined pollers can be used (see ark_pollers.py):</p> <ul> <li>default_poller (default console logger polling)</li> <li>line_spinner_poller</li> <li>pixel_spinner_poller</li> <li>moon_spinner_poller</li> <li>spinner_poller</li> <li>pie_spinner_poller</li> </ul>"},{"location":"sdk/authenticators/","title":"Authenticators","text":"<p>An authenticator provides the ability to authenticate to a CyberArk Identity Security Platform (ISP) resource. The authentication is based on authentication profiles, where the authentication profile defines the authentication method and its associated settings.</p> <p>Here's an example of initialize an authenticator:</p> <pre><code>from ark_sdk_python.auth import ArkISPAuth\n\nauth = ArkISPAuth(cache_authentication=False)\n</code></pre> <p>Note</p> <p>When you call the constructor, you can determine whether or not the authentication credentials are cached.</p> <p>The Authenticators have a base authenticate method that receives a profile as an input and returns an auth token. Additionally, the ArkISPAuth class exposes functions to retrieve a profile's authentication methods and settings. Although the returned token can be used as a return value, it can normally be ignored as it is saved internally.</p> <p>These are the different types of authenticator types and auth methods:</p>"},{"location":"sdk/authenticators/#authenticator-types","title":"Authenticator types","text":"<p>Currently, ArkISPAuth is the only supported authenticator type, which is derived from the ArkISPAuth class and accepts the <code>Identity</code> (default) and <code>IdentityServiceUser</code> auth methods.</p>"},{"location":"sdk/authenticators/#auth-methods","title":"Auth methods","text":"<ul> <li>Identity (<code>identity</code>) - Identity authentication to a tenant or to an application within the Identity tenant, used with the IdentityArkAuthMethodSettings class</li> <li>IdentityServiceUser (<code>identity_service_user</code>) - Identity authentication with a service user, used with IdentityServiceUserArkAuthMethodSettings class</li> <li>Direct (<code>direct</code>) - Direct authentication to an endpoint, used with the DirectArkAuthMethodSettings class</li> <li>Default (<code>default</code>) - Default authenticator auth method for the authenticator</li> <li>Other (<code>other</code>) - For custom implementations</li> </ul> <p>See ark_auth_method.py for more information about auth methods.</p>"},{"location":"sdk/authenticators/#sdk-authenticate-example","title":"SDK authenticate example","text":"<p>Here is an example authentication flow that uses implements the ArkISPAuth class:</p> <pre><code>from ark_sdk_python.auth import ArkISPAuth\n\nisp_auth = ArkISPAuth(cache_authentication=False)\nisp_auth.authenticate(\n    auth_profile=ArkAuthProfile(\n        username='smarom@cyberark.cloud.84573',\n        auth_method=ArkAuthMethod.Identity,\n        auth_method_settings=IdentityArkAuthMethodSettings(),\n    ),\n    secret=ArkSecret(secret=\"CoolPassword\"),\n)\nsia_api = ArkSIAAPI(isp_auth=isp_auth)\n</code></pre> <p>The example above initializes an instance of the ArkISPAuth class and authenticates to the specified ISP tenant, using the <code>Identity</code> authentication type with the provided username and password.</p> <p>The <code>authenticate</code> method returns a token, which be ignored because it is stored internally.</p> <p>After authenticating, the authenticator can be used passed to the services you want to access.</p>"},{"location":"sdk/pagination/","title":"Pagination","text":"<p>When a response returns many items or is paginated, the response contains an page iterator instead of all the items. This ensures fast response times and the ability to just retrieve a required subset of items.</p> <p>Responses that do return paginated results contain an item iterator.</p>"},{"location":"sdk/schemas/","title":"Schemas","text":"<p>Ark SDK is entirely based on schemas constructed from Pydantic. Pydantic is a schema and data validation library that also provides settings management and uses Python type annotations.</p> <p>All <code>exec</code> actions in the Ark SDK receive a model parsed from the CLI or from the SDK in code and, some of them, return a model or set of models. All of these models inherit from ArkModel:</p> <pre><code>class ArkModel(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n</code></pre> <p>Derived from the model above, there are different model types that serve different purposes, such as aliasing attributes with camelCase and adding polling parameters.</p>"},{"location":"sdk/schemas/#example","title":"Example","text":"<p>Any request can be called with a defined model, for example:</p> <pre><code>policies_service = ArkSIADBPoliciesService(isp_auth)\npolicies = policies_service.list_policies()\n</code></pre> <p>The above example creates a DB policies service and calls <code>list_policies()</code> to retrieve a list of all tenant DB polices. The returned list items contain <code>policy_id</code> and <code>policy_name</code> fields, which can be used with the ArkSIAGetPolicy model:</p> <pre><code>class ArkSIAGetPolicy(ArkModel):\n    policy_id: Optional[str] = Field(description='Policy id to get')\n    policy_name: Optional[str] = Field(description='Policy name to get')\n</code></pre> <p>All models can be found here and are separated to folders based on topic, from auth to services</p>"},{"location":"sdk/services/","title":"Services","text":"<p>SDK services are defined to execute requests on available ISP services (such as SIA). When a service is initialized, a valid authenticator is required to authorize access to the ISP service. To perform service actions, each service exposes a set of classes and methods.</p> <p>Here's an example that initializes the <code>ArkSIADBPoliciesService</code> service:</p> <pre><code>import pprint\n\nfrom ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.auth import ArkAuthMethod, ArkAuthProfile, ArkSecret, IdentityArkAuthMethodSettings\nfrom ark_sdk_python.services.sia.policies import ArkSIAPoliciesService\n\nif __name__ == '__main__':\n    isp_auth = ArkISPAuth(cache_authentication=False)\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='tina@cyberark.cloud.12345',\n            auth_method=ArkAuthMethod.Identity,\n            auth_method_settings=IdentityArkAuthMethodSettings(),\n        ),\n        secret=ArkSecret(secret=\"CoolPassword\"),\n    )\n    policies_service = ArkSIADBPoliciesService(isp_auth=isp_auth)\n    policies = policies_service.list_policies()\n    for policy in policies:\n        pprint.pprint(policy.json(indent=4))\n</code></pre> <p>The above example authenticates to the specified ISP tenant, initializes a SIA policies service using the authorized authenticator, and then uses the service to list the policies.</p>"},{"location":"sdk/services/#dynamic-privilege-access-service","title":"Dynamic Privilege Access service","text":"<p>The Dynamic Privilege Access (SIA) service requires the ArkISPAuth authenticator, and exposes these service classes:</p> <ul> <li>ArkSIACertificatesService (certificates) - SIA certificates service</li> <li>ArkSIASSOService (sso) - SIA end-user SSO service</li> <li>ArkSIAK8SService (kubernetes) - SIA end-user Kubernetes service</li> <li>ArkSIADatabasesService (databases) - SIA end-user databases service</li> <li>ArkSIAPoliciesService (policies) - SIA policies management<ul> <li>ArkSIADBPoliciesService (db) - SIA DB policies management<ul> <li>ArkSIADBPoliciesEditorService (editor) - SIA DB policies interactive</li> </ul> </li> <li>ArkSIAVMPoliciesService (vm) - SIA VM policies management<ul> <li>ArkSIAVMPoliciesEditorService (editor) - SIA VM policies interactive</li> </ul> </li> </ul> </li> <li>ArkSIASecretsService (secrets) - SIA secrets management<ul> <li>ArkSIADBSecretsService (db) - SIA DB secrets services</li> <li>ArkSIAVMSecretsService (vm) - SIA VM secrets services</li> </ul> </li> <li>ArkSIAWorkspacesService (workspaces) - SIA workspaces management<ul> <li>ArkSIADBWorkspaceService (db) - SIA DB workspace management</li> <li>ArkSIATargetSetsWorkspaceService (db) - SIA Target Sets workspace management</li> </ul> </li> </ul>"},{"location":"sdk/services/#session-monitoring-service","title":"Session monitoring service","text":"<p>The Session Monitoring (SM) service requires ArkISPAuth authenticator, and exposes these service classes: - ArkSMService (sm) - Session Monitoring Service</p>"},{"location":"sdk/services/#identity-service","title":"Identity service","text":"<p>The Identity (identity) service requires ArkISPAuth authenticator, and exposes those service classes: - ArkIdentityRolesService - Identity roles service - ArkIdentityUsersService - Identity users service - ArkIdentityPoliciesService - Identity policies service - ArkIdentityDirectoriesService - Identity directories service"},{"location":"sdk/services/#privilege-cloud-service","title":"Privilege Cloud service","text":"<p>The Privilege Cloud (pcloud) service requires ArkISPAuth authenticator, and exposes those service classes: - ArkPCloudAccountsService - Accounts management service - ArkPCloudSafesService - Safes management service - ArkPCloudPlatformsService - Platforms management service</p>"}]}