{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ark SDK","text":"<p>The official Python SDK and CLI for CyberArk's Identity Security Platform Services.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Ark SDK, an API first library, is used to automate different sets of operations in order to ease day to day development. Ark provides a CLI for general purpose automation as well as a Python SDK for code integration.</p>"},{"location":"#tldr","title":"TL;DR","text":""},{"location":"#enduser","title":"Enduser","text":""},{"location":"#admin","title":"Admin","text":""},{"location":"#license","title":"License","text":"<p>This project is licensed under Apache License 2.0 - see <code>LICENSE</code> for more details</p> <p>Copyright (c) 2023 CyberArk Software Ltd. All rights reserved.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>The library is designed as follows:</p> <p></p>"},{"location":"architecture/#design-perspectives","title":"Design Perspectives","text":"<p>The main components are:</p> <ul> <li>Profile: The profile defines a set of properties and information about the user's authentication methods. Profiles are persisted on the filesystem for subsequent actions.</li> <li>Authenticators: The integrations with specific authentication methods, which enable interaction with services. An authentication method can either be Identity (User/Service User) or a custom implementation.</li> <li>Services: The service providing functionality (requires one or more associated authenticators to perform actions). For example, the DPA service exposes DPA APIs in an secure manner.</li> <li>Services Model Schemes The models exposed by a service, which can be used to perform the service's actions.</li> <li>CLI Actions: CLI interface built on the SDK, which provides users with the following shell commands:<ul> <li><code>configure</code>: Configure a profile with authentication details</li> <li><code>login</code>: Log in with a configured profile authenticator</li> <li><code>exec</code>: Execute services actions</li> </ul> </li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>You can install the SDK via PyPI with the following command: <pre><code>pip3 install ark-sdk-python\n</code></pre></p>"},{"location":"getting_started/#cli-usage","title":"CLI Usage","text":"<p>Both the SDK and the CLI support profiles, which can be configured as needed and used for consecutive actions.</p> <p>The CLI has the following basic commands:</p> <ul> <li>configure: Configure profiles and their authentication methods (see Configure)</li> <li>login: Log in using the configured profile authentication methods (see Login)</li> <li>exec: Execute commands for supported services (see Exec)</li> <li>profiles: Manage multiple profiles on the machine (see Profiles)</li> <li>cache: Manage ark cache on the machine (see Cache)</li> </ul>"},{"location":"getting_started/#basic-flow","title":"Basic flow","text":"<ol> <li> <p>Install Ark SDK and then configure a profile (either silently or interactively): <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></p> </li> <li> <p>After the profile is configured, log in:     <pre><code>ark login --silent --isp-secret mysecret\n</code></pre></p> </li> <li> <p>Execute actions (such as generating a short-lived SSO password):     <pre><code>ark exec dpa sso short-lived-password\n</code></pre></p> </li> </ol>"},{"location":"license/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <pre><code> APPENDIX: How to apply the Apache License to your work.\n\n  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"{}\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright \u00a9 2023 CyberArk Software Ltd</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"commands/cache/","title":"Cache","text":"<p>Use the <code>cache</code> command to manage the Ark data cached on your machine. Currently, you can only clear the filesystem cache (not data cached in the OS's keystore). </p>"},{"location":"commands/cache/#running","title":"Running","text":"<pre><code>ark cache\n</code></pre>"},{"location":"commands/cache/#usage","title":"Usage","text":"<pre><code>usage: ark cache [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}] [-dcv] [-tc TRUSTED_CERT] {clear} ...\n\npositional arguments:\n  {clear}\n    clear               Clears all profiles cache\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n</code></pre>"},{"location":"commands/configure/","title":"Configure command","text":"<p>The <code>configure</code> command is used to create a profile. Profiles define user and authentication information, such as which authentication methods to use, the method settings, and other information like MFA.</p> <p>Profiles are saved in the <code>~/.ark_profiles</code> folder.</p>"},{"location":"commands/configure/#run","title":"Run","text":"<pre><code>ark configure\n</code></pre> <p>When you run the command without arguments, you are prompted for the required information (alternatively, add the <code>--silent</code> flag with the required arguments).</p>"},{"location":"commands/configure/#usage","title":"Usage","text":"<pre><code>usage: ark configure [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                     [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-pd PROFILE_DESCRIPTION] [-wwis]\n                     [-isam {identity,identity_service_user}] [-iu ISP_USERNAME]\n                     [-iimm {pf,sms,email,otp}] [-iiu ISP_IDENTITY_URL]\n                     [-iiaa ISP_IDENTITY_AUTHORIZATION_APPLICATION]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name for storage\n  -pd PROFILE_DESCRIPTION, --profile-description PROFILE_DESCRIPTION\n                        Info about the profile\n  -wwis, --work-with-isp\n                        Whether to work with Identity Security Platform services\n  -isam {identity,identity_service_user}, --isp-auth-method {identity,identity_service_user}\n  -iu ISP_USERNAME, --isp-username ISP_USERNAME\n                        Username to authenticate with\n  -iimm {pf,sms,email,otp}, --isp-identity-mfa-method {pf,sms,email,otp}\n                        MFA method if mfa is needed\n  -iiu ISP_IDENTITY_URL, --isp-identity-url ISP_IDENTITY_URL\n                        Identity url to use for authentication instead of fqdn resolving\n  -iiaa ISP_IDENTITY_AUTHORIZATION_APPLICATION, --isp-identity-authorization-application ISP_IDENTITY_AUTHORIZATION_APPLICATION\n                        Identity application to authorize once logged in with the service user\n</code></pre>"},{"location":"commands/exec/","title":"Exec","text":"<p>You use the <code>exec</code> command is used to run commands on available services (the available services depend on the authorized user's account).</p>"},{"location":"commands/exec/#dpa-services","title":"DPA services","text":"<p>The following DPA commands are supported:</p> <ul> <li><code>ark exec dpa</code>: Root command for the DBA service<ul> <li><code>policies</code> - Policy management<ul> <li><code>db</code> - DB policies<ul> <li><code>editor</code> - DB policies interactive editor</li> </ul> </li> <li><code>vm</code> - DPA VM policies<ul> <li><code>editor</code> - DPA VM policies interactive editor</li> </ul> </li> </ul> </li> <li><code>certificates</code> - Certificate management</li> <li><code>db</code> - Databases end-user operations</li> <li><code>sso</code> - SSO end-user operations</li> <li><code>secrets</code> - Secrets service<ul> <li><code>db</code> - DB secrets service</li> </ul> </li> <li><code>workspaces</code> - Workspaces management<ul> <li><code>db</code> - DB workspace management</li> </ul> </li> <li><code>k8s</code> - Kubernetes service</li> </ul> </li> </ul> <p>All commands have their own subcommands and respective arguments.</p>"},{"location":"commands/exec/#running","title":"Running","text":"<pre><code>ark exec\n</code></pre>"},{"location":"commands/exec/#usage","title":"Usage","text":"<pre><code>usage: ark exec [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-op OUTPUT_PATH] [-rf REQUEST_FILE]\n                [-rc RETRY_COUNT] [-ra]\n                {dpa} ...\n\npositional arguments:\n  {dpa}\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name to load\n  -op OUTPUT_PATH, --output-path OUTPUT_PATH\n                        Output file to write data to\n  -rf REQUEST_FILE, --request-file REQUEST_FILE\n                        Request file containing the parameters for the exec action\n  -rc RETRY_COUNT, --retry-count RETRY_COUNT\n                        Retry count for execution\n  -ra, --refresh-auth   If possible, will try to refresh the active authentication before running the\n                        actual command\n</code></pre>"},{"location":"commands/login/","title":"Login","text":"<p>The <code>login</code> command is used to authenticate to Ark using the configured profile. When you run the command, you are prompted for the required login information (such as a password and MFA verifications).</p> <p>After you have logged in, the returned access tokens are stored in a secure location on your machine. After the tokens expire, a token refresh maybe attempted (see Refresh token) or a new login is required.</p>"},{"location":"commands/login/#run","title":"Run","text":"<pre><code>ark login\n</code></pre>"},{"location":"commands/login/#usage","title":"Usage","text":"<pre><code>usage: ark login [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                 [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-f] [-nss] [-st] [-ra]\n                 [-isu ISP_USERNAME] [-iss ISP_SECRET]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name to load\n  -f, --force           Whether to force login even thou token has not expired yet\n  -nss, --no-shared-secrets\n                        Do not share secrets between different authenticators with the\n                        same username\n  -st, --show-tokens    Print out tokens as well if not silent\n  -ra, --refresh-auth   If a cache exists, will also try to refresh it\n  -isu ISP_USERNAME, --isp-username ISP_USERNAME\n                        Username to authenticate with to Identity Security Platform\n  -iss ISP_SECRET, --isp-secret ISP_SECRET\n                        Secret to authenticate with to Identity Security Platform\n</code></pre>"},{"location":"commands/profiles/","title":"Profiles","text":"<p>Use the <code>profiles</code> command to manage multiple users and tenants. You can create, copy, modify, and delete profiles for different users and tenant, and to list all existing profiles.</p>"},{"location":"commands/profiles/#running","title":"Running","text":"<pre><code>ark profiles\n</code></pre>"},{"location":"commands/profiles/#usage","title":"Usage","text":"<pre><code>usage: ark profiles [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}] [-dcv] [-tc TRUSTED_CERT]\n                    {list,show,delete,clear,clone,add} ...\n\npositional arguments:\n  {list,show,delete,clear,clone,add}\n    list                List all profiles\n    show                Show a profile\n    delete              Delete a specific profile\n    clear               Clear all profiles\n    clone               Clones a profile\n    add                 Adds a profile to the profiles folder from a given path\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n</code></pre>"},{"location":"examples/commands_examples/","title":"Commands examples","text":"<p>This page lists some useful CLI examples.</p> <p>Note</p> <p>You can disable certificate validation for login to an authenticator using the <code>--disable-certificate-verification</code> flag. This option is not recommended.</p> <p>Useful environment variables</p> <ul> <li><code>ARK_PROFILE</code>: Sets the profile to be used across the CLI</li> <li><code>ARK_DISABLE_CERTIFICATE_VERIFICATION</code>: Disables certificate verification for REST APIs</li> </ul>"},{"location":"examples/commands_examples/#configure-command-example","title":"Configure command example","text":"<p>The <code>configure</code> command works in interactive or silent mode. When using silent mode, the required parameters need to specified. Here's an example of configuring ISP in silent mode:</p> <pre><code>ark configure --profile-name=\"PROD\" --work-with-isp --isp-username=\"tina@cyberark.cloud.12345\" --silent --allow-output\n</code></pre>"},{"location":"examples/commands_examples/#login-commands-example","title":"Login commands Example","text":"<p>The login command can work in interactive or silent mode. Here's an example of a silent login with the profile configured in the example above: <pre><code>ark login -s --isp-secret=CoolPassword\u00df\n</code></pre></p>"},{"location":"examples/commands_examples/#exec-command-examples","title":"Exec command examples","text":"<p>Use the <code>--help</code> flag to view all <code>exec</code> options.</p>"},{"location":"examples/commands_examples/#add-dpa-database-secret","title":"Add DPA database secret","text":"<pre><code>ark exec dpa secrets db add-secret --secret-name mysecret --secret-type username_password --username user --password mypass\n</code></pre>"},{"location":"examples/commands_examples/#delete-dpa-database-secret","title":"Delete DPA database secret","text":"<pre><code>ark exec dpa secrets db delete-secret --secret-name mysecret\n</code></pre>"},{"location":"examples/commands_examples/#add-dpa-database","title":"Add DPA database","text":"<pre><code>ark exec dpa workspaces db add-database --name mydb --provider-engine postgres-sh --read-write-endpoint myendpoint.domain.com\n</code></pre>"},{"location":"examples/commands_examples/#list-dpa-databases","title":"List DPA databases","text":"<pre><code>ark exec dpa workspaces db list-databases\n</code></pre>"},{"location":"examples/commands_examples/#get-vm-policies-stats","title":"Get VM policies stats","text":"<pre><code>ark exec dpa policies vm policies-stats\n</code></pre>"},{"location":"examples/commands_examples/#edit-policies-interactively-example","title":"Edit policies interactively example","text":"<p>This example shows how to locally work with a policies workspace, and edit, reset, and create policies that are applied to both databases and VM policies. After the local policies are ready, you can commit all the policies changes to the remote workspace.</p> <p>To load and reload policies locally:</p> <pre><code>ark exec dpa policies vm editor load-policies\n</code></pre> <p>After loading the policies, use these commands to edit them: <pre><code>ark exec dpa policies vm editor edit-policies\nark exec dpa policies vm editor view-policies\nark exec dpa policies vm editor reset-policies\nark exec dpa policies vm editor generate-policy\nark exec dpa policies vm editor remove-policies\nark exec dpa policies vm editor policies diff\n</code></pre></p> <p>When they are ready to be committed, run: <pre><code>ark exec dpa policies vm editor commit-policies\n</code></pre></p>"},{"location":"examples/commands_examples/#generate-a-short-lived-sso-password-for-a-database-connection","title":"Generate a short-lived SSO password for a database connection","text":"<pre><code>ark exec dpa sso short-lived-password\n</code></pre>"},{"location":"examples/commands_examples/#generate-a-short-lived-sso-oracle-wallet-for-an-oracle-database-connection","title":"Generate a short-lived SSO Oracle wallet for an Oracle database connection","text":"<pre><code>ark exec dpa sso short-lived-oracle-wallet --folder ~/wallet\n</code></pre>"},{"location":"examples/commands_examples/#generate-a-kubectl-config-file","title":"Generate a kubectl config file","text":"<pre><code>ark exec dpa k8s generate-kubeconfig \n</code></pre>"},{"location":"examples/commands_examples/#generate-a-kubectl-config-file-and-save-it-in-the-specified-path","title":"Generate a kubectl config file and save it in the specified path","text":"<pre><code>ark exec dpa k8s generate-kubeconfig --folder=/Users/My.User/.kube\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-monitoring-sessions-from-the-last-24-hours","title":"List All Session Monitoring sessions from the last 24 hours","text":"<pre><code>ark exec sm list-sessions\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-monitoring-sessions-from-the-last-24-hours","title":"Count All Session Monitoring sessions from the last 24 hours","text":"<pre><code>ark exec sm count-sessions\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-monitoring-sessions-matching-search-query","title":"List All Session Monitoring sessions matching Search Query","text":"<pre><code>ark exec sm list-sessions-by --search 'startTime ge 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01 AND protocol IN SSH,RDP,Database'\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-monitoring-sessions-matching-search-query","title":"Count All Session Monitoring sessions matching Search Query","text":"<pre><code>ark exec sm count-sessions-by --search 'startTime ge 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01 AND protocol IN SSH,RDP,Database'\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-monitoring-sessions-from-the-last-24-hours_1","title":"Count All Session Monitoring sessions from the last 24 hours","text":"<pre><code>ark exec sm count-sessions\n</code></pre>"},{"location":"examples/commands_examples/#retrieve-a-session-by-id","title":"Retrieve a session by id","text":"<pre><code>ark exec sm session --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-activities","title":"List all session activities","text":"<pre><code>ark exec sm list-session-activities --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-activities","title":"Count all session activities","text":"<pre><code>ark exec sm count-session-activities --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d\n</code></pre>"},{"location":"examples/commands_examples/#list-all-session-activities-with-specific-command","title":"List all session activities with specific command","text":"<pre><code>ark exec sm list-session-activities-by --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d --command-contains 'ls'\n</code></pre>"},{"location":"examples/commands_examples/#count-all-session-activities-with-specific-command","title":"Count all session activities with specific command","text":"<pre><code>ark exec sm count-session-activities-by --session-id 5e62bdb8-cd81-42b8-ac72-1e06bf9c496d --command-contains 'ls'\n</code></pre>"},{"location":"examples/commands_examples/#display-general-sessions-statistics-from-the-last-30-days","title":"Display general sessions statistics from the last 30 days","text":"<pre><code>ark exec sm sessions-stats\n</code></pre>"},{"location":"examples/sdk_examples/","title":"SDK examples","text":"<p>This page lists some useful SDK examples.</p>"},{"location":"examples/sdk_examples/#authenticate-and-read-tenant-db-policies","title":"Authenticate and read tenant DB policies","text":"<pre><code>from ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.auth import ArkSecret, ArkAuthMethod, ArkAuthProfile, IdentityArkAuthMethodSettings\nfrom ark_sdk_python.services.dpa.policies.db import ArkDPADBPoliciesService\n\nif __name__ == \"__main__\":\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='tina@cyberark.cloud.12345', auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n    db_policies_service = ArkDPADBPoliciesService(isp_auth)\n    policies = db_policies_service.list_policies()\n</code></pre>"},{"location":"examples/sdk_examples/#authenticate-and-provision-dpa-databases-and-policy","title":"Authenticate and provision DPA databases and policy","text":"<pre><code>if __name__ == '__main__':\n    ArkSystemConfig.disable_verbose_logging()\n    # Authenticate to the tenant with an auth profile to configure DPA\n    username = 'user@cyberark.cloud.12345'\n    print(f'Authenticating to the created tenant with user [{username}]')\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n\n    # Create DPA DB Secret, Database, Connector and DB Policy\n    dpa_service = ArkDPAAPI(isp_auth)\n    print('Adding DPA DB User Secret')\n    secret = dpa_service.secrets_db.add_secret(\n        ArkDPADBAddSecret(secret_type=ArkDPADBSecretType.UsernamePassword, username='Administrator', password='CoolPassword')\n    )\n    print('Adding DPA Database')\n    dpa_service.workspace_db.add_database(\n        ArkDPADBAddDatabase(\n            name='mydomain.com',\n            provider_engine=ArkDPADBDatabaseEngineType.PostgresSH,\n            secret_id=secret.secret_id,\n            read_write_endpoint=\"myendpoint.mydomain.com\",\n        )\n    )\n    print('Adding DPA DB Policy')\n    dpa_service.policies_db.add_policy(\n        ArkDPADBAddPolicy(\n            policy_name='IT Policy',\n            status=ArkDPARuleStatus.Active,\n            description='IT Policy',\n            providers_data=ArkDPADBProvidersData(\n                postgres=ArkDPADBPostgres(\n                    resources=['postgres-onboarded-asset'],\n                ),\n            ),\n            user_access_rules=[\n                ArkDPADBAuthorizationRule(\n                    rule_name='IT Rule',\n                    user_data=ArkDPAUserData(roles=['DpaAdmin'], groups=[], users=[]),\n                    connection_information=ArkDPADBConnectionInformation(\n                        grant_access=2,\n                        idle_time=10,\n                        full_days=True,\n                        hours_from='07:00',\n                        hours_to='17:00',\n                        time_zone='Asia/Jerusalem',\n                        connect_as=ArkDPADBConnectAs(\n                            db_auth=[\n                                ArkDPADBLocalDBAuth(\n                                    roles=['rds_superuser'],\n                                    applied_to=[\n                                        ArkDPADBAppliedTo(\n                                            name='postgres-onboarded-asset',\n                                            type=ArkDPADBResourceIdentifierType.RESOURCE,\n                                        )\n                                    ],\n                                ),\n                            ],\n                        ),\n                    ),\n                )\n            ],\n        )\n    )\n</code></pre>"},{"location":"examples/sdk_examples/#authenticate-and-provision-dpa-vm-policies","title":"Authenticate and provision DPA VM policies","text":"<pre><code>    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n    print('Adding DPA Policy')\n    dpa_service.policies.add_policy(\n        ArkDPAVMAddPolicy(\n            policy_name='IT Policy',\n            description='IT Policy',\n            status=ArkDPARuleStatus.Enabled,\n            providers_data={\n                ArkWorkspaceType.AWS: ArkDPAVMAWSProviderData(\n                    account_ids=['965428623928'], tags=[{'key': 'team', 'value': 'IT'}], regions=[], vpc_ids=[]\n                )\n            },\n            user_access_rules=[\n                ArkDPAVMAuthorizationRule(\n                    rule_name='IT Rule',\n                    user_data=ArkDPAUserData(roles=['IT']),\n                    connection_information=ArkDPAVMConnectionInformation(\n                        full_days=True,\n                        days_of_week=[],\n                        time_zone='Asia/Jerusalem',\n                        connect_as={\n                            ArkWorkspaceType.AWS: {\n                                ArkProtocolType.SSH: 'root',\n                                ArkProtocolType.RDP: ArkDPAVMRDPLocalEphemeralUserConnectionData(\n                                    local_ephemeral_user=ArkDPAVMLocalEphemeralUserConnectionMethodData(assign_groups={'Administrators'})\n                                ),\n                            }\n                        },\n                    ),\n                )\n            ],\n        )\n    )\n</code></pre>"},{"location":"examples/sdk_examples/#view-session-monitoring-sessions-and-activities-per-session","title":"View Session Monitoring Sessions And Activities Per Session","text":"<pre><code>    from ark_sdk_python.services.sm import ArkSMService\n    from ark_sdk_python.models.services.sm import ArkSMSessionsFilter, ArkSMGetSession, ArkSMGetSessionActivities\n    from ark_sdk_python.models.ark_profile import ArkProfileLoader\n    from ark_sdk_python.models.common import ArkProtocolType\n    from ark_sdk_python.auth import ArkISPAuth\n    from datetime import datetime, timedelta\n    if __name__ == \"__main__\":\n        isp_auth = ArkISPAuth()\n        isp_auth.authenticate(\n            profile=ArkProfileLoader().load_default_profile()\n        )\n        sm: ArkSMService = ArkSMService(isp_auth)\n        search_by = 'startTime ge {start_time_from} AND sessionDuration GE {min_duration} AND protocol IN {protocols}'\n        search_by = search_by.format(\n            start_time_from=(datetime.utcnow() - timedelta(days=30)).isoformat(timespec='seconds'),\n            min_duration='00:00:01',\n            protocols=','.join([ArkProtocolType.DB[0], ArkProtocolType.SSH[0], ArkProtocolType.RDP[0]]),\n        )\n        sessions_filter = ArkSMSessionsFilter(\n            search=search_by,\n        )\n        print(f'session_count = {sm.count_sessions_by(sessions_filter)}')\n        for s_page in sm.list_sessions_by(sessions_filter):\n            for session in s_page.items:\n                session = sm.session(ArkSMGetSession(session_id=session.session_id))\n                get_session_activities = ArkSMGetSessionActivities(session_id=session.session_id)\n                print(f'session = {session}, activities_count = {sm.count_session_activities(get_session_activities)}')\n                session_activities = [activity for page in sm.list_session_activities(get_session_activities) for activity in page.items]\n                print(session_activities)\n</code></pre>"},{"location":"howto/enduser_databases_workflow/","title":"End-user database Workflow","text":"<p>Here is an example workflow for connecting to a database:</p> <ol> <li>Install Ark SDK: <code>pip3 install ark-sdk-python</code></li> <li>Create a profile:  <ul> <li>Interactively:     <pre><code>ark configure\n</code></pre></li> <li>Silently:     <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></li> </ul> </li> <li>Log in to Ark:     <pre><code>ark login --silent --isp-secret &lt;my-ark-secret&gt;\n</code></pre></li> <li>Get a short-lived SSO password for a database from the DPA service:     <pre><code>ark exec dpa sso short-lived-password\n</code></pre></li> <li>One of these:<ul> <li>Log in directly to the database:     <pre><code>psql \"host=mytenant.postgres.cyberark.cloud user=user@cyberark.cloud.12345@postgres@mypostgres.fqdn.com\"\n</code></pre></li> <li>Log in to the database from Ark:     <pre><code>ark exec dpa db psql --target-username postgres --target-address mypostgres.fqdn.com\n</code></pre></li> </ul> </li> </ol>"},{"location":"howto/enduser_kubernetes_workflow/","title":"End-user Kubernetes workflow","text":"<p>To securely access a Kubernetes cluster, do the following:</p> <ol> <li>If required, install the Ark SDK (<code>pip3 install ark-sdk-python</code>).</li> <li>Configure a profile:<ul> <li>Interactively:     <pre><code>ark configure\n</code></pre></li> <li>Silently:     <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></li> </ul> </li> <li>Log in to Ark:     <pre><code>ark login --silent --isp-secret &lt;my-ark-secret&gt;\n</code></pre></li> <li>To generate a kubectl kubeconfig file, which defines the user's permissions and accessible clusters, do one of the following:<ul> <li>Run this command:     <pre><code>ark exec dpa k8s generate-kubeconfig\n</code></pre></li> <li>Use the <code>-f</code> flag to generate the config file in the specified path (this option overrides existing files with the same name):     <pre><code>ark exec dpa k8s generate-kubeconfig -f ~/.kube\n</code></pre></li> </ul> </li> </ol>"},{"location":"howto/enduser_kubernetes_workflow/#refresh-sso-certificate-workflow","title":"Refresh SSO certificate workflow","text":"<p>When you refresh the certificate, you can keep using its associated kubeconfig file and only need to refresh the MFA authentication data. To refresh the certificate, run one of the following:</p> <ul> <li>To generate two files (certificate and private key files), where the required <code>-f</code> flag defines the generated files' location:     <pre><code>ark exec dpa sso short-lived-client-certificate -of file -f ~/home\n</code></pre></li> <li>To print the certificate and private key to the console as plaintext:     <pre><code>ark exec dpa sso short-lived-client-certificate -of raw\n</code></pre></li> <li>To print the certificate and private key to the console as base64-encoded strings:     <pre><code>ark ark exec dpa sso short-lived-client-certificate -of base64\n</code></pre></li> </ul>"},{"location":"howto/refreshing_authentication/","title":"Refresh authentication","text":"<p>When you want to continue working with an existing authenticator, you can refresh the authentications. You can refresh authentications for the following:</p> <ul> <li>The login command</li> <li>The exec command</li> <li>Polling operations</li> <li>Via the SDK code</li> </ul>"},{"location":"howto/refreshing_authentication/#login-command","title":"Login command","text":"<p>To try to authenticate with an existing authenticator, use the <code>-ra</code>or <code>--refresh-auth</code> CLI flag: <pre><code>ark login -ra\n</code></pre> The <code>-ra</code> flag indicates that the user's profile authenticator should be refreshed and used for authentication. The user is only prompted for additional authentication values when the refresh fails.</p>"},{"location":"howto/refreshing_authentication/#exec-command","title":"Exec command","text":"<p>To try to run any command with an existing authenticator, use the <code>-ra</code>or -<code>-refresh-auth</code> CLI flag: <pre><code>ark exec -ra dpa policies list-policies\n</code></pre></p> <p>The <code>-ra</code> flag indicates that the user's profile authenticator should be refreshed and used before executing the command. When the refresh fails, an error is returned and you must log in again.</p>"},{"location":"howto/refreshing_authentication/#polling-operations","title":"Polling operations","text":"<p>When polling any async command, a timeout can occur before the polling operation finishes. To try and overcome these timeouts, you can enable automatic authentication refreshes for polling operations.</p> <p>When refreshed are configured, if an unauthorized (<code>401</code>) response is returned, Ark refreshes the authenticator before the next poll. When the refresh fails, a timeout error is reported in the CLI. </p> <p>To enable refreshes, use the <code>-parc</code> or <code>--poll-allow-refresh-connection</code> CLI flag.</p>"},{"location":"howto/refreshing_authentication/#sdk","title":"SDK","text":"<p>When using the SDK, use the <code>load_authentication</code> method to attempt using a cached authenticator (with a refresh if required): <pre><code>isp_auth = ArkISPAuth()\nisp_auth.authenticate(\n    auth_profile=ArkAuthProfile(\n        username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n    ),\n    secret=ArkSecret(secret='CoolPassword'),\n)\n...\nisp_auth.load_authentication(refresh_auth=True)\n</code></pre></p>"},{"location":"howto/simple_commands_workflow/","title":"Simple commands workflow","text":"<p>Here's an example of how to:</p> <ol> <li>Configure a profile for logging in to a tenant</li> <li>Log in to the tenant</li> <li>Run a DPA action to configure a database secret and policy</li> </ol>"},{"location":"howto/simple_commands_workflow/#configure-profile-and-log-in","title":"Configure profile and log in","text":"<pre><code>ark configure --work-with-isp --isp-username=username\nark login -s --isp-secret=secret\n</code></pre>"},{"location":"howto/simple_commands_workflow/#configure-a-database-secret-and-policy","title":"Configure a database secret and policy","text":"<pre><code>ark exec dpa secrets db add-secret -sn name -st username_password -u user -pa coolpassword\nark exec dpa workspaces db add-database -n somedb -pe postgres-sh -rwe myendpoint.domain.com\nark exec dpa policies db editor generate-policy\n</code></pre>"},{"location":"howto/simple_sdk_workflow/","title":"Simple SDK workflow","text":"<p>This example shows how to create, with a Python script, a demo environment that contains the required DPA DB assets:</p> <pre><code>ArkSystemConfig.disable_verbose_logging()\n# Authenticate to the tenant with an auth profile to configure DPA\nprint(f'Authenticating to the created tenant with user [{username}]')\nisp_auth = ArkISPAuth()\nisp_auth.authenticate(auth_profile=ArkAuthProfile(\n    username='user@cyberark.cloud.12345',\n    auth_method=ArkAuthMethod.Identity,\n    auth_method_settings=IdentityArkAuthMethodSettings()\n), secret=ArkSecret(secret='CoolPassword'))\n\n# Create DPA DB secret, database, connector, and DB policy\ndpa_service = ArkDPAAPI(isp_auth)\nprint('Adding DPA DB User Secret')\nsecret = dpa_service.secrets_db.add_secret(ArkDPADBAddSecret(\n    secret_type=ArkDPADBSecretType.UsernamePassword,\n    username='Administrator',\n    password='CoolPassword'\n))\nprint('Adding DPA Database')\ndpa_service.workspace_db.add_database(ArkDPADBAddDatabase(\n    name='mydomain.com',\n    provider_engine=ArkDPADBDatabaseEngineType.PosgresSH,\n    secret_id=secret.secret_id,\n    read_write_endpoint=\"myendpoint.mydomain.com\"\n))\nprint('Adding DPA DB Policy')\ndpa_service.policies_db.add_policy(\n    ArkDPADBAddPolicy(\n        policy_name='IT Policy',\n        status=ArkDPARuleStatus.Active,\n        description='IT Policy',\n        providers_data=ArkDPADBProvidersData(\n            postgres=ArkDPADBPostgres(\n                resources=['postgres-onboarded-asset'],\n            ),\n        ),\n        user_access_rules=[\n            ArkDPADBAuthorizationRule(\n                rule_name='IT Rule',\n                user_data=ArkDPAUserData(roles=['DpaAdmin'], groups=[], users=[]),\n                connection_information=ArkDPADBConnectionInformation(\n                    grant_access=2,\n                    idle_time=10,\n                    full_days=True,\n                    hours_from='07:00',\n                    hours_to='17:00',\n                    time_zone='Asia/Jerusalem',\n                    connect_as=ArkDPADBConnectAs(\n                        db_auth=[\n                            ArkDPADBLocalDBAuth(\n                                roles=['rds_superuser'],\n                                applied_to=[\n                                    ArkDPADBAppliedTo(\n                                        name='postgres-onboarded-asset',\n                                        type=ArkDPADBResourceIdentifierType.RESOURCE,\n                                    )\n                                ],\n                            ),\n                        ],\n                    ),\n                ),\n            )\n        ],\n    )\n)\nprint('Finished Successfully')\n</code></pre> <p>In the script above, the following actions are defined:</p> <ul> <li>The admin user is logged in to perform actions on the tenant (lines 4-9)</li> <li>The DPA's secret, database, and policy are configured (lines 12-65)</li> </ul>"},{"location":"howto/working_with_ark_cache/","title":"Work with Ark cache","text":"<p>Both the CLI and SDK cache login information in the local machine's keystore or, when a keystore does not exist, in an encrypted folder (located in <code>$HOME/.ark_cache</code>). The cached information is used to run commands until the authentication tokens expire or are otherwise invalided.</p> <p>You can set the cache folder with the <code>ARK_KEYRING_FOLDER</code> env variable. To force Ark SDK to work only with the filesystem cache, use the <code>ARK_BASIC_KEYRING</code> environment variable</p> <p>If you want to ignore the cache when logging in, use the <code>-f</code> flag: <pre><code>ark login -f\n</code></pre></p> <p>Also, you can disable caching in the SDK: <pre><code>isp_auth = ArkISPAuth(cache_authentication=False)\n</code></pre></p> <p>To clear the cache, run <code>ark cache clear</code> or, when using an encrypted folder, remove the files from the <code>$HOME/.ark_cache</code> folder.</p>"},{"location":"howto/working_with_profiles/","title":"Work with profiles","text":"<p>Profiles define authentication methods for users. They are used with the CLI and, to a lesser extent, the SDK. Different profiles can be created and configured via the Ark <code>configure</code> command.</p> <p>You can specify which profile a command uses with the <code>--profile-name</code> flag or setting the <code>ARK_PROFILE</code> environment variable.</p> <p>Profiles are stored as JSON files in the <code>$HOME/.ark_profiles</code> folder.</p> <p>Note</p> <p>When There are multiple profiles configured, if profile is not specified explicitly in the command via --profile-name or ARK_PROFILE environment variable not set, the default profile called \"ark\" will be used.</p> <p>Here is an example profile file:</p> <pre><code>{\n    \"profile_name\": \"ark\",\n    \"profile_description\": \"Default Ark Profile\",\n    \"auth_profiles\": {\n        \"isp\": {\n            \"username\": \"tina@cyberark.cloud.1234567\",\n            \"auth_method\": \"identity\",\n            \"auth_method_settings\": {\n                \"identity_mfa_method\": \"email\",\n                \"identity_mfa_interactive\": true,\n                \"identity_application\": null,\n                \"identity_url\": null\n            }\n        }\n    }\n}\n</code></pre> <p>As well as using the CLI to manage profiles, you can create, modify, and delete profiles directly in the <code>$HOME/.ark_profiles</code> folder.</p>"},{"location":"reference/","title":".","text":""},{"location":"reference/#ark_sdk_python.ArkAPI","title":"<code>ArkAPI</code>","text":"Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>class ArkAPI:\n    def __init__(self, authenticators: List[ArkAuth], profile: Optional[ArkProfile] = None) -&gt; None:\n        self.__authenticators = authenticators\n        self.__lazy_loaded_services: Dict[str, ArkService] = {}\n        self.__profile = profile or ArkProfileLoader.load_default_profile()\n\n    def __lazy_load_service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        service_name = service_type.service_config().service_name\n        required_auth_names = service_type.service_config().required_authenticator_names\n        required_autheneticators = [auth for auth in self.__authenticators if auth.authenticator_name() in required_auth_names]\n        optional_authenticators = [\n            auth\n            for auth in self.__authenticators\n            if auth.authenticator_name() in service_type.service_config().optional_authenticator_names\n        ]\n        if len(required_autheneticators) == len(required_auth_names):\n            authenticators = {f'{a.authenticator_name()}_auth': a for a in required_autheneticators + optional_authenticators}\n            self.__lazy_loaded_services[service_name] = service_type(**authenticators)\n        else:\n            raise ArkServiceException(\n                f'{service_name.title()} is not supported or missing fitting authenticators, please make sure you are logged in'\n            )\n        return self.__lazy_loaded_services[service_name]\n\n    def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Returns the specified authenticator.\n\n        Args:\n            authenticator_name (str): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.__authenticators:\n            if auth.authenticator_name() == authenticator_name:\n                return auth\n        raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n\n    def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        \"\"\"\n        Returns the specified service when the appropriate authenticators were provided.\n\n        Args:\n            service_type (Type[ArkService]): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkService: _description_\n        \"\"\"\n        if not issubclass(service_type, ArkService):\n            raise ArkServiceException(f\"Type {service_type} is invalid\")\n        service_name = service_type.service_config().service_name\n        if service_name in self.__lazy_loaded_services:\n            return self.__lazy_loaded_services[service_name]\n        return self.__lazy_load_service(service_type)\n\n    @property\n    def profile(self) -&gt; ArkProfile:\n        \"\"\"\n        Gets the API profile\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        return self.__profile\n\n    @property\n    def dpa_workspaces_db(self) -&gt; \"ArkDPADBWorkspaceService\":\n        \"\"\"\n        Returns the DPA DB Workspace service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.workspaces.db import ArkDPADBWorkspaceService\n\n        return cast(ArkDPADBWorkspaceService, self.service(ArkDPADBWorkspaceService))\n\n    @property\n    def dpa_policies_vm(self) -&gt; \"ArkDPAVMPoliciesService\":\n        \"\"\"\n        Returns the DPA VM Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPAVMPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.vm import ArkDPAVMPoliciesService\n\n        return cast(ArkDPAVMPoliciesService, self.service(ArkDPAVMPoliciesService))\n\n    @property\n    def dpa_policies_db(self) -&gt; \"ArkDPADBPoliciesService\":\n        \"\"\"\n        Returns the DPA DB Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.db import ArkDPADBPoliciesService\n\n        return cast(ArkDPADBPoliciesService, self.service(ArkDPADBPoliciesService))\n\n    @property\n    def dpa_secrets_db(self) -&gt; \"ArkDPADBSecretsService\":\n        \"\"\"\n        Returns the DPA DB Secrets service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.secrets.db import ArkDPADBSecretsService\n\n        return cast(ArkDPADBSecretsService, self.service(ArkDPADBSecretsService))\n\n    @property\n    def dpa_sso(self) -&gt; \"ArkDPASSOService\":\n        \"\"\"\n        Returns the DPA sso service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.sso import ArkDPASSOService\n\n        return cast(ArkDPASSOService, self.service(ArkDPASSOService))\n\n    @property\n    def dpa_db(self) -&gt; \"ArkDPADBService\":\n        \"\"\"\n        Returns the DPA DB service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.db import ArkDPADBService\n\n        return cast(ArkDPADBService, self.service(ArkDPADBService))\n\n    @property\n    def dpa_certificates(self) -&gt; \"ArkDPACertificatesService\":\n        \"\"\"\n        Returns DPA certificates service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.certificates import ArkDPACertificatesService\n\n        return cast(ArkDPACertificatesService, self.service(ArkDPACertificatesService))\n\n    @property\n    def dpa_k8s(self) -&gt; \"ArkDPAK8SService\":\n        \"\"\"\n        Returns the DPA Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.k8s import ArkDPAK8SService\n\n        return cast(ArkDPAK8SService, self.service(ArkDPAK8SService))\n\n    @property\n    def sm(self) -&gt; \"ArkSMService\":\n        \"\"\"\n        Returns the SM service if the appropriate authenticators were given\n\n        Returns:\n            ArkSMService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sm import ArkSMService\n\n        return cast(ArkSMService, self.service(ArkSMService))\n</code></pre>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_certificates","title":"<code>dpa_certificates: 'ArkDPACertificatesService'</code>  <code>property</code>","text":"<p>Returns DPA certificates service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>'ArkDPACertificatesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_db","title":"<code>dpa_db: 'ArkDPADBService'</code>  <code>property</code>","text":"<p>Returns the DPA DB service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>'ArkDPADBService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_k8s","title":"<code>dpa_k8s: 'ArkDPAK8SService'</code>  <code>property</code>","text":"<p>Returns the DPA Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>'ArkDPAK8SService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_policies_db","title":"<code>dpa_policies_db: 'ArkDPADBPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>'ArkDPADBPoliciesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_policies_vm","title":"<code>dpa_policies_vm: 'ArkDPAVMPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA VM Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesService</code> <code>'ArkDPAVMPoliciesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_secrets_db","title":"<code>dpa_secrets_db: 'ArkDPADBSecretsService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Secrets service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>'ArkDPADBSecretsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_sso","title":"<code>dpa_sso: 'ArkDPASSOService'</code>  <code>property</code>","text":"<p>Returns the DPA sso service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>'ArkDPASSOService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_workspaces_db","title":"<code>dpa_workspaces_db: 'ArkDPADBWorkspaceService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Workspace service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>'ArkDPADBWorkspaceService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.profile","title":"<code>profile: ArkProfile</code>  <code>property</code>","text":"<p>Gets the API profile</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.sm","title":"<code>sm: 'ArkSMService'</code>  <code>property</code>","text":"<p>Returns the SM service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkSMService</code> <code>'ArkSMService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.authenticator","title":"<code>authenticator(authenticator_name)</code>","text":"<p>Returns the specified authenticator.</p> <p>Parameters:</p> Name Type Description Default <code>authenticator_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Returns the specified authenticator.\n\n    Args:\n        authenticator_name (str): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.__authenticators:\n        if auth.authenticator_name() == authenticator_name:\n            return auth\n    raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n</code></pre>"},{"location":"reference/#ark_sdk_python.ArkAPI.service","title":"<code>service(service_type)</code>","text":"<p>Returns the specified service when the appropriate authenticators were provided.</p> <p>Parameters:</p> Name Type Description Default <code>service_type</code> <code>Type[ArkService]</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkService</code> <code>ArkService</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n    \"\"\"\n    Returns the specified service when the appropriate authenticators were provided.\n\n    Args:\n        service_type (Type[ArkService]): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkService: _description_\n    \"\"\"\n    if not issubclass(service_type, ArkService):\n        raise ArkServiceException(f\"Type {service_type} is invalid\")\n    service_name = service_type.service_config().service_name\n    if service_name in self.__lazy_loaded_services:\n        return self.__lazy_loaded_services[service_name]\n    return self.__lazy_load_service(service_type)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>.</li> <li>actions<ul> <li>ark_action</li> <li>ark_cache_action</li> <li>ark_configure_action</li> <li>ark_exec_action</li> <li>ark_login_action</li> <li>ark_profiles_action</li> <li>ark_service_exec_action</li> </ul> </li> <li>args<ul> <li>ark_args_formatter</li> <li>ark_pydantic_argparse</li> </ul> </li> <li>ark</li> <li>ark_api</li> <li>auth<ul> <li>ark_auth</li> <li>ark_isp_auth</li> <li>identity<ul> <li>ark_identity</li> <li>ark_identity_fqdn_resolver</li> <li>ark_identity_service_user</li> </ul> </li> </ul> </li> <li>cli_services<ul> <li>ark_cli_api</li> <li>dpa<ul> <li>common<ul> <li>ark_dpa_base_policies_editor_service</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_policies_editor_service</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_policies_editor_service</li> </ul> </li> </ul> </li> </ul> </li> <li>common<ul> <li>ark_async_client</li> <li>ark_async_request</li> <li>ark_client</li> <li>ark_keyring</li> <li>ark_logger</li> <li>ark_page</li> <li>ark_pollers</li> <li>ark_random_utils</li> <li>ark_system_config</li> <li>env<ul> <li>ark_env_mapping</li> </ul> </li> <li>isp<ul> <li>ark_isp_service_client</li> </ul> </li> </ul> </li> <li>models<ul> <li>actions<ul> <li>ark_configure_action_consts</li> <li>ark_service_action_definition</li> <li>services<ul> <li>ark_dpa_exec_action_consts</li> <li>ark_sm_exec_action_consts</li> </ul> </li> </ul> </li> <li>ark_exceptions</li> <li>ark_model</li> <li>ark_profile</li> <li>auth<ul> <li>ark_auth_method</li> <li>ark_auth_profile</li> <li>ark_secret</li> <li>ark_token</li> </ul> </li> <li>cli_services<ul> <li>dpa<ul> <li>policies_editor<ul> <li>common<ul> <li>ark_dpa_base_generate_policy</li> <li>ark_dpa_commit_policies</li> <li>ark_dpa_edit_policies</li> <li>ark_dpa_get_policies_status</li> <li>ark_dpa_load_policies</li> <li>ark_dpa_loaded_policies</li> <li>ark_dpa_policies_diff</li> <li>ark_dpa_policies_status</li> <li>ark_dpa_remove_policies</li> <li>ark_dpa_reset_policies</li> <li>ark_dpa_view_policies</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_generate_policy</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_generate_policy</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>common<ul> <li>ark_access_method</li> <li>ark_application_code</li> <li>ark_async_request_settings</li> <li>ark_async_status</li> <li>ark_async_task</li> <li>ark_connection_method</li> <li>ark_connector_type</li> <li>ark_counted_values</li> <li>ark_network_entity_type</li> <li>ark_os_type</li> <li>ark_protocol_type</li> <li>ark_region</li> <li>ark_status</li> <li>ark_status_stats</li> <li>ark_validations</li> <li>ark_workspace_type</li> <li>aws<ul> <li>ark_cfn_async_task</li> </ul> </li> <li>connections<ul> <li>ark_connection_command</li> <li>ark_connection_credentials</li> <li>ark_connection_details</li> <li>ark_connection_result</li> <li>connection_data<ul> <li>ark_ssh_connection_data</li> <li>ark_winrm_connection_data</li> </ul> </li> </ul> </li> <li>identity<ul> <li>ark_identity_auth_schemas</li> <li>ark_identity_common_schemas</li> <li>ark_identity_directory_schemas</li> </ul> </li> <li>isp<ul> <li>ark_platform_discovery_schemas</li> </ul> </li> </ul> </li> <li>services<ul> <li>ark_service_config</li> <li>dpa<ul> <li>certificates<ul> <li>ark_dpa_certificates_certificate</li> <li>ark_dpa_certificates_delete_certificate</li> <li>ark_dpa_certificates_filter</li> <li>ark_dpa_certificates_get_certificate</li> <li>ark_dpa_certificates_update_certificate</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_base_execution</li> <li>ark_dpa_db_base_generate_assets</li> <li>ark_dpa_db_generated_assets</li> <li>ark_dpa_db_mysql_execution</li> <li>ark_dpa_db_oracle_generate_assets</li> <li>ark_dpa_db_psql_execution</li> </ul> </li> <li>k8s<ul> <li>ark_dpa_k8s_generate_kubeconfig</li> </ul> </li> <li>policies<ul> <li>common<ul> <li>ark_dpa_base_add_policy</li> <li>ark_dpa_base_authorization_rule</li> <li>ark_dpa_base_connection_information</li> <li>ark_dpa_base_policies_filter</li> <li>ark_dpa_base_policies_stats</li> <li>ark_dpa_base_policy</li> <li>ark_dpa_base_policy_list_item</li> <li>ark_dpa_base_update_policy</li> <li>ark_dpa_delete_policy</li> <li>ark_dpa_get_policy</li> <li>ark_dpa_rule_status</li> <li>ark_dpa_update_policy_status</li> <li>ark_dpa_user_data</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_add_policy</li> <li>ark_dpa_db_authorization_rule</li> <li>ark_dpa_db_connection_data</li> <li>ark_dpa_db_policies_filter</li> <li>ark_dpa_db_policies_stats</li> <li>ark_dpa_db_policies_workspace_type_serializer</li> <li>ark_dpa_db_policy</li> <li>ark_dpa_db_policy_list_item</li> <li>ark_dpa_db_providers</li> <li>ark_dpa_db_update_policy</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_add_policy</li> <li>ark_dpa_vm_authorization_rule</li> <li>ark_dpa_vm_connection_data</li> <li>ark_dpa_vm_policies_filter</li> <li>ark_dpa_vm_policies_protocol_type_serializer</li> <li>ark_dpa_vm_policies_stats</li> <li>ark_dpa_vm_policies_workspace_type_serializer</li> <li>ark_dpa_vm_policy</li> <li>ark_dpa_vm_policy_list_item</li> <li>ark_dpa_vm_providers</li> <li>ark_dpa_vm_update_policy</li> </ul> </li> </ul> </li> <li>secrets<ul> <li>db<ul> <li>ark_dpa_db_add_secret</li> <li>ark_dpa_db_delete_secret</li> <li>ark_dpa_db_disable_secret</li> <li>ark_dpa_db_enable_secret</li> <li>ark_dpa_db_get_secret</li> <li>ark_dpa_db_secret_metadata</li> <li>ark_dpa_db_secret_type</li> <li>ark_dpa_db_secrets_filter</li> <li>ark_dpa_db_secrets_stats</li> <li>ark_dpa_db_store_descriptor</li> <li>ark_dpa_db_store_type</li> <li>ark_dpa_db_update_secret</li> <li>secret_links<ul> <li>ark_dpa_db_pam_account_secret_link</li> </ul> </li> <li>secrets_data<ul> <li>ark_dpa_db_user_password_secret_data</li> </ul> </li> </ul> </li> </ul> </li> <li>sso<ul> <li>ark_dpa_sso_acquire_token_response</li> <li>ark_dpa_sso_get_short_lived_client_certificate</li> <li>ark_dpa_sso_get_short_lived_oracle_wallet</li> <li>ark_dpa_sso_get_short_lived_password</li> <li>ark_dpa_sso_get_short_lived_rdp_file</li> </ul> </li> <li>workspaces<ul> <li>db<ul> <li>ark_dpa_db_add_database</li> <li>ark_dpa_db_database</li> <li>ark_dpa_db_database_info</li> <li>ark_dpa_db_databases_filter</li> <li>ark_dpa_db_databases_stats</li> <li>ark_dpa_db_delete_database</li> <li>ark_dpa_db_get_database</li> <li>ark_dpa_db_platform_type_serializer</li> <li>ark_dpa_db_provider</li> <li>ark_dpa_db_tag</li> <li>ark_dpa_db_update_database</li> <li>ark_dpa_db_warning</li> </ul> </li> </ul> </li> </ul> </li> <li>sm<ul> <li>ark_sm_get_session</li> <li>ark_sm_get_session_activities</li> <li>ark_sm_protocol_type_serializer</li> <li>ark_sm_session</li> <li>ark_sm_session_activity</li> <li>ark_sm_session_activity_filter</li> <li>ark_sm_sessions_filter</li> <li>ark_sm_sessions_stats</li> <li>ark_sm_workspace_type_serializer</li> </ul> </li> </ul> </li> </ul> </li> <li>services<ul> <li>ark_service</li> <li>dpa<ul> <li>ark_dpa_api</li> <li>certificates<ul> <li>ark_dpa_certificates_service</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_service</li> </ul> </li> <li>k8s<ul> <li>ark_dpa_k8s_service</li> </ul> </li> <li>policies<ul> <li>db<ul> <li>ark_dpa_db_policies_service</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_policies_service</li> </ul> </li> </ul> </li> <li>secrets<ul> <li>db<ul> <li>ark_dpa_db_secrets_service</li> </ul> </li> </ul> </li> <li>sso<ul> <li>ark_dpa_sso_service</li> </ul> </li> <li>workspaces<ul> <li>db<ul> <li>ark_dpa_db_workspace_service</li> </ul> </li> </ul> </li> </ul> </li> <li>sm<ul> <li>ark_sm_service</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/ark/","title":"ark","text":""},{"location":"reference/ark_api/","title":"ark_api","text":""},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI","title":"<code>ArkAPI</code>","text":"Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>class ArkAPI:\n    def __init__(self, authenticators: List[ArkAuth], profile: Optional[ArkProfile] = None) -&gt; None:\n        self.__authenticators = authenticators\n        self.__lazy_loaded_services: Dict[str, ArkService] = {}\n        self.__profile = profile or ArkProfileLoader.load_default_profile()\n\n    def __lazy_load_service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        service_name = service_type.service_config().service_name\n        required_auth_names = service_type.service_config().required_authenticator_names\n        required_autheneticators = [auth for auth in self.__authenticators if auth.authenticator_name() in required_auth_names]\n        optional_authenticators = [\n            auth\n            for auth in self.__authenticators\n            if auth.authenticator_name() in service_type.service_config().optional_authenticator_names\n        ]\n        if len(required_autheneticators) == len(required_auth_names):\n            authenticators = {f'{a.authenticator_name()}_auth': a for a in required_autheneticators + optional_authenticators}\n            self.__lazy_loaded_services[service_name] = service_type(**authenticators)\n        else:\n            raise ArkServiceException(\n                f'{service_name.title()} is not supported or missing fitting authenticators, please make sure you are logged in'\n            )\n        return self.__lazy_loaded_services[service_name]\n\n    def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Returns the specified authenticator.\n\n        Args:\n            authenticator_name (str): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.__authenticators:\n            if auth.authenticator_name() == authenticator_name:\n                return auth\n        raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n\n    def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        \"\"\"\n        Returns the specified service when the appropriate authenticators were provided.\n\n        Args:\n            service_type (Type[ArkService]): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkService: _description_\n        \"\"\"\n        if not issubclass(service_type, ArkService):\n            raise ArkServiceException(f\"Type {service_type} is invalid\")\n        service_name = service_type.service_config().service_name\n        if service_name in self.__lazy_loaded_services:\n            return self.__lazy_loaded_services[service_name]\n        return self.__lazy_load_service(service_type)\n\n    @property\n    def profile(self) -&gt; ArkProfile:\n        \"\"\"\n        Gets the API profile\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        return self.__profile\n\n    @property\n    def dpa_workspaces_db(self) -&gt; \"ArkDPADBWorkspaceService\":\n        \"\"\"\n        Returns the DPA DB Workspace service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.workspaces.db import ArkDPADBWorkspaceService\n\n        return cast(ArkDPADBWorkspaceService, self.service(ArkDPADBWorkspaceService))\n\n    @property\n    def dpa_policies_vm(self) -&gt; \"ArkDPAVMPoliciesService\":\n        \"\"\"\n        Returns the DPA VM Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPAVMPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.vm import ArkDPAVMPoliciesService\n\n        return cast(ArkDPAVMPoliciesService, self.service(ArkDPAVMPoliciesService))\n\n    @property\n    def dpa_policies_db(self) -&gt; \"ArkDPADBPoliciesService\":\n        \"\"\"\n        Returns the DPA DB Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.db import ArkDPADBPoliciesService\n\n        return cast(ArkDPADBPoliciesService, self.service(ArkDPADBPoliciesService))\n\n    @property\n    def dpa_secrets_db(self) -&gt; \"ArkDPADBSecretsService\":\n        \"\"\"\n        Returns the DPA DB Secrets service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.secrets.db import ArkDPADBSecretsService\n\n        return cast(ArkDPADBSecretsService, self.service(ArkDPADBSecretsService))\n\n    @property\n    def dpa_sso(self) -&gt; \"ArkDPASSOService\":\n        \"\"\"\n        Returns the DPA sso service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.sso import ArkDPASSOService\n\n        return cast(ArkDPASSOService, self.service(ArkDPASSOService))\n\n    @property\n    def dpa_db(self) -&gt; \"ArkDPADBService\":\n        \"\"\"\n        Returns the DPA DB service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.db import ArkDPADBService\n\n        return cast(ArkDPADBService, self.service(ArkDPADBService))\n\n    @property\n    def dpa_certificates(self) -&gt; \"ArkDPACertificatesService\":\n        \"\"\"\n        Returns DPA certificates service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.certificates import ArkDPACertificatesService\n\n        return cast(ArkDPACertificatesService, self.service(ArkDPACertificatesService))\n\n    @property\n    def dpa_k8s(self) -&gt; \"ArkDPAK8SService\":\n        \"\"\"\n        Returns the DPA Policies service if the appropriate authenticators were provided.\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.k8s import ArkDPAK8SService\n\n        return cast(ArkDPAK8SService, self.service(ArkDPAK8SService))\n\n    @property\n    def sm(self) -&gt; \"ArkSMService\":\n        \"\"\"\n        Returns the SM service if the appropriate authenticators were given\n\n        Returns:\n            ArkSMService: _description_\n        \"\"\"\n        from ark_sdk_python.services.sm import ArkSMService\n\n        return cast(ArkSMService, self.service(ArkSMService))\n</code></pre>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_certificates","title":"<code>dpa_certificates: 'ArkDPACertificatesService'</code>  <code>property</code>","text":"<p>Returns DPA certificates service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>'ArkDPACertificatesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_db","title":"<code>dpa_db: 'ArkDPADBService'</code>  <code>property</code>","text":"<p>Returns the DPA DB service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>'ArkDPADBService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_k8s","title":"<code>dpa_k8s: 'ArkDPAK8SService'</code>  <code>property</code>","text":"<p>Returns the DPA Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>'ArkDPAK8SService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_policies_db","title":"<code>dpa_policies_db: 'ArkDPADBPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>'ArkDPADBPoliciesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_policies_vm","title":"<code>dpa_policies_vm: 'ArkDPAVMPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA VM Policies service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesService</code> <code>'ArkDPAVMPoliciesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_secrets_db","title":"<code>dpa_secrets_db: 'ArkDPADBSecretsService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Secrets service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>'ArkDPADBSecretsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_sso","title":"<code>dpa_sso: 'ArkDPASSOService'</code>  <code>property</code>","text":"<p>Returns the DPA sso service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>'ArkDPASSOService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_workspaces_db","title":"<code>dpa_workspaces_db: 'ArkDPADBWorkspaceService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Workspace service if the appropriate authenticators were provided.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>'ArkDPADBWorkspaceService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.profile","title":"<code>profile: ArkProfile</code>  <code>property</code>","text":"<p>Gets the API profile</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.sm","title":"<code>sm: 'ArkSMService'</code>  <code>property</code>","text":"<p>Returns the SM service if the appropriate authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkSMService</code> <code>'ArkSMService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.authenticator","title":"<code>authenticator(authenticator_name)</code>","text":"<p>Returns the specified authenticator.</p> <p>Parameters:</p> Name Type Description Default <code>authenticator_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Returns the specified authenticator.\n\n    Args:\n        authenticator_name (str): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.__authenticators:\n        if auth.authenticator_name() == authenticator_name:\n            return auth\n    raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n</code></pre>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.service","title":"<code>service(service_type)</code>","text":"<p>Returns the specified service when the appropriate authenticators were provided.</p> <p>Parameters:</p> Name Type Description Default <code>service_type</code> <code>Type[ArkService]</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkService</code> <code>ArkService</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n    \"\"\"\n    Returns the specified service when the appropriate authenticators were provided.\n\n    Args:\n        service_type (Type[ArkService]): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkService: _description_\n    \"\"\"\n    if not issubclass(service_type, ArkService):\n        raise ArkServiceException(f\"Type {service_type} is invalid\")\n    service_name = service_type.service_config().service_name\n    if service_name in self.__lazy_loaded_services:\n        return self.__lazy_loaded_services[service_name]\n    return self.__lazy_load_service(service_type)\n</code></pre>"},{"location":"reference/actions/","title":"actions","text":""},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction","title":"<code>ArkAction</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>class ArkAction(ABC):\n    def __init__(self):\n        self._logger = get_logger(app=self.__class__.__name__)\n\n    def _common_actions_configuration(self, parser: argparse.ArgumentParser) -&gt; None:\n        parser.add_argument('-r', '--raw', action='store_true', help='Whether to raw output')\n        parser.add_argument('-s', '--silent', action='store_true', help='Silent execution, no interactiveness')\n        parser.add_argument('-ao', '--allow-output', action='store_true', help='Allow stdout / stderr even when silent and not interactive')\n        parser.add_argument('-v', '--verbose', action='store_true', help='Whether to verbose log')\n        parser.add_argument('-ls', '--logger-style', choices=['default'], help='Which verbose logger style to use', default='default')\n        parser.add_argument(\n            '-ll',\n            '--log-level',\n            help='Log level to use while verbose',\n            choices=['DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL'],\n            default='INFO',\n        )\n        parser.add_argument(\n            '-dcv', '--disable-cert-verification', action='store_true', help='Disables certificate verification on HTTPS calls, unsafe!'\n        )\n        parser.add_argument('-tc', '--trusted-cert', help='Certificate to use for HTTPS calls')\n\n    def _common_actions_execution(self, args: argparse.Namespace) -&gt; None:\n        ArkSystemConfig.enable_color()\n        ArkSystemConfig.enable_interactive()\n        ArkSystemConfig.disable_verbose_logging()\n        ArkSystemConfig.disallow_output()\n        ArkSystemConfig.set_logger_style(args.logger_style)\n        ArkSystemConfig.enable_certificate_verification()\n        if args.raw:\n            ArkSystemConfig.disable_color()\n        if args.silent:\n            ArkSystemConfig.disable_interactive()\n        if args.verbose:\n            ArkSystemConfig.enable_verbose_logging(args.log_level)\n        if args.allow_output:\n            ArkSystemConfig.allow_output()\n        if args.disable_cert_verification:\n            ArkSystemConfig.disable_certificate_verification()\n        elif args.trusted_cert is not None:\n            ArkSystemConfig.set_trusted_certificate(args.trusted_cert)\n        self._logger = get_logger(app=self.__class__.__name__)\n        if 'profile-name' in args:\n            args.profile_name = ArkProfileLoader.deduce_profile_name(args.profile_name)\n        if 'DEPLOY_ENV' not in os.environ:\n            # Last fallback on deploy env\n            os.environ['DEPLOY_ENV'] = 'prod'\n\n    @abstractmethod\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the action as part of the specified subparsers group.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the actual action with the given arguments.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the given action can be run with the specified arguments.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the given action can be run with the specified arguments.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the given action can be run with the specified arguments.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.define_action","title":"<code>define_action(subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines the action as part of the specified subparsers group.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the action as part of the specified subparsers group.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.run_action","title":"<code>run_action(args)</code>  <code>abstractmethod</code>","text":"<p>Runs the actual action with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the actual action with the given arguments.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction","title":"<code>ArkCacheAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>class ArkCacheAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `cache` action, and adds the clear cache function.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n        self._common_actions_configuration(cache_parser)\n        cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n        cache_cmd_subparsers.required = True\n        cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n\n    def __run_clear_cache_action(self) -&gt; None:\n        if isinstance(ArkKeyring.get_keyring(), BasicKeyring):\n            cache_folder_path = os.path.join(os.path.expanduser('~'), DEFAULT_BASIC_KEYRING_FOLDER)\n            if ARK_BASIC_KEYRING_FOLDER_ENV_VAR in os.environ:\n                cache_folder_path = os.environ[ARK_BASIC_KEYRING_FOLDER_ENV_VAR]\n            os.unlink(f'{cache_folder_path}{os.sep}keyring')\n            os.unlink(f'{cache_folder_path}{os.sep}mac')\n        else:\n            ArkArgsFormatter.print_normal('Cache clear is only valid for basic keyring implementation at the moment')\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the cache action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        if args.cache_cmd == 'clear':\n            self.__run_clear_cache_action()\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `cache`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>cache</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `cache`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>cache</code> action, and adds the clear cache function.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `cache` action, and adds the clear cache function.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n    self._common_actions_configuration(cache_parser)\n    cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n    cache_cmd_subparsers.required = True\n    cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the cache action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the cache action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    if args.cache_cmd == 'clear':\n        self.__run_clear_cache_action()\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction","title":"<code>ArkConfigureAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>class ArkConfigureAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `configure` action.\n        For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n        self._common_actions_configuration(conf_parser)\n\n        # Add the profile settings to the arguments\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n        )\n\n        # Add the supported authenticator settings and whether to work with them or not\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            conf_parser.add_argument(\n                f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n                f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n                action='store_true',\n                help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                conf_parser.add_argument(\n                    f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                    f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                    choices=[am.value for am in authenticator.supported_auth_methods()],\n                    default=ArkAuthMethod.Default.value,\n                )\n            # Add the rest of the ark auth profile params\n            ArkPydanticArgparse.schema_to_argparse(\n                ArkAuthProfile.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n            )\n\n            # Add the supported authentication methods settings of the authenticators\n            for auth_method in authenticator.supported_auth_methods():\n                auth_settings = ArkAuthMethodSettingsMap[auth_method]\n                ArkPydanticArgparse.schema_to_argparse(\n                    auth_settings.schema(by_alias=False),\n                    conf_parser,\n                    key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                    ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n                )\n\n    def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Performs an interactive configuration.\n        The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n        Selected authenticators are also configured with the user's auth methods and settings.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile first with the given profile name from the user\n        profile_name = ArkArgsFormatter.get_arg(\n            args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n        )\n        profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n        # Fill the rest of the profile settings\n        profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n            ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n        )\n        profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n        if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n            work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n        else:\n            work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n                args,\n                [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n                'Which authenticators would you like to connect to',\n                [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n                {\n                    f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                    for a in SUPPORTED_AUTHENTICATORS_LIST\n                    if a.authenticator_name() in profile.auth_profiles\n                },\n                True,\n            )\n        for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n            # Find out if we are working with the authenticator\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n                # Get the authenticator auth method\n                ArkArgsFormatter.print_success_bright(\n                    ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n                )\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    auth_method = ArkArgsFormatter.get_switch_arg(\n                        args,\n                        f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                        'Authentication Method',\n                        [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                        ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                        if authenticator.authenticator_name() in profile.auth_profiles\n                        else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                        prioritize_existing_val=True,\n                    )\n                    auth_method = next(\n                        filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                    )\n                    # If the default is chosen, override it by the authenticator's default\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n                ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                    authenticator.authenticator_name(), []\n                )\n                # Get the auth profile general settings\n                auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    ArkAuthProfile.schema(by_alias=False),\n                    args,\n                    ignored_keys=ignored_keys,\n                    existing_values=auth_profile.dict(),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    auth_profile_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignore_keys=['auth_method_settings'],\n                )\n\n                # Get the auth method settings and fill them\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    method_settings.schema(by_alias=False),\n                    args,\n                    existing_values=method_settings.dict(),\n                    override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                    empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                    default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n                )\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Runs the CLI configure action silently, without user interaction.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile based on the cli params and merge the rest of the params\n        profile = ArkPydanticArgparse.merge_by_model(\n            ArkProfile,\n            ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n            ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n        )\n\n        # Load the authenticators\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    # Load the auth method\n                    auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                    # If default, fallback to default auth method of the authenticator\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n\n                # Load the rest of the auth profile\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    ArkPydanticArgparse.argparse_to_schema(\n                        ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                    ),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n\n                # Make sure if the type requires credentials, a username was supplied\n                if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                    raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n                # Load the method settings\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n                # Parse and merge the method settings from the cli\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                    method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                )\n\n                # Remove the postfix\n                method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    defaults={\n                        k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                        for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                        if k.startswith(f'{authenticator.authenticator_name()}_')\n                    },\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the configure action.\n        Prompts the user when interactive mode is run, based on the associated authenticators,\n        and saves the configured profile when completed.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n        # Parse the profile\n        self._common_actions_execution(args)\n        profile: Optional[ArkProfile] = None\n        if ArkSystemConfig.is_interactive():\n            profile = self.__run_interactive_action(args)\n        else:\n            profile = self.__run_silent_action(args)\n\n        # Store it\n        ArkProfileLoader.save_profile(profile)\n\n        # Print out results\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n        ArkArgsFormatter.print_success_bright(\n            f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `configure`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.__run_interactive_action","title":"<code>__run_interactive_action(args)</code>","text":"<p>Performs an interactive configuration. The user is prompted for each Ark profile setting, with the default/defined CLI arguments. Selected authenticators are also configured with the user's auth methods and settings.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Performs an interactive configuration.\n    The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n    Selected authenticators are also configured with the user's auth methods and settings.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile first with the given profile name from the user\n    profile_name = ArkArgsFormatter.get_arg(\n        args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n    )\n    profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n    # Fill the rest of the profile settings\n    profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n        ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n    )\n    profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n    if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n        work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n    else:\n        work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n            args,\n            [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n            'Which authenticators would you like to connect to',\n            [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n            {\n                f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                for a in SUPPORTED_AUTHENTICATORS_LIST\n                if a.authenticator_name() in profile.auth_profiles\n            },\n            True,\n        )\n    for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n        # Find out if we are working with the authenticator\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n            # Get the authenticator auth method\n            ArkArgsFormatter.print_success_bright(\n                ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                auth_method = ArkArgsFormatter.get_switch_arg(\n                    args,\n                    f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                    'Authentication Method',\n                    [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                    ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                    if authenticator.authenticator_name() in profile.auth_profiles\n                    else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                    prioritize_existing_val=True,\n                )\n                auth_method = next(\n                    filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                )\n                # If the default is chosen, override it by the authenticator's default\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n            ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                authenticator.authenticator_name(), []\n            )\n            # Get the auth profile general settings\n            auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                ArkAuthProfile.schema(by_alias=False),\n                args,\n                ignored_keys=ignored_keys,\n                existing_values=auth_profile.dict(),\n                key_prefix=authenticator.authenticator_name(),\n            )\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                auth_profile_vals,\n                key_prefix=authenticator.authenticator_name(),\n                ignore_keys=['auth_method_settings'],\n            )\n\n            # Get the auth method settings and fill them\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                method_settings.schema(by_alias=False),\n                args,\n                existing_values=method_settings.dict(),\n                override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                key_prefix=authenticator.authenticator_name(),\n                ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n            )\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.__run_silent_action","title":"<code>__run_silent_action(args)</code>","text":"<p>Runs the CLI configure action silently, without user interaction.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Runs the CLI configure action silently, without user interaction.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile based on the cli params and merge the rest of the params\n    profile = ArkPydanticArgparse.merge_by_model(\n        ArkProfile,\n        ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n        ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n    )\n\n    # Load the authenticators\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                # Load the auth method\n                auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                # If default, fallback to default auth method of the authenticator\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n\n            # Load the rest of the auth profile\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                ArkPydanticArgparse.argparse_to_schema(\n                    ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                ),\n                key_prefix=authenticator.authenticator_name(),\n            )\n\n            # Make sure if the type requires credentials, a username was supplied\n            if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n            # Load the method settings\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n            # Parse and merge the method settings from the cli\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n            )\n\n            # Remove the postfix\n            method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n                defaults={\n                    k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                    for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                    if k.startswith(f'{authenticator.authenticator_name()}_')\n                },\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>configure</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `configure`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>configure</code> action. For each supported authenticator, sets whether it is used and adds the appropriate parameters.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `configure` action.\n    For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n    self._common_actions_configuration(conf_parser)\n\n    # Add the profile settings to the arguments\n    ArkPydanticArgparse.schema_to_argparse(\n        ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n    )\n\n    # Add the supported authenticator settings and whether to work with them or not\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        conf_parser.add_argument(\n            f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n            f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n            action='store_true',\n            help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n        )\n        if len(authenticator.supported_auth_methods()) &gt; 1:\n            conf_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                choices=[am.value for am in authenticator.supported_auth_methods()],\n                default=ArkAuthMethod.Default.value,\n            )\n        # Add the rest of the ark auth profile params\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkAuthProfile.schema(by_alias=False),\n            conf_parser,\n            key_prefix=authenticator.authenticator_name().replace('_', '-'),\n            ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n        )\n\n        # Add the supported authentication methods settings of the authenticators\n        for auth_method in authenticator.supported_auth_methods():\n            auth_settings = ArkAuthMethodSettingsMap[auth_method]\n            ArkPydanticArgparse.schema_to_argparse(\n                auth_settings.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n            )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the configure action. Prompts the user when interactive mode is run, based on the associated authenticators, and saves the configured profile when completed.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the configure action.\n    Prompts the user when interactive mode is run, based on the associated authenticators,\n    and saves the configured profile when completed.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n    # Parse the profile\n    self._common_actions_execution(args)\n    profile: Optional[ArkProfile] = None\n    if ArkSystemConfig.is_interactive():\n        profile = self.__run_interactive_action(args)\n    else:\n        profile = self.__run_silent_action(args)\n\n    # Store it\n    ArkProfileLoader.save_profile(profile)\n\n    # Print out results\n    ArkArgsFormatter.print_success(profile.json(indent=4))\n    ArkArgsFormatter.print_success_bright(\n        f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction","title":"<code>ArkExecAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>class ArkExecAction(ArkAction):\n    def _serialize_output(self, output: Optional[Union[List, Dict, ArkModel, Generator, Tuple, Any]]) -&gt; str:\n        if output is None:\n            return ''\n        if isinstance(output, Generator):\n            return self._serialize_output(list(itertools.chain.from_iterable([p.items for p in output])))\n        if isinstance(output, list):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, tuple):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, dict):\n            return json.dumps(\n                {\n                    k: json.loads(v.json(indent=4, by_alias=False, exclude={'poll_progress_callback'}))\n                    for k, v in output.items()\n                    if k is not None and v is not None\n                },\n                indent=4,\n            )\n        elif issubclass(type(output), ArkModel):\n            return output.json(indent=4, by_alias=False, exclude={'poll_progress_callback'})\n        elif issubclass(type(output), ArkAsyncRequest):\n            return output.async_task.json(indent=4, by_alias=False)\n        return str(output)\n\n    def _write_output_to_file(self, output_path: str, serialized_output: str) -&gt; None:\n        output_path = os.path.abspath(output_path)\n        if not os.path.exists(os.path.dirname(output_path)):\n            os.makedirs(os.path.dirname(output_path), exist_ok=True)\n        with open(output_path, 'w', encoding='utf-8') as f:\n            f.write(serialized_output)\n\n    def _run_async_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            model: ArkPollableModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n            model.poll_progress_callback = ArkPollers.default_poller()\n            output = getattr(service, action.replace('-', '_'))(model)\n            async_req = None\n            if issubclass(type(output), ArkAsyncRequest):\n                async_req = output\n            elif isinstance(output, tuple):\n                for a in output:\n                    if issubclass(type(a), ArkAsyncRequest):\n                        async_req = a\n                        break\n            if async_req is not None:\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path, async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})\n                    )\n                if async_req.task_failed():\n                    if async_req.task_timeout():\n                        ArkArgsFormatter.print_warning(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                    else:\n                        ArkArgsFormatter.print_failure(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                else:\n                    ArkArgsFormatter.print_success(self._serialize_output(output))\n            elif isinstance(output, list) and all(issubclass(type(ar), ArkAsyncRequest) for ar in output):\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path,\n                        json.dumps([ar.async_task.dict(indent=4, by_alias=False, exclude={\"poll_progress_callback\"}) for ar in output]),\n                    )\n                for ar in output:\n                    if ar.task_failed():\n                        if ar.task_timeout():\n                            ArkArgsFormatter.print_warning(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                        else:\n                            ArkArgsFormatter.print_failure(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                    else:\n                        ArkArgsFormatter.print_success(self._serialize_output(ar))\n            elif output is not None:\n                ArkArgsFormatter.print_success(self._serialize_output(output))\n        except Exception as ex:\n            self._logger.exception(f'Failed running async command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute async command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _run_sync_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            if model_type:\n                model: ArkModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n                output = getattr(service, action.replace('-', '_'))(model)\n            else:\n                output = getattr(service, action.replace('-', '_'))()\n            if output is not None:\n                serialized_output: str = self._serialize_output(output)\n                if args.output_path:\n                    self._write_output_to_file(args.output_path, serialized_output)\n                ArkArgsFormatter.print_success(serialized_output)\n            else:\n                ArkArgsFormatter.print_success(f'{action.replace(\"-\", \" \").title()} finished successfully')\n        except Exception as ex:\n            self._logger.exception(f'Failed running command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _define_actions_by_schemas(\n        self,\n        subparsers: argparse._SubParsersAction,\n        schemas_map: Dict[str, Optional[Type[ArkModel]]],\n        defaults_map: Optional[Dict[str, Dict[str, Any]]] = None,\n    ):\n        for action, schema in schemas_map.items():\n            parser = subparsers.add_parser(action)\n            if schema:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema.schema(), parser, defaults=defaults_map.get(action, None) if defaults_map else None\n                )\n\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        exec_parser = None\n        exec_subparsers = None\n        # Check if the exec subparser already exists from previous definitions of a service\n        if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n            # Retrieve the existing exec parser\n            exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n            exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n        else:\n            # Create a new exec parser\n            exec_parser = subparsers.add_parser('exec')\n            self._common_actions_configuration(exec_parser)\n            exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n            exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n            exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n            exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n            exec_parser.add_argument(\n                '-ra',\n                '--refresh-auth',\n                action='store_true',\n                help='If possible, will try to refresh the active authentication before running the actual command',\n            )\n            exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n            exec_subparsers.required = True\n        self.define_exec_action(exec_subparsers)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action.\n        Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n        Each service is created from the API, based on the given authenticators, and then\n        runs the exec action using the API.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile and login before trying to exec')\n\n        # Load token from cache for each auth profile\n        authenticators: List[ArkAuth] = []\n        for authenticator_name in profile.auth_profiles.keys():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n            if not authenticator.load_authentication(profile, args.refresh_auth):\n                continue\n            authenticators.append(authenticator)\n\n        if len(authenticators) == 0:\n            raise ArkException(\n                'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n            )\n        if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n            ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n        # Create the CLI API with the authenticators\n        api = ArkCLIAPI(authenticators, profile)\n\n        # Run the actual exec fitting action with the api\n        # Run it with retries as per defined by user\n        retry_call(\n            self.run_exec_action,\n            fargs=[api, args],\n            tries=args.retry_count,\n            delay=1,\n            logger=namedtuple(\"logger\", (\"warning\"))(\n                warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n            ),\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `exec`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n\n    @abstractmethod\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines an exec action, and its specified configurations and args, for a service.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action for a service with the specified arguments and API.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the specified exec service action can be run.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>exec</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `exec`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the specified exec service action can be run.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the specified exec service action can be run.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>exec</code> action, with its subparsers (args) for the service.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    exec_parser = None\n    exec_subparsers = None\n    # Check if the exec subparser already exists from previous definitions of a service\n    if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n        # Retrieve the existing exec parser\n        exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n        exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n    else:\n        # Create a new exec parser\n        exec_parser = subparsers.add_parser('exec')\n        self._common_actions_configuration(exec_parser)\n        exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n        exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n        exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n        exec_parser.add_argument(\n            '-ra',\n            '--refresh-auth',\n            action='store_true',\n            help='If possible, will try to refresh the active authentication before running the actual command',\n        )\n        exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n        exec_subparsers.required = True\n    self.define_exec_action(exec_subparsers)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines an exec action, and its specified configurations and args, for a service.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines an exec action, and its specified configurations and args, for a service.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the exec action. Loads the authenticators from the cache and connects to the API using the loaded authenticators. Each service is created from the API, based on the given authenticators, and then runs the exec action using the API.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action.\n    Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n    Each service is created from the API, based on the given authenticators, and then\n    runs the exec action using the API.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile and login before trying to exec')\n\n    # Load token from cache for each auth profile\n    authenticators: List[ArkAuth] = []\n    for authenticator_name in profile.auth_profiles.keys():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n        if not authenticator.load_authentication(profile, args.refresh_auth):\n            continue\n        authenticators.append(authenticator)\n\n    if len(authenticators) == 0:\n        raise ArkException(\n            'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n        )\n    if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n        ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n    # Create the CLI API with the authenticators\n    api = ArkCLIAPI(authenticators, profile)\n\n    # Run the actual exec fitting action with the api\n    # Run it with retries as per defined by user\n    retry_call(\n        self.run_exec_action,\n        fargs=[api, args],\n        tries=args.retry_count,\n        delay=1,\n        logger=namedtuple(\"logger\", (\"warning\"))(\n            warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n        ),\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>  <code>abstractmethod</code>","text":"<p>Runs the exec action for a service with the specified arguments and API.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action for a service with the specified arguments and API.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction","title":"<code>ArkLoginAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>class ArkLoginAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `login` action.\n        For each supported authenticator, adds the username/secret params for logging in.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n        self._common_actions_configuration(login_parser)\n        login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n        login_parser.add_argument(\n            '-nss',\n            '--no-shared-secrets',\n            action='store_true',\n            help='Do not share secrets between different authenticators with the same username',\n        )\n        login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n        login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n        # Add username and secret for each authenticator for logging in\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n                help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n                help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the login action for each authenticator.\n        After a login completes, credentials are stored in the keyring for future use.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        # Load up the profile\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile before trying to login')\n\n        # Login for each auth profile\n        # Share secrets between authenticators for allowed auth methods\n        shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n        # Save tokens for finalization output\n        tokens_map: Dict[str, ArkToken] = dict()\n        for authenticator_name, auth_profile in profile.auth_profiles.items():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n            # Only perform the authentication if not already authenticated and not forced\n            if authenticator.is_authenticated(profile) and not args.force:\n                try:\n                    if args.refresh_auth:\n                        token = authenticator.load_authentication(profile, True)\n                        if token:\n                            ArkArgsFormatter.print_success(\n                                f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                            )\n                        else:\n                            raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                    else:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                        )\n                    continue\n                except Exception as ex:\n                    self._logger.info(\n                        f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                    )\n            secret = (\n                ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n            )\n            auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n            # Ask the user for the user and secret if interactive\n            if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n                auth_profile.username = ArkArgsFormatter.get_arg(\n                    args,\n                    f'{authenticator_name}_username',\n                    f'{authenticator.authenticator_human_readable_name()} Username',\n                    auth_profile.username,\n                )\n                # Check if there is an existing secret who is sharable\n                if (\n                    auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                    and auth_profile.auth_method in shared_secrets_map\n                    and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                    and not args.__dict__[f'{authenticator_name}_secret']\n                    and not args.no_shared_secrets\n                ):\n                    secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n                else:\n                    if not args.force and (\n                        (\n                            auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                        )\n                    ):\n                        # Check if there is a secret already cached, if there is, no need to ask for password\n                        secret = ArkSecret(secret='')\n                    else:\n                        # Check if we really need to ask for a password in specific use cases\n                        if (\n                            authenticator_name == 'isp'\n                            and auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.is_idp_user(auth_profile.username)\n                        ):\n                            secret = ArkSecret(secret='')\n                        else:\n                            secret = ArkSecret(\n                                secret=ArkArgsFormatter.get_arg(\n                                    args,\n                                    f'{authenticator_name}_secret',\n                                    f'{authenticator.authenticator_human_readable_name()} Secret',\n                                    hidden=True,\n                                )\n                            )\n            elif (\n                not ArkSystemConfig.is_interactive()\n                and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n                and not args.__dict__[f'{authenticator_name}_secret']\n            ):\n                raise ArkException(\n                    f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n                )\n            # Perform the authentication, will also cache the token\n            token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n            if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n                shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n            tokens_map[authenticator.authenticator_human_readable_name()] = token\n        if not args.show_tokens and tokens_map:\n            ArkArgsFormatter.print_success('Login tokens are hidden')\n        for k, v in tokens_map.items():\n            if 'cookies' in v.metadata:\n                del v.metadata['cookies']\n            ArkArgsFormatter.print_success(\n                f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n            )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `login`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>login</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `login`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>login</code> action. For each supported authenticator, adds the username/secret params for logging in.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `login` action.\n    For each supported authenticator, adds the username/secret params for logging in.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n    self._common_actions_configuration(login_parser)\n    login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n    login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n    login_parser.add_argument(\n        '-nss',\n        '--no-shared-secrets',\n        action='store_true',\n        help='Do not share secrets between different authenticators with the same username',\n    )\n    login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n    login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n    # Add username and secret for each authenticator for logging in\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n            help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n            help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the login action for each authenticator. After a login completes, credentials are stored in the keyring for future use.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the login action for each authenticator.\n    After a login completes, credentials are stored in the keyring for future use.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    # Load up the profile\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile before trying to login')\n\n    # Login for each auth profile\n    # Share secrets between authenticators for allowed auth methods\n    shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n    # Save tokens for finalization output\n    tokens_map: Dict[str, ArkToken] = dict()\n    for authenticator_name, auth_profile in profile.auth_profiles.items():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n        # Only perform the authentication if not already authenticated and not forced\n        if authenticator.is_authenticated(profile) and not args.force:\n            try:\n                if args.refresh_auth:\n                    token = authenticator.load_authentication(profile, True)\n                    if token:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                        )\n                    else:\n                        raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                else:\n                    ArkArgsFormatter.print_success(\n                        f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                    )\n                continue\n            except Exception as ex:\n                self._logger.info(\n                    f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                )\n        secret = (\n            ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n        )\n        auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n        # Ask the user for the user and secret if interactive\n        if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n            auth_profile.username = ArkArgsFormatter.get_arg(\n                args,\n                f'{authenticator_name}_username',\n                f'{authenticator.authenticator_human_readable_name()} Username',\n                auth_profile.username,\n            )\n            # Check if there is an existing secret who is sharable\n            if (\n                auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                and auth_profile.auth_method in shared_secrets_map\n                and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                and not args.__dict__[f'{authenticator_name}_secret']\n                and not args.no_shared_secrets\n            ):\n                secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n            else:\n                if not args.force and (\n                    (\n                        auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                    )\n                ):\n                    # Check if there is a secret already cached, if there is, no need to ask for password\n                    secret = ArkSecret(secret='')\n                else:\n                    # Check if we really need to ask for a password in specific use cases\n                    if (\n                        authenticator_name == 'isp'\n                        and auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.is_idp_user(auth_profile.username)\n                    ):\n                        secret = ArkSecret(secret='')\n                    else:\n                        secret = ArkSecret(\n                            secret=ArkArgsFormatter.get_arg(\n                                args,\n                                f'{authenticator_name}_secret',\n                                f'{authenticator.authenticator_human_readable_name()} Secret',\n                                hidden=True,\n                            )\n                        )\n        elif (\n            not ArkSystemConfig.is_interactive()\n            and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n            and not args.__dict__[f'{authenticator_name}_secret']\n        ):\n            raise ArkException(\n                f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n            )\n        # Perform the authentication, will also cache the token\n        token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n        if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n            shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n        tokens_map[authenticator.authenticator_human_readable_name()] = token\n    if not args.show_tokens and tokens_map:\n        ArkArgsFormatter.print_success('Login tokens are hidden')\n    for k, v in tokens_map.items():\n        if 'cookies' in v.metadata:\n            del v.metadata['cookies']\n        ArkArgsFormatter.print_success(\n            f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n        )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction","title":"<code>ArkProfilesAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>class ArkProfilesAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n        self._common_actions_configuration(profile_parser)\n        profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n        profile_cmd_subparsers.required = True\n        list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n        list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n        list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n        list_profiles_parser.add_argument(\n            '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n        )\n        show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n        show_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n        )\n        delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n        delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n        delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n        clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n        clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n        clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n        clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n        clone_profile_parser.add_argument(\n            '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n        )\n        clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n        add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n        add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n        edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n        edit_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n        )\n\n    def __run_list_action(self, args: argparse.Namespace) -&gt; None:\n        # Start by loading all the profiles\n        profiles: Optional[List[ArkProfile]] = ArkProfileLoader.load_all_profiles()\n        if not profiles:\n            ArkArgsFormatter.print_warning(\n                'No profiles were found',\n            )\n            return\n        # Filter profiles\n        if args.name:\n            profiles = [p for p in profiles if fnmatch(p.profile_name, args.name)]\n        if args.auth_profile:\n            profiles = [p for p in profiles if args.auth_profile in list(p.auth_profiles.keys())]\n        # Print them based on request\n        if args.all:\n            ArkArgsFormatter.print_success(json.dumps([p.dict() for p in profiles], indent=4))\n        else:\n            ArkArgsFormatter.print_success(json.dumps([p.profile_name for p in profiles], indent=4))\n\n    def __run_show_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n\n    def __run_delete_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message=f'Are you sure you want to delete profile {args.profile_name}')],\n                render=ArkInquirerRender(),\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.delete_profile(args.profile_name)\n\n    def __run_clear_action(self, args: argparse.Namespace) -&gt; None:\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message='Are you sure you want to clear all profiles')], render=ArkInquirerRender()\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.clear_all_profiles()\n\n    def __run_clone_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        cloned_profile: ArkProfile = profile.copy(update={'profile_name': args.new_profile_name or f'{profile.profile_name}_clone'})\n        if ArkProfileLoader.profile_exists(cloned_profile.profile_name):\n            if not args.yes:\n                answer = inquirer.prompt(\n                    [\n                        inquirer.Confirm(\n                            'answer', message=f'Are you sure you want to override existing profile {cloned_profile.profile_name}'\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answer or not answer['answer']:\n                    return\n        ArkProfileLoader.save_profile(cloned_profile)\n\n    def __run_add_action(self, args: argparse.Namespace) -&gt; None:\n        if not os.path.exists(args.profile_path):\n            ArkArgsFormatter.print_warning(\n                f'Profile path [{args.profile_path}] does not exist, ignoring',\n            )\n            return\n        try:\n            profile: ArkProfile = ArkProfile.parse_file(args.profile_path)\n            ArkProfileLoader.save_profile(profile)\n        except Exception as ex:\n            self._logger.exception(f'Failed to parser profile [{str(ex)}]')\n            ArkArgsFormatter.print_failure(\n                f'Profile path [{args.profile_path}] failed to be parsed, aborting',\n            )\n            return\n\n    def __run_edit_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        answer = inquirer.prompt(\n            [inquirer.Editor('profile_edit', message=f'Chosen profile [{profile_name}] is about to be edited')],\n            render=ArkInquirerRender(),\n            answers={'profile_edit': profile.json(indent=4)},\n        )\n        edited_profile = ArkProfile.parse_raw(answer['profile_edit'])\n        ArkProfileLoader.save_profile(edited_profile)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the profile action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.profile_cmd == 'list':\n            self.__run_list_action(args)\n        elif args.profile_cmd == 'show':\n            self.__run_show_action(args)\n        elif args.profile_cmd == 'delete':\n            self.__run_delete_action(args)\n        elif args.profile_cmd == 'clear':\n            self.__run_clear_action(args)\n        elif args.profile_cmd == 'clone':\n            self.__run_clone_action(args)\n        elif args.profile_cmd == 'add':\n            self.__run_add_action(args)\n        elif args.profile_cmd == 'edit':\n            self.__run_edit_action(args)\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `profile`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>profile</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `profile`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>profile</code> action, and adds actions for managing multiple profiles.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n    self._common_actions_configuration(profile_parser)\n    profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n    profile_cmd_subparsers.required = True\n    list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n    list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n    list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n    list_profiles_parser.add_argument(\n        '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n    )\n    show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n    show_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n    )\n    delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n    delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n    delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n    clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n    clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n    clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n    clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n    clone_profile_parser.add_argument(\n        '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n    )\n    clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n    add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n    add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n    edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n    edit_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the profile action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the profile action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.profile_cmd == 'list':\n        self.__run_list_action(args)\n    elif args.profile_cmd == 'show':\n        self.__run_show_action(args)\n    elif args.profile_cmd == 'delete':\n        self.__run_delete_action(args)\n    elif args.profile_cmd == 'clear':\n        self.__run_clear_action(args)\n    elif args.profile_cmd == 'clone':\n        self.__run_clone_action(args)\n    elif args.profile_cmd == 'add':\n        self.__run_add_action(args)\n    elif args.profile_cmd == 'edit':\n        self.__run_edit_action(args)\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction","title":"<code>ArkServiceExecAction</code>","text":"<p>             Bases: <code>ArkExecAction</code></p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>class ArkServiceExecAction(ArkExecAction):\n    def __define_service_exec_action(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; argparse._SubParsersAction:\n        action_parser = subparsers.add_parser(action_def.action_name)\n        action_dest = action_def.action_name\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}'\n        action_subparsers = action_parser.add_subparsers(dest=f\"{action_dest}_action\")\n        action_subparsers.required = True\n        if action_def.schemas:\n            self._define_actions_by_schemas(action_subparsers, action_def.schemas, action_def.defaults)\n        return action_subparsers\n\n    def __define_service_exec_actions(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; None:\n        action_subparsers = self.__define_service_exec_action(action_def, subparsers, parent_actions_def)\n        if action_def.subactions:\n            for subaction in action_def.subactions:\n                self.__define_service_exec_actions(\n                    subaction, action_subparsers, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                )\n\n    def __deduce_action_def(\n        self,\n        args: argparse.Namespace,\n        action_def: ArkServiceActionDefinition,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        action_dest = f'{action_def.action_name}_action'\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}_action'\n        if action_dest in args.__dict__:\n            action_value = args.__dict__[action_dest]\n            if action_def.subactions:\n                for subaction in action_def.subactions:\n                    if subaction.action_name == action_value:\n                        return self.__deduce_action_def(\n                            args, subaction, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                        )\n            return action_def, action_dest\n\n    def __deduce_action_command_def(self, command_name: str, args: argparse.Namespace) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        for action_def in SUPPORTED_SERVICE_ACTIONS:\n            if action_def.action_name == command_name:\n                # Find the fitting action\n                return self.__deduce_action_def(args, action_def)\n\n    @overrides\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        for actions in SUPPORTED_SERVICE_ACTIONS:\n            self.__define_service_exec_actions(actions, exec_subparsers)\n\n    @overrides\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Deduces from the arguments the appropriate service definition and action.\n        Finds the appropriate service using the definition and executes the sync or async service action.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n        action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n        action_value = args.__dict__[action_dest]\n        api_name = action_dest.replace('_action', '')\n        while '_' in api_name and not hasattr(api, api_name):\n            api_name = api_name.rsplit('_', 1)[0]\n        service = getattr(api, api_name)\n        if action_def.async_actions and action_value in action_def.async_actions:\n            self._run_async_action(service, action_def.schemas, action_value, args)\n        else:\n            self._run_sync_action(service, action_def.schemas, action_value, args)\n\n    @overrides\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether there is a service definition for the command and its actions.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>","text":"<p>Checks whether there is a service definition for the command and its actions.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether there is a service definition for the command and its actions.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>","text":"<p>Defines all the supported service actions as CLI actions, with its associated arguments and schemas.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    for actions in SUPPORTED_SERVICE_ACTIONS:\n        self.__define_service_exec_actions(actions, exec_subparsers)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>","text":"<p>Deduces from the arguments the appropriate service definition and action. Finds the appropriate service using the definition and executes the sync or async service action.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Deduces from the arguments the appropriate service definition and action.\n    Finds the appropriate service using the definition and executes the sync or async service action.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n    action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n    action_value = args.__dict__[action_dest]\n    api_name = action_dest.replace('_action', '')\n    while '_' in api_name and not hasattr(api, api_name):\n        api_name = api_name.rsplit('_', 1)[0]\n    service = getattr(api, api_name)\n    if action_def.async_actions and action_value in action_def.async_actions:\n        self._run_async_action(service, action_def.schemas, action_value, args)\n    else:\n        self._run_sync_action(service, action_def.schemas, action_value, args)\n</code></pre>"},{"location":"reference/actions/ark_action/","title":"ark_action","text":""},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction","title":"<code>ArkAction</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>class ArkAction(ABC):\n    def __init__(self):\n        self._logger = get_logger(app=self.__class__.__name__)\n\n    def _common_actions_configuration(self, parser: argparse.ArgumentParser) -&gt; None:\n        parser.add_argument('-r', '--raw', action='store_true', help='Whether to raw output')\n        parser.add_argument('-s', '--silent', action='store_true', help='Silent execution, no interactiveness')\n        parser.add_argument('-ao', '--allow-output', action='store_true', help='Allow stdout / stderr even when silent and not interactive')\n        parser.add_argument('-v', '--verbose', action='store_true', help='Whether to verbose log')\n        parser.add_argument('-ls', '--logger-style', choices=['default'], help='Which verbose logger style to use', default='default')\n        parser.add_argument(\n            '-ll',\n            '--log-level',\n            help='Log level to use while verbose',\n            choices=['DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL'],\n            default='INFO',\n        )\n        parser.add_argument(\n            '-dcv', '--disable-cert-verification', action='store_true', help='Disables certificate verification on HTTPS calls, unsafe!'\n        )\n        parser.add_argument('-tc', '--trusted-cert', help='Certificate to use for HTTPS calls')\n\n    def _common_actions_execution(self, args: argparse.Namespace) -&gt; None:\n        ArkSystemConfig.enable_color()\n        ArkSystemConfig.enable_interactive()\n        ArkSystemConfig.disable_verbose_logging()\n        ArkSystemConfig.disallow_output()\n        ArkSystemConfig.set_logger_style(args.logger_style)\n        ArkSystemConfig.enable_certificate_verification()\n        if args.raw:\n            ArkSystemConfig.disable_color()\n        if args.silent:\n            ArkSystemConfig.disable_interactive()\n        if args.verbose:\n            ArkSystemConfig.enable_verbose_logging(args.log_level)\n        if args.allow_output:\n            ArkSystemConfig.allow_output()\n        if args.disable_cert_verification:\n            ArkSystemConfig.disable_certificate_verification()\n        elif args.trusted_cert is not None:\n            ArkSystemConfig.set_trusted_certificate(args.trusted_cert)\n        self._logger = get_logger(app=self.__class__.__name__)\n        if 'profile-name' in args:\n            args.profile_name = ArkProfileLoader.deduce_profile_name(args.profile_name)\n        if 'DEPLOY_ENV' not in os.environ:\n            # Last fallback on deploy env\n            os.environ['DEPLOY_ENV'] = 'prod'\n\n    @abstractmethod\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the action as part of the specified subparsers group.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the actual action with the given arguments.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the given action can be run with the specified arguments.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the given action can be run with the specified arguments.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the given action can be run with the specified arguments.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.define_action","title":"<code>define_action(subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines the action as part of the specified subparsers group.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the action as part of the specified subparsers group.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.run_action","title":"<code>run_action(args)</code>  <code>abstractmethod</code>","text":"<p>Runs the actual action with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the actual action with the given arguments.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_cache_action/","title":"ark_cache_action","text":""},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction","title":"<code>ArkCacheAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>class ArkCacheAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `cache` action, and adds the clear cache function.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n        self._common_actions_configuration(cache_parser)\n        cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n        cache_cmd_subparsers.required = True\n        cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n\n    def __run_clear_cache_action(self) -&gt; None:\n        if isinstance(ArkKeyring.get_keyring(), BasicKeyring):\n            cache_folder_path = os.path.join(os.path.expanduser('~'), DEFAULT_BASIC_KEYRING_FOLDER)\n            if ARK_BASIC_KEYRING_FOLDER_ENV_VAR in os.environ:\n                cache_folder_path = os.environ[ARK_BASIC_KEYRING_FOLDER_ENV_VAR]\n            os.unlink(f'{cache_folder_path}{os.sep}keyring')\n            os.unlink(f'{cache_folder_path}{os.sep}mac')\n        else:\n            ArkArgsFormatter.print_normal('Cache clear is only valid for basic keyring implementation at the moment')\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the cache action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        if args.cache_cmd == 'clear':\n            self.__run_clear_cache_action()\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `cache`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>cache</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `cache`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>cache</code> action, and adds the clear cache function.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `cache` action, and adds the clear cache function.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n    self._common_actions_configuration(cache_parser)\n    cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n    cache_cmd_subparsers.required = True\n    cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the cache action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the cache action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    if args.cache_cmd == 'clear':\n        self.__run_clear_cache_action()\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/ark_configure_action/","title":"ark_configure_action","text":""},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction","title":"<code>ArkConfigureAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>class ArkConfigureAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `configure` action.\n        For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n        self._common_actions_configuration(conf_parser)\n\n        # Add the profile settings to the arguments\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n        )\n\n        # Add the supported authenticator settings and whether to work with them or not\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            conf_parser.add_argument(\n                f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n                f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n                action='store_true',\n                help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                conf_parser.add_argument(\n                    f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                    f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                    choices=[am.value for am in authenticator.supported_auth_methods()],\n                    default=ArkAuthMethod.Default.value,\n                )\n            # Add the rest of the ark auth profile params\n            ArkPydanticArgparse.schema_to_argparse(\n                ArkAuthProfile.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n            )\n\n            # Add the supported authentication methods settings of the authenticators\n            for auth_method in authenticator.supported_auth_methods():\n                auth_settings = ArkAuthMethodSettingsMap[auth_method]\n                ArkPydanticArgparse.schema_to_argparse(\n                    auth_settings.schema(by_alias=False),\n                    conf_parser,\n                    key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                    ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n                )\n\n    def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Performs an interactive configuration.\n        The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n        Selected authenticators are also configured with the user's auth methods and settings.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile first with the given profile name from the user\n        profile_name = ArkArgsFormatter.get_arg(\n            args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n        )\n        profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n        # Fill the rest of the profile settings\n        profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n            ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n        )\n        profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n        if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n            work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n        else:\n            work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n                args,\n                [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n                'Which authenticators would you like to connect to',\n                [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n                {\n                    f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                    for a in SUPPORTED_AUTHENTICATORS_LIST\n                    if a.authenticator_name() in profile.auth_profiles\n                },\n                True,\n            )\n        for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n            # Find out if we are working with the authenticator\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n                # Get the authenticator auth method\n                ArkArgsFormatter.print_success_bright(\n                    ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n                )\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    auth_method = ArkArgsFormatter.get_switch_arg(\n                        args,\n                        f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                        'Authentication Method',\n                        [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                        ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                        if authenticator.authenticator_name() in profile.auth_profiles\n                        else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                        prioritize_existing_val=True,\n                    )\n                    auth_method = next(\n                        filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                    )\n                    # If the default is chosen, override it by the authenticator's default\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n                ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                    authenticator.authenticator_name(), []\n                )\n                # Get the auth profile general settings\n                auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    ArkAuthProfile.schema(by_alias=False),\n                    args,\n                    ignored_keys=ignored_keys,\n                    existing_values=auth_profile.dict(),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    auth_profile_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignore_keys=['auth_method_settings'],\n                )\n\n                # Get the auth method settings and fill them\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    method_settings.schema(by_alias=False),\n                    args,\n                    existing_values=method_settings.dict(),\n                    override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                    empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                    default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n                )\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Runs the CLI configure action silently, without user interaction.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile based on the cli params and merge the rest of the params\n        profile = ArkPydanticArgparse.merge_by_model(\n            ArkProfile,\n            ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n            ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n        )\n\n        # Load the authenticators\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    # Load the auth method\n                    auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                    # If default, fallback to default auth method of the authenticator\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n\n                # Load the rest of the auth profile\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    ArkPydanticArgparse.argparse_to_schema(\n                        ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                    ),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n\n                # Make sure if the type requires credentials, a username was supplied\n                if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                    raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n                # Load the method settings\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n                # Parse and merge the method settings from the cli\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                    method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                )\n\n                # Remove the postfix\n                method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    defaults={\n                        k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                        for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                        if k.startswith(f'{authenticator.authenticator_name()}_')\n                    },\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the configure action.\n        Prompts the user when interactive mode is run, based on the associated authenticators,\n        and saves the configured profile when completed.\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n        # Parse the profile\n        self._common_actions_execution(args)\n        profile: Optional[ArkProfile] = None\n        if ArkSystemConfig.is_interactive():\n            profile = self.__run_interactive_action(args)\n        else:\n            profile = self.__run_silent_action(args)\n\n        # Store it\n        ArkProfileLoader.save_profile(profile)\n\n        # Print out results\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n        ArkArgsFormatter.print_success_bright(\n            f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `configure`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.__run_interactive_action","title":"<code>__run_interactive_action(args)</code>","text":"<p>Performs an interactive configuration. The user is prompted for each Ark profile setting, with the default/defined CLI arguments. Selected authenticators are also configured with the user's auth methods and settings.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Performs an interactive configuration.\n    The user is prompted for each Ark profile setting, with the default/defined CLI arguments.\n    Selected authenticators are also configured with the user's auth methods and settings.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile first with the given profile name from the user\n    profile_name = ArkArgsFormatter.get_arg(\n        args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n    )\n    profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n    # Fill the rest of the profile settings\n    profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n        ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n    )\n    profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n    if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n        work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n    else:\n        work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n            args,\n            [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n            'Which authenticators would you like to connect to',\n            [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n            {\n                f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                for a in SUPPORTED_AUTHENTICATORS_LIST\n                if a.authenticator_name() in profile.auth_profiles\n            },\n            True,\n        )\n    for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n        # Find out if we are working with the authenticator\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n            # Get the authenticator auth method\n            ArkArgsFormatter.print_success_bright(\n                ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                auth_method = ArkArgsFormatter.get_switch_arg(\n                    args,\n                    f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                    'Authentication Method',\n                    [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                    ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                    if authenticator.authenticator_name() in profile.auth_profiles\n                    else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                    prioritize_existing_val=True,\n                )\n                auth_method = next(\n                    filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                )\n                # If the default is chosen, override it by the authenticator's default\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n            ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                authenticator.authenticator_name(), []\n            )\n            # Get the auth profile general settings\n            auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                ArkAuthProfile.schema(by_alias=False),\n                args,\n                ignored_keys=ignored_keys,\n                existing_values=auth_profile.dict(),\n                key_prefix=authenticator.authenticator_name(),\n            )\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                auth_profile_vals,\n                key_prefix=authenticator.authenticator_name(),\n                ignore_keys=['auth_method_settings'],\n            )\n\n            # Get the auth method settings and fill them\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                method_settings.schema(by_alias=False),\n                args,\n                existing_values=method_settings.dict(),\n                override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                key_prefix=authenticator.authenticator_name(),\n                ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n            )\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.__run_silent_action","title":"<code>__run_silent_action(args)</code>","text":"<p>Runs the CLI configure action silently, without user interaction.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Runs the CLI configure action silently, without user interaction.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile based on the cli params and merge the rest of the params\n    profile = ArkPydanticArgparse.merge_by_model(\n        ArkProfile,\n        ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n        ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n    )\n\n    # Load the authenticators\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                # Load the auth method\n                auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                # If default, fallback to default auth method of the authenticator\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n\n            # Load the rest of the auth profile\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                ArkPydanticArgparse.argparse_to_schema(\n                    ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                ),\n                key_prefix=authenticator.authenticator_name(),\n            )\n\n            # Make sure if the type requires credentials, a username was supplied\n            if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n            # Load the method settings\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n            # Parse and merge the method settings from the cli\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n            )\n\n            # Remove the postfix\n            method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n                defaults={\n                    k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                    for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                    if k.startswith(f'{authenticator.authenticator_name()}_')\n                },\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>configure</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `configure`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>configure</code> action. For each supported authenticator, sets whether it is used and adds the appropriate parameters.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `configure` action.\n    For each supported authenticator, sets whether it is used and adds the appropriate parameters.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n    self._common_actions_configuration(conf_parser)\n\n    # Add the profile settings to the arguments\n    ArkPydanticArgparse.schema_to_argparse(\n        ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n    )\n\n    # Add the supported authenticator settings and whether to work with them or not\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        conf_parser.add_argument(\n            f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n            f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n            action='store_true',\n            help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n        )\n        if len(authenticator.supported_auth_methods()) &gt; 1:\n            conf_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                choices=[am.value for am in authenticator.supported_auth_methods()],\n                default=ArkAuthMethod.Default.value,\n            )\n        # Add the rest of the ark auth profile params\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkAuthProfile.schema(by_alias=False),\n            conf_parser,\n            key_prefix=authenticator.authenticator_name().replace('_', '-'),\n            ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n        )\n\n        # Add the supported authentication methods settings of the authenticators\n        for auth_method in authenticator.supported_auth_methods():\n            auth_settings = ArkAuthMethodSettingsMap[auth_method]\n            ArkPydanticArgparse.schema_to_argparse(\n                auth_settings.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n            )\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the configure action. Prompts the user when interactive mode is run, based on the associated authenticators, and saves the configured profile when completed.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the configure action.\n    Prompts the user when interactive mode is run, based on the associated authenticators,\n    and saves the configured profile when completed.\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n    # Parse the profile\n    self._common_actions_execution(args)\n    profile: Optional[ArkProfile] = None\n    if ArkSystemConfig.is_interactive():\n        profile = self.__run_interactive_action(args)\n    else:\n        profile = self.__run_silent_action(args)\n\n    # Store it\n    ArkProfileLoader.save_profile(profile)\n\n    # Print out results\n    ArkArgsFormatter.print_success(profile.json(indent=4))\n    ArkArgsFormatter.print_success_bright(\n        f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n    )\n</code></pre>"},{"location":"reference/actions/ark_exec_action/","title":"ark_exec_action","text":""},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction","title":"<code>ArkExecAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>class ArkExecAction(ArkAction):\n    def _serialize_output(self, output: Optional[Union[List, Dict, ArkModel, Generator, Tuple, Any]]) -&gt; str:\n        if output is None:\n            return ''\n        if isinstance(output, Generator):\n            return self._serialize_output(list(itertools.chain.from_iterable([p.items for p in output])))\n        if isinstance(output, list):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, tuple):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, dict):\n            return json.dumps(\n                {\n                    k: json.loads(v.json(indent=4, by_alias=False, exclude={'poll_progress_callback'}))\n                    for k, v in output.items()\n                    if k is not None and v is not None\n                },\n                indent=4,\n            )\n        elif issubclass(type(output), ArkModel):\n            return output.json(indent=4, by_alias=False, exclude={'poll_progress_callback'})\n        elif issubclass(type(output), ArkAsyncRequest):\n            return output.async_task.json(indent=4, by_alias=False)\n        return str(output)\n\n    def _write_output_to_file(self, output_path: str, serialized_output: str) -&gt; None:\n        output_path = os.path.abspath(output_path)\n        if not os.path.exists(os.path.dirname(output_path)):\n            os.makedirs(os.path.dirname(output_path), exist_ok=True)\n        with open(output_path, 'w', encoding='utf-8') as f:\n            f.write(serialized_output)\n\n    def _run_async_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            model: ArkPollableModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n            model.poll_progress_callback = ArkPollers.default_poller()\n            output = getattr(service, action.replace('-', '_'))(model)\n            async_req = None\n            if issubclass(type(output), ArkAsyncRequest):\n                async_req = output\n            elif isinstance(output, tuple):\n                for a in output:\n                    if issubclass(type(a), ArkAsyncRequest):\n                        async_req = a\n                        break\n            if async_req is not None:\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path, async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})\n                    )\n                if async_req.task_failed():\n                    if async_req.task_timeout():\n                        ArkArgsFormatter.print_warning(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                    else:\n                        ArkArgsFormatter.print_failure(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                else:\n                    ArkArgsFormatter.print_success(self._serialize_output(output))\n            elif isinstance(output, list) and all(issubclass(type(ar), ArkAsyncRequest) for ar in output):\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path,\n                        json.dumps([ar.async_task.dict(indent=4, by_alias=False, exclude={\"poll_progress_callback\"}) for ar in output]),\n                    )\n                for ar in output:\n                    if ar.task_failed():\n                        if ar.task_timeout():\n                            ArkArgsFormatter.print_warning(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                        else:\n                            ArkArgsFormatter.print_failure(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                    else:\n                        ArkArgsFormatter.print_success(self._serialize_output(ar))\n            elif output is not None:\n                ArkArgsFormatter.print_success(self._serialize_output(output))\n        except Exception as ex:\n            self._logger.exception(f'Failed running async command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute async command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _run_sync_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            if model_type:\n                model: ArkModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n                output = getattr(service, action.replace('-', '_'))(model)\n            else:\n                output = getattr(service, action.replace('-', '_'))()\n            if output is not None:\n                serialized_output: str = self._serialize_output(output)\n                if args.output_path:\n                    self._write_output_to_file(args.output_path, serialized_output)\n                ArkArgsFormatter.print_success(serialized_output)\n            else:\n                ArkArgsFormatter.print_success(f'{action.replace(\"-\", \" \").title()} finished successfully')\n        except Exception as ex:\n            self._logger.exception(f'Failed running command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _define_actions_by_schemas(\n        self,\n        subparsers: argparse._SubParsersAction,\n        schemas_map: Dict[str, Optional[Type[ArkModel]]],\n        defaults_map: Optional[Dict[str, Dict[str, Any]]] = None,\n    ):\n        for action, schema in schemas_map.items():\n            parser = subparsers.add_parser(action)\n            if schema:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema.schema(), parser, defaults=defaults_map.get(action, None) if defaults_map else None\n                )\n\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        exec_parser = None\n        exec_subparsers = None\n        # Check if the exec subparser already exists from previous definitions of a service\n        if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n            # Retrieve the existing exec parser\n            exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n            exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n        else:\n            # Create a new exec parser\n            exec_parser = subparsers.add_parser('exec')\n            self._common_actions_configuration(exec_parser)\n            exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n            exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n            exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n            exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n            exec_parser.add_argument(\n                '-ra',\n                '--refresh-auth',\n                action='store_true',\n                help='If possible, will try to refresh the active authentication before running the actual command',\n            )\n            exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n            exec_subparsers.required = True\n        self.define_exec_action(exec_subparsers)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action.\n        Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n        Each service is created from the API, based on the given authenticators, and then\n        runs the exec action using the API.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile and login before trying to exec')\n\n        # Load token from cache for each auth profile\n        authenticators: List[ArkAuth] = []\n        for authenticator_name in profile.auth_profiles.keys():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n            if not authenticator.load_authentication(profile, args.refresh_auth):\n                continue\n            authenticators.append(authenticator)\n\n        if len(authenticators) == 0:\n            raise ArkException(\n                'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n            )\n        if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n            ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n        # Create the CLI API with the authenticators\n        api = ArkCLIAPI(authenticators, profile)\n\n        # Run the actual exec fitting action with the api\n        # Run it with retries as per defined by user\n        retry_call(\n            self.run_exec_action,\n            fargs=[api, args],\n            tries=args.retry_count,\n            delay=1,\n            logger=namedtuple(\"logger\", (\"warning\"))(\n                warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n            ),\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `exec`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n\n    @abstractmethod\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines an exec action, and its specified configurations and args, for a service.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action for a service with the specified arguments and API.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the specified exec service action can be run.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>exec</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `exec`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the specified exec service action can be run.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the specified exec service action can be run.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>exec</code> action, with its subparsers (args) for the service.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `exec` action, with its subparsers (args) for the service.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    exec_parser = None\n    exec_subparsers = None\n    # Check if the exec subparser already exists from previous definitions of a service\n    if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n        # Retrieve the existing exec parser\n        exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n        exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n    else:\n        # Create a new exec parser\n        exec_parser = subparsers.add_parser('exec')\n        self._common_actions_configuration(exec_parser)\n        exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n        exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n        exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n        exec_parser.add_argument(\n            '-ra',\n            '--refresh-auth',\n            action='store_true',\n            help='If possible, will try to refresh the active authentication before running the actual command',\n        )\n        exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n        exec_subparsers.required = True\n    self.define_exec_action(exec_subparsers)\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines an exec action, and its specified configurations and args, for a service.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines an exec action, and its specified configurations and args, for a service.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the exec action. Loads the authenticators from the cache and connects to the API using the loaded authenticators. Each service is created from the API, based on the given authenticators, and then runs the exec action using the API.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action.\n    Loads the authenticators from the cache and connects to the API using the loaded authenticators.\n    Each service is created from the API, based on the given authenticators, and then\n    runs the exec action using the API.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile and login before trying to exec')\n\n    # Load token from cache for each auth profile\n    authenticators: List[ArkAuth] = []\n    for authenticator_name in profile.auth_profiles.keys():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n        if not authenticator.load_authentication(profile, args.refresh_auth):\n            continue\n        authenticators.append(authenticator)\n\n    if len(authenticators) == 0:\n        raise ArkException(\n            'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n        )\n    if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n        ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n    # Create the CLI API with the authenticators\n    api = ArkCLIAPI(authenticators, profile)\n\n    # Run the actual exec fitting action with the api\n    # Run it with retries as per defined by user\n    retry_call(\n        self.run_exec_action,\n        fargs=[api, args],\n        tries=args.retry_count,\n        delay=1,\n        logger=namedtuple(\"logger\", (\"warning\"))(\n            warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n        ),\n    )\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>  <code>abstractmethod</code>","text":"<p>Runs the exec action for a service with the specified arguments and API.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action for a service with the specified arguments and API.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_login_action/","title":"ark_login_action","text":""},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction","title":"<code>ArkLoginAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>class ArkLoginAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `login` action.\n        For each supported authenticator, adds the username/secret params for logging in.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n        self._common_actions_configuration(login_parser)\n        login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n        login_parser.add_argument(\n            '-nss',\n            '--no-shared-secrets',\n            action='store_true',\n            help='Do not share secrets between different authenticators with the same username',\n        )\n        login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n        login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n        # Add username and secret for each authenticator for logging in\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n                help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n                help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the login action for each authenticator.\n        After a login completes, credentials are stored in the keyring for future use.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        # Load up the profile\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile before trying to login')\n\n        # Login for each auth profile\n        # Share secrets between authenticators for allowed auth methods\n        shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n        # Save tokens for finalization output\n        tokens_map: Dict[str, ArkToken] = dict()\n        for authenticator_name, auth_profile in profile.auth_profiles.items():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n            # Only perform the authentication if not already authenticated and not forced\n            if authenticator.is_authenticated(profile) and not args.force:\n                try:\n                    if args.refresh_auth:\n                        token = authenticator.load_authentication(profile, True)\n                        if token:\n                            ArkArgsFormatter.print_success(\n                                f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                            )\n                        else:\n                            raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                    else:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                        )\n                    continue\n                except Exception as ex:\n                    self._logger.info(\n                        f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                    )\n            secret = (\n                ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n            )\n            auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n            # Ask the user for the user and secret if interactive\n            if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n                auth_profile.username = ArkArgsFormatter.get_arg(\n                    args,\n                    f'{authenticator_name}_username',\n                    f'{authenticator.authenticator_human_readable_name()} Username',\n                    auth_profile.username,\n                )\n                # Check if there is an existing secret who is sharable\n                if (\n                    auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                    and auth_profile.auth_method in shared_secrets_map\n                    and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                    and not args.__dict__[f'{authenticator_name}_secret']\n                    and not args.no_shared_secrets\n                ):\n                    secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n                else:\n                    if not args.force and (\n                        (\n                            auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                        )\n                    ):\n                        # Check if there is a secret already cached, if there is, no need to ask for password\n                        secret = ArkSecret(secret='')\n                    else:\n                        # Check if we really need to ask for a password in specific use cases\n                        if (\n                            authenticator_name == 'isp'\n                            and auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.is_idp_user(auth_profile.username)\n                        ):\n                            secret = ArkSecret(secret='')\n                        else:\n                            secret = ArkSecret(\n                                secret=ArkArgsFormatter.get_arg(\n                                    args,\n                                    f'{authenticator_name}_secret',\n                                    f'{authenticator.authenticator_human_readable_name()} Secret',\n                                    hidden=True,\n                                )\n                            )\n            elif (\n                not ArkSystemConfig.is_interactive()\n                and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n                and not args.__dict__[f'{authenticator_name}_secret']\n            ):\n                raise ArkException(\n                    f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n                )\n            # Perform the authentication, will also cache the token\n            token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n            if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n                shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n            tokens_map[authenticator.authenticator_human_readable_name()] = token\n        if not args.show_tokens and tokens_map:\n            ArkArgsFormatter.print_success('Login tokens are hidden')\n        for k, v in tokens_map.items():\n            if 'cookies' in v.metadata:\n                del v.metadata['cookies']\n            ArkArgsFormatter.print_success(\n                f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n            )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `login`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>login</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `login`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>login</code> action. For each supported authenticator, adds the username/secret params for logging in.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `login` action.\n    For each supported authenticator, adds the username/secret params for logging in.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n    self._common_actions_configuration(login_parser)\n    login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n    login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n    login_parser.add_argument(\n        '-nss',\n        '--no-shared-secrets',\n        action='store_true',\n        help='Do not share secrets between different authenticators with the same username',\n    )\n    login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n    login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n    # Add username and secret for each authenticator for logging in\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n            help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n            help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the login action for each authenticator. After a login completes, credentials are stored in the keyring for future use.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the login action for each authenticator.\n    After a login completes, credentials are stored in the keyring for future use.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    # Load up the profile\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile before trying to login')\n\n    # Login for each auth profile\n    # Share secrets between authenticators for allowed auth methods\n    shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n    # Save tokens for finalization output\n    tokens_map: Dict[str, ArkToken] = dict()\n    for authenticator_name, auth_profile in profile.auth_profiles.items():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n        # Only perform the authentication if not already authenticated and not forced\n        if authenticator.is_authenticated(profile) and not args.force:\n            try:\n                if args.refresh_auth:\n                    token = authenticator.load_authentication(profile, True)\n                    if token:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                        )\n                    else:\n                        raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                else:\n                    ArkArgsFormatter.print_success(\n                        f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                    )\n                continue\n            except Exception as ex:\n                self._logger.info(\n                    f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                )\n        secret = (\n            ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n        )\n        auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n        # Ask the user for the user and secret if interactive\n        if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n            auth_profile.username = ArkArgsFormatter.get_arg(\n                args,\n                f'{authenticator_name}_username',\n                f'{authenticator.authenticator_human_readable_name()} Username',\n                auth_profile.username,\n            )\n            # Check if there is an existing secret who is sharable\n            if (\n                auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                and auth_profile.auth_method in shared_secrets_map\n                and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                and not args.__dict__[f'{authenticator_name}_secret']\n                and not args.no_shared_secrets\n            ):\n                secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n            else:\n                if not args.force and (\n                    (\n                        auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                    )\n                ):\n                    # Check if there is a secret already cached, if there is, no need to ask for password\n                    secret = ArkSecret(secret='')\n                else:\n                    # Check if we really need to ask for a password in specific use cases\n                    if (\n                        authenticator_name == 'isp'\n                        and auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.is_idp_user(auth_profile.username)\n                    ):\n                        secret = ArkSecret(secret='')\n                    else:\n                        secret = ArkSecret(\n                            secret=ArkArgsFormatter.get_arg(\n                                args,\n                                f'{authenticator_name}_secret',\n                                f'{authenticator.authenticator_human_readable_name()} Secret',\n                                hidden=True,\n                            )\n                        )\n        elif (\n            not ArkSystemConfig.is_interactive()\n            and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n            and not args.__dict__[f'{authenticator_name}_secret']\n        ):\n            raise ArkException(\n                f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n            )\n        # Perform the authentication, will also cache the token\n        token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n        if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n            shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n        tokens_map[authenticator.authenticator_human_readable_name()] = token\n    if not args.show_tokens and tokens_map:\n        ArkArgsFormatter.print_success('Login tokens are hidden')\n    for k, v in tokens_map.items():\n        if 'cookies' in v.metadata:\n            del v.metadata['cookies']\n        ArkArgsFormatter.print_success(\n            f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n        )\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/","title":"ark_profiles_action","text":""},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction","title":"<code>ArkProfilesAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>class ArkProfilesAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n        self._common_actions_configuration(profile_parser)\n        profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n        profile_cmd_subparsers.required = True\n        list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n        list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n        list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n        list_profiles_parser.add_argument(\n            '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n        )\n        show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n        show_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n        )\n        delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n        delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n        delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n        clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n        clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n        clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n        clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n        clone_profile_parser.add_argument(\n            '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n        )\n        clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n        add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n        add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n        edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n        edit_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n        )\n\n    def __run_list_action(self, args: argparse.Namespace) -&gt; None:\n        # Start by loading all the profiles\n        profiles: Optional[List[ArkProfile]] = ArkProfileLoader.load_all_profiles()\n        if not profiles:\n            ArkArgsFormatter.print_warning(\n                'No profiles were found',\n            )\n            return\n        # Filter profiles\n        if args.name:\n            profiles = [p for p in profiles if fnmatch(p.profile_name, args.name)]\n        if args.auth_profile:\n            profiles = [p for p in profiles if args.auth_profile in list(p.auth_profiles.keys())]\n        # Print them based on request\n        if args.all:\n            ArkArgsFormatter.print_success(json.dumps([p.dict() for p in profiles], indent=4))\n        else:\n            ArkArgsFormatter.print_success(json.dumps([p.profile_name for p in profiles], indent=4))\n\n    def __run_show_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n\n    def __run_delete_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message=f'Are you sure you want to delete profile {args.profile_name}')],\n                render=ArkInquirerRender(),\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.delete_profile(args.profile_name)\n\n    def __run_clear_action(self, args: argparse.Namespace) -&gt; None:\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message='Are you sure you want to clear all profiles')], render=ArkInquirerRender()\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.clear_all_profiles()\n\n    def __run_clone_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        cloned_profile: ArkProfile = profile.copy(update={'profile_name': args.new_profile_name or f'{profile.profile_name}_clone'})\n        if ArkProfileLoader.profile_exists(cloned_profile.profile_name):\n            if not args.yes:\n                answer = inquirer.prompt(\n                    [\n                        inquirer.Confirm(\n                            'answer', message=f'Are you sure you want to override existing profile {cloned_profile.profile_name}'\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answer or not answer['answer']:\n                    return\n        ArkProfileLoader.save_profile(cloned_profile)\n\n    def __run_add_action(self, args: argparse.Namespace) -&gt; None:\n        if not os.path.exists(args.profile_path):\n            ArkArgsFormatter.print_warning(\n                f'Profile path [{args.profile_path}] does not exist, ignoring',\n            )\n            return\n        try:\n            profile: ArkProfile = ArkProfile.parse_file(args.profile_path)\n            ArkProfileLoader.save_profile(profile)\n        except Exception as ex:\n            self._logger.exception(f'Failed to parser profile [{str(ex)}]')\n            ArkArgsFormatter.print_failure(\n                f'Profile path [{args.profile_path}] failed to be parsed, aborting',\n            )\n            return\n\n    def __run_edit_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        answer = inquirer.prompt(\n            [inquirer.Editor('profile_edit', message=f'Chosen profile [{profile_name}] is about to be edited')],\n            render=ArkInquirerRender(),\n            answers={'profile_edit': profile.json(indent=4)},\n        )\n        edited_profile = ArkProfile.parse_raw(answer['profile_edit'])\n        ArkProfileLoader.save_profile(edited_profile)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the profile action.\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.profile_cmd == 'list':\n            self.__run_list_action(args)\n        elif args.profile_cmd == 'show':\n            self.__run_show_action(args)\n        elif args.profile_cmd == 'delete':\n            self.__run_delete_action(args)\n        elif args.profile_cmd == 'clear':\n            self.__run_clear_action(args)\n        elif args.profile_cmd == 'clone':\n            self.__run_clone_action(args)\n        elif args.profile_cmd == 'add':\n            self.__run_add_action(args)\n        elif args.profile_cmd == 'edit':\n            self.__run_edit_action(args)\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is `profile`.\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is <code>profile</code>.</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is `profile`.\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the CLI <code>profile</code> action, and adds actions for managing multiple profiles.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the CLI `profile` action, and adds actions for managing multiple profiles.\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n    self._common_actions_configuration(profile_parser)\n    profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n    profile_cmd_subparsers.required = True\n    list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n    list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n    list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n    list_profiles_parser.add_argument(\n        '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n    )\n    show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n    show_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n    )\n    delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n    delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n    delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n    clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n    clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n    clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n    clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n    clone_profile_parser.add_argument(\n        '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n    )\n    clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n    add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n    add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n    edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n    edit_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n    )\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the profile action.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the profile action.\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.profile_cmd == 'list':\n        self.__run_list_action(args)\n    elif args.profile_cmd == 'show':\n        self.__run_show_action(args)\n    elif args.profile_cmd == 'delete':\n        self.__run_delete_action(args)\n    elif args.profile_cmd == 'clear':\n        self.__run_clear_action(args)\n    elif args.profile_cmd == 'clone':\n        self.__run_clone_action(args)\n    elif args.profile_cmd == 'add':\n        self.__run_add_action(args)\n    elif args.profile_cmd == 'edit':\n        self.__run_edit_action(args)\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/","title":"ark_service_exec_action","text":""},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction","title":"<code>ArkServiceExecAction</code>","text":"<p>             Bases: <code>ArkExecAction</code></p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>class ArkServiceExecAction(ArkExecAction):\n    def __define_service_exec_action(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; argparse._SubParsersAction:\n        action_parser = subparsers.add_parser(action_def.action_name)\n        action_dest = action_def.action_name\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}'\n        action_subparsers = action_parser.add_subparsers(dest=f\"{action_dest}_action\")\n        action_subparsers.required = True\n        if action_def.schemas:\n            self._define_actions_by_schemas(action_subparsers, action_def.schemas, action_def.defaults)\n        return action_subparsers\n\n    def __define_service_exec_actions(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; None:\n        action_subparsers = self.__define_service_exec_action(action_def, subparsers, parent_actions_def)\n        if action_def.subactions:\n            for subaction in action_def.subactions:\n                self.__define_service_exec_actions(\n                    subaction, action_subparsers, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                )\n\n    def __deduce_action_def(\n        self,\n        args: argparse.Namespace,\n        action_def: ArkServiceActionDefinition,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        action_dest = f'{action_def.action_name}_action'\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}_action'\n        if action_dest in args.__dict__:\n            action_value = args.__dict__[action_dest]\n            if action_def.subactions:\n                for subaction in action_def.subactions:\n                    if subaction.action_name == action_value:\n                        return self.__deduce_action_def(\n                            args, subaction, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                        )\n            return action_def, action_dest\n\n    def __deduce_action_command_def(self, command_name: str, args: argparse.Namespace) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        for action_def in SUPPORTED_SERVICE_ACTIONS:\n            if action_def.action_name == command_name:\n                # Find the fitting action\n                return self.__deduce_action_def(args, action_def)\n\n    @overrides\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        for actions in SUPPORTED_SERVICE_ACTIONS:\n            self.__define_service_exec_actions(actions, exec_subparsers)\n\n    @overrides\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Deduces from the arguments the appropriate service definition and action.\n        Finds the appropriate service using the definition and executes the sync or async service action.\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n        action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n        action_value = args.__dict__[action_dest]\n        api_name = action_dest.replace('_action', '')\n        while '_' in api_name and not hasattr(api, api_name):\n            api_name = api_name.rsplit('_', 1)[0]\n        service = getattr(api, api_name)\n        if action_def.async_actions and action_value in action_def.async_actions:\n            self._run_async_action(service, action_def.schemas, action_value, args)\n        else:\n            self._run_sync_action(service, action_def.schemas, action_value, args)\n\n    @overrides\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether there is a service definition for the command and its actions.\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>","text":"<p>Checks whether there is a service definition for the command and its actions.</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether there is a service definition for the command and its actions.\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>","text":"<p>Defines all the supported service actions as CLI actions, with its associated arguments and schemas.</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines all the supported service actions as CLI actions, with its associated arguments and schemas.\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    for actions in SUPPORTED_SERVICE_ACTIONS:\n        self.__define_service_exec_actions(actions, exec_subparsers)\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>","text":"<p>Deduces from the arguments the appropriate service definition and action. Finds the appropriate service using the definition and executes the sync or async service action.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Deduces from the arguments the appropriate service definition and action.\n    Finds the appropriate service using the definition and executes the sync or async service action.\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n    action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n    action_value = args.__dict__[action_dest]\n    api_name = action_dest.replace('_action', '')\n    while '_' in api_name and not hasattr(api, api_name):\n        api_name = api_name.rsplit('_', 1)[0]\n    service = getattr(api, api_name)\n    if action_def.async_actions and action_value in action_def.async_actions:\n        self._run_async_action(service, action_def.schemas, action_value, args)\n    else:\n        self._run_sync_action(service, action_def.schemas, action_value, args)\n</code></pre>"},{"location":"reference/args/","title":"args","text":""},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse","title":"<code>ArkPydanticArgparse</code>","text":"Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>class ArkPydanticArgparse:\n    @staticmethod\n    def __populate_type(\n        prop_type: str,\n        snake_prop_name: str,\n        default: Optional[str],\n        required: bool,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        description: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        enum: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '-'\n        if ignore_keys != None and snake_prop_name in ignore_keys:\n            return\n        if default != None:\n            required = False\n        if isinstance(default, Enum):\n            default = default.value\n        arg_type = None\n        if prop_type == 'string':\n            arg_type = str\n        elif prop_type == 'integer':\n            arg_type = int\n        elif prop_type == 'boolean':\n            arg_type = bool\n        elif prop_type == 'object':\n            arg_type = object\n        else:\n            arg_type = str\n        long_name = key_prefix + prefix + snake_prop_name\n        shorted_name = ''.join([s[0] for s in long_name.replace('.', '-').split('-')])\n        for i in range(5):\n            for action in parser._actions:  # pylint: disable=protected-access\n                if f'-{shorted_name}' in action.option_strings:\n                    shorted_name = ''.join([s[: i + 1] for s in long_name.split('-')])\n                    break\n        if arg_type == bool:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                action='store_true',\n                help=description,\n            )\n            if long_name != 'poll':\n                parser.add_argument(\n                    '-n' + shorted_name,\n                    '--no-' + long_name,\n                    dest=long_name.replace('-', '_'),\n                    required='--request-file' not in ' '.join(sys.argv) and required,\n                    action='store_false',\n                    help=description,\n                )\n            parser.set_defaults(**{f\"{long_name.replace('-', '_')}\": default})\n        elif arg_type == object:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                metavar=\"KEY=VALUE\",\n                nargs='+',\n                default=default,\n                help=description,\n            )\n        else:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                type=arg_type,\n                default=default,\n                help=description,\n                choices=enum,\n            )\n\n    @staticmethod\n    def __schema_definition_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if not definitions:\n            return\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n        def_prop = definitions[def_prop_name]\n        if 'type' not in def_prop.keys():\n            return\n        prop_type = def_prop['type']\n        desc = ''\n        if 'description' in def_prop.keys():\n            desc = def_prop['description']\n        default: Optional[str] = None\n        if 'default' in def_prop.keys():\n            default = def_prop['default']\n        elif defaults and prefix + snake_prop_name in defaults:\n            default = defaults[snake_prop_name]\n        if prop_type == 'object':\n            ArkPydanticArgparse.schema_to_argparse(\n                def_prop, parser, defaults, f'{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n            )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in def_prop:\n                enum = def_prop\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n\n    @staticmethod\n    def __schema_allof_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        desc = ''\n        default: Optional[str] = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        for item in schema['properties'][prop_name]['allOf']:\n            if '$ref' in item.keys() and definitions:\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                if 'type' not in item.keys():\n                    continue\n                prop_type = item['type']\n                if 'default' in item.keys():\n                    default = item['default']\n                elif defaults and prefix + snake_prop_name in defaults:\n                    default = defaults[snake_prop_name]\n                if 'description' in item.keys():\n                    desc = item['description']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        item, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in item:\n                        enum = item['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n\n    @staticmethod\n    def __arg_in_schema(arg_key: str, schema: Dict[str, Any], definitions: Optional[Dict[str, Any]], prefix: str = '') -&gt; Optional[str]:\n        if 'properties' not in schema:\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if prefix + snake_prop_name == arg_key:\n                return schema['type']\n            else:\n                return None\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if '$ref' in schema['properties'][prop_name].keys():\n                def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        return 'string'\n                    continue\n                if def_prop['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    return def_prop['type']\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                for item in schema['properties'][prop_name]['allOf']:\n                    if '$ref' in item.keys():\n                        def_prop_name = item['$ref'].split('/')[2]\n                        def_prop = definitions[def_prop_name]\n                        if 'type' not in def_prop.keys():\n                            if 'enum' in def_prop.keys():\n                                return 'string'\n                            continue\n                        if def_prop['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                                return def_prop['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return def_prop['type']\n                    if 'type' in item.keys():\n                        if item['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, item, definitions, f'{prefix}{snake_prop_name}.'):\n                                return item['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return item['type']\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                if prefix + snake_prop_name == arg_key:\n                    return 'string'\n            elif 'type' in schema['properties'][prop_name].keys():\n                if prefix + snake_prop_name == arg_key:\n                    return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(\n                        arg_key, schema['properties'][prop_name], definitions, f'{prefix}{snake_prop_name}.'\n                    ):\n                        return schema['properties'][prop_name]['type']\n        return None\n\n    @staticmethod\n    def __arg_to_schema(\n        arg_key: str, arg_val: Any, args_map: Dict[str, Any], arg_type: str, keep_empty_values: bool = False, key_prefix: str = ''\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if '.' in arg_key:\n            args = arg_key.split('.')\n            key = args[0]\n            if key not in args_map.keys() or args_map[key] == None:\n                args_map[key] = {}\n            ArkPydanticArgparse.__arg_to_schema('.'.join(args[1:]), arg_val, args_map[key], arg_type, key_prefix)\n        elif arg_val != None or keep_empty_values:\n            if arg_type == 'array':\n                if isinstance(arg_val, list):\n                    args_map[key_prefix + arg_key] = arg_val\n                elif re.match('({.*},?)+', arg_val) != None:\n                    objs = []\n                    for m in re.finditer('{.*?}', arg_val):\n                        objs.append(json.loads(m.group(0)))\n                    args_map[key_prefix + arg_key] = objs\n                else:\n                    args_map[key_prefix + arg_key] = arg_val.split(',')\n            elif arg_type == 'object' and not isinstance(arg_val, (int, bool, float)):\n                if isinstance(arg_val, list):\n                    arg_val = ','.join(arg_val)\n                if '=' not in arg_val:\n                    args_map[key_prefix + arg_key] = arg_val\n                else:\n                    args_dict = dict(\n                        next(csv.reader([item], delimiter='=', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                        for item in next(csv.reader([arg_val], delimiter=',', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                    )\n                    if len(args_dict) &gt; 0:\n                        args_map[key_prefix + arg_key] = args_dict\n                    elif arg_key != 'extrafields':\n                        args_map[key_prefix + arg_key] = arg_val\n            else:\n                args_map[key_prefix + arg_key] = arg_val\n\n    @staticmethod\n    def schema_to_argparse(\n        schema: Dict[str, Any],\n        parser: argparse.ArgumentParser,\n        defaults: Optional[Dict[str, str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        required: Optional[List[str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        \"\"\"\n        Converts the given schema to argparse parameters.\n\n        Recursively iterates over the JSON schema and adds parameters to the parser.\n        The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n\n        This function does not return anything, but updates the parser itself.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            parser (argparse.ArgumentParser): _description_\n            defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            required (Optional[List[str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n        \"\"\"\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not required and 'required' in schema.keys():\n            required = schema['required']\n        elif not required:\n            required = []\n        if 'properties' not in schema.keys():\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema.keys():\n                default = schema['default']\n            desc = ''\n            if 'description' in schema.keys():\n                desc = schema['description']\n            enum = None\n            if 'enum' in schema:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            return\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if '$ref' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_definition_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_allof_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                is_required = False\n                if prop_name in required:\n                    is_required = True\n                default = None\n                if 'default' in schema['properties'][prop_name].keys():\n                    default = schema['properties'][prop_name]['default']\n                desc = ''\n                if 'description' in schema['properties'][prop_name].keys():\n                    desc = schema['properties'][prop_name]['description']\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n                continue\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            elif defaults and prefix + snake_prop_name in defaults.keys():\n                default = defaults[snake_prop_name]\n            if 'type' not in schema['properties'][prop_name].keys():\n                if 'enum' in schema['properties'][prop_name].keys():\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                continue\n            prop_type = schema['properties'][prop_name]['type']\n            if prop_type == 'object':\n                if (\n                    'properties' not in schema['properties'][prop_name]\n                    and (\n                        'additionalProperties' in schema['properties'][prop_name]\n                        and 'type' in schema['properties'][prop_name]['additionalProperties']\n                        and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                    )\n                    or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n                ):\n                    # Special use case for dicitionary\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                else:\n                    ArkPydanticArgparse.schema_to_argparse(\n                        schema['properties'][prop_name],\n                        parser,\n                        defaults,\n                        f'{prefix}{snake_prop_name}.',\n                        definitions,\n                        required,\n                        ignore_keys,\n                        key_prefix,\n                    )\n            else:\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n\n    @staticmethod\n    def schema_to_aliases(\n        schema: Dict[str, Any],\n        override_aliases: Optional[Dict[str, str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        key_prefix: str = '',\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n        Converts a schema to only a dictionary containing its aliases (title).\n        Returns a string to string dictionary with the aliases.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n\n        Returns:\n            Dict[str, str]: _description_\n        \"\"\"\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if 'properties' not in schema:\n            return {}\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not override_aliases:\n            override_aliases = {}\n        aliases_map: Dict[str, Any] = {}\n        for prop_name in schema['properties']:\n            snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n                continue\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if snake_prop_name in override_aliases:\n                aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n            else:\n                aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n            if 'type' in schema['properties'][prop_name]:\n                if schema['properties'][prop_name]['type'] == 'object':\n                    aliases_map.update(\n                        ArkPydanticArgparse.schema_to_aliases(\n                            schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                        )\n                    )\n        return aliases_map\n\n    @staticmethod\n    def argparse_to_schema(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        keep_empty_values: bool = False,\n        key_prefix: str = '',\n        ignored_keys: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given JSON schema and argparse args into a finalized dictionary.\n        The conversion is recursive and converts keys according to snake case.\n\n        Returns a finalized args dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            keep_empty_values (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        file_args_map: Dict = {}\n        args_map: Dict = {}\n        definitions: Optional[Dict] = None\n        if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n            request_file = args.__dict__['request_file']\n            with open(request_file, 'r', encoding='utf-8') as f:\n                loaded_args_map = json.load(f)\n                for key, value in loaded_args_map.items():\n                    first, *others = key.split('_')\n                    file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        for arg_key, arg_val in args.__dict__.items():\n            if ignored_keys and arg_key in ignored_keys:\n                continue\n            if key_prefix:\n                arg_key = arg_key.replace(f'{key_prefix}_', '')\n            arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n            if not arg_type:\n                continue\n            ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n        args_map.update(file_args_map)\n        return args_map\n\n    @staticmethod\n    def argparse_to_schema_interactive(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        ignored_keys: Optional[List[str]] = None,\n        existing_values: Optional[Dict[str, Any]] = None,\n        hidden_keys: Optional[List[str]] = None,\n        override_aliases: Optional[Dict[str, str]] = None,\n        key_prefix: str = '',\n        empty_allowed_keys: Optional[List[str]] = None,\n        default_values: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given schema and args into a finalized dictionary.\n        The function interacts with the user and requests args that were not provided in the CLI.\n\n        Returns a dict that combines the schema with the user inputs.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        if key_prefix:\n            existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n        args_map = {\n            k: existing_values[k]\n            if existing_values and k in existing_values and existing_values[k] != None\n            else v\n            if v\n            else default_values[k]\n            if default_values and k in default_values\n            else None\n            for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n        }\n        aliases_map = {\n            k: v\n            for k, v in ArkPydanticArgparse.schema_to_aliases(\n                schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n            ).items()\n            if k in args_map\n        }\n        for k, v in aliases_map.items():\n            if ignored_keys and k in ignored_keys:\n                continue\n            args_map[k] = ArkArgsFormatter.get_arg(\n                args=args,\n                key=k,\n                prompt=v,\n                existing_val=args_map[k],\n                hidden=k in hidden_keys if hidden_keys else False,\n                prioritize_existing_val=True,\n                empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n            )\n        if key_prefix:\n            return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n        return args_map\n\n    @staticmethod\n    def merge_by_model(\n        model: Type[BaseModel],\n        existing_model: BaseModel,\n        new_vals: Union[BaseModel, Dict[str, Any]],\n        by_alias: bool = False,\n        key_prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        defaults: Optional[Dict[str, Any]] = None,\n    ) -&gt; BaseModel:\n        \"\"\"\n        Merges the given existing model with new values.\n        The new values can be either a base model or dictionary of values.\n        When provided, the merging is based on the specified key prefix.\n\n        Args:\n            model (Type[BaseModel]): _description_\n            existing_model (BaseModel): _description_\n            new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n            by_alias (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            BaseModel: _description_\n        \"\"\"\n        if key_prefix:\n            new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n        if isinstance(new_vals, BaseModel):\n            new_vals = new_vals.dict(by_alias=by_alias)\n        new_vals = {k: v for k, v in new_vals.items() if v is not None}\n        vals_dict = existing_model.dict(by_alias=by_alias)\n        if ignore_keys:\n            new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n        vals_dict.update(new_vals)\n        if defaults:\n            vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n        return model.parse_obj(vals_dict)\n\n    @staticmethod\n    def schema_to_simple_arguments(\n        schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Exports model's schema as task's input parameters dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        Returns:\n            Dict[str, TaskInputParameter]: _description_\n        \"\"\"\n        definitions: dict = None\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        parser = argparse.ArgumentParser()\n        ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n        input_args = {}\n        if extra_params:\n            input_args.update(extra_params)\n        for action in parser._actions:  # pylint: disable=protected-access\n            if '_HelpAction' not in str(type(action)):\n                arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n                action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n                if 'strtobool' in str(action_type):\n                    action_type = bool\n                if 'format' in arg_info and arg_info['format'] == 'password':\n                    action_type = 'secret'\n                default = action.default\n                name = action.dest\n                input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n                if default is not None:\n                    input_args[name]['default'] = default\n                if action.choices:\n                    input_args[name]['choices'] = action.choices\n        for _, val in input_args.items():\n            if val['type'] == bool:\n                val['type'] = 'boolean'\n            elif 'choices' in val:\n                val['type'] = 'choice'\n                val['choices'] = [str(v) for v in val['choices']]\n            elif val['type'] != 'secret':\n                val['type'] = 'string'\n            if 'default' not in val:\n                val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n            if val['type'] == 'string':\n                val['default'] = str(val['default'])\n        return input_args\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.argparse_to_schema","title":"<code>argparse_to_schema(schema, args, keep_empty_values=False, key_prefix='', ignored_keys=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given JSON schema and argparse args into a finalized dictionary. The conversion is recursive and converts keys according to snake case.</p> <p>Returns a finalized args dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>keep_empty_values</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    keep_empty_values: bool = False,\n    key_prefix: str = '',\n    ignored_keys: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given JSON schema and argparse args into a finalized dictionary.\n    The conversion is recursive and converts keys according to snake case.\n\n    Returns a finalized args dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        keep_empty_values (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    file_args_map: Dict = {}\n    args_map: Dict = {}\n    definitions: Optional[Dict] = None\n    if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n        request_file = args.__dict__['request_file']\n        with open(request_file, 'r', encoding='utf-8') as f:\n            loaded_args_map = json.load(f)\n            for key, value in loaded_args_map.items():\n                first, *others = key.split('_')\n                file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    for arg_key, arg_val in args.__dict__.items():\n        if ignored_keys and arg_key in ignored_keys:\n            continue\n        if key_prefix:\n            arg_key = arg_key.replace(f'{key_prefix}_', '')\n        arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n        if not arg_type:\n            continue\n        ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n    args_map.update(file_args_map)\n    return args_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.argparse_to_schema_interactive","title":"<code>argparse_to_schema_interactive(schema, args, ignored_keys=None, existing_values=None, hidden_keys=None, override_aliases=None, key_prefix='', empty_allowed_keys=None, default_values=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given schema and args into a finalized dictionary. The function interacts with the user and requests args that were not provided in the CLI.</p> <p>Returns a dict that combines the schema with the user inputs.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>existing_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>hidden_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>empty_allowed_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>default_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema_interactive(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    ignored_keys: Optional[List[str]] = None,\n    existing_values: Optional[Dict[str, Any]] = None,\n    hidden_keys: Optional[List[str]] = None,\n    override_aliases: Optional[Dict[str, str]] = None,\n    key_prefix: str = '',\n    empty_allowed_keys: Optional[List[str]] = None,\n    default_values: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given schema and args into a finalized dictionary.\n    The function interacts with the user and requests args that were not provided in the CLI.\n\n    Returns a dict that combines the schema with the user inputs.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    if key_prefix:\n        existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n    args_map = {\n        k: existing_values[k]\n        if existing_values and k in existing_values and existing_values[k] != None\n        else v\n        if v\n        else default_values[k]\n        if default_values and k in default_values\n        else None\n        for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n    }\n    aliases_map = {\n        k: v\n        for k, v in ArkPydanticArgparse.schema_to_aliases(\n            schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n        ).items()\n        if k in args_map\n    }\n    for k, v in aliases_map.items():\n        if ignored_keys and k in ignored_keys:\n            continue\n        args_map[k] = ArkArgsFormatter.get_arg(\n            args=args,\n            key=k,\n            prompt=v,\n            existing_val=args_map[k],\n            hidden=k in hidden_keys if hidden_keys else False,\n            prioritize_existing_val=True,\n            empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n        )\n    if key_prefix:\n        return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n    return args_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.merge_by_model","title":"<code>merge_by_model(model, existing_model, new_vals, by_alias=False, key_prefix='', ignore_keys=None, defaults=None)</code>  <code>staticmethod</code>","text":"<p>Merges the given existing model with new values. The new values can be either a base model or dictionary of values. When provided, the merging is based on the specified key prefix.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>description</p> required <code>existing_model</code> <code>BaseModel</code> <p>description</p> required <code>new_vals</code> <code>Union[BaseModel, Dict[str, Any]]</code> <p>description</p> required <code>by_alias</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>defaults</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef merge_by_model(\n    model: Type[BaseModel],\n    existing_model: BaseModel,\n    new_vals: Union[BaseModel, Dict[str, Any]],\n    by_alias: bool = False,\n    key_prefix: str = '',\n    ignore_keys: Optional[List[str]] = None,\n    defaults: Optional[Dict[str, Any]] = None,\n) -&gt; BaseModel:\n    \"\"\"\n    Merges the given existing model with new values.\n    The new values can be either a base model or dictionary of values.\n    When provided, the merging is based on the specified key prefix.\n\n    Args:\n        model (Type[BaseModel]): _description_\n        existing_model (BaseModel): _description_\n        new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n        by_alias (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        BaseModel: _description_\n    \"\"\"\n    if key_prefix:\n        new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n    if isinstance(new_vals, BaseModel):\n        new_vals = new_vals.dict(by_alias=by_alias)\n    new_vals = {k: v for k, v in new_vals.items() if v is not None}\n    vals_dict = existing_model.dict(by_alias=by_alias)\n    if ignore_keys:\n        new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n    vals_dict.update(new_vals)\n    if defaults:\n        vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n    return model.parse_obj(vals_dict)\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_aliases","title":"<code>schema_to_aliases(schema, override_aliases=None, ignore_keys=None, prefix='', definitions=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a schema to only a dictionary containing its aliases (title). Returns a string to string dictionary with the aliases.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_aliases(\n    schema: Dict[str, Any],\n    override_aliases: Optional[Dict[str, str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    key_prefix: str = '',\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Converts a schema to only a dictionary containing its aliases (title).\n    Returns a string to string dictionary with the aliases.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n\n    Returns:\n        Dict[str, str]: _description_\n    \"\"\"\n    if key_prefix:\n        key_prefix = key_prefix + '_'\n    if 'properties' not in schema:\n        return {}\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not override_aliases:\n        override_aliases = {}\n    aliases_map: Dict[str, Any] = {}\n    for prop_name in schema['properties']:\n        snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n        if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n            continue\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if snake_prop_name in override_aliases:\n            aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n        else:\n            aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n        if 'type' in schema['properties'][prop_name]:\n            if schema['properties'][prop_name]['type'] == 'object':\n                aliases_map.update(\n                    ArkPydanticArgparse.schema_to_aliases(\n                        schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                    )\n                )\n    return aliases_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_argparse","title":"<code>schema_to_argparse(schema, parser, defaults=None, prefix='', definitions=None, required=None, ignore_keys=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts the given schema to argparse parameters.</p> <p>Recursively iterates over the JSON schema and adds parameters to the parser. The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.</p> <p>This function does not return anything, but updates the parser itself.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>parser</code> <code>ArgumentParser</code> <p>description</p> required <code>defaults</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>required</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_argparse(\n    schema: Dict[str, Any],\n    parser: argparse.ArgumentParser,\n    defaults: Optional[Dict[str, str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    required: Optional[List[str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    key_prefix: str = '',\n) -&gt; None:\n    \"\"\"\n    Converts the given schema to argparse parameters.\n\n    Recursively iterates over the JSON schema and adds parameters to the parser.\n    The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n\n    This function does not return anything, but updates the parser itself.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        parser (argparse.ArgumentParser): _description_\n        defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        required (Optional[List[str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n    \"\"\"\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not required and 'required' in schema.keys():\n        required = schema['required']\n    elif not required:\n        required = []\n    if 'properties' not in schema.keys():\n        prop_name = schema['title']\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        is_required = False\n        if prop_name in required:\n            is_required = True\n        default = None\n        if 'default' in schema.keys():\n            default = schema['default']\n        desc = ''\n        if 'description' in schema.keys():\n            desc = schema['description']\n        enum = None\n        if 'enum' in schema:\n            enum = schema['enum']\n        ArkPydanticArgparse.__populate_type(\n            schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n        )\n        return\n    for prop_name in schema['properties'].keys():\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if '$ref' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_definition_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif 'allOf' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_allof_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif (\n            'anyOf' in schema['properties'][prop_name].keys()\n            and isinstance(schema['properties'][prop_name]['anyOf'], list)\n            and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n        ):\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            continue\n        desc = ''\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        default = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'type' not in schema['properties'][prop_name].keys():\n            if 'enum' in schema['properties'][prop_name].keys():\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            continue\n        prop_type = schema['properties'][prop_name]['type']\n        if prop_type == 'object':\n            if (\n                'properties' not in schema['properties'][prop_name]\n                and (\n                    'additionalProperties' in schema['properties'][prop_name]\n                    and 'type' in schema['properties'][prop_name]['additionalProperties']\n                    and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                )\n                or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n            ):\n                # Special use case for dicitionary\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            else:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema['properties'][prop_name],\n                    parser,\n                    defaults,\n                    f'{prefix}{snake_prop_name}.',\n                    definitions,\n                    required,\n                    ignore_keys,\n                    key_prefix,\n                )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['properties'][prop_name]['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_simple_arguments","title":"<code>schema_to_simple_arguments(schema, ignore_keys=None, extra_params=None)</code>  <code>staticmethod</code>","text":"<p>Exports model's schema as task's input parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_simple_arguments(\n    schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Exports model's schema as task's input parameters dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n    Returns:\n        Dict[str, TaskInputParameter]: _description_\n    \"\"\"\n    definitions: dict = None\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    parser = argparse.ArgumentParser()\n    ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n    input_args = {}\n    if extra_params:\n        input_args.update(extra_params)\n    for action in parser._actions:  # pylint: disable=protected-access\n        if '_HelpAction' not in str(type(action)):\n            arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n            action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n            if 'strtobool' in str(action_type):\n                action_type = bool\n            if 'format' in arg_info and arg_info['format'] == 'password':\n                action_type = 'secret'\n            default = action.default\n            name = action.dest\n            input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n            if default is not None:\n                input_args[name]['default'] = default\n            if action.choices:\n                input_args[name]['choices'] = action.choices\n    for _, val in input_args.items():\n        if val['type'] == bool:\n            val['type'] = 'boolean'\n        elif 'choices' in val:\n            val['type'] = 'choice'\n            val['choices'] = [str(v) for v in val['choices']]\n        elif val['type'] != 'secret':\n            val['type'] = 'string'\n        if 'default' not in val:\n            val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n        if val['type'] == 'string':\n            val['default'] = str(val['default'])\n    return input_args\n</code></pre>"},{"location":"reference/args/ark_args_formatter/","title":"ark_args_formatter","text":""},{"location":"reference/args/ark_pydantic_argparse/","title":"ark_pydantic_argparse","text":""},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse","title":"<code>ArkPydanticArgparse</code>","text":"Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>class ArkPydanticArgparse:\n    @staticmethod\n    def __populate_type(\n        prop_type: str,\n        snake_prop_name: str,\n        default: Optional[str],\n        required: bool,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        description: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        enum: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '-'\n        if ignore_keys != None and snake_prop_name in ignore_keys:\n            return\n        if default != None:\n            required = False\n        if isinstance(default, Enum):\n            default = default.value\n        arg_type = None\n        if prop_type == 'string':\n            arg_type = str\n        elif prop_type == 'integer':\n            arg_type = int\n        elif prop_type == 'boolean':\n            arg_type = bool\n        elif prop_type == 'object':\n            arg_type = object\n        else:\n            arg_type = str\n        long_name = key_prefix + prefix + snake_prop_name\n        shorted_name = ''.join([s[0] for s in long_name.replace('.', '-').split('-')])\n        for i in range(5):\n            for action in parser._actions:  # pylint: disable=protected-access\n                if f'-{shorted_name}' in action.option_strings:\n                    shorted_name = ''.join([s[: i + 1] for s in long_name.split('-')])\n                    break\n        if arg_type == bool:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                action='store_true',\n                help=description,\n            )\n            if long_name != 'poll':\n                parser.add_argument(\n                    '-n' + shorted_name,\n                    '--no-' + long_name,\n                    dest=long_name.replace('-', '_'),\n                    required='--request-file' not in ' '.join(sys.argv) and required,\n                    action='store_false',\n                    help=description,\n                )\n            parser.set_defaults(**{f\"{long_name.replace('-', '_')}\": default})\n        elif arg_type == object:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                metavar=\"KEY=VALUE\",\n                nargs='+',\n                default=default,\n                help=description,\n            )\n        else:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                type=arg_type,\n                default=default,\n                help=description,\n                choices=enum,\n            )\n\n    @staticmethod\n    def __schema_definition_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if not definitions:\n            return\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n        def_prop = definitions[def_prop_name]\n        if 'type' not in def_prop.keys():\n            return\n        prop_type = def_prop['type']\n        desc = ''\n        if 'description' in def_prop.keys():\n            desc = def_prop['description']\n        default: Optional[str] = None\n        if 'default' in def_prop.keys():\n            default = def_prop['default']\n        elif defaults and prefix + snake_prop_name in defaults:\n            default = defaults[snake_prop_name]\n        if prop_type == 'object':\n            ArkPydanticArgparse.schema_to_argparse(\n                def_prop, parser, defaults, f'{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n            )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in def_prop:\n                enum = def_prop\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n\n    @staticmethod\n    def __schema_allof_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        desc = ''\n        default: Optional[str] = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        for item in schema['properties'][prop_name]['allOf']:\n            if '$ref' in item.keys() and definitions:\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                if 'type' not in item.keys():\n                    continue\n                prop_type = item['type']\n                if 'default' in item.keys():\n                    default = item['default']\n                elif defaults and prefix + snake_prop_name in defaults:\n                    default = defaults[snake_prop_name]\n                if 'description' in item.keys():\n                    desc = item['description']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        item, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in item:\n                        enum = item['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n\n    @staticmethod\n    def __arg_in_schema(arg_key: str, schema: Dict[str, Any], definitions: Optional[Dict[str, Any]], prefix: str = '') -&gt; Optional[str]:\n        if 'properties' not in schema:\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if prefix + snake_prop_name == arg_key:\n                return schema['type']\n            else:\n                return None\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if '$ref' in schema['properties'][prop_name].keys():\n                def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        return 'string'\n                    continue\n                if def_prop['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    return def_prop['type']\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                for item in schema['properties'][prop_name]['allOf']:\n                    if '$ref' in item.keys():\n                        def_prop_name = item['$ref'].split('/')[2]\n                        def_prop = definitions[def_prop_name]\n                        if 'type' not in def_prop.keys():\n                            if 'enum' in def_prop.keys():\n                                return 'string'\n                            continue\n                        if def_prop['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                                return def_prop['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return def_prop['type']\n                    if 'type' in item.keys():\n                        if item['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, item, definitions, f'{prefix}{snake_prop_name}.'):\n                                return item['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return item['type']\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                if prefix + snake_prop_name == arg_key:\n                    return 'string'\n            elif 'type' in schema['properties'][prop_name].keys():\n                if prefix + snake_prop_name == arg_key:\n                    return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(\n                        arg_key, schema['properties'][prop_name], definitions, f'{prefix}{snake_prop_name}.'\n                    ):\n                        return schema['properties'][prop_name]['type']\n        return None\n\n    @staticmethod\n    def __arg_to_schema(\n        arg_key: str, arg_val: Any, args_map: Dict[str, Any], arg_type: str, keep_empty_values: bool = False, key_prefix: str = ''\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if '.' in arg_key:\n            args = arg_key.split('.')\n            key = args[0]\n            if key not in args_map.keys() or args_map[key] == None:\n                args_map[key] = {}\n            ArkPydanticArgparse.__arg_to_schema('.'.join(args[1:]), arg_val, args_map[key], arg_type, key_prefix)\n        elif arg_val != None or keep_empty_values:\n            if arg_type == 'array':\n                if isinstance(arg_val, list):\n                    args_map[key_prefix + arg_key] = arg_val\n                elif re.match('({.*},?)+', arg_val) != None:\n                    objs = []\n                    for m in re.finditer('{.*?}', arg_val):\n                        objs.append(json.loads(m.group(0)))\n                    args_map[key_prefix + arg_key] = objs\n                else:\n                    args_map[key_prefix + arg_key] = arg_val.split(',')\n            elif arg_type == 'object' and not isinstance(arg_val, (int, bool, float)):\n                if isinstance(arg_val, list):\n                    arg_val = ','.join(arg_val)\n                if '=' not in arg_val:\n                    args_map[key_prefix + arg_key] = arg_val\n                else:\n                    args_dict = dict(\n                        next(csv.reader([item], delimiter='=', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                        for item in next(csv.reader([arg_val], delimiter=',', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                    )\n                    if len(args_dict) &gt; 0:\n                        args_map[key_prefix + arg_key] = args_dict\n                    elif arg_key != 'extrafields':\n                        args_map[key_prefix + arg_key] = arg_val\n            else:\n                args_map[key_prefix + arg_key] = arg_val\n\n    @staticmethod\n    def schema_to_argparse(\n        schema: Dict[str, Any],\n        parser: argparse.ArgumentParser,\n        defaults: Optional[Dict[str, str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        required: Optional[List[str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        \"\"\"\n        Converts the given schema to argparse parameters.\n\n        Recursively iterates over the JSON schema and adds parameters to the parser.\n        The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n\n        This function does not return anything, but updates the parser itself.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            parser (argparse.ArgumentParser): _description_\n            defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            required (Optional[List[str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n        \"\"\"\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not required and 'required' in schema.keys():\n            required = schema['required']\n        elif not required:\n            required = []\n        if 'properties' not in schema.keys():\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema.keys():\n                default = schema['default']\n            desc = ''\n            if 'description' in schema.keys():\n                desc = schema['description']\n            enum = None\n            if 'enum' in schema:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            return\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if '$ref' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_definition_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_allof_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                is_required = False\n                if prop_name in required:\n                    is_required = True\n                default = None\n                if 'default' in schema['properties'][prop_name].keys():\n                    default = schema['properties'][prop_name]['default']\n                desc = ''\n                if 'description' in schema['properties'][prop_name].keys():\n                    desc = schema['properties'][prop_name]['description']\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n                continue\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            elif defaults and prefix + snake_prop_name in defaults.keys():\n                default = defaults[snake_prop_name]\n            if 'type' not in schema['properties'][prop_name].keys():\n                if 'enum' in schema['properties'][prop_name].keys():\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                continue\n            prop_type = schema['properties'][prop_name]['type']\n            if prop_type == 'object':\n                if (\n                    'properties' not in schema['properties'][prop_name]\n                    and (\n                        'additionalProperties' in schema['properties'][prop_name]\n                        and 'type' in schema['properties'][prop_name]['additionalProperties']\n                        and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                    )\n                    or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n                ):\n                    # Special use case for dicitionary\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                else:\n                    ArkPydanticArgparse.schema_to_argparse(\n                        schema['properties'][prop_name],\n                        parser,\n                        defaults,\n                        f'{prefix}{snake_prop_name}.',\n                        definitions,\n                        required,\n                        ignore_keys,\n                        key_prefix,\n                    )\n            else:\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n\n    @staticmethod\n    def schema_to_aliases(\n        schema: Dict[str, Any],\n        override_aliases: Optional[Dict[str, str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        key_prefix: str = '',\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n        Converts a schema to only a dictionary containing its aliases (title).\n        Returns a string to string dictionary with the aliases.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n\n        Returns:\n            Dict[str, str]: _description_\n        \"\"\"\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if 'properties' not in schema:\n            return {}\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not override_aliases:\n            override_aliases = {}\n        aliases_map: Dict[str, Any] = {}\n        for prop_name in schema['properties']:\n            snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n                continue\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if snake_prop_name in override_aliases:\n                aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n            else:\n                aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n            if 'type' in schema['properties'][prop_name]:\n                if schema['properties'][prop_name]['type'] == 'object':\n                    aliases_map.update(\n                        ArkPydanticArgparse.schema_to_aliases(\n                            schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                        )\n                    )\n        return aliases_map\n\n    @staticmethod\n    def argparse_to_schema(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        keep_empty_values: bool = False,\n        key_prefix: str = '',\n        ignored_keys: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given JSON schema and argparse args into a finalized dictionary.\n        The conversion is recursive and converts keys according to snake case.\n\n        Returns a finalized args dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            keep_empty_values (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        file_args_map: Dict = {}\n        args_map: Dict = {}\n        definitions: Optional[Dict] = None\n        if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n            request_file = args.__dict__['request_file']\n            with open(request_file, 'r', encoding='utf-8') as f:\n                loaded_args_map = json.load(f)\n                for key, value in loaded_args_map.items():\n                    first, *others = key.split('_')\n                    file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        for arg_key, arg_val in args.__dict__.items():\n            if ignored_keys and arg_key in ignored_keys:\n                continue\n            if key_prefix:\n                arg_key = arg_key.replace(f'{key_prefix}_', '')\n            arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n            if not arg_type:\n                continue\n            ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n        args_map.update(file_args_map)\n        return args_map\n\n    @staticmethod\n    def argparse_to_schema_interactive(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        ignored_keys: Optional[List[str]] = None,\n        existing_values: Optional[Dict[str, Any]] = None,\n        hidden_keys: Optional[List[str]] = None,\n        override_aliases: Optional[Dict[str, str]] = None,\n        key_prefix: str = '',\n        empty_allowed_keys: Optional[List[str]] = None,\n        default_values: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the given schema and args into a finalized dictionary.\n        The function interacts with the user and requests args that were not provided in the CLI.\n\n        Returns a dict that combines the schema with the user inputs.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        if key_prefix:\n            existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n        args_map = {\n            k: existing_values[k]\n            if existing_values and k in existing_values and existing_values[k] != None\n            else v\n            if v\n            else default_values[k]\n            if default_values and k in default_values\n            else None\n            for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n        }\n        aliases_map = {\n            k: v\n            for k, v in ArkPydanticArgparse.schema_to_aliases(\n                schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n            ).items()\n            if k in args_map\n        }\n        for k, v in aliases_map.items():\n            if ignored_keys and k in ignored_keys:\n                continue\n            args_map[k] = ArkArgsFormatter.get_arg(\n                args=args,\n                key=k,\n                prompt=v,\n                existing_val=args_map[k],\n                hidden=k in hidden_keys if hidden_keys else False,\n                prioritize_existing_val=True,\n                empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n            )\n        if key_prefix:\n            return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n        return args_map\n\n    @staticmethod\n    def merge_by_model(\n        model: Type[BaseModel],\n        existing_model: BaseModel,\n        new_vals: Union[BaseModel, Dict[str, Any]],\n        by_alias: bool = False,\n        key_prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        defaults: Optional[Dict[str, Any]] = None,\n    ) -&gt; BaseModel:\n        \"\"\"\n        Merges the given existing model with new values.\n        The new values can be either a base model or dictionary of values.\n        When provided, the merging is based on the specified key prefix.\n\n        Args:\n            model (Type[BaseModel]): _description_\n            existing_model (BaseModel): _description_\n            new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n            by_alias (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            BaseModel: _description_\n        \"\"\"\n        if key_prefix:\n            new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n        if isinstance(new_vals, BaseModel):\n            new_vals = new_vals.dict(by_alias=by_alias)\n        new_vals = {k: v for k, v in new_vals.items() if v is not None}\n        vals_dict = existing_model.dict(by_alias=by_alias)\n        if ignore_keys:\n            new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n        vals_dict.update(new_vals)\n        if defaults:\n            vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n        return model.parse_obj(vals_dict)\n\n    @staticmethod\n    def schema_to_simple_arguments(\n        schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Exports model's schema as task's input parameters dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        Returns:\n            Dict[str, TaskInputParameter]: _description_\n        \"\"\"\n        definitions: dict = None\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        parser = argparse.ArgumentParser()\n        ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n        input_args = {}\n        if extra_params:\n            input_args.update(extra_params)\n        for action in parser._actions:  # pylint: disable=protected-access\n            if '_HelpAction' not in str(type(action)):\n                arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n                action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n                if 'strtobool' in str(action_type):\n                    action_type = bool\n                if 'format' in arg_info and arg_info['format'] == 'password':\n                    action_type = 'secret'\n                default = action.default\n                name = action.dest\n                input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n                if default is not None:\n                    input_args[name]['default'] = default\n                if action.choices:\n                    input_args[name]['choices'] = action.choices\n        for _, val in input_args.items():\n            if val['type'] == bool:\n                val['type'] = 'boolean'\n            elif 'choices' in val:\n                val['type'] = 'choice'\n                val['choices'] = [str(v) for v in val['choices']]\n            elif val['type'] != 'secret':\n                val['type'] = 'string'\n            if 'default' not in val:\n                val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n            if val['type'] == 'string':\n                val['default'] = str(val['default'])\n        return input_args\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.argparse_to_schema","title":"<code>argparse_to_schema(schema, args, keep_empty_values=False, key_prefix='', ignored_keys=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given JSON schema and argparse args into a finalized dictionary. The conversion is recursive and converts keys according to snake case.</p> <p>Returns a finalized args dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>keep_empty_values</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    keep_empty_values: bool = False,\n    key_prefix: str = '',\n    ignored_keys: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given JSON schema and argparse args into a finalized dictionary.\n    The conversion is recursive and converts keys according to snake case.\n\n    Returns a finalized args dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        keep_empty_values (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    file_args_map: Dict = {}\n    args_map: Dict = {}\n    definitions: Optional[Dict] = None\n    if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n        request_file = args.__dict__['request_file']\n        with open(request_file, 'r', encoding='utf-8') as f:\n            loaded_args_map = json.load(f)\n            for key, value in loaded_args_map.items():\n                first, *others = key.split('_')\n                file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    for arg_key, arg_val in args.__dict__.items():\n        if ignored_keys and arg_key in ignored_keys:\n            continue\n        if key_prefix:\n            arg_key = arg_key.replace(f'{key_prefix}_', '')\n        arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n        if not arg_type:\n            continue\n        ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n    args_map.update(file_args_map)\n    return args_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.argparse_to_schema_interactive","title":"<code>argparse_to_schema_interactive(schema, args, ignored_keys=None, existing_values=None, hidden_keys=None, override_aliases=None, key_prefix='', empty_allowed_keys=None, default_values=None)</code>  <code>staticmethod</code>","text":"<p>Converts the given schema and args into a finalized dictionary. The function interacts with the user and requests args that were not provided in the CLI.</p> <p>Returns a dict that combines the schema with the user inputs.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>existing_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>hidden_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>empty_allowed_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>default_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema_interactive(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    ignored_keys: Optional[List[str]] = None,\n    existing_values: Optional[Dict[str, Any]] = None,\n    hidden_keys: Optional[List[str]] = None,\n    override_aliases: Optional[Dict[str, str]] = None,\n    key_prefix: str = '',\n    empty_allowed_keys: Optional[List[str]] = None,\n    default_values: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the given schema and args into a finalized dictionary.\n    The function interacts with the user and requests args that were not provided in the CLI.\n\n    Returns a dict that combines the schema with the user inputs.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    if key_prefix:\n        existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n    args_map = {\n        k: existing_values[k]\n        if existing_values and k in existing_values and existing_values[k] != None\n        else v\n        if v\n        else default_values[k]\n        if default_values and k in default_values\n        else None\n        for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n    }\n    aliases_map = {\n        k: v\n        for k, v in ArkPydanticArgparse.schema_to_aliases(\n            schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n        ).items()\n        if k in args_map\n    }\n    for k, v in aliases_map.items():\n        if ignored_keys and k in ignored_keys:\n            continue\n        args_map[k] = ArkArgsFormatter.get_arg(\n            args=args,\n            key=k,\n            prompt=v,\n            existing_val=args_map[k],\n            hidden=k in hidden_keys if hidden_keys else False,\n            prioritize_existing_val=True,\n            empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n        )\n    if key_prefix:\n        return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n    return args_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.merge_by_model","title":"<code>merge_by_model(model, existing_model, new_vals, by_alias=False, key_prefix='', ignore_keys=None, defaults=None)</code>  <code>staticmethod</code>","text":"<p>Merges the given existing model with new values. The new values can be either a base model or dictionary of values. When provided, the merging is based on the specified key prefix.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>description</p> required <code>existing_model</code> <code>BaseModel</code> <p>description</p> required <code>new_vals</code> <code>Union[BaseModel, Dict[str, Any]]</code> <p>description</p> required <code>by_alias</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>defaults</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef merge_by_model(\n    model: Type[BaseModel],\n    existing_model: BaseModel,\n    new_vals: Union[BaseModel, Dict[str, Any]],\n    by_alias: bool = False,\n    key_prefix: str = '',\n    ignore_keys: Optional[List[str]] = None,\n    defaults: Optional[Dict[str, Any]] = None,\n) -&gt; BaseModel:\n    \"\"\"\n    Merges the given existing model with new values.\n    The new values can be either a base model or dictionary of values.\n    When provided, the merging is based on the specified key prefix.\n\n    Args:\n        model (Type[BaseModel]): _description_\n        existing_model (BaseModel): _description_\n        new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n        by_alias (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        BaseModel: _description_\n    \"\"\"\n    if key_prefix:\n        new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n    if isinstance(new_vals, BaseModel):\n        new_vals = new_vals.dict(by_alias=by_alias)\n    new_vals = {k: v for k, v in new_vals.items() if v is not None}\n    vals_dict = existing_model.dict(by_alias=by_alias)\n    if ignore_keys:\n        new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n    vals_dict.update(new_vals)\n    if defaults:\n        vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n    return model.parse_obj(vals_dict)\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_aliases","title":"<code>schema_to_aliases(schema, override_aliases=None, ignore_keys=None, prefix='', definitions=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a schema to only a dictionary containing its aliases (title). Returns a string to string dictionary with the aliases.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_aliases(\n    schema: Dict[str, Any],\n    override_aliases: Optional[Dict[str, str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    key_prefix: str = '',\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Converts a schema to only a dictionary containing its aliases (title).\n    Returns a string to string dictionary with the aliases.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n\n    Returns:\n        Dict[str, str]: _description_\n    \"\"\"\n    if key_prefix:\n        key_prefix = key_prefix + '_'\n    if 'properties' not in schema:\n        return {}\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not override_aliases:\n        override_aliases = {}\n    aliases_map: Dict[str, Any] = {}\n    for prop_name in schema['properties']:\n        snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n        if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n            continue\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if snake_prop_name in override_aliases:\n            aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n        else:\n            aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n        if 'type' in schema['properties'][prop_name]:\n            if schema['properties'][prop_name]['type'] == 'object':\n                aliases_map.update(\n                    ArkPydanticArgparse.schema_to_aliases(\n                        schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                    )\n                )\n    return aliases_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_argparse","title":"<code>schema_to_argparse(schema, parser, defaults=None, prefix='', definitions=None, required=None, ignore_keys=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts the given schema to argparse parameters.</p> <p>Recursively iterates over the JSON schema and adds parameters to the parser. The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.</p> <p>This function does not return anything, but updates the parser itself.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>parser</code> <code>ArgumentParser</code> <p>description</p> required <code>defaults</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>required</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_argparse(\n    schema: Dict[str, Any],\n    parser: argparse.ArgumentParser,\n    defaults: Optional[Dict[str, str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    required: Optional[List[str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    key_prefix: str = '',\n) -&gt; None:\n    \"\"\"\n    Converts the given schema to argparse parameters.\n\n    Recursively iterates over the JSON schema and adds parameters to the parser.\n    The argparse parameters can then be parsed from the CLI and then converted back using argparse_to_schema function.\n\n    This function does not return anything, but updates the parser itself.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        parser (argparse.ArgumentParser): _description_\n        defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        required (Optional[List[str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n    \"\"\"\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not required and 'required' in schema.keys():\n        required = schema['required']\n    elif not required:\n        required = []\n    if 'properties' not in schema.keys():\n        prop_name = schema['title']\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        is_required = False\n        if prop_name in required:\n            is_required = True\n        default = None\n        if 'default' in schema.keys():\n            default = schema['default']\n        desc = ''\n        if 'description' in schema.keys():\n            desc = schema['description']\n        enum = None\n        if 'enum' in schema:\n            enum = schema['enum']\n        ArkPydanticArgparse.__populate_type(\n            schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n        )\n        return\n    for prop_name in schema['properties'].keys():\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if '$ref' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_definition_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif 'allOf' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_allof_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif (\n            'anyOf' in schema['properties'][prop_name].keys()\n            and isinstance(schema['properties'][prop_name]['anyOf'], list)\n            and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n        ):\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            continue\n        desc = ''\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        default = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'type' not in schema['properties'][prop_name].keys():\n            if 'enum' in schema['properties'][prop_name].keys():\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            continue\n        prop_type = schema['properties'][prop_name]['type']\n        if prop_type == 'object':\n            if (\n                'properties' not in schema['properties'][prop_name]\n                and (\n                    'additionalProperties' in schema['properties'][prop_name]\n                    and 'type' in schema['properties'][prop_name]['additionalProperties']\n                    and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                )\n                or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n            ):\n                # Special use case for dicitionary\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            else:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema['properties'][prop_name],\n                    parser,\n                    defaults,\n                    f'{prefix}{snake_prop_name}.',\n                    definitions,\n                    required,\n                    ignore_keys,\n                    key_prefix,\n                )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['properties'][prop_name]['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_simple_arguments","title":"<code>schema_to_simple_arguments(schema, ignore_keys=None, extra_params=None)</code>  <code>staticmethod</code>","text":"<p>Exports model's schema as task's input parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_simple_arguments(\n    schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Exports model's schema as task's input parameters dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n    Returns:\n        Dict[str, TaskInputParameter]: _description_\n    \"\"\"\n    definitions: dict = None\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    parser = argparse.ArgumentParser()\n    ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n    input_args = {}\n    if extra_params:\n        input_args.update(extra_params)\n    for action in parser._actions:  # pylint: disable=protected-access\n        if '_HelpAction' not in str(type(action)):\n            arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n            action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n            if 'strtobool' in str(action_type):\n                action_type = bool\n            if 'format' in arg_info and arg_info['format'] == 'password':\n                action_type = 'secret'\n            default = action.default\n            name = action.dest\n            input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n            if default is not None:\n                input_args[name]['default'] = default\n            if action.choices:\n                input_args[name]['choices'] = action.choices\n    for _, val in input_args.items():\n        if val['type'] == bool:\n            val['type'] = 'boolean'\n        elif 'choices' in val:\n            val['type'] = 'choice'\n            val['choices'] = [str(v) for v in val['choices']]\n        elif val['type'] != 'secret':\n            val['type'] = 'string'\n        if 'default' not in val:\n            val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n        if val['type'] == 'string':\n            val['default'] = str(val['default'])\n    return input_args\n</code></pre>"},{"location":"reference/auth/","title":"auth","text":""},{"location":"reference/auth/ark_auth/","title":"ark_auth","text":""},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth","title":"<code>ArkAuth</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>class ArkAuth(ABC):\n    def __init__(self, cache_authentication: bool = True) -&gt; None:\n        self._logger = get_logger(app=self.__class__.__name__)\n        self._cache_authentication = cache_authentication\n        self._cache_keyring = None\n        if cache_authentication:\n            self._cache_keyring = ArkKeyring(self.authenticator_name())\n        self.__token = None\n        self._active_profile = None\n        self._active_auth_profile = None\n\n    def _resolve_cache_postfix(self, auth_profile: ArkAuthProfile) -&gt; str:\n        \"\"\"\n        Resolves the postfix used to get the token based on the auth method\n\n        Args:\n            auth_profile (ArkAuthProfile): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        postfix = auth_profile.username\n        if auth_profile.auth_method == ArkAuthMethod.Direct and auth_profile.auth_method_settings:\n            direct_method_settings = cast(DirectArkAuthMethodSettings, auth_profile.auth_method_settings)\n            if direct_method_settings.endpoint:\n                postfix = f'{postfix}_{urlparse(direct_method_settings.endpoint).netloc}'\n        return postfix\n\n    @abstractmethod\n    def _perform_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n    ) -&gt; ArkToken:\n        \"\"\"\n        Performs the actual authentication, based on the implementation\n\n        Args:\n            profile (ArkProfile): Profile to authenticate on\n            auth_profile (ArkAuthProfile): Specific auth profile for the authentication\n            secret (Optional[ArkSecret]): Secret used for authentication. Defaults to None\n            force (bool): Force authenticate and ignore caching\n\n        Returns:\n            Optional[ArkToken]: Token of the authentication to be used\n        \"\"\"\n\n    @abstractmethod\n    def _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        \"\"\"\n        Tries to perform refresh authentication on the existing token\n        This is not promised for all authenticators\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            token (ArkToken): _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n\n    def authenticate(\n        self,\n        profile: Optional[ArkProfile] = None,\n        auth_profile: Optional[ArkAuthProfile] = None,\n        secret: Optional[ArkSecret] = None,\n        force: bool = False,\n        refresh_auth: bool = False,\n    ) -&gt; ArkToken:\n        \"\"\"\n        Authenticates with the specified authenticator implementation.\n        The implementation is based on the `_perform_authentication` method.\n        When caching is allowed, authorization credentials are loaded from the cache.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile containing information about the environment and authentication methods\n            auth_profile (Optional[ArkAuthProfile]): Specific auth profile to use instead of the profile, when provided\n            secret (Optional[ArkSecret]): Secret used for authentication\n            force (bool): Determines whether to force authentication without cached credentials\n            refresh_auth (bool): Attempts to refresh an existing cached auth when it is available\n\n        Raises:\n            ArkAuthException: _description_\n\n        Returns:\n            ArkToken: The authentication token to use. The token is also saved in the object.\n        \"\"\"\n        if not auth_profile and not profile:\n            raise ArkAuthException('Either a profile or a specific auth profile must be supplied')\n        if not auth_profile and profile:\n            if self.authenticator_name() in profile.auth_profiles:\n                auth_profile = profile.auth_profiles[self.authenticator_name()]\n            else:\n                raise ArkAuthException(\n                    f'{self.authenticator_human_readable_name()} [{self.authenticator_name()}] is not defined within the authentication profiles'\n                )\n        if not profile:\n            profile = ArkProfileLoader.load_default_profile()\n        if auth_profile.auth_method not in self.supported_auth_methods() and auth_profile.auth_method != ArkAuthMethod.Default:\n            raise ArkAuthException(\n                f'{self.authenticator_human_readable_name()} does not support authentication method {auth_profile.auth_method}'\n            )\n        if auth_profile.auth_method == ArkAuthMethod.Default:\n            auth_profile.auth_method, auth_profile.auth_method_settings = self.default_auth_method()\n        if auth_profile.auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n            raise ArkAuthException(f'{self.authenticator_human_readable_name()} requires a username and optionally a secret')\n        ark_token = None\n        token_refreshed = False\n        if self._cache_authentication and self._cache_keyring and not force:\n            # Load the postfix of the token based on the auth profile and method type\n            ark_token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n            if ark_token and ark_token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                # Expired, try to refresh\n                if refresh_auth and ark_token.refresh_token:\n                    ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                    if ark_token:\n                        token_refreshed = True\n                else:\n                    ark_token = None\n        if not ark_token:\n            ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        elif refresh_auth and not token_refreshed:\n            try:\n                ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                if self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n            except Exception as ex:  # Fallback to normal authentication\n                self._logger.info(\n                    f'Refresh auth for [{self.authenticator_human_readable_name()}] failed, falling back to normal authentication [{str(ex)}]'\n                )\n                ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n                if self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        self.__token = ark_token\n        self._active_profile = profile\n        self._active_auth_profile = auth_profile\n        return ark_token\n\n    def is_authenticated(self, profile: ArkProfile) -&gt; bool:\n        \"\"\"\n        Checks whether the specified profile is authenticated (has a valid token), either from the keyring or in memory.\n        If the valid token originated from the keyring, it is loaded into memory.\n\n        Args:\n            profile (ArkProfile): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        self._logger.info(f'Checking if [{self.authenticator_name()}] is authenticated')\n        if self.__token:\n            self._logger.info('Token is already loaded')\n            return True\n        if self.authenticator_name() in profile.auth_profiles and self._cache_keyring:\n            self.__token = self._cache_keyring.load_token(profile, profile.auth_profiles[self.authenticator_name()].username)\n            if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                self.__token = None\n            else:\n                self._logger.info('Loaded token from cache successfully')\n            return self.__token != None\n        return False\n\n    def load_authentication(self, profile: Optional[ArkProfile] = None, refresh_auth: bool = False) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads and returns the authentication token from the cache, if it exists.\n        If specified, the method also attempts to refresh the token as needed.\n\n        Args:\n            profile (Optional[ArkProfile], optional): _description_. Defaults to None.\n            refresh_auth (bool, optional): _description_. Defaults to False.\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        self._logger.info(f'Trying to load [{self.authenticator_name()}] authentication')\n        if not profile:\n            if self._active_profile:\n                profile = self._active_profile\n            else:\n                profile = ArkProfileLoader.load_default_profile()\n        auth_profile = self._active_auth_profile\n        if not auth_profile and self.authenticator_name() in profile.auth_profiles:\n            auth_profile = profile.auth_profiles[self.authenticator_name()]\n        if auth_profile:\n            self._logger.info(\n                f'Loading authentication for profile [{profile.profile_name}] and auth profile [{self.authenticator_name()}] of type [{auth_profile.auth_method.value}]'\n            )\n            if self._cache_keyring:\n                self.__token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n            if refresh_auth:\n                if (\n                    self.__token\n                    and self.__token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)\n                    &gt; datetime.now()\n                ):\n                    self._logger.info('Token did not pass grace expiration, no need to refresh')\n                else:\n                    self._logger.info('Trying to refresh token authentication')\n                    self.__token = self._perform_refresh_authentication(profile, auth_profile, self.__token)\n                    if self.__token and self.__token.expires_in.replace(tzinfo=None) &gt; datetime.now():\n                        self._logger.info('Token refreshed')\n                    if self.__token and self._cache_authentication and self._cache_keyring:\n                        self._cache_keyring.save_token(profile, self.__token, self._resolve_cache_postfix(auth_profile))\n            if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                self.__token = None\n            if self.__token:\n                self._active_profile = profile\n                self._active_auth_profile = auth_profile\n            return self.__token\n        return None\n\n    @property\n    def token(self) -&gt; Optional[ArkToken]:\n        return self.__token\n\n    @property\n    def active_profile(self) -&gt; Optional[ArkProfile]:\n        return self._active_profile\n\n    @property\n    def active_auth_profile(self) -&gt; Optional[ArkAuthProfile]:\n        return self._active_auth_profile\n\n    @staticmethod\n    @abstractmethod\n    def authenticator_name() -&gt; str:\n        \"\"\"\n        Returns the name of the authenticator used for the auth profile and services.\n\n        Returns:\n            str: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def authenticator_human_readable_name() -&gt; str:\n        \"\"\"\n        Returns the human-readable name of the authenticator.\n\n        Returns:\n            str: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def supported_auth_methods() -&gt; List[ArkAuthMethod]:\n        \"\"\"\n        Returns the authenticator's supported authentication methods.\n\n        Returns:\n            List[ArkAuthMethod]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n        \"\"\"\n        Returns the default authentication method and settings.\n\n        Returns:\n            Tuple[ArkAuthMethod, ArkAuthMethodSettings]: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticate","title":"<code>authenticate(profile=None, auth_profile=None, secret=None, force=False, refresh_auth=False)</code>","text":"<p>Authenticates with the specified authenticator implementation. The implementation is based on the <code>_perform_authentication</code> method. When caching is allowed, authorization credentials are loaded from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile containing information about the environment and authentication methods</p> <code>None</code> <code>auth_profile</code> <code>Optional[ArkAuthProfile]</code> <p>Specific auth profile to use instead of the profile, when provided</p> <code>None</code> <code>secret</code> <code>Optional[ArkSecret]</code> <p>Secret used for authentication</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to force authentication without cached credentials</p> <code>False</code> <code>refresh_auth</code> <code>bool</code> <p>Attempts to refresh an existing cached auth when it is available</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkToken</code> <code>ArkToken</code> <p>The authentication token to use. The token is also saved in the object.</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def authenticate(\n    self,\n    profile: Optional[ArkProfile] = None,\n    auth_profile: Optional[ArkAuthProfile] = None,\n    secret: Optional[ArkSecret] = None,\n    force: bool = False,\n    refresh_auth: bool = False,\n) -&gt; ArkToken:\n    \"\"\"\n    Authenticates with the specified authenticator implementation.\n    The implementation is based on the `_perform_authentication` method.\n    When caching is allowed, authorization credentials are loaded from the cache.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile containing information about the environment and authentication methods\n        auth_profile (Optional[ArkAuthProfile]): Specific auth profile to use instead of the profile, when provided\n        secret (Optional[ArkSecret]): Secret used for authentication\n        force (bool): Determines whether to force authentication without cached credentials\n        refresh_auth (bool): Attempts to refresh an existing cached auth when it is available\n\n    Raises:\n        ArkAuthException: _description_\n\n    Returns:\n        ArkToken: The authentication token to use. The token is also saved in the object.\n    \"\"\"\n    if not auth_profile and not profile:\n        raise ArkAuthException('Either a profile or a specific auth profile must be supplied')\n    if not auth_profile and profile:\n        if self.authenticator_name() in profile.auth_profiles:\n            auth_profile = profile.auth_profiles[self.authenticator_name()]\n        else:\n            raise ArkAuthException(\n                f'{self.authenticator_human_readable_name()} [{self.authenticator_name()}] is not defined within the authentication profiles'\n            )\n    if not profile:\n        profile = ArkProfileLoader.load_default_profile()\n    if auth_profile.auth_method not in self.supported_auth_methods() and auth_profile.auth_method != ArkAuthMethod.Default:\n        raise ArkAuthException(\n            f'{self.authenticator_human_readable_name()} does not support authentication method {auth_profile.auth_method}'\n        )\n    if auth_profile.auth_method == ArkAuthMethod.Default:\n        auth_profile.auth_method, auth_profile.auth_method_settings = self.default_auth_method()\n    if auth_profile.auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n        raise ArkAuthException(f'{self.authenticator_human_readable_name()} requires a username and optionally a secret')\n    ark_token = None\n    token_refreshed = False\n    if self._cache_authentication and self._cache_keyring and not force:\n        # Load the postfix of the token based on the auth profile and method type\n        ark_token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n        if ark_token and ark_token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            # Expired, try to refresh\n            if refresh_auth and ark_token.refresh_token:\n                ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                if ark_token:\n                    token_refreshed = True\n            else:\n                ark_token = None\n    if not ark_token:\n        ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n        if self._cache_authentication and self._cache_keyring:\n            self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n    elif refresh_auth and not token_refreshed:\n        try:\n            ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        except Exception as ex:  # Fallback to normal authentication\n            self._logger.info(\n                f'Refresh auth for [{self.authenticator_human_readable_name()}] failed, falling back to normal authentication [{str(ex)}]'\n            )\n            ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n    self.__token = ark_token\n    self._active_profile = profile\n    self._active_auth_profile = auth_profile\n    return ark_token\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticator_human_readable_name","title":"<code>authenticator_human_readable_name()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the human-readable name of the authenticator.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef authenticator_human_readable_name() -&gt; str:\n    \"\"\"\n    Returns the human-readable name of the authenticator.\n\n    Returns:\n        str: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticator_name","title":"<code>authenticator_name()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the name of the authenticator used for the auth profile and services.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef authenticator_name() -&gt; str:\n    \"\"\"\n    Returns the name of the authenticator used for the auth profile and services.\n\n    Returns:\n        str: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.default_auth_method","title":"<code>default_auth_method()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the default authentication method and settings.</p> <p>Returns:</p> Type Description <code>Tuple[ArkAuthMethod, ArkAuthMethodSettings]</code> <p>Tuple[ArkAuthMethod, ArkAuthMethodSettings]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n    \"\"\"\n    Returns the default authentication method and settings.\n\n    Returns:\n        Tuple[ArkAuthMethod, ArkAuthMethodSettings]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.is_authenticated","title":"<code>is_authenticated(profile)</code>","text":"<p>Checks whether the specified profile is authenticated (has a valid token), either from the keyring or in memory. If the valid token originated from the keyring, it is loaded into memory.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def is_authenticated(self, profile: ArkProfile) -&gt; bool:\n    \"\"\"\n    Checks whether the specified profile is authenticated (has a valid token), either from the keyring or in memory.\n    If the valid token originated from the keyring, it is loaded into memory.\n\n    Args:\n        profile (ArkProfile): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    self._logger.info(f'Checking if [{self.authenticator_name()}] is authenticated')\n    if self.__token:\n        self._logger.info('Token is already loaded')\n        return True\n    if self.authenticator_name() in profile.auth_profiles and self._cache_keyring:\n        self.__token = self._cache_keyring.load_token(profile, profile.auth_profiles[self.authenticator_name()].username)\n        if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            self.__token = None\n        else:\n            self._logger.info('Loaded token from cache successfully')\n        return self.__token != None\n    return False\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.load_authentication","title":"<code>load_authentication(profile=None, refresh_auth=False)</code>","text":"<p>Loads and returns the authentication token from the cache, if it exists. If specified, the method also attempts to refresh the token as needed.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>description. Defaults to None.</p> <code>None</code> <code>refresh_auth</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def load_authentication(self, profile: Optional[ArkProfile] = None, refresh_auth: bool = False) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads and returns the authentication token from the cache, if it exists.\n    If specified, the method also attempts to refresh the token as needed.\n\n    Args:\n        profile (Optional[ArkProfile], optional): _description_. Defaults to None.\n        refresh_auth (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    self._logger.info(f'Trying to load [{self.authenticator_name()}] authentication')\n    if not profile:\n        if self._active_profile:\n            profile = self._active_profile\n        else:\n            profile = ArkProfileLoader.load_default_profile()\n    auth_profile = self._active_auth_profile\n    if not auth_profile and self.authenticator_name() in profile.auth_profiles:\n        auth_profile = profile.auth_profiles[self.authenticator_name()]\n    if auth_profile:\n        self._logger.info(\n            f'Loading authentication for profile [{profile.profile_name}] and auth profile [{self.authenticator_name()}] of type [{auth_profile.auth_method.value}]'\n        )\n        if self._cache_keyring:\n            self.__token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n        if refresh_auth:\n            if (\n                self.__token\n                and self.__token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)\n                &gt; datetime.now()\n            ):\n                self._logger.info('Token did not pass grace expiration, no need to refresh')\n            else:\n                self._logger.info('Trying to refresh token authentication')\n                self.__token = self._perform_refresh_authentication(profile, auth_profile, self.__token)\n                if self.__token and self.__token.expires_in.replace(tzinfo=None) &gt; datetime.now():\n                    self._logger.info('Token refreshed')\n                if self.__token and self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, self.__token, self._resolve_cache_postfix(auth_profile))\n        if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            self.__token = None\n        if self.__token:\n            self._active_profile = profile\n            self._active_auth_profile = auth_profile\n        return self.__token\n    return None\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.supported_auth_methods","title":"<code>supported_auth_methods()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the authenticator's supported authentication methods.</p> <p>Returns:</p> Type Description <code>List[ArkAuthMethod]</code> <p>List[ArkAuthMethod]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef supported_auth_methods() -&gt; List[ArkAuthMethod]:\n    \"\"\"\n    Returns the authenticator's supported authentication methods.\n\n    Returns:\n        List[ArkAuthMethod]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_isp_auth/","title":"ark_isp_auth","text":""},{"location":"reference/auth/ark_isp_auth/#ark_sdk_python.auth.ark_isp_auth.ArkISPAuth","title":"<code>ArkISPAuth</code>","text":"<p>             Bases: <code>ArkAuth</code></p> Source code in <code>ark_sdk_python/auth/ark_isp_auth.py</code> <pre><code>class ArkISPAuth(ArkAuth):\n    def __perform_identity_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret], force: bool\n    ) -&gt; ArkToken:\n        try:\n            method_settings = cast(IdentityArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentity(\n                username=auth_profile.username,\n                password=secret.secret.get_secret_value() if secret else None,\n                identity_url=method_settings.identity_url,\n                mfa_type=method_settings.identity_mfa_method,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n            )\n            identity.auth_identity(profile, ArkSystemConfig.is_interactive() and method_settings.identity_mfa_interactive, force)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            token_lifetime = identity.session_details.token_lifetime\n            if not token_lifetime:\n                token_lifetime = DEFAULT_TOKEN_LIFETIME\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.Identity,\n                expires_in=datetime.now() + timedelta(seconds=token_lifetime),\n                refresh_token=identity.session_details.refresh_token,\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            self._logger.exception(f'Failed to authenticate to identity security platform [{str(ex)}]')\n            raise ArkAuthException from ex\n\n    def __perform_identity_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        try:\n            method_settings = cast(IdentityArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentity(\n                username=auth_profile.username,\n                password=None,\n                identity_url=method_settings.identity_url,\n                mfa_type=method_settings.identity_mfa_method,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n                load_cache=True,\n                cache_profile=profile,\n            )\n            identity.refresh_auth_identity(profile, method_settings.identity_mfa_interactive, False)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            token_lifetime = identity.session_details.token_lifetime\n            if not token_lifetime:\n                token_lifetime = DEFAULT_TOKEN_LIFETIME\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.Identity,\n                expires_in=datetime.now() + timedelta(seconds=token_lifetime),\n                refresh_token=identity.session_details.refresh_token,\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            raise ArkAuthException('Failed to authenticate to isp via identity') from ex\n\n    def __perform_identity_service_user_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret], force: bool\n    ) -&gt; ArkToken:\n        try:\n            if not secret:\n                raise ArkException('Token secret is required for identity service user auth')\n            method_settings = cast(IdentityServiceUserArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentityServiceUser(\n                username=auth_profile.username,\n                token=secret.secret.get_secret_value(),\n                app_name=method_settings.identity_authorization_application,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n            )\n            identity.auth_identity(profile, force)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.IdentityServiceUser,\n                expires_in=datetime.now() + timedelta(hours=4),\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            self._logger.exception(f'Failed to authenticate to identity security platform with service user [{str(ex)}]')\n            raise ArkAuthException from ex\n\n    @overrides\n    def _perform_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n    ) -&gt; ArkToken:\n        \"\"\"\n        Performs authentication to the identity security platform identity tenant\n        Authentication can be done with either a service user or a normal user\n        Authentication Methods:\n        - Identity, Default\n        - IdentityServiceUser\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            secret (Optional[ArkSecret], optional): _description_. Defaults to None.\n            force (bool, optional): _description_. Defaults to False.\n\n        Raises:\n            ArkAuthException: _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n        self._logger.info('Performing authentication to ISP')\n        if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n            return self.__perform_identity_authentication(profile, auth_profile, secret, force)\n        if auth_profile.auth_method == ArkAuthMethod.IdentityServiceUser:\n            return self.__perform_identity_service_user_authentication(profile, auth_profile, secret, force)\n        raise ArkAuthException('Given auth method is not supported')\n\n    @overrides\n    def _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        \"\"\"\n        Refresh for isp tenant is supported only for identity\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            token (ArkToken): _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n        self._logger.info('Performing refresh authentication to ISP')\n        if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n            return self.__perform_identity_refresh_authentication(profile, auth_profile, token)\n        return token\n\n    @staticmethod\n    @overrides\n    def authenticator_name() -&gt; str:\n        return AUTH_NAME\n\n    @staticmethod\n    @overrides\n    def authenticator_human_readable_name() -&gt; str:\n        return AUTH_HUMAN_READABLE_NAME\n\n    @staticmethod\n    @overrides\n    def supported_auth_methods() -&gt; List[ArkAuthMethod]:\n        return AUTH_METHODS\n\n    @staticmethod\n    @overrides\n    def default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n        return DEFAULT_AUTH_METHOD, DEFAULT_AUTH_METHOD_SETTINGS\n</code></pre>"},{"location":"reference/auth/identity/","title":"identity","text":""},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity","title":"<code>ArkIdentity</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>class ArkIdentity:\n    def __init__(\n        self,\n        username: str,\n        password: Optional[str],\n        identity_url: Optional[str] = None,\n        mfa_type: Optional[str] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__password = password\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        if not self.__identity_url.startswith('https://'):\n            self.__identity_url = f'https://{self.__identity_url}'\n        self.__mfa_type = mfa_type\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__interaction_process: Optional[Process] = None\n        self.__is_polling: bool = False\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_details = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__verify = verify\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity')\n            session = self.__keyring.load_token(profile, f'{self.__username}_identity_session')\n            if token and session:\n                import dill as pickle\n\n                try:\n                    self.__session_details = AdvanceAuthResult.parse_raw(token.token.get_secret_value())\n                except ValidationError:\n                    self.__session_details = IdpAuthStatusResult.parse_raw(token.token.get_secret_value())\n                self.__session_exp = token.expires_in\n                self.__session = pickle.loads(codecs.decode(session.token.get_secret_value().encode(), \"base64\"))\n                self.__session.verify = self.__verify\n                self.__identity_url = token.endpoint\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_details:\n            import dill as pickle\n\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_details.json(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                    refresh_token=self.__session_details.refresh_token,\n                ),\n                f'{self.__username}_identity',\n            )\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=codecs.encode(pickle.dumps(self.__session), 'base64').decode(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_session',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix=tenant_suffix)\n\n    def __start_authentication(self) -&gt; StartAuthResponse:\n        self.__logger.info(f'Starting authentication with user {self.__username} and fqdn {self.__identity_url}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/StartAuthentication',\n            json={'User': self.__username, 'Version': '1.0', 'PlatformTokenResponse': True},\n        )\n        try:\n            parsed_res: StartAuthResponse = StartAuthResponse.parse_raw(response.text)\n            if not parsed_res.result.challenges and not parsed_res.result.idp_redirect_url:\n                raise ValidationError('No challenges or idp redirect url on start auth')\n        except (ValidationError, TypeError) as ex:\n            try:\n                if 'PodFqdn' in response.text:\n                    fqdn = TenantFqdnResponse.parse_raw(response.text)\n                    self.__identity_url = f'https://{fqdn.result.pod_fqdn}'\n                    self.__session = Session()\n                    self.__session.verify = self.__verify\n                    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n                    return self.__start_authentication()\n            except Exception:\n                pass\n            raise ArkException('Identity start authentication failed to be parsed / validated') from ex\n        return parsed_res\n\n    def __advance_authentication(\n        self, mechanism_id: str, session_id: str, answer: str, action: str\n    ) -&gt; Union[AdvanceAuthMidResponse, AdvanceAuthResponse]:\n        self.__logger.info(f'Advancing authentication with user {self.__username} and fqdn {self.__identity_url} and action {action}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/AdvanceAuthentication',\n            json={'SessionId': session_id, 'MechanismId': mechanism_id, 'Action': action, 'Answer': answer},\n        )\n        try:\n            parsed_res: AdvanceAuthMidResponse = AdvanceAuthMidResponse.parse_raw(response.text)\n            if parsed_res.result.summary == 'LoginSuccess':\n                parsed_res: AdvanceAuthResponse = AdvanceAuthResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity advance authentication failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __identity_idp_auth_status(self, session_id: str) -&gt; IdpAuthStatusResponse:\n        self.__logger.info(f'Calling idp auth status for fqdn {self.__identity_url} and session id {session_id}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/OobAuthStatus',\n            json={'SessionId': session_id},\n        )\n        try:\n            parsed_res: IdpAuthStatusResponse = IdpAuthStatusResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity idp auth status failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __start_input_process(\n        self, pipe_write: Connection, pipe_read: Connection, mechanism: Mechanism, oob_advance_resp: AdvanceAuthMidResponse\n    ) -&gt; None:\n        if self.__interaction_process:\n            raise ArkException('Interaction thread is already in progress')\n        if sys.platform not in ['win32', 'cygwin']:\n            ctx = get_context('fork')\n        else:\n            ctx = get_context('spawn')\n        self.__interaction_process = ctx.Process(\n            target=input_process,\n            args=(\n                pipe_write,\n                pipe_read,\n                mechanism,\n                oob_advance_resp,\n            ),\n        )\n        self.__interaction_process.start()\n\n    def __stop_input_process(self) -&gt; None:\n        if self.__interaction_process:\n            self.__interaction_process.kill()\n            self.__interaction_process.join()\n            self.__interaction_process = None\n\n    def __poll_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        start_auth_response: StartAuthResponse,\n        oob_advance_resp: AdvanceAuthMidResponse,\n        is_interactive: bool,\n    ) -&gt; None:\n        try:\n            if self.__is_polling:\n                raise ArkException('MFA Polling is already in progress')\n            self.__is_polling = True\n            input_conn, output_conn = Pipe(duplex=True)\n            if is_interactive:\n                self.__start_input_process(input_conn, output_conn, mechanism, oob_advance_resp)\n            start_time = datetime.now()\n            while self.__is_polling:\n                current_time = datetime.now()\n                if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                    self.__is_polling = False\n                    raise ArkException('Timeout reached while polling for user answer')\n                if output_conn.poll():\n                    mfa_code = output_conn.recv()\n                    advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, mfa_code, 'Answer'\n                    )\n                    if isinstance(advance_resp, AdvanceAuthResponse):\n                        input_conn.send('DONE')\n                    else:\n                        input_conn.send('CONTINUE')\n                else:\n                    advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'Poll')\n                if isinstance(advance_resp, AdvanceAuthResponse):\n                    # Done here, save the token\n                    self.__is_polling = False\n                    if is_interactive:\n                        self.__stop_input_process()\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                time.sleep(POLL_INTERVAL_MS)\n        except Exception as ex:\n            if is_interactive:\n                self.__stop_input_process()\n            if not self.__session_details:\n                raise ex\n        finally:\n            if is_interactive:\n                self.__stop_input_process()\n\n    def __pick_mechanism(self, challenge: Challenge) -&gt; Mechanism:\n        factors = {'otp': '\ud83d\udcf2 Push / Code', 'sms': '\ud83d\udcdf SMS', 'email': '\ud83d\udce7 Email', 'pf': '\ud83d\udcde Phone call'}\n        supported_mechanisms = [m for m in challenge.mechanisms if m.name.lower() in SUPPORTED_MECHANISMS]\n        answers = inquirer.prompt(\n            [\n                inquirer.List(\n                    'mfa',\n                    'Please pick one of the following MFA methods',\n                    choices=[factors[m.name.lower()] for m in supported_mechanisms],\n                    default=factors[self.__mfa_type] if self.__mfa_type and self.__mfa_type in factors else None,\n                    carousel=True,\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            raise ArkException('Failed to get answer for which MFA method to use')\n        self.__mfa_type = next(filter(lambda f: factors[f] == answers['mfa'], factors.keys()))\n        return next(filter(lambda m: factors[m.name.lower()] == answers['mfa'], supported_mechanisms))\n\n    def __perform_idp_authentication(\n        self, start_auth_response: StartAuthResponse, profile: Optional[ArkProfile] = None, interactive: bool = False\n    ) -&gt; None:\n        if self.__is_polling:\n            raise ArkException('MFA / IDP Polling is already in progress')\n        # Print the user some info if we are interactive\n        if interactive:\n            ArkArgsFormatter.print_normal_bright(\n                \"\\nYou are now being redirected from your browser to your external identity provider for authentication\\n\"\n                \"If the browser did not open, you may also click the following URL to access your identity provider authentication\\n\\n\"\n                f\"{start_auth_response.result.idp_redirect_short_url}\\n\"\n            )\n\n        # Error can be ignored\n        webbrowser.open(start_auth_response.result.idp_redirect_short_url, new=0, autoraise=True)\n\n        # Start polling for idp auth\n        self.__is_polling = True\n        start_time = datetime.now()\n        while self.__is_polling:\n            current_time = datetime.now()\n            if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                self.__is_polling = False\n                raise ArkException('Timeout reached while polling for idp auth')\n            idp_auth_status = self.__identity_idp_auth_status(start_auth_response.result.idp_login_session_id)\n            if idp_auth_status.result.state == 'Success' and idp_auth_status.result.token:\n                # We managed to successfully authenticate\n                # Done here, save the token\n                self.__session_details = idp_auth_status.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {idp_auth_status.result.token}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                break\n            time.sleep(POLL_INTERVAL_MS)\n\n    @classmethod\n    def has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n        \"\"\"\n        Checks if a cache record exists for the specified profile and username.\n\n        Args:\n            profile (ArkProfile): _description_\n            username (str): _description_\n            refresh_auth_allowed (bool): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        keyring = ArkKeyring(cls.__name__.lower())\n        token = keyring.load_token(profile, f'{username}_identity')\n        session = keyring.load_token(profile, f'{username}_identity_session')\n        if token is not None and session is not None:\n            if token.expires_in and token.expires_in &lt; datetime.now():\n                if token.refresh_token and refresh_auth_allowed:\n                    return True\n                return False\n            return True\n        return False\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_idp_user(cls, username: str) -&gt; bool:\n        \"\"\"\n        Checks whether or not the specified username is from an external IDP.\n\n        Args:\n            username (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n            return False\n        identity = ArkIdentity(username=username, password='')\n        resp = identity.__start_authentication()\n        return resp.result.idp_redirect_url != None\n\n    def get_apps(self) -&gt; Dict:\n        \"\"\"\n        Returns the applications to which the user is logged in.\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            Dict: _description_\n        \"\"\"\n        if not self.__session_details:\n            raise ArkException('Identity authentication is required first')\n        cookies = self.__session.cookies.copy()\n        response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n        self.__session.cookies = cookies\n        return json.loads(response.text)\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with the information specified in the constructor.\n        If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n        The auth token and other details are stored in the object for future use.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n            interactive (bool): Determines whether interactive user prompts are allowed\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        self.__logger.debug('Attempting to authenticate to Identity')\n        self.__session_details = None\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity details from cache')\n                return\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n        # Start the authentication\n        start_auth_response = self.__start_authentication()\n        if start_auth_response.result.idp_redirect_url:\n            # External IDP Flow, ignore the mechanisms and just open a browser\n            self.__perform_idp_authentication(start_auth_response, profile, interactive)\n            return\n\n        # Check if password is part of the first challenges list and if so, answer it directly\n        current_challenge_idx = 0\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == 'up':\n                current_challenge_idx += 1\n                # Password, answer it\n                if not self.__password:\n                    if not interactive:\n                        raise ArkAuthException('No password and not interactive, cannot continue')\n                    answers = inquirer.prompt(\n                        [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                        render=ArkInquirerRender(),\n                    )\n                    if not answers:\n                        raise ArkAuthException('Canceled by user')\n                    self.__password = answers['answer']\n                advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n                )\n                if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                    # Done here, save the token\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                break\n\n        # Pick MFA for the user\n        if interactive:\n            self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n        # Handle a case where MFA type was supplied\n        if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n            for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n                if mechanism.name.lower() == self.__mfa_type.lower():\n                    oob_advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                    )\n                    self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                    return\n\n        if not interactive:\n            raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n        # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n        for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n            mechanism = self.__pick_mechanism(challenge)\n            oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n\n    # pylint: disable=unused-argument\n    def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Performs a token refresh with the object's existing details.\n\n        Args:\n            profile (Optional[ArkProfile]): The profile to load from the cache, if available\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        from jose.jwt import get_unverified_claims\n\n        if not self.__session_details.token:\n            # We only refresh platform token at the moment, call the normal authentication instead\n            return self.auth_identity(profile, interactive, force)\n\n        self.__logger.debug('Attempting to refresh authenticate to Identity')\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        decoded_token = get_unverified_claims(self.__session_details.token)\n        platform_tenant_id = decoded_token['tenant_id']\n        cookies = {\n            f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n            f'idToken-{platform_tenant_id}': self.__session_details.token,\n        }\n        response = self.__session.post(\n            url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n            cookies=cookies,\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed to refresh token')\n        new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n        new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n        if not new_token or not new_refresh_token:\n            raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n        self.__session_details.token = new_token\n        self.__session_details.refresh_token = new_refresh_token\n        self.__session_details.token_lifetime = (\n            datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n            - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n        ).seconds\n        delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n        self.__session_exp = datetime.now() + timedelta(seconds=delta)\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        if self.__session_details:\n            if self.__session_details.token:\n                return self.__session_details.token\n            if 'auth' in self.__session_details.__dict__ and self.__session_details.auth:\n                return self.__session_details.auth\n        return None\n\n    @property\n    def session_details(self) -&gt; Optional[AdvanceAuthResult]:\n        return self.__session_details\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.auth_identity","title":"<code>auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Authenticates to Identity with the information specified in the constructor. If MFA is configured and <code>interactive</code> is enabled, the user is prompted for the MFA secret. The auth token and other details are stored in the object for future use.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to use (loaded from cache, if available)</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Determines whether interactive user prompts are allowed</p> <code>False</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with the information specified in the constructor.\n    If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n    The auth token and other details are stored in the object for future use.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n        interactive (bool): Determines whether interactive user prompts are allowed\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    self.__logger.debug('Attempting to authenticate to Identity')\n    self.__session_details = None\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity details from cache')\n            return\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n    # Start the authentication\n    start_auth_response = self.__start_authentication()\n    if start_auth_response.result.idp_redirect_url:\n        # External IDP Flow, ignore the mechanisms and just open a browser\n        self.__perform_idp_authentication(start_auth_response, profile, interactive)\n        return\n\n    # Check if password is part of the first challenges list and if so, answer it directly\n    current_challenge_idx = 0\n    for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n        if mechanism.name.lower() == 'up':\n            current_challenge_idx += 1\n            # Password, answer it\n            if not self.__password:\n                if not interactive:\n                    raise ArkAuthException('No password and not interactive, cannot continue')\n                answers = inquirer.prompt(\n                    [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    raise ArkAuthException('Canceled by user')\n                self.__password = answers['answer']\n            advance_resp = self.__advance_authentication(\n                mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n            )\n            if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                # Done here, save the token\n                self.__session_details = advance_resp.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                return\n            break\n\n    # Pick MFA for the user\n    if interactive:\n        self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n    # Handle a case where MFA type was supplied\n    if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == self.__mfa_type.lower():\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                return\n\n    if not interactive:\n        raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n    # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n    for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n        mechanism = self.__pick_mechanism(challenge)\n        oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n        self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.get_apps","title":"<code>get_apps()</code>","text":"<p>Returns the applications to which the user is logged in.</p> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def get_apps(self) -&gt; Dict:\n    \"\"\"\n    Returns the applications to which the user is logged in.\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        Dict: _description_\n    \"\"\"\n    if not self.__session_details:\n        raise ArkException('Identity authentication is required first')\n    cookies = self.__session.cookies.copy()\n    response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n    self.__session.cookies = cookies\n    return json.loads(response.text)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.has_cache_record","title":"<code>has_cache_record(profile, username, refresh_auth_allowed)</code>  <code>classmethod</code>","text":"<p>Checks if a cache record exists for the specified profile and username.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>username</code> <code>str</code> <p>description</p> required <code>refresh_auth_allowed</code> <code>bool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\ndef has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n    \"\"\"\n    Checks if a cache record exists for the specified profile and username.\n\n    Args:\n        profile (ArkProfile): _description_\n        username (str): _description_\n        refresh_auth_allowed (bool): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    keyring = ArkKeyring(cls.__name__.lower())\n    token = keyring.load_token(profile, f'{username}_identity')\n    session = keyring.load_token(profile, f'{username}_identity_session')\n    if token is not None and session is not None:\n        if token.expires_in and token.expires_in &lt; datetime.now():\n            if token.refresh_token and refresh_auth_allowed:\n                return True\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.is_idp_user","title":"<code>is_idp_user(username)</code>  <code>classmethod</code>","text":"<p>Checks whether or not the specified username is from an external IDP.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_idp_user(cls, username: str) -&gt; bool:\n    \"\"\"\n    Checks whether or not the specified username is from an external IDP.\n\n    Args:\n        username (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n        return False\n    identity = ArkIdentity(username=username, password='')\n    resp = identity.__start_authentication()\n    return resp.result.idp_redirect_url != None\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.refresh_auth_identity","title":"<code>refresh_auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Performs a token refresh with the object's existing details.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>The profile to load from the cache, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Performs a token refresh with the object's existing details.\n\n    Args:\n        profile (Optional[ArkProfile]): The profile to load from the cache, if available\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    from jose.jwt import get_unverified_claims\n\n    if not self.__session_details.token:\n        # We only refresh platform token at the moment, call the normal authentication instead\n        return self.auth_identity(profile, interactive, force)\n\n    self.__logger.debug('Attempting to refresh authenticate to Identity')\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n    decoded_token = get_unverified_claims(self.__session_details.token)\n    platform_tenant_id = decoded_token['tenant_id']\n    cookies = {\n        f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n        f'idToken-{platform_tenant_id}': self.__session_details.token,\n    }\n    response = self.__session.post(\n        url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n        cookies=cookies,\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed to refresh token')\n    new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n    new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n    if not new_token or not new_refresh_token:\n        raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n    self.__session_details.token = new_token\n    self.__session_details.refresh_token = new_refresh_token\n    self.__session_details.token_lifetime = (\n        datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n        - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n    ).seconds\n    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver","title":"<code>ArkIdentityFQDNResolver</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>class ArkIdentityFQDNResolver:\n    __DISCOVERY_SERVICE_DOMAIN_NAME: Final[str] = 'platform-discovery'\n    __DISCOVERY_TIMEOUT: Final[int] = 30\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {\n            'Content-Type': 'application/json',\n            'X-IDAP-NATIVE-CLIENT': 'true',\n            'User-Agent': UserAgent(browsers=['chrome']).chrome,\n            'OobIdPAuth': 'true',\n        }\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_system_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {'X-IDAP-NATIVE-CLIENT': 'true', 'User-Agent': UserAgent(browsers=['chrome']).chrome}\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL from its subdomain.\n        The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n        Args:\n            tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n            env (AwsEnv): The environment for which the the tenant URL is resolved\n\n        Raises:\n            ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n        Returns:\n            str: The tenant's resolved FQDN\n        \"\"\"\n        platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n        session = Session()\n        response = session.get(\n            f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n            headers={'Content-Type': 'application/json'},\n            timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n        )\n        try:\n            if response.status_code == HTTPStatus.OK:\n                parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n                return str(parsed_response.endpoint)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n        raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL in Identity.\n        By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n        Args:\n            tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n            identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: The tenant's FQDN\n        \"\"\"\n        identity_env_url = identity_env_url or (\n            IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n        )\n        session = Session()\n        response = session.post(\n            f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n            json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n            headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n        )\n        try:\n            parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n        if not parsed_res.result.pod_fqdn.startswith('https://'):\n            parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n        return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain","title":"<code>resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain, env)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL from its subdomain. The resolved URL is based on the current working environment, which is provided in the <code>tenant_subdomain</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_subdomain</code> <code>str</code> <p>The tenant subdomain, for example: <code>mytenant</code></p> required <code>env</code> <code>AwsEnv</code> <p>The environment for which the the tenant URL is resolved</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>When an error occurs or the tenant username prefix was not found in the Identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's resolved FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL from its subdomain.\n    The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n    Args:\n        tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n        env (AwsEnv): The environment for which the the tenant URL is resolved\n\n    Raises:\n        ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n    Returns:\n        str: The tenant's resolved FQDN\n    \"\"\"\n    platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n    session = Session()\n    response = session.get(\n        f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n        headers={'Content-Type': 'application/json'},\n        timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n    )\n    try:\n        if response.status_code == HTTPStatus.OK:\n            parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n            return str(parsed_response.endpoint)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n    raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix","title":"<code>resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix, identity_env_url=None)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL in Identity. By default, the Identity address is resolved from the current environment mapping (see <code>get_identity_env_url()</code>), but it can be optionally be resolved from the <code>identity_env_url</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_suffix</code> <code>str</code> <p>The tenant's URL suffix, for example: <code>@tenant-a-527.shell.cyberark.cloud</code></p> required <code>identity_env_url</code> <code>str</code> <p>If specified, used as the Identity pod0 URL; otherwise, defaults to <code>None</code> (use environment mapping)</p> <code>None</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL in Identity.\n    By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n    Args:\n        tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n        identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: The tenant's FQDN\n    \"\"\"\n    identity_env_url = identity_env_url or (\n        IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n    )\n    session = Session()\n    response = session.post(\n        f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n        json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n    )\n    try:\n        parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n    if not parsed_res.result.pod_fqdn.startswith('https://'):\n        parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n    return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityServiceUser","title":"<code>ArkIdentityServiceUser</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>class ArkIdentityServiceUser:\n    def __init__(\n        self,\n        username: str,\n        token: str,\n        app_name: str,\n        identity_url: Optional[str] = None,\n        env: Optional[AwsEnv] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__token = token\n        self.__app_name = app_name\n        self.__env = env or AwsEnv(os.getenv(DEPLOY_ENV, AwsEnv.PROD.value))\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_token = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_system_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity_service_user')\n            if token and token.username == self.__username:\n                self.__session_token = token.token.get_secret_value()\n                self.__session_exp = token.expires_in\n                self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}'})\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_token:\n            self.__session_exp = datetime.now() + timedelta(hours=4)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_token,\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_service_user',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(\n            tenant_suffix=tenant_suffix, identity_env_url=IDENTITY_ENV_URLS[self.__env]\n        )\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with a service user.\n        This method creates an auth token and authorizes to the service.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n            force (bool): Determines whether to discard existing cache, defaults to `False`\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        # Login to identity with the service service user\n        self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity service user details from cache')\n                return\n\n        token_response: Response = self.__session.post(\n            url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n            auth=HTTPBasicAuth(self.__username, self.__token),\n            verify=True,\n            data={'grant_type': 'client_credentials', 'scope': 'api'},\n        )\n        if token_response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed logging in to identity service user')\n        auth_result = json.loads(token_response.text)\n        if 'access_token' not in auth_result.keys():\n            raise ArkAuthException('Failed logging in to identity service user, access token not found')\n        access_token = auth_result['access_token']\n\n        # Authorize to the application with the service user\n        params = {\n            'client_id': self.__app_name,\n            'response_type': 'id_token',\n            'scope': 'openid profile api',\n            'redirect_uri': 'https://cyberark.cloud/redirect',\n        }\n        self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n        authorize_response = self.__session.get(\n            url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n            headers={'Authorization': f'Bearer {access_token}'},\n            params=params,\n            allow_redirects=False,\n        )\n        if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n            raise ArkAuthException('Failed to authorize to application')\n        # Parse the authorized token and return the session with it\n        location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n        if len(location_header_splitted) != 2:\n            raise ArkAuthException('Failed to parse location header to retrieve token from')\n        parsed_query = parse_qs(location_header_splitted[1])\n        if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n            raise ArkAuthException('Failed to parse id token from location header')\n        self.__session_token = parsed_query['id_token'][0]\n        self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n        self.__session_exp = datetime.now() + timedelta(hours=4)\n        self.__logger.info(\n            f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n        )\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__session_token\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityServiceUser.auth_identity","title":"<code>auth_identity(profile=None, force=False)</code>","text":"<p>Authenticates to Identity with a service user. This method creates an auth token and authorizes to the service.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to discard existing cache, defaults to <code>False</code></p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with a service user.\n    This method creates an auth token and authorizes to the service.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n        force (bool): Determines whether to discard existing cache, defaults to `False`\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    # Login to identity with the service service user\n    self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity service user details from cache')\n            return\n\n    token_response: Response = self.__session.post(\n        url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n        auth=HTTPBasicAuth(self.__username, self.__token),\n        verify=True,\n        data={'grant_type': 'client_credentials', 'scope': 'api'},\n    )\n    if token_response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed logging in to identity service user')\n    auth_result = json.loads(token_response.text)\n    if 'access_token' not in auth_result.keys():\n        raise ArkAuthException('Failed logging in to identity service user, access token not found')\n    access_token = auth_result['access_token']\n\n    # Authorize to the application with the service user\n    params = {\n        'client_id': self.__app_name,\n        'response_type': 'id_token',\n        'scope': 'openid profile api',\n        'redirect_uri': 'https://cyberark.cloud/redirect',\n    }\n    self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n    authorize_response = self.__session.get(\n        url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n        headers={'Authorization': f'Bearer {access_token}'},\n        params=params,\n        allow_redirects=False,\n    )\n    if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n        raise ArkAuthException('Failed to authorize to application')\n    # Parse the authorized token and return the session with it\n    location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n    if len(location_header_splitted) != 2:\n        raise ArkAuthException('Failed to parse location header to retrieve token from')\n    parsed_query = parse_qs(location_header_splitted[1])\n    if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n        raise ArkAuthException('Failed to parse id token from location header')\n    self.__session_token = parsed_query['id_token'][0]\n    self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n    self.__session_exp = datetime.now() + timedelta(hours=4)\n    self.__logger.info(\n        f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n    )\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/","title":"ark_identity","text":""},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity","title":"<code>ArkIdentity</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>class ArkIdentity:\n    def __init__(\n        self,\n        username: str,\n        password: Optional[str],\n        identity_url: Optional[str] = None,\n        mfa_type: Optional[str] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__password = password\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        if not self.__identity_url.startswith('https://'):\n            self.__identity_url = f'https://{self.__identity_url}'\n        self.__mfa_type = mfa_type\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__interaction_process: Optional[Process] = None\n        self.__is_polling: bool = False\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_details = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__verify = verify\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity')\n            session = self.__keyring.load_token(profile, f'{self.__username}_identity_session')\n            if token and session:\n                import dill as pickle\n\n                try:\n                    self.__session_details = AdvanceAuthResult.parse_raw(token.token.get_secret_value())\n                except ValidationError:\n                    self.__session_details = IdpAuthStatusResult.parse_raw(token.token.get_secret_value())\n                self.__session_exp = token.expires_in\n                self.__session = pickle.loads(codecs.decode(session.token.get_secret_value().encode(), \"base64\"))\n                self.__session.verify = self.__verify\n                self.__identity_url = token.endpoint\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_details:\n            import dill as pickle\n\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_details.json(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                    refresh_token=self.__session_details.refresh_token,\n                ),\n                f'{self.__username}_identity',\n            )\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=codecs.encode(pickle.dumps(self.__session), 'base64').decode(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_session',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix=tenant_suffix)\n\n    def __start_authentication(self) -&gt; StartAuthResponse:\n        self.__logger.info(f'Starting authentication with user {self.__username} and fqdn {self.__identity_url}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/StartAuthentication',\n            json={'User': self.__username, 'Version': '1.0', 'PlatformTokenResponse': True},\n        )\n        try:\n            parsed_res: StartAuthResponse = StartAuthResponse.parse_raw(response.text)\n            if not parsed_res.result.challenges and not parsed_res.result.idp_redirect_url:\n                raise ValidationError('No challenges or idp redirect url on start auth')\n        except (ValidationError, TypeError) as ex:\n            try:\n                if 'PodFqdn' in response.text:\n                    fqdn = TenantFqdnResponse.parse_raw(response.text)\n                    self.__identity_url = f'https://{fqdn.result.pod_fqdn}'\n                    self.__session = Session()\n                    self.__session.verify = self.__verify\n                    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n                    return self.__start_authentication()\n            except Exception:\n                pass\n            raise ArkException('Identity start authentication failed to be parsed / validated') from ex\n        return parsed_res\n\n    def __advance_authentication(\n        self, mechanism_id: str, session_id: str, answer: str, action: str\n    ) -&gt; Union[AdvanceAuthMidResponse, AdvanceAuthResponse]:\n        self.__logger.info(f'Advancing authentication with user {self.__username} and fqdn {self.__identity_url} and action {action}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/AdvanceAuthentication',\n            json={'SessionId': session_id, 'MechanismId': mechanism_id, 'Action': action, 'Answer': answer},\n        )\n        try:\n            parsed_res: AdvanceAuthMidResponse = AdvanceAuthMidResponse.parse_raw(response.text)\n            if parsed_res.result.summary == 'LoginSuccess':\n                parsed_res: AdvanceAuthResponse = AdvanceAuthResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity advance authentication failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __identity_idp_auth_status(self, session_id: str) -&gt; IdpAuthStatusResponse:\n        self.__logger.info(f'Calling idp auth status for fqdn {self.__identity_url} and session id {session_id}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/OobAuthStatus',\n            json={'SessionId': session_id},\n        )\n        try:\n            parsed_res: IdpAuthStatusResponse = IdpAuthStatusResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity idp auth status failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __start_input_process(\n        self, pipe_write: Connection, pipe_read: Connection, mechanism: Mechanism, oob_advance_resp: AdvanceAuthMidResponse\n    ) -&gt; None:\n        if self.__interaction_process:\n            raise ArkException('Interaction thread is already in progress')\n        if sys.platform not in ['win32', 'cygwin']:\n            ctx = get_context('fork')\n        else:\n            ctx = get_context('spawn')\n        self.__interaction_process = ctx.Process(\n            target=input_process,\n            args=(\n                pipe_write,\n                pipe_read,\n                mechanism,\n                oob_advance_resp,\n            ),\n        )\n        self.__interaction_process.start()\n\n    def __stop_input_process(self) -&gt; None:\n        if self.__interaction_process:\n            self.__interaction_process.kill()\n            self.__interaction_process.join()\n            self.__interaction_process = None\n\n    def __poll_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        start_auth_response: StartAuthResponse,\n        oob_advance_resp: AdvanceAuthMidResponse,\n        is_interactive: bool,\n    ) -&gt; None:\n        try:\n            if self.__is_polling:\n                raise ArkException('MFA Polling is already in progress')\n            self.__is_polling = True\n            input_conn, output_conn = Pipe(duplex=True)\n            if is_interactive:\n                self.__start_input_process(input_conn, output_conn, mechanism, oob_advance_resp)\n            start_time = datetime.now()\n            while self.__is_polling:\n                current_time = datetime.now()\n                if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                    self.__is_polling = False\n                    raise ArkException('Timeout reached while polling for user answer')\n                if output_conn.poll():\n                    mfa_code = output_conn.recv()\n                    advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, mfa_code, 'Answer'\n                    )\n                    if isinstance(advance_resp, AdvanceAuthResponse):\n                        input_conn.send('DONE')\n                    else:\n                        input_conn.send('CONTINUE')\n                else:\n                    advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'Poll')\n                if isinstance(advance_resp, AdvanceAuthResponse):\n                    # Done here, save the token\n                    self.__is_polling = False\n                    if is_interactive:\n                        self.__stop_input_process()\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                time.sleep(POLL_INTERVAL_MS)\n        except Exception as ex:\n            if is_interactive:\n                self.__stop_input_process()\n            if not self.__session_details:\n                raise ex\n        finally:\n            if is_interactive:\n                self.__stop_input_process()\n\n    def __pick_mechanism(self, challenge: Challenge) -&gt; Mechanism:\n        factors = {'otp': '\ud83d\udcf2 Push / Code', 'sms': '\ud83d\udcdf SMS', 'email': '\ud83d\udce7 Email', 'pf': '\ud83d\udcde Phone call'}\n        supported_mechanisms = [m for m in challenge.mechanisms if m.name.lower() in SUPPORTED_MECHANISMS]\n        answers = inquirer.prompt(\n            [\n                inquirer.List(\n                    'mfa',\n                    'Please pick one of the following MFA methods',\n                    choices=[factors[m.name.lower()] for m in supported_mechanisms],\n                    default=factors[self.__mfa_type] if self.__mfa_type and self.__mfa_type in factors else None,\n                    carousel=True,\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            raise ArkException('Failed to get answer for which MFA method to use')\n        self.__mfa_type = next(filter(lambda f: factors[f] == answers['mfa'], factors.keys()))\n        return next(filter(lambda m: factors[m.name.lower()] == answers['mfa'], supported_mechanisms))\n\n    def __perform_idp_authentication(\n        self, start_auth_response: StartAuthResponse, profile: Optional[ArkProfile] = None, interactive: bool = False\n    ) -&gt; None:\n        if self.__is_polling:\n            raise ArkException('MFA / IDP Polling is already in progress')\n        # Print the user some info if we are interactive\n        if interactive:\n            ArkArgsFormatter.print_normal_bright(\n                \"\\nYou are now being redirected from your browser to your external identity provider for authentication\\n\"\n                \"If the browser did not open, you may also click the following URL to access your identity provider authentication\\n\\n\"\n                f\"{start_auth_response.result.idp_redirect_short_url}\\n\"\n            )\n\n        # Error can be ignored\n        webbrowser.open(start_auth_response.result.idp_redirect_short_url, new=0, autoraise=True)\n\n        # Start polling for idp auth\n        self.__is_polling = True\n        start_time = datetime.now()\n        while self.__is_polling:\n            current_time = datetime.now()\n            if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                self.__is_polling = False\n                raise ArkException('Timeout reached while polling for idp auth')\n            idp_auth_status = self.__identity_idp_auth_status(start_auth_response.result.idp_login_session_id)\n            if idp_auth_status.result.state == 'Success' and idp_auth_status.result.token:\n                # We managed to successfully authenticate\n                # Done here, save the token\n                self.__session_details = idp_auth_status.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {idp_auth_status.result.token}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                break\n            time.sleep(POLL_INTERVAL_MS)\n\n    @classmethod\n    def has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n        \"\"\"\n        Checks if a cache record exists for the specified profile and username.\n\n        Args:\n            profile (ArkProfile): _description_\n            username (str): _description_\n            refresh_auth_allowed (bool): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        keyring = ArkKeyring(cls.__name__.lower())\n        token = keyring.load_token(profile, f'{username}_identity')\n        session = keyring.load_token(profile, f'{username}_identity_session')\n        if token is not None and session is not None:\n            if token.expires_in and token.expires_in &lt; datetime.now():\n                if token.refresh_token and refresh_auth_allowed:\n                    return True\n                return False\n            return True\n        return False\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_idp_user(cls, username: str) -&gt; bool:\n        \"\"\"\n        Checks whether or not the specified username is from an external IDP.\n\n        Args:\n            username (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n            return False\n        identity = ArkIdentity(username=username, password='')\n        resp = identity.__start_authentication()\n        return resp.result.idp_redirect_url != None\n\n    def get_apps(self) -&gt; Dict:\n        \"\"\"\n        Returns the applications to which the user is logged in.\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            Dict: _description_\n        \"\"\"\n        if not self.__session_details:\n            raise ArkException('Identity authentication is required first')\n        cookies = self.__session.cookies.copy()\n        response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n        self.__session.cookies = cookies\n        return json.loads(response.text)\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with the information specified in the constructor.\n        If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n        The auth token and other details are stored in the object for future use.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n            interactive (bool): Determines whether interactive user prompts are allowed\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        self.__logger.debug('Attempting to authenticate to Identity')\n        self.__session_details = None\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity details from cache')\n                return\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n        # Start the authentication\n        start_auth_response = self.__start_authentication()\n        if start_auth_response.result.idp_redirect_url:\n            # External IDP Flow, ignore the mechanisms and just open a browser\n            self.__perform_idp_authentication(start_auth_response, profile, interactive)\n            return\n\n        # Check if password is part of the first challenges list and if so, answer it directly\n        current_challenge_idx = 0\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == 'up':\n                current_challenge_idx += 1\n                # Password, answer it\n                if not self.__password:\n                    if not interactive:\n                        raise ArkAuthException('No password and not interactive, cannot continue')\n                    answers = inquirer.prompt(\n                        [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                        render=ArkInquirerRender(),\n                    )\n                    if not answers:\n                        raise ArkAuthException('Canceled by user')\n                    self.__password = answers['answer']\n                advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n                )\n                if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                    # Done here, save the token\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                break\n\n        # Pick MFA for the user\n        if interactive:\n            self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n        # Handle a case where MFA type was supplied\n        if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n            for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n                if mechanism.name.lower() == self.__mfa_type.lower():\n                    oob_advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                    )\n                    self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                    return\n\n        if not interactive:\n            raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n        # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n        for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n            mechanism = self.__pick_mechanism(challenge)\n            oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n\n    # pylint: disable=unused-argument\n    def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Performs a token refresh with the object's existing details.\n\n        Args:\n            profile (Optional[ArkProfile]): The profile to load from the cache, if available\n            force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        from jose.jwt import get_unverified_claims\n\n        if not self.__session_details.token:\n            # We only refresh platform token at the moment, call the normal authentication instead\n            return self.auth_identity(profile, interactive, force)\n\n        self.__logger.debug('Attempting to refresh authenticate to Identity')\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        decoded_token = get_unverified_claims(self.__session_details.token)\n        platform_tenant_id = decoded_token['tenant_id']\n        cookies = {\n            f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n            f'idToken-{platform_tenant_id}': self.__session_details.token,\n        }\n        response = self.__session.post(\n            url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n            cookies=cookies,\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed to refresh token')\n        new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n        new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n        if not new_token or not new_refresh_token:\n            raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n        self.__session_details.token = new_token\n        self.__session_details.refresh_token = new_refresh_token\n        self.__session_details.token_lifetime = (\n            datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n            - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n        ).seconds\n        delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n        self.__session_exp = datetime.now() + timedelta(seconds=delta)\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        if self.__session_details:\n            if self.__session_details.token:\n                return self.__session_details.token\n            if 'auth' in self.__session_details.__dict__ and self.__session_details.auth:\n                return self.__session_details.auth\n        return None\n\n    @property\n    def session_details(self) -&gt; Optional[AdvanceAuthResult]:\n        return self.__session_details\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.auth_identity","title":"<code>auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Authenticates to Identity with the information specified in the constructor. If MFA is configured and <code>interactive</code> is enabled, the user is prompted for the MFA secret. The auth token and other details are stored in the object for future use.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to use (loaded from cache, if available)</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Determines whether interactive user prompts are allowed</p> <code>False</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with the information specified in the constructor.\n    If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.\n    The auth token and other details are stored in the object for future use.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to use (loaded from cache, if available)\n        interactive (bool): Determines whether interactive user prompts are allowed\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    self.__logger.debug('Attempting to authenticate to Identity')\n    self.__session_details = None\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity details from cache')\n            return\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n    # Start the authentication\n    start_auth_response = self.__start_authentication()\n    if start_auth_response.result.idp_redirect_url:\n        # External IDP Flow, ignore the mechanisms and just open a browser\n        self.__perform_idp_authentication(start_auth_response, profile, interactive)\n        return\n\n    # Check if password is part of the first challenges list and if so, answer it directly\n    current_challenge_idx = 0\n    for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n        if mechanism.name.lower() == 'up':\n            current_challenge_idx += 1\n            # Password, answer it\n            if not self.__password:\n                if not interactive:\n                    raise ArkAuthException('No password and not interactive, cannot continue')\n                answers = inquirer.prompt(\n                    [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    raise ArkAuthException('Canceled by user')\n                self.__password = answers['answer']\n            advance_resp = self.__advance_authentication(\n                mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n            )\n            if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                # Done here, save the token\n                self.__session_details = advance_resp.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                return\n            break\n\n    # Pick MFA for the user\n    if interactive:\n        self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n    # Handle a case where MFA type was supplied\n    if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == self.__mfa_type.lower():\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                return\n\n    if not interactive:\n        raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n    # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n    for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n        mechanism = self.__pick_mechanism(challenge)\n        oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n        self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.get_apps","title":"<code>get_apps()</code>","text":"<p>Returns the applications to which the user is logged in.</p> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def get_apps(self) -&gt; Dict:\n    \"\"\"\n    Returns the applications to which the user is logged in.\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        Dict: _description_\n    \"\"\"\n    if not self.__session_details:\n        raise ArkException('Identity authentication is required first')\n    cookies = self.__session.cookies.copy()\n    response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n    self.__session.cookies = cookies\n    return json.loads(response.text)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.has_cache_record","title":"<code>has_cache_record(profile, username, refresh_auth_allowed)</code>  <code>classmethod</code>","text":"<p>Checks if a cache record exists for the specified profile and username.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>username</code> <code>str</code> <p>description</p> required <code>refresh_auth_allowed</code> <code>bool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\ndef has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n    \"\"\"\n    Checks if a cache record exists for the specified profile and username.\n\n    Args:\n        profile (ArkProfile): _description_\n        username (str): _description_\n        refresh_auth_allowed (bool): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    keyring = ArkKeyring(cls.__name__.lower())\n    token = keyring.load_token(profile, f'{username}_identity')\n    session = keyring.load_token(profile, f'{username}_identity_session')\n    if token is not None and session is not None:\n        if token.expires_in and token.expires_in &lt; datetime.now():\n            if token.refresh_token and refresh_auth_allowed:\n                return True\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.is_idp_user","title":"<code>is_idp_user(username)</code>  <code>classmethod</code>","text":"<p>Checks whether or not the specified username is from an external IDP.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_idp_user(cls, username: str) -&gt; bool:\n    \"\"\"\n    Checks whether or not the specified username is from an external IDP.\n\n    Args:\n        username (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n        return False\n    identity = ArkIdentity(username=username, password='')\n    resp = identity.__start_authentication()\n    return resp.result.idp_redirect_url != None\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.refresh_auth_identity","title":"<code>refresh_auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Performs a token refresh with the object's existing details.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>The profile to load from the cache, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to ignore cache and force authentication (defaults to false)</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Performs a token refresh with the object's existing details.\n\n    Args:\n        profile (Optional[ArkProfile]): The profile to load from the cache, if available\n        force (bool): Determines whether to ignore cache and force authentication (defaults to false)\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    from jose.jwt import get_unverified_claims\n\n    if not self.__session_details.token:\n        # We only refresh platform token at the moment, call the normal authentication instead\n        return self.auth_identity(profile, interactive, force)\n\n    self.__logger.debug('Attempting to refresh authenticate to Identity')\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n    decoded_token = get_unverified_claims(self.__session_details.token)\n    platform_tenant_id = decoded_token['tenant_id']\n    cookies = {\n        f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n        f'idToken-{platform_tenant_id}': self.__session_details.token,\n    }\n    response = self.__session.post(\n        url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n        cookies=cookies,\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed to refresh token')\n    new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n    new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n    if not new_token or not new_refresh_token:\n        raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n    self.__session_details.token = new_token\n    self.__session_details.refresh_token = new_refresh_token\n    self.__session_details.token_lifetime = (\n        datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n        - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n    ).seconds\n    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/","title":"ark_identity_fqdn_resolver","text":""},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver","title":"<code>ArkIdentityFQDNResolver</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>class ArkIdentityFQDNResolver:\n    __DISCOVERY_SERVICE_DOMAIN_NAME: Final[str] = 'platform-discovery'\n    __DISCOVERY_TIMEOUT: Final[int] = 30\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {\n            'Content-Type': 'application/json',\n            'X-IDAP-NATIVE-CLIENT': 'true',\n            'User-Agent': UserAgent(browsers=['chrome']).chrome,\n            'OobIdPAuth': 'true',\n        }\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_system_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {'X-IDAP-NATIVE-CLIENT': 'true', 'User-Agent': UserAgent(browsers=['chrome']).chrome}\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL from its subdomain.\n        The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n        Args:\n            tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n            env (AwsEnv): The environment for which the the tenant URL is resolved\n\n        Raises:\n            ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n        Returns:\n            str: The tenant's resolved FQDN\n        \"\"\"\n        platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n        session = Session()\n        response = session.get(\n            f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n            headers={'Content-Type': 'application/json'},\n            timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n        )\n        try:\n            if response.status_code == HTTPStatus.OK:\n                parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n                return str(parsed_response.endpoint)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n        raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Resolves the tenant's FQDN URL in Identity.\n        By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n        Args:\n            tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n            identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: The tenant's FQDN\n        \"\"\"\n        identity_env_url = identity_env_url or (\n            IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n        )\n        session = Session()\n        response = session.post(\n            f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n            json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n            headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n        )\n        try:\n            parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n        if not parsed_res.result.pod_fqdn.startswith('https://'):\n            parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n        return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain","title":"<code>resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain, env)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL from its subdomain. The resolved URL is based on the current working environment, which is provided in the <code>tenant_subdomain</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_subdomain</code> <code>str</code> <p>The tenant subdomain, for example: <code>mytenant</code></p> required <code>env</code> <code>AwsEnv</code> <p>The environment for which the the tenant URL is resolved</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>When an error occurs or the tenant username prefix was not found in the Identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's resolved FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL from its subdomain.\n    The resolved URL is based on the current working environment, which is provided in the `tenant_subdomain` argument.\n\n    Args:\n        tenant_subdomain (str): The tenant subdomain, for example: `mytenant`\n        env (AwsEnv): The environment for which the the tenant URL is resolved\n\n    Raises:\n        ArkException: When an error occurs or the tenant username prefix was not found in the Identity environment\n\n    Returns:\n        str: The tenant's resolved FQDN\n    \"\"\"\n    platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n    session = Session()\n    response = session.get(\n        f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n        headers={'Content-Type': 'application/json'},\n        timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n    )\n    try:\n        if response.status_code == HTTPStatus.OK:\n            parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n            return str(parsed_response.endpoint)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n    raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix","title":"<code>resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix, identity_env_url=None)</code>  <code>staticmethod</code>","text":"<p>Resolves the tenant's FQDN URL in Identity. By default, the Identity address is resolved from the current environment mapping (see <code>get_identity_env_url()</code>), but it can be optionally be resolved from the <code>identity_env_url</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>tenant_suffix</code> <code>str</code> <p>The tenant's URL suffix, for example: <code>@tenant-a-527.shell.cyberark.cloud</code></p> required <code>identity_env_url</code> <code>str</code> <p>If specified, used as the Identity pod0 URL; otherwise, defaults to <code>None</code> (use environment mapping)</p> <code>None</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The tenant's FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Resolves the tenant's FQDN URL in Identity.\n    By default, the Identity address is resolved from the current environment mapping (see `get_identity_env_url()`), but it can be optionally be resolved from the `identity_env_url` argument.\n\n    Args:\n        tenant_suffix (str): The tenant's URL suffix, for example: `@tenant-a-527.shell.cyberark.cloud`\n        identity_env_url (str, optional): If specified, used as the Identity pod0 URL; otherwise, defaults to `None` (use environment mapping)\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: The tenant's FQDN\n    \"\"\"\n    identity_env_url = identity_env_url or (\n        IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n    )\n    session = Session()\n    response = session.post(\n        f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n        json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n    )\n    try:\n        parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n    if not parsed_res.result.pod_fqdn.startswith('https://'):\n        parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n    return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_service_user/","title":"ark_identity_service_user","text":""},{"location":"reference/auth/identity/ark_identity_service_user/#ark_sdk_python.auth.identity.ark_identity_service_user.ArkIdentityServiceUser","title":"<code>ArkIdentityServiceUser</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>class ArkIdentityServiceUser:\n    def __init__(\n        self,\n        username: str,\n        token: str,\n        app_name: str,\n        identity_url: Optional[str] = None,\n        env: Optional[AwsEnv] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__token = token\n        self.__app_name = app_name\n        self.__env = env or AwsEnv(os.getenv(DEPLOY_ENV, AwsEnv.PROD.value))\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_token = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_system_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity_service_user')\n            if token and token.username == self.__username:\n                self.__session_token = token.token.get_secret_value()\n                self.__session_exp = token.expires_in\n                self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}'})\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_token:\n            self.__session_exp = datetime.now() + timedelta(hours=4)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_token,\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_service_user',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(\n            tenant_suffix=tenant_suffix, identity_env_url=IDENTITY_ENV_URLS[self.__env]\n        )\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to Identity with a service user.\n        This method creates an auth token and authorizes to the service.\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n            force (bool): Determines whether to discard existing cache, defaults to `False`\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        # Login to identity with the service service user\n        self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity service user details from cache')\n                return\n\n        token_response: Response = self.__session.post(\n            url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n            auth=HTTPBasicAuth(self.__username, self.__token),\n            verify=True,\n            data={'grant_type': 'client_credentials', 'scope': 'api'},\n        )\n        if token_response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed logging in to identity service user')\n        auth_result = json.loads(token_response.text)\n        if 'access_token' not in auth_result.keys():\n            raise ArkAuthException('Failed logging in to identity service user, access token not found')\n        access_token = auth_result['access_token']\n\n        # Authorize to the application with the service user\n        params = {\n            'client_id': self.__app_name,\n            'response_type': 'id_token',\n            'scope': 'openid profile api',\n            'redirect_uri': 'https://cyberark.cloud/redirect',\n        }\n        self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n        authorize_response = self.__session.get(\n            url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n            headers={'Authorization': f'Bearer {access_token}'},\n            params=params,\n            allow_redirects=False,\n        )\n        if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n            raise ArkAuthException('Failed to authorize to application')\n        # Parse the authorized token and return the session with it\n        location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n        if len(location_header_splitted) != 2:\n            raise ArkAuthException('Failed to parse location header to retrieve token from')\n        parsed_query = parse_qs(location_header_splitted[1])\n        if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n            raise ArkAuthException('Failed to parse id token from location header')\n        self.__session_token = parsed_query['id_token'][0]\n        self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n        self.__session_exp = datetime.now() + timedelta(hours=4)\n        self.__logger.info(\n            f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n        )\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__session_token\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_service_user/#ark_sdk_python.auth.identity.ark_identity_service_user.ArkIdentityServiceUser.auth_identity","title":"<code>auth_identity(profile=None, force=False)</code>","text":"<p>Authenticates to Identity with a service user. This method creates an auth token and authorizes to the service.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching, if available</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to discard existing cache, defaults to <code>False</code></p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to Identity with a service user.\n    This method creates an auth token and authorizes to the service.\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching, if available\n        force (bool): Determines whether to discard existing cache, defaults to `False`\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    # Login to identity with the service service user\n    self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity service user details from cache')\n            return\n\n    token_response: Response = self.__session.post(\n        url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n        auth=HTTPBasicAuth(self.__username, self.__token),\n        verify=True,\n        data={'grant_type': 'client_credentials', 'scope': 'api'},\n    )\n    if token_response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed logging in to identity service user')\n    auth_result = json.loads(token_response.text)\n    if 'access_token' not in auth_result.keys():\n        raise ArkAuthException('Failed logging in to identity service user, access token not found')\n    access_token = auth_result['access_token']\n\n    # Authorize to the application with the service user\n    params = {\n        'client_id': self.__app_name,\n        'response_type': 'id_token',\n        'scope': 'openid profile api',\n        'redirect_uri': 'https://cyberark.cloud/redirect',\n    }\n    self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n    authorize_response = self.__session.get(\n        url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n        headers={'Authorization': f'Bearer {access_token}'},\n        params=params,\n        allow_redirects=False,\n    )\n    if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n        raise ArkAuthException('Failed to authorize to application')\n    # Parse the authorized token and return the session with it\n    location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n    if len(location_header_splitted) != 2:\n        raise ArkAuthException('Failed to parse location header to retrieve token from')\n    parsed_query = parse_qs(location_header_splitted[1])\n    if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n        raise ArkAuthException('Failed to parse id token from location header')\n    self.__session_token = parsed_query['id_token'][0]\n    self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n    self.__session_exp = datetime.now() + timedelta(hours=4)\n    self.__logger.info(\n        f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n    )\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/cli_services/","title":"cli_services","text":""},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI","title":"<code>ArkCLIAPI</code>","text":"<p>             Bases: <code>ArkAPI</code></p> Source code in <code>ark_sdk_python/cli_services/ark_cli_api.py</code> <pre><code>class ArkCLIAPI(ArkAPI):\n    @property\n    def dpa_policies_vm_editor(self) -&gt; \"ArkDPAVMPoliciesEditorService\":\n        \"\"\"\n        VM policy editor CLI service\n\n        Returns:\n            ArkDPAVMPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.dpa.vm import ArkDPAVMPoliciesEditorService\n\n        return ArkDPAVMPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n\n    @property\n    def dpa_policies_db_editor(self) -&gt; \"ArkDPADBPoliciesEditorService\":\n        \"\"\"\n        DB policy editor CLI service\n\n        Returns:\n            ArkDPADBPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.dpa.db import ArkDPADBPoliciesEditorService\n\n        return ArkDPADBPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n</code></pre>"},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI.dpa_policies_db_editor","title":"<code>dpa_policies_db_editor: 'ArkDPADBPoliciesEditorService'</code>  <code>property</code>","text":"<p>DB policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesEditorService</code> <code>'ArkDPADBPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI.dpa_policies_vm_editor","title":"<code>dpa_policies_vm_editor: 'ArkDPAVMPoliciesEditorService'</code>  <code>property</code>","text":"<p>VM policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesEditorService</code> <code>'ArkDPAVMPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/ark_cli_api/","title":"ark_cli_api","text":""},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI","title":"<code>ArkCLIAPI</code>","text":"<p>             Bases: <code>ArkAPI</code></p> Source code in <code>ark_sdk_python/cli_services/ark_cli_api.py</code> <pre><code>class ArkCLIAPI(ArkAPI):\n    @property\n    def dpa_policies_vm_editor(self) -&gt; \"ArkDPAVMPoliciesEditorService\":\n        \"\"\"\n        VM policy editor CLI service\n\n        Returns:\n            ArkDPAVMPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.dpa.vm import ArkDPAVMPoliciesEditorService\n\n        return ArkDPAVMPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n\n    @property\n    def dpa_policies_db_editor(self) -&gt; \"ArkDPADBPoliciesEditorService\":\n        \"\"\"\n        DB policy editor CLI service\n\n        Returns:\n            ArkDPADBPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.dpa.db import ArkDPADBPoliciesEditorService\n\n        return ArkDPADBPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n</code></pre>"},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI.dpa_policies_db_editor","title":"<code>dpa_policies_db_editor: 'ArkDPADBPoliciesEditorService'</code>  <code>property</code>","text":"<p>DB policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesEditorService</code> <code>'ArkDPADBPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI.dpa_policies_vm_editor","title":"<code>dpa_policies_vm_editor: 'ArkDPAVMPoliciesEditorService'</code>  <code>property</code>","text":"<p>VM policy editor CLI service</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesEditorService</code> <code>'ArkDPAVMPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/dpa/","title":"dpa","text":""},{"location":"reference/cli_services/dpa/common/","title":"common","text":""},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/","title":"ark_dpa_base_policies_editor_service","text":""},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService","title":"<code>ArkDPABasePoliciesEditorService</code>","text":"<p>             Bases: <code>ArkService</code>, <code>ABC</code>, <code>Generic[PolicyType, PolicyListItemType, AddPolicyType, UpdatePolicyType, GeneratePolicyType]</code></p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>class ArkDPABasePoliciesEditorService(\n    ArkService, ABC, Generic[PolicyType, PolicyListItemType, AddPolicyType, UpdatePolicyType, GeneratePolicyType]\n):\n    def __init__(\n        self,\n        policy_type: PolicyType,\n        add_policy_type: AddPolicyType,\n        update_policy_type: UpdatePolicyType,\n        isp_auth: ArkISPAuth,\n        policies_family: str,\n        tenant_id: str,\n        policies_cache_dir: Optional[str] = None,\n        profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        super().__init__(isp_auth)\n        profile = profile or ArkProfileLoader.load_default_profile()\n        self._policies_family = policies_family\n        self.__policies_cache_dir = Path(policies_cache_dir or Path.home() / '.ark_cache' / 'profiles' / profile.profile_name / tenant_id)\n        if not policies_cache_dir and 'ARK_DPA_POLICIES_EDITOR_FOLDER' in os.environ:\n            self.__policies_cache_dir = Path(os.environ['ARK_DPA_POLICIES_EDITOR_FOLDER'])\n        self.__policies_cache_dir = self.__policies_cache_dir / policies_family\n        self.__policies_cache_dir.mkdir(exist_ok=True, parents=True)\n        self.__policy_type = policy_type\n        self.__add_policy_type = add_policy_type\n        self.__update_policy_type = update_policy_type\n\n    @abstractmethod\n    def _policy(self, get_policy: ArkDPAGetPolicy) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _list_policies(self) -&gt; List[PolicyListItemType]:\n        pass\n\n    @abstractmethod\n    def _add_policy(self, add_policy: AddPolicyType) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _update_policy(self, update_policy: UpdatePolicyType) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        pass\n\n    @abstractmethod\n    def _generate_policy(self, generate_policy: GeneratePolicyType, workspace_policies: List[PolicyType]) -&gt; PolicyType:\n        pass\n\n    def __load_policy_diff(self, workspace_policy: PolicyType) -&gt; Optional[Tuple[PolicyType, PolicyType]]:\n        remote_policy = self._policy(ArkDPAGetPolicy(policy_id=str(workspace_policy.policy_id)))\n        if remote_policy != workspace_policy:\n            return (workspace_policy, remote_policy)\n        return None\n\n    def __load_policies_diff(self) -&gt; Dict[str, Tuple[PolicyType, PolicyType]]:\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        with ThreadPoolExecutor() as executor:\n            remote_policies = {\n                p[0].policy_name: p for p in executor.map(self.__load_policy_diff, workspace_policies.values()) if p is not None\n            }\n            return remote_policies\n\n    def __load_policies_from_workspace_by_suffix(self, suffix: str = '') -&gt; Dict[str, PolicyType]:\n        p = Path(self.__policies_cache_dir).glob(f'*.json{suffix}')\n        policies_files = [x for x in p if x.is_file() and x.suffix == suffix or '.json']\n        policies = {}\n        for f in policies_files:\n            policy = self.__policy_type.parse_file(f)\n            policies[policy.policy_name] = policy\n        return policies\n\n    def __load_removed_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix('.removed')\n\n    def __load_generated_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix('.generated')\n\n    def __load_existing_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix()\n\n    def __load_policy_to_workspace(self, policy: PolicyListItemType, override: bool) -&gt; Optional[PolicyType]:\n        policy_data = self._policy(ArkDPAGetPolicy(policy_id=policy.policy_id))\n        policy_path = Path(self.__policies_cache_dir) / (policy_data.policy_name + '.json')\n        if policy_path.exists():\n            existing_data = self.__policy_type.parse_raw(policy_path.read_text())\n            if existing_data != policy_data:\n                if not override:\n                    return policy_data\n        if not policy_data.policy_id:\n            policy_data.policy_id = policy.policy_id\n        policy_path.write_text(policy_data.json(indent=4))\n        (Path(self.__policies_cache_dir) / (policy_data.policy_name + '.json.removed')).unlink(missing_ok=True)\n\n    def load_policies(self, load_policies: ArkDPALoadPolicies) -&gt; ArkDPALoadedPolicies:\n        \"\"\"\n        Loads all remote policies into the local workspace.\n        The user is asked whether to overwrite existing policies that were edited either locally or remotely.\n        When default overwrite is enabled, existing policies are overwritten without prompts.\n\n        Args:\n            load_policies (ArkDPALoadPolicies): _description_\n\n        Returns:\n            ArkDPALoadedPolicies: _description_\n        \"\"\"\n        policies = self._list_policies()\n        policies_to_query: Dict[str, PolicyType] = []\n        with ThreadPoolExecutor() as executor:\n            policies_to_query = {\n                p.policy_name: p\n                for p in executor.map(lambda p: self.__load_policy_to_workspace(p, load_policies.override), policies)\n                if p is not None\n            }\n        # Build the query editor to ask the user\n        policies_to_override = []\n        if policies_to_query:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'override',\n                        message=f'Conflicts detected, please choose if you wish to override local {self._policies_family} policies or leave them as is',\n                        choices=[p.policy_name for p in policies_to_query.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policies_to_override = answers['override']\n            for policy_name in policies_to_override:\n                policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n                if policy_path.exists() and policy_name in policies_to_query:\n                    policy_path.write_text(policies_to_query[policy_name].json(indent=4))\n        return ArkDPALoadedPolicies(\n            loaded_path=str(self.__policies_cache_dir),\n            overall_policies_count=len(policies),\n            loaded_policies_count=len(policies) - len(policies_to_query),\n            overriden_policies_count=len(policies_to_override),\n            untouched_policies_count=len(policies_to_query) - len(policies_to_override),\n        )\n\n    def edit_policies(self, edit_policies: ArkDPAEditPolicies) -&gt; None:\n        \"\"\"\n        Edits the set of specified policies one at a time, either via the CLI or the default OS editor.\n        Edited policies are only saved locally until they are committed.\n\n        Args:\n            edit_policies (ArkDPAEditPolicies): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        if not workspace_policies:\n            raise ArkServiceException(\n                f'No {self._policies_family} policies to edit in the workspace, please load the policies or generate a new one'\n            )\n        policy_names = edit_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to edit?, press space to select',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        try:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Editor(f'{name}_edit', message=f'Chosen {self._policies_family} policy [{name}] is about to be edited')\n                    for name in policy_names\n                ],\n                render=ArkInquirerRender(),\n                answers={f'{name}_edit': workspace_policies[name].json(indent=4) for name in policy_names},\n            )\n            for name in policy_names:\n                policy = self.__policy_type.parse_raw(answers[f'{name}_edit'])\n                for path in [\n                    Path(self.__policies_cache_dir) / (name + '.json'),\n                    Path(self.__policies_cache_dir) / (name + '.json.generated'),\n                ]:\n                    if path.exists():\n                        path.write_text(policy.json(indent=4))\n                        break\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to edit {self._policies_family} policies, '\n                f'you can edit the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def remove_policies(self, remove_policies: ArkDPARemovePolicies) -&gt; None:\n        \"\"\"\n        Removes one or more policies from the local workspace.\n        Until changes are committed, removing a remote policy only appends the `.deleted` indication to its name.\n        After committing the changes, the policies are deleted both locally and remotely.\n        New, uncommitted policies are deleted locally after the user consents.\n\n        Args:\n            remove_policies (ArkDPARemovePolicies): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        if not workspace_policies:\n            raise ArkServiceException(\n                f'No {self._policies_family} policies to remove in the workspace, please load the policies or generate a new one'\n            )\n        policy_names = remove_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to remove?, press space to select',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        for policy_name in policy_names:\n            for path in [\n                Path(self.__policies_cache_dir) / (policy_name + '.json'),\n                Path(self.__policies_cache_dir) / (policy_name + '.json.generated'),\n            ]:\n                if path.exists():\n                    if path.suffix == '.json':\n                        path.rename(Path(self.__policies_cache_dir) / (policy_name + '.json.removed'))\n                    else:\n                        answers = inquirer.prompt(\n                            [\n                                inquirer.Confirm(\n                                    'remove',\n                                    message=f'Are you sure you want to remove local {self._policies_family} policy [{policy_name}]?, removing an uncommitted local policy cannot be reverted',\n                                )\n                            ],\n                            render=ArkInquirerRender(),\n                        )\n                        if not answers:\n                            return\n                        if answers['remove']:\n                            path.unlink(missing_ok=True)\n\n    def view_policies(self, view_policies: ArkDPAViewPolicies) -&gt; None:\n        \"\"\"\n        Allows the user to view one or more policies either together or individually, as defined in the CLI user prompt.\n        Policies are viewed in the machine's default editor (both existing policies and newly generated policies).\n\n        Args:\n            view_policies (ArkDPAViewPolicies): _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        policy_names = view_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to view?',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        if not policy_names:\n            return\n        try:\n            if view_policies.unified:\n                inquirer.prompt(\n                    [inquirer.Editor('views', f'Show all selected {self._policies_family} policies')],\n                    answers={\n                        'views': '\\n\\n\\n'.join(\n                            [f'# Policy [{policy_name}]\\n{workspace_policies[policy_name].json(indent=4)}' for policy_name in policy_names]\n                        )\n                    },\n                    render=ArkInquirerRender(),\n                )\n            else:\n                inquirer.prompt(\n                    [inquirer.Editor(f'{policy_name}_view', f'Show [{policy_name}]') for policy_name in policy_names],\n                    render=ArkInquirerRender(),\n                    answers={f'{policy_name}_view': workspace_policies[policy_name].json(indent=4) for policy_name in policy_names},\n                )\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to view the {self._policies_family} policies, '\n                f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def reset_policies(self, reset_policy: ArkDPAResetPolicies) -&gt; None:\n        \"\"\"\n        Resets local workspace policies.\n        When all policies are reset, all local policies are overwritten and deleted policies are removed.\n        Otherwise, the user can select which policies are reset.\n        This function does not alter newly generated uncommitted policies.\n\n        Args:\n            reset_policy (ArkDPAResetPolicies): _description_\n        \"\"\"\n        if reset_policy.all:\n            answers = inquirer.prompt(\n                [inquirer.Confirm('reset', message=f'Are you sure you want to reset all edited {self._policies_family} policies?')]\n            )\n            if not answers:\n                return\n            if answers['reset']:\n                self.load_policies(ArkDPALoadPolicies(override=True))\n        else:\n            policies_diff = self.__load_policies_diff()\n            removed_policies = self.__load_removed_policies_from_workspace()\n            if not policies_diff and not removed_policies:\n                return\n            policy_names = reset_policy.names\n            if not policy_names:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Checkbox(\n                            'names',\n                            f'Which {self._policies_family} policies would you like to reset?, press space to select',\n                            choices=[p for p in policies_diff.keys() + removed_policies.keys()],\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    return\n                policy_names = answers['names']\n            policy_names = [p for p in policy_names if p in policies_diff or p in removed_policies]\n            for policy_name in policy_names:\n                policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n                if policy_name in policies_diff:\n                    policy_path.write_text(policies_diff[policy_name][1].json(indent=4))\n                elif policy_name in removed_policies:\n                    policy_path.write_text(removed_policies[policy_name].json(indent=4))\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n\n    def generate_policy(self, generate_policy: GeneratePolicyType) -&gt; None:\n        \"\"\"\n        Generates a new policy from a template and the user's parameters.\n        The user is prompted for the parameters when they are not specified in the CLI.\n        After policy's parameters are defined, the policy is generates in memory and can bee edited.\n        The new policy is saved locally until it is committed.\n\n        Args:\n            generate_policy (GeneratePolicyType): _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        policy = self._generate_policy(generate_policy, workspace_policies)\n        policy_path = Path(self.__policies_cache_dir) / (policy.policy_name + '.json.generated')\n        # Let the user edit the generated policy\n        if not generate_policy.disable_edit:\n            try:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Editor(\n                            'policy_editor',\n                            f'Newly {self._policies_family} policy is generated and ready to be edited, once edited, it will be saved to the local workspace',\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                    answers={'policy_editor': policy.json(indent=4, exclude_none=True)},\n                )\n                if not answers:\n                    return\n                policy = self.__policy_type.parse_raw(answers['policy_editor'])\n            except Exception as ex:\n                self._logger.error(\n                    f'An error occurred while trying to edit the {self._policies_family} policy, '\n                    f'the policy will be saved to [{policy_path}] and can be edited manually [{str(ex)}]'\n                )\n        policy_path.write_text(policy.json(indent=4))\n\n    def policies_diff(self, policies_diff: ArkDPAPoliciesDiff) -&gt; None:\n        \"\"\"\n        Calculates the diff between the local workspace and remote policies.\n        This diff includes uncommitted removed policies. A unified or per policy diff can be displayed.\n\n        Args:\n            policies_diff (ArkDPAPoliciesDiff): _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        if not loaded_policies_diff and not removed_policies:\n            return\n        if policies_diff.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in policies_diff.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in policies_diff.names}\n        if not loaded_policies_diff and not removed_policies:\n            return\n        diffs = {\n            policy_name: difflib.unified_diff(\n                policy_tuple[1].json(indent=4).splitlines(True),\n                policy_tuple[0].json(indent=4).splitlines(True),\n                fromfile=f'local policy [{policy_name}]',\n                tofile=f'remote policy [{policy_name}]',\n                n=MAX_LINE_DIFF,\n            )\n            for policy_name, policy_tuple in loaded_policies_diff.items()\n        }\n        diffs.update(\n            {\n                policy_name: difflib.unified_diff(\n                    policy.json(indent=4).splitlines(True),\n                    '',\n                    fromfile=f'local policy [{policy_name}]',\n                    tofile=f'remote policy [{policy_name}]',\n                    n=MAX_LINE_DIFF,\n                )\n                for policy_name, policy in removed_policies.items()\n            }\n        )\n        try:\n            if policies_diff.unified:\n                inquirer.prompt(\n                    [inquirer.Editor('diffs', 'Show all diffs')],\n                    render=ArkInquirerRender(),\n                    answers={'diffs': '\\n\\n\\n'.join([''.join(d) for d in diffs.values()])},\n                )\n            else:\n                inquirer.prompt(\n                    [inquirer.Editor(f'{policy_name}_diff', f'Show [{policy_name}] diff') for policy_name in diffs.keys()],\n                    render=ArkInquirerRender(),\n                    answers={f'{policy_name}_diff': ''.join(policy_diffs) for policy_name, policy_diffs in diffs.items()},\n                )\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to show {self._policies_family} policies diff, '\n                f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def policies_status(self, get_policies_status: ArkDPAGetPoliciesStatus) -&gt; ArkDPAPoliciesStatus:\n        \"\"\"\n        Gets the status of locally altered policies.\n\n        Args:\n            get_policies_status (ArkDPAGetPoliciesStatus): _description_\n\n        Returns:\n            ArkDPAPoliciesStatus: _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        generated_policies = self.__load_generated_policies_from_workspace()\n        if get_policies_status.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in get_policies_status.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in get_policies_status.names}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in get_policies_status.names}\n        return ArkDPAPoliciesStatus(\n            modified_policies=list(loaded_policies_diff.keys()),\n            removed_policies=list(removed_policies.keys()),\n            added_policies=list(generated_policies.keys()),\n        )\n\n    def commit_policies(self, commit_policies: ArkDPACommitPolicies) -&gt; None:\n        \"\"\"\n        Commits policies.\n        The function first calculates the differences between the local and remote policies to find out which policies were edited, including\n        the policies selected for deletion and new, uncommitted policies. It also\n        allows selecting whether to commit all the edited policies or only specific policies by name.\n\n        After all policies are committed, the workspace is reorganized accordingly.\n\n        Args:\n            commit_policies (ArkDPACommitPolicies): _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        generated_policies = self.__load_generated_policies_from_workspace()\n        if not loaded_policies_diff and not removed_policies and not generated_policies:\n            return\n        if commit_policies.all:\n            answers = inquirer.prompt(\n                [inquirer.Confirm('reset', message=f'Are you sure you want to commit all edited {self._policies_family} policies?')]\n            )\n            if not answers or not answers['reset']:\n                return\n        else:\n            if commit_policies.names:\n                loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in commit_policies.names}\n                removed_policies = {k: v for k, v in removed_policies.items() if k in commit_policies.names}\n                generated_policies = {k: v for k, v in generated_policies.items() if k in commit_policies.names}\n            else:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Checkbox(\n                            'names',\n                            f'Which {self._policies_family} policies would you like to commit?, press space to select',\n                            choices=list(loaded_policies_diff.keys()) + list(removed_policies.keys()) + list(generated_policies.keys()),\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    return\n                loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in answers['names']}\n                removed_policies = {k: v for k, v in removed_policies.items() if k in answers['names']}\n                generated_policies = {k: v for k, v in generated_policies.items() if k in answers['names']}\n            if not loaded_policies_diff and not removed_policies and not generated_policies:\n                return\n        with ThreadPoolExecutor() as executor:\n            added = executor.map(lambda p: self._add_policy(self.__add_policy_type(**p.dict())), generated_policies.values())\n            updated = executor.map(lambda p: self._update_policy(self.__update_policy_type(**p[0].dict())), loaded_policies_diff.values())\n            deleted = executor.map(\n                lambda p: self._delete_policy(ArkDPADeletePolicy(policy_id=p.policy_id, policy_name=p.policy_name)),\n                removed_policies.values(),\n            )\n            # Loop for exception checking\n            added_policies = list(added)\n            for _ in itertools.chain(updated, deleted):\n                pass\n        for policy_name in removed_policies.keys():\n            (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n        for policy_name in generated_policies.keys():\n            for policy in added_policies:\n                if policy.policy_name == policy_name:\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json.generated')).rename(\n                        (Path(self.__policies_cache_dir) / (policy_name + '.json'))\n                    )\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json')).write_text(policy.json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.commit_policies","title":"<code>commit_policies(commit_policies)</code>","text":"<p>Commits policies. The function first calculates the differences between the local and remote policies to find out which policies were edited, including the policies selected for deletion and new, uncommitted policies. It also allows selecting whether to commit all the edited policies or only specific policies by name.</p> <p>After all policies are committed, the workspace is reorganized accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>commit_policies</code> <code>ArkDPACommitPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def commit_policies(self, commit_policies: ArkDPACommitPolicies) -&gt; None:\n    \"\"\"\n    Commits policies.\n    The function first calculates the differences between the local and remote policies to find out which policies were edited, including\n    the policies selected for deletion and new, uncommitted policies. It also\n    allows selecting whether to commit all the edited policies or only specific policies by name.\n\n    After all policies are committed, the workspace is reorganized accordingly.\n\n    Args:\n        commit_policies (ArkDPACommitPolicies): _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    generated_policies = self.__load_generated_policies_from_workspace()\n    if not loaded_policies_diff and not removed_policies and not generated_policies:\n        return\n    if commit_policies.all:\n        answers = inquirer.prompt(\n            [inquirer.Confirm('reset', message=f'Are you sure you want to commit all edited {self._policies_family} policies?')]\n        )\n        if not answers or not answers['reset']:\n            return\n    else:\n        if commit_policies.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in commit_policies.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in commit_policies.names}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in commit_policies.names}\n        else:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to commit?, press space to select',\n                        choices=list(loaded_policies_diff.keys()) + list(removed_policies.keys()) + list(generated_policies.keys()),\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in answers['names']}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in answers['names']}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in answers['names']}\n        if not loaded_policies_diff and not removed_policies and not generated_policies:\n            return\n    with ThreadPoolExecutor() as executor:\n        added = executor.map(lambda p: self._add_policy(self.__add_policy_type(**p.dict())), generated_policies.values())\n        updated = executor.map(lambda p: self._update_policy(self.__update_policy_type(**p[0].dict())), loaded_policies_diff.values())\n        deleted = executor.map(\n            lambda p: self._delete_policy(ArkDPADeletePolicy(policy_id=p.policy_id, policy_name=p.policy_name)),\n            removed_policies.values(),\n        )\n        # Loop for exception checking\n        added_policies = list(added)\n        for _ in itertools.chain(updated, deleted):\n            pass\n    for policy_name in removed_policies.keys():\n        (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n    for policy_name in generated_policies.keys():\n        for policy in added_policies:\n            if policy.policy_name == policy_name:\n                (Path(self.__policies_cache_dir) / (policy_name + '.json.generated')).rename(\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json'))\n                )\n                (Path(self.__policies_cache_dir) / (policy_name + '.json')).write_text(policy.json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.edit_policies","title":"<code>edit_policies(edit_policies)</code>","text":"<p>Edits the set of specified policies one at a time, either via the CLI or the default OS editor. Edited policies are only saved locally until they are committed.</p> <p>Parameters:</p> Name Type Description Default <code>edit_policies</code> <code>ArkDPAEditPolicies</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def edit_policies(self, edit_policies: ArkDPAEditPolicies) -&gt; None:\n    \"\"\"\n    Edits the set of specified policies one at a time, either via the CLI or the default OS editor.\n    Edited policies are only saved locally until they are committed.\n\n    Args:\n        edit_policies (ArkDPAEditPolicies): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    if not workspace_policies:\n        raise ArkServiceException(\n            f'No {self._policies_family} policies to edit in the workspace, please load the policies or generate a new one'\n        )\n    policy_names = edit_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to edit?, press space to select',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    try:\n        answers = inquirer.prompt(\n            [\n                inquirer.Editor(f'{name}_edit', message=f'Chosen {self._policies_family} policy [{name}] is about to be edited')\n                for name in policy_names\n            ],\n            render=ArkInquirerRender(),\n            answers={f'{name}_edit': workspace_policies[name].json(indent=4) for name in policy_names},\n        )\n        for name in policy_names:\n            policy = self.__policy_type.parse_raw(answers[f'{name}_edit'])\n            for path in [\n                Path(self.__policies_cache_dir) / (name + '.json'),\n                Path(self.__policies_cache_dir) / (name + '.json.generated'),\n            ]:\n                if path.exists():\n                    path.write_text(policy.json(indent=4))\n                    break\n    except Exception as ex:\n        self._logger.error(\n            f'An error occurred while trying to edit {self._policies_family} policies, '\n            f'you can edit the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.generate_policy","title":"<code>generate_policy(generate_policy)</code>","text":"<p>Generates a new policy from a template and the user's parameters. The user is prompted for the parameters when they are not specified in the CLI. After policy's parameters are defined, the policy is generates in memory and can bee edited. The new policy is saved locally until it is committed.</p> <p>Parameters:</p> Name Type Description Default <code>generate_policy</code> <code>GeneratePolicyType</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def generate_policy(self, generate_policy: GeneratePolicyType) -&gt; None:\n    \"\"\"\n    Generates a new policy from a template and the user's parameters.\n    The user is prompted for the parameters when they are not specified in the CLI.\n    After policy's parameters are defined, the policy is generates in memory and can bee edited.\n    The new policy is saved locally until it is committed.\n\n    Args:\n        generate_policy (GeneratePolicyType): _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    policy = self._generate_policy(generate_policy, workspace_policies)\n    policy_path = Path(self.__policies_cache_dir) / (policy.policy_name + '.json.generated')\n    # Let the user edit the generated policy\n    if not generate_policy.disable_edit:\n        try:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Editor(\n                        'policy_editor',\n                        f'Newly {self._policies_family} policy is generated and ready to be edited, once edited, it will be saved to the local workspace',\n                    )\n                ],\n                render=ArkInquirerRender(),\n                answers={'policy_editor': policy.json(indent=4, exclude_none=True)},\n            )\n            if not answers:\n                return\n            policy = self.__policy_type.parse_raw(answers['policy_editor'])\n        except Exception as ex:\n            self._logger.error(\n                f'An error occurred while trying to edit the {self._policies_family} policy, '\n                f'the policy will be saved to [{policy_path}] and can be edited manually [{str(ex)}]'\n            )\n    policy_path.write_text(policy.json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.load_policies","title":"<code>load_policies(load_policies)</code>","text":"<p>Loads all remote policies into the local workspace. The user is asked whether to overwrite existing policies that were edited either locally or remotely. When default overwrite is enabled, existing policies are overwritten without prompts.</p> <p>Parameters:</p> Name Type Description Default <code>load_policies</code> <code>ArkDPALoadPolicies</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPALoadedPolicies</code> <code>ArkDPALoadedPolicies</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def load_policies(self, load_policies: ArkDPALoadPolicies) -&gt; ArkDPALoadedPolicies:\n    \"\"\"\n    Loads all remote policies into the local workspace.\n    The user is asked whether to overwrite existing policies that were edited either locally or remotely.\n    When default overwrite is enabled, existing policies are overwritten without prompts.\n\n    Args:\n        load_policies (ArkDPALoadPolicies): _description_\n\n    Returns:\n        ArkDPALoadedPolicies: _description_\n    \"\"\"\n    policies = self._list_policies()\n    policies_to_query: Dict[str, PolicyType] = []\n    with ThreadPoolExecutor() as executor:\n        policies_to_query = {\n            p.policy_name: p\n            for p in executor.map(lambda p: self.__load_policy_to_workspace(p, load_policies.override), policies)\n            if p is not None\n        }\n    # Build the query editor to ask the user\n    policies_to_override = []\n    if policies_to_query:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'override',\n                    message=f'Conflicts detected, please choose if you wish to override local {self._policies_family} policies or leave them as is',\n                    choices=[p.policy_name for p in policies_to_query.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policies_to_override = answers['override']\n        for policy_name in policies_to_override:\n            policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n            if policy_path.exists() and policy_name in policies_to_query:\n                policy_path.write_text(policies_to_query[policy_name].json(indent=4))\n    return ArkDPALoadedPolicies(\n        loaded_path=str(self.__policies_cache_dir),\n        overall_policies_count=len(policies),\n        loaded_policies_count=len(policies) - len(policies_to_query),\n        overriden_policies_count=len(policies_to_override),\n        untouched_policies_count=len(policies_to_query) - len(policies_to_override),\n    )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.policies_diff","title":"<code>policies_diff(policies_diff)</code>","text":"<p>Calculates the diff between the local workspace and remote policies. This diff includes uncommitted removed policies. A unified or per policy diff can be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>policies_diff</code> <code>ArkDPAPoliciesDiff</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def policies_diff(self, policies_diff: ArkDPAPoliciesDiff) -&gt; None:\n    \"\"\"\n    Calculates the diff between the local workspace and remote policies.\n    This diff includes uncommitted removed policies. A unified or per policy diff can be displayed.\n\n    Args:\n        policies_diff (ArkDPAPoliciesDiff): _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    if not loaded_policies_diff and not removed_policies:\n        return\n    if policies_diff.names:\n        loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in policies_diff.names}\n        removed_policies = {k: v for k, v in removed_policies.items() if k in policies_diff.names}\n    if not loaded_policies_diff and not removed_policies:\n        return\n    diffs = {\n        policy_name: difflib.unified_diff(\n            policy_tuple[1].json(indent=4).splitlines(True),\n            policy_tuple[0].json(indent=4).splitlines(True),\n            fromfile=f'local policy [{policy_name}]',\n            tofile=f'remote policy [{policy_name}]',\n            n=MAX_LINE_DIFF,\n        )\n        for policy_name, policy_tuple in loaded_policies_diff.items()\n    }\n    diffs.update(\n        {\n            policy_name: difflib.unified_diff(\n                policy.json(indent=4).splitlines(True),\n                '',\n                fromfile=f'local policy [{policy_name}]',\n                tofile=f'remote policy [{policy_name}]',\n                n=MAX_LINE_DIFF,\n            )\n            for policy_name, policy in removed_policies.items()\n        }\n    )\n    try:\n        if policies_diff.unified:\n            inquirer.prompt(\n                [inquirer.Editor('diffs', 'Show all diffs')],\n                render=ArkInquirerRender(),\n                answers={'diffs': '\\n\\n\\n'.join([''.join(d) for d in diffs.values()])},\n            )\n        else:\n            inquirer.prompt(\n                [inquirer.Editor(f'{policy_name}_diff', f'Show [{policy_name}] diff') for policy_name in diffs.keys()],\n                render=ArkInquirerRender(),\n                answers={f'{policy_name}_diff': ''.join(policy_diffs) for policy_name, policy_diffs in diffs.items()},\n            )\n    except Exception as ex:\n        self._logger.error(\n            f'An error occurred while trying to show {self._policies_family} policies diff, '\n            f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.policies_status","title":"<code>policies_status(get_policies_status)</code>","text":"<p>Gets the status of locally altered policies.</p> <p>Parameters:</p> Name Type Description Default <code>get_policies_status</code> <code>ArkDPAGetPoliciesStatus</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPAPoliciesStatus</code> <code>ArkDPAPoliciesStatus</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def policies_status(self, get_policies_status: ArkDPAGetPoliciesStatus) -&gt; ArkDPAPoliciesStatus:\n    \"\"\"\n    Gets the status of locally altered policies.\n\n    Args:\n        get_policies_status (ArkDPAGetPoliciesStatus): _description_\n\n    Returns:\n        ArkDPAPoliciesStatus: _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    generated_policies = self.__load_generated_policies_from_workspace()\n    if get_policies_status.names:\n        loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in get_policies_status.names}\n        removed_policies = {k: v for k, v in removed_policies.items() if k in get_policies_status.names}\n        generated_policies = {k: v for k, v in generated_policies.items() if k in get_policies_status.names}\n    return ArkDPAPoliciesStatus(\n        modified_policies=list(loaded_policies_diff.keys()),\n        removed_policies=list(removed_policies.keys()),\n        added_policies=list(generated_policies.keys()),\n    )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.remove_policies","title":"<code>remove_policies(remove_policies)</code>","text":"<p>Removes one or more policies from the local workspace. Until changes are committed, removing a remote policy only appends the <code>.deleted</code> indication to its name. After committing the changes, the policies are deleted both locally and remotely. New, uncommitted policies are deleted locally after the user consents.</p> <p>Parameters:</p> Name Type Description Default <code>remove_policies</code> <code>ArkDPARemovePolicies</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def remove_policies(self, remove_policies: ArkDPARemovePolicies) -&gt; None:\n    \"\"\"\n    Removes one or more policies from the local workspace.\n    Until changes are committed, removing a remote policy only appends the `.deleted` indication to its name.\n    After committing the changes, the policies are deleted both locally and remotely.\n    New, uncommitted policies are deleted locally after the user consents.\n\n    Args:\n        remove_policies (ArkDPARemovePolicies): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    if not workspace_policies:\n        raise ArkServiceException(\n            f'No {self._policies_family} policies to remove in the workspace, please load the policies or generate a new one'\n        )\n    policy_names = remove_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to remove?, press space to select',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    for policy_name in policy_names:\n        for path in [\n            Path(self.__policies_cache_dir) / (policy_name + '.json'),\n            Path(self.__policies_cache_dir) / (policy_name + '.json.generated'),\n        ]:\n            if path.exists():\n                if path.suffix == '.json':\n                    path.rename(Path(self.__policies_cache_dir) / (policy_name + '.json.removed'))\n                else:\n                    answers = inquirer.prompt(\n                        [\n                            inquirer.Confirm(\n                                'remove',\n                                message=f'Are you sure you want to remove local {self._policies_family} policy [{policy_name}]?, removing an uncommitted local policy cannot be reverted',\n                            )\n                        ],\n                        render=ArkInquirerRender(),\n                    )\n                    if not answers:\n                        return\n                    if answers['remove']:\n                        path.unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.reset_policies","title":"<code>reset_policies(reset_policy)</code>","text":"<p>Resets local workspace policies. When all policies are reset, all local policies are overwritten and deleted policies are removed. Otherwise, the user can select which policies are reset. This function does not alter newly generated uncommitted policies.</p> <p>Parameters:</p> Name Type Description Default <code>reset_policy</code> <code>ArkDPAResetPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def reset_policies(self, reset_policy: ArkDPAResetPolicies) -&gt; None:\n    \"\"\"\n    Resets local workspace policies.\n    When all policies are reset, all local policies are overwritten and deleted policies are removed.\n    Otherwise, the user can select which policies are reset.\n    This function does not alter newly generated uncommitted policies.\n\n    Args:\n        reset_policy (ArkDPAResetPolicies): _description_\n    \"\"\"\n    if reset_policy.all:\n        answers = inquirer.prompt(\n            [inquirer.Confirm('reset', message=f'Are you sure you want to reset all edited {self._policies_family} policies?')]\n        )\n        if not answers:\n            return\n        if answers['reset']:\n            self.load_policies(ArkDPALoadPolicies(override=True))\n    else:\n        policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        if not policies_diff and not removed_policies:\n            return\n        policy_names = reset_policy.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to reset?, press space to select',\n                        choices=[p for p in policies_diff.keys() + removed_policies.keys()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        policy_names = [p for p in policy_names if p in policies_diff or p in removed_policies]\n        for policy_name in policy_names:\n            policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n            if policy_name in policies_diff:\n                policy_path.write_text(policies_diff[policy_name][1].json(indent=4))\n            elif policy_name in removed_policies:\n                policy_path.write_text(removed_policies[policy_name].json(indent=4))\n                (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.view_policies","title":"<code>view_policies(view_policies)</code>","text":"<p>Allows the user to view one or more policies either together or individually, as defined in the CLI user prompt. Policies are viewed in the machine's default editor (both existing policies and newly generated policies).</p> <p>Parameters:</p> Name Type Description Default <code>view_policies</code> <code>ArkDPAViewPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def view_policies(self, view_policies: ArkDPAViewPolicies) -&gt; None:\n    \"\"\"\n    Allows the user to view one or more policies either together or individually, as defined in the CLI user prompt.\n    Policies are viewed in the machine's default editor (both existing policies and newly generated policies).\n\n    Args:\n        view_policies (ArkDPAViewPolicies): _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    policy_names = view_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to view?',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    if not policy_names:\n        return\n    try:\n        if view_policies.unified:\n            inquirer.prompt(\n                [inquirer.Editor('views', f'Show all selected {self._policies_family} policies')],\n                answers={\n                    'views': '\\n\\n\\n'.join(\n                        [f'# Policy [{policy_name}]\\n{workspace_policies[policy_name].json(indent=4)}' for policy_name in policy_names]\n                    )\n                },\n                render=ArkInquirerRender(),\n            )\n        else:\n            inquirer.prompt(\n                [inquirer.Editor(f'{policy_name}_view', f'Show [{policy_name}]') for policy_name in policy_names],\n                render=ArkInquirerRender(),\n                answers={f'{policy_name}_view': workspace_policies[policy_name].json(indent=4) for policy_name in policy_names},\n            )\n    except Exception as ex:\n        self._logger.error(\n            f'An error occurred while trying to view the {self._policies_family} policies, '\n            f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/dpa/db/","title":"db","text":""},{"location":"reference/cli_services/dpa/db/ark_dpa_db_policies_editor_service/","title":"ark_dpa_db_policies_editor_service","text":""},{"location":"reference/cli_services/dpa/vm/","title":"vm","text":""},{"location":"reference/cli_services/dpa/vm/ark_dpa_vm_policies_editor_service/","title":"ark_dpa_vm_policies_editor_service","text":""},{"location":"reference/common/","title":"common","text":""},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient","title":"<code>ArkAsyncClient</code>","text":"<p>             Bases: <code>ABC</code>, <code>ArkClient</code></p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>class ArkAsyncClient(ABC, ArkClient):\n    def __init__(\n        self,\n        async_request_settings: ArkAsyncRequestSettings = None,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        super().__init__(\n            base_url, token, token_type, cookies, auth_header_name, auth, refresh_connection_callback=refresh_connection_callback\n        )\n        self.__async_request_settings = async_request_settings or ArkAsyncRequestSettings()\n\n    @abstractmethod\n    def async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n        \"\"\"\n        Creates an async request for the specified model and task.\n        The request polls for async operations as defined by the poll model's implementation.\n\n        Args:\n            poll_model (ArkPollableModel): _description_\n            async_task (ArkAsyncTask): _description_\n\n        Returns:\n            ArkAsyncRequest: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_task_type() -&gt; Type[ArkAsyncTask]:\n        \"\"\"\n        Returns the client's async task type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_request_type() -&gt; Type[ArkAsyncRequest]:\n        \"\"\"\n        Returns the client's async request type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @property\n    def async_request_settings(self) -&gt; ArkAsyncRequestSettings:\n        return self.__async_request_settings\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_request_for","title":"<code>async_request_for(poll_model, async_task)</code>  <code>abstractmethod</code>","text":"<p>Creates an async request for the specified model and task. The request polls for async operations as defined by the poll model's implementation.</p> <p>Parameters:</p> Name Type Description Default <code>poll_model</code> <code>ArkPollableModel</code> <p>description</p> required <code>async_task</code> <code>ArkAsyncTask</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkAsyncRequest</code> <code>ArkAsyncRequest</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@abstractmethod\ndef async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n    \"\"\"\n    Creates an async request for the specified model and task.\n    The request polls for async operations as defined by the poll model's implementation.\n\n    Args:\n        poll_model (ArkPollableModel): _description_\n        async_task (ArkAsyncTask): _description_\n\n    Returns:\n        ArkAsyncRequest: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_request_type","title":"<code>async_request_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async request type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncRequest]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_request_type() -&gt; Type[ArkAsyncRequest]:\n    \"\"\"\n    Returns the client's async request type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_task_type","title":"<code>async_task_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async task type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncTask]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_task_type() -&gt; Type[ArkAsyncTask]:\n    \"\"\"\n    Returns the client's async task type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest","title":"<code>ArkAsyncRequest</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>class ArkAsyncRequest(ABC):\n    def __init__(self, client: ArkClient, async_task: ArkAsyncTask, async_request_settings: ArkAsyncRequestSettings):\n        self._async_task = async_task\n        self._client = client\n        self._async_request_settings = async_request_settings\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def is_finished(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has finished.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_failed(self) -&gt; bool:\n        \"\"\"\n        Checks whether or the current async request failed.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_timeout(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has timed out.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n        \"\"\"\n        Polls the async request until it has completed.\n        Progress callbacks can also be used to return the async request's status.\n\n        Args:\n            timeout_seconds (int): _description_\n            progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @property\n    def async_task(self) -&gt; ArkAsyncTask:\n        return self._async_task\n\n    @property\n    def client(self) -&gt; ArkClient:\n        return self._client\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.is_finished","title":"<code>is_finished()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has finished.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has finished.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.poll","title":"<code>poll(timeout_seconds, progress_callback)</code>  <code>abstractmethod</code>","text":"<p>Polls the async request until it has completed. Progress callbacks can also be used to return the async request's status.</p> <p>Parameters:</p> Name Type Description Default <code>timeout_seconds</code> <code>int</code> <p>description</p> required <code>progress_callback</code> <code>Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls the async request until it has completed.\n    Progress callbacks can also be used to return the async request's status.\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.task_failed","title":"<code>task_failed()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or the current async request failed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether or the current async request failed.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.task_timeout","title":"<code>task_timeout()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has timed out.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has timed out.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient","title":"<code>ArkClient</code>","text":"Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>class ArkClient:\n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        cookie_jar: Optional[RequestsCookieJar] = None,\n        verify: Optional[Union[str, bool]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        from fake_useragent import UserAgent\n\n        self.__session = Session()\n        self.__base_url = base_url\n        self.__token = token\n        self.__token_type = token_type\n        self.__auth_header_name = auth_header_name\n        self.__refresh_connection_callback = refresh_connection_callback\n        if self.__base_url and not self.__base_url.startswith('https://'):\n            self.__base_url = f'https://{self.__base_url}'\n        if auth:\n            self.__session.auth = auth\n        self.update_token(token)\n        self.update_cookies(cookies, cookie_jar)\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        self.__session.headers['User-Agent'] = UserAgent(browsers=['chrome']).googlechrome\n\n    @property\n    def base_url(self) -&gt; Optional[str]:\n        return self.__base_url\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__token\n\n    @property\n    def refresh_connection_callback(self) -&gt; Optional[Callable[['ArkClient'], None]]:\n        return self.__refresh_connection_callback\n\n    def add_header(self, key: str, value: str) -&gt; None:\n        self.__session.headers.update({key: value})\n\n    def add_headers(self, headers: Dict[str, str]) -&gt; None:\n        self.__session.headers.update(headers)\n\n    def add_cookie(self, key: str, value: str) -&gt; None:\n        self.__session.cookies[key] = value\n\n    def generic_http_method_request(self, method: str, route: str, **kwargs) -&gt; Response:\n        url = route\n        if self.__base_url:\n            url = f'{self.__base_url}'\n            if route and route != '':\n                if self.__base_url.endswith('/') or route.startswith('/'):\n                    url = f'{self.__base_url}{route}'\n                else:\n                    url = f'{self.__base_url}/{route}'\n        http_method = getattr(self.__session, method)\n        response: Response = http_method(url, **kwargs)\n        return response\n\n    def get(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a GET request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('get', route, **kwargs)\n\n    def post(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a POST request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('post', route, **kwargs)\n\n    def put(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PUT request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('put', route, **kwargs)\n\n    def delete(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a DELETE request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('delete', route, **kwargs)\n\n    def patch(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PATCH request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('patch', route, **kwargs)\n\n    def options(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a OPTIONS request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('options', route, **kwargs)\n\n    def update_token(self, token: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Updates a session token.\n\n        Args:\n            token (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\n        self.__token = token\n        if token:\n            if self.__token_type == 'Basic':\n                user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n                self.__session.auth = (user, password)\n            else:\n                if len(self.__token_type) == 0:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n                else:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n\n    def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n        \"\"\"\n        Updates session cookies.\n\n        Args:\n            cookies (Optional[List], optional): _description_. Defaults to None.\n            cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n        \"\"\"\n        if cookies:\n            for c in cookies:\n                self.__session.cookies.set_cookie(c)\n        if cookie_jar:\n            self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.delete","title":"<code>delete(route, **kwargs)</code>","text":"<p>Performs a DELETE request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def delete(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a DELETE request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('delete', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.get","title":"<code>get(route, **kwargs)</code>","text":"<p>Performs a GET request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def get(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a GET request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('get', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.options","title":"<code>options(route, **kwargs)</code>","text":"<p>Performs a OPTIONS request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def options(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a OPTIONS request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('options', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.patch","title":"<code>patch(route, **kwargs)</code>","text":"<p>Performs a PATCH request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def patch(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PATCH request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('patch', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.post","title":"<code>post(route, **kwargs)</code>","text":"<p>Performs a POST request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def post(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a POST request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('post', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.put","title":"<code>put(route, **kwargs)</code>","text":"<p>Performs a PUT request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def put(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PUT request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('put', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.update_cookies","title":"<code>update_cookies(cookies=None, cookie_jar=None)</code>","text":"<p>Updates session cookies.</p> <p>Parameters:</p> Name Type Description Default <code>cookies</code> <code>Optional[List]</code> <p>description. Defaults to None.</p> <code>None</code> <code>cookie_jar</code> <code>Optional[RequestsCookieJar]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n    \"\"\"\n    Updates session cookies.\n\n    Args:\n        cookies (Optional[List], optional): _description_. Defaults to None.\n        cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n    \"\"\"\n    if cookies:\n        for c in cookies:\n            self.__session.cookies.set_cookie(c)\n    if cookie_jar:\n        self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.update_token","title":"<code>update_token(token=None)</code>","text":"<p>Updates a session token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_token(self, token: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Updates a session token.\n\n    Args:\n        token (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\n    self.__token = token\n    if token:\n        if self.__token_type == 'Basic':\n            user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n            self.__session.auth = (user, password)\n        else:\n            if len(self.__token_type) == 0:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n            else:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring","title":"<code>ArkKeyring</code>","text":"Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>class ArkKeyring:\n    def __init__(self, service_name: str) -&gt; None:\n        self.__service_name = service_name\n        self.__logger = get_logger(self.__class__.__name__)\n\n    @staticmethod\n    def __is_docker():\n        path = '/proc/self/cgroup'\n        return os.path.exists('/.dockerenv') or os.path.isfile(path) and any('docker' in line for line in open(path, encoding='utf-8'))\n\n    @staticmethod\n    def get_keyring(enforce_basic_keyring: bool = False):\n        try:\n            # Docker or WSL\n            if (\n                ArkKeyring.__is_docker()\n                or 'Microsoft' in uname().release\n                or ARK_BASIC_KEYRING_OVERRIDE_ENV_VAR in os.environ\n                or enforce_basic_keyring\n            ):\n                return BasicKeyring()\n            if sys.platform == 'win32':\n                from keyrings.cryptfile.cryptfile import CryptFileKeyring  # pylint: disable=import-error\n\n                kr = CryptFileKeyring()\n                kr.keyring_key = socket.gethostname()\n                return kr\n            elif sys.platform == 'darwin' or os.path.exists('/etc/redhat-release'):\n                return BasicKeyring()\n            else:\n                if DBUS_SESSION_ENV_VAR not in os.environ:\n                    return BasicKeyring()\n                from keyring.backends import SecretService  # pylint: disable=unused-import\n\n                return SecretService.Keyring()\n        except Exception:\n            return BasicKeyring()\n\n    def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n        \"\"\"\n        Saves the specified token for a profile in the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n        Args:\n            profile (ArkProfile): _description_\n            token (ArkToken): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n        \"\"\"\n        try:\n            self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            kr = self.get_keyring(enforce_basic_keyring)\n            kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n            self.__logger.info('Saved token successfully')\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n                return self.save_token(profile, token, postfix, True)\n            self.__logger.warning(f'Failed to save token [{str(ex)}]')\n\n    def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads a token for a profile from the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n        When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n        When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n        Args:\n            profile (ArkProfile): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        try:\n            kr = self.get_keyring(enforce_basic_keyring)\n            self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            if not token_val:\n                self.__logger.info('No token found')\n                return None\n            token = ArkToken.parse_raw(token_val)\n            if token.expires_in:\n                if (\n                    not token.refresh_token\n                    and token.token_type != ArkTokenType.Internal\n                    and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and no refresh token exists')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n                elif (\n                    token.refresh_token\n                    and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n            self.__logger.info('Loaded token successfully')\n            return token\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n                return self.load_token(profile, postfix, True)\n            self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n            try:\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            except Exception as ex_deletion:\n                self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n            return None\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring.load_token","title":"<code>load_token(profile, postfix, enforce_basic_keyring=False)</code>","text":"<p>Loads a token for a profile from the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used. When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned. When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads a token for a profile from the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n    When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n    When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n    Args:\n        profile (ArkProfile): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    try:\n        kr = self.get_keyring(enforce_basic_keyring)\n        self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        if not token_val:\n            self.__logger.info('No token found')\n            return None\n        token = ArkToken.parse_raw(token_val)\n        if token.expires_in:\n            if (\n                not token.refresh_token\n                and token.token_type != ArkTokenType.Internal\n                and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and no refresh token exists')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n            elif (\n                token.refresh_token\n                and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n        self.__logger.info('Loaded token successfully')\n        return token\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n            return self.load_token(profile, postfix, True)\n        self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n        try:\n            kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        except Exception as ex_deletion:\n            self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n        return None\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring.save_token","title":"<code>save_token(profile, token, postfix, enforce_basic_keyring=False)</code>","text":"<p>Saves the specified token for a profile in the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n    \"\"\"\n    Saves the specified token for a profile in the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n    Args:\n        profile (ArkProfile): _description_\n        token (ArkToken): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n    \"\"\"\n    try:\n        self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        kr = self.get_keyring(enforce_basic_keyring)\n        kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n        self.__logger.info('Saved token successfully')\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n            return self.save_token(profile, token, postfix, True)\n        self.__logger.warning(f'Failed to save token [{str(ex)}]')\n</code></pre>"},{"location":"reference/common/ark_async_client/","title":"ark_async_client","text":""},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient","title":"<code>ArkAsyncClient</code>","text":"<p>             Bases: <code>ABC</code>, <code>ArkClient</code></p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>class ArkAsyncClient(ABC, ArkClient):\n    def __init__(\n        self,\n        async_request_settings: ArkAsyncRequestSettings = None,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        super().__init__(\n            base_url, token, token_type, cookies, auth_header_name, auth, refresh_connection_callback=refresh_connection_callback\n        )\n        self.__async_request_settings = async_request_settings or ArkAsyncRequestSettings()\n\n    @abstractmethod\n    def async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n        \"\"\"\n        Creates an async request for the specified model and task.\n        The request polls for async operations as defined by the poll model's implementation.\n\n        Args:\n            poll_model (ArkPollableModel): _description_\n            async_task (ArkAsyncTask): _description_\n\n        Returns:\n            ArkAsyncRequest: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_task_type() -&gt; Type[ArkAsyncTask]:\n        \"\"\"\n        Returns the client's async task type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_request_type() -&gt; Type[ArkAsyncRequest]:\n        \"\"\"\n        Returns the client's async request type.\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @property\n    def async_request_settings(self) -&gt; ArkAsyncRequestSettings:\n        return self.__async_request_settings\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_request_for","title":"<code>async_request_for(poll_model, async_task)</code>  <code>abstractmethod</code>","text":"<p>Creates an async request for the specified model and task. The request polls for async operations as defined by the poll model's implementation.</p> <p>Parameters:</p> Name Type Description Default <code>poll_model</code> <code>ArkPollableModel</code> <p>description</p> required <code>async_task</code> <code>ArkAsyncTask</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkAsyncRequest</code> <code>ArkAsyncRequest</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@abstractmethod\ndef async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n    \"\"\"\n    Creates an async request for the specified model and task.\n    The request polls for async operations as defined by the poll model's implementation.\n\n    Args:\n        poll_model (ArkPollableModel): _description_\n        async_task (ArkAsyncTask): _description_\n\n    Returns:\n        ArkAsyncRequest: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_request_type","title":"<code>async_request_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async request type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncRequest]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_request_type() -&gt; Type[ArkAsyncRequest]:\n    \"\"\"\n    Returns the client's async request type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_task_type","title":"<code>async_task_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the client's async task type.</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncTask]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_task_type() -&gt; Type[ArkAsyncTask]:\n    \"\"\"\n    Returns the client's async task type.\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/","title":"ark_async_request","text":""},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest","title":"<code>ArkAsyncRequest</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>class ArkAsyncRequest(ABC):\n    def __init__(self, client: ArkClient, async_task: ArkAsyncTask, async_request_settings: ArkAsyncRequestSettings):\n        self._async_task = async_task\n        self._client = client\n        self._async_request_settings = async_request_settings\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def is_finished(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has finished.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_failed(self) -&gt; bool:\n        \"\"\"\n        Checks whether or the current async request failed.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_timeout(self) -&gt; bool:\n        \"\"\"\n        Checks whether or not the current async request has timed out.\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n        \"\"\"\n        Polls the async request until it has completed.\n        Progress callbacks can also be used to return the async request's status.\n\n        Args:\n            timeout_seconds (int): _description_\n            progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @property\n    def async_task(self) -&gt; ArkAsyncTask:\n        return self._async_task\n\n    @property\n    def client(self) -&gt; ArkClient:\n        return self._client\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.is_finished","title":"<code>is_finished()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has finished.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has finished.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.poll","title":"<code>poll(timeout_seconds, progress_callback)</code>  <code>abstractmethod</code>","text":"<p>Polls the async request until it has completed. Progress callbacks can also be used to return the async request's status.</p> <p>Parameters:</p> Name Type Description Default <code>timeout_seconds</code> <code>int</code> <p>description</p> required <code>progress_callback</code> <code>Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls the async request until it has completed.\n    Progress callbacks can also be used to return the async request's status.\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.task_failed","title":"<code>task_failed()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or the current async request failed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether or the current async request failed.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.task_timeout","title":"<code>task_timeout()</code>  <code>abstractmethod</code>","text":"<p>Checks whether or not the current async request has timed out.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether or not the current async request has timed out.\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_client/","title":"ark_client","text":""},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient","title":"<code>ArkClient</code>","text":"Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>class ArkClient:\n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        cookie_jar: Optional[RequestsCookieJar] = None,\n        verify: Optional[Union[str, bool]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        from fake_useragent import UserAgent\n\n        self.__session = Session()\n        self.__base_url = base_url\n        self.__token = token\n        self.__token_type = token_type\n        self.__auth_header_name = auth_header_name\n        self.__refresh_connection_callback = refresh_connection_callback\n        if self.__base_url and not self.__base_url.startswith('https://'):\n            self.__base_url = f'https://{self.__base_url}'\n        if auth:\n            self.__session.auth = auth\n        self.update_token(token)\n        self.update_cookies(cookies, cookie_jar)\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        self.__session.headers['User-Agent'] = UserAgent(browsers=['chrome']).googlechrome\n\n    @property\n    def base_url(self) -&gt; Optional[str]:\n        return self.__base_url\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__token\n\n    @property\n    def refresh_connection_callback(self) -&gt; Optional[Callable[['ArkClient'], None]]:\n        return self.__refresh_connection_callback\n\n    def add_header(self, key: str, value: str) -&gt; None:\n        self.__session.headers.update({key: value})\n\n    def add_headers(self, headers: Dict[str, str]) -&gt; None:\n        self.__session.headers.update(headers)\n\n    def add_cookie(self, key: str, value: str) -&gt; None:\n        self.__session.cookies[key] = value\n\n    def generic_http_method_request(self, method: str, route: str, **kwargs) -&gt; Response:\n        url = route\n        if self.__base_url:\n            url = f'{self.__base_url}'\n            if route and route != '':\n                if self.__base_url.endswith('/') or route.startswith('/'):\n                    url = f'{self.__base_url}{route}'\n                else:\n                    url = f'{self.__base_url}/{route}'\n        http_method = getattr(self.__session, method)\n        response: Response = http_method(url, **kwargs)\n        return response\n\n    def get(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a GET request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('get', route, **kwargs)\n\n    def post(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a POST request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('post', route, **kwargs)\n\n    def put(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PUT request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('put', route, **kwargs)\n\n    def delete(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a DELETE request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('delete', route, **kwargs)\n\n    def patch(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PATCH request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('patch', route, **kwargs)\n\n    def options(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a OPTIONS request with the session details and given headers and tokens.\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('options', route, **kwargs)\n\n    def update_token(self, token: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Updates a session token.\n\n        Args:\n            token (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\n        self.__token = token\n        if token:\n            if self.__token_type == 'Basic':\n                user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n                self.__session.auth = (user, password)\n            else:\n                if len(self.__token_type) == 0:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n                else:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n\n    def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n        \"\"\"\n        Updates session cookies.\n\n        Args:\n            cookies (Optional[List], optional): _description_. Defaults to None.\n            cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n        \"\"\"\n        if cookies:\n            for c in cookies:\n                self.__session.cookies.set_cookie(c)\n        if cookie_jar:\n            self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.delete","title":"<code>delete(route, **kwargs)</code>","text":"<p>Performs a DELETE request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def delete(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a DELETE request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('delete', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.get","title":"<code>get(route, **kwargs)</code>","text":"<p>Performs a GET request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def get(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a GET request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('get', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.options","title":"<code>options(route, **kwargs)</code>","text":"<p>Performs a OPTIONS request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def options(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a OPTIONS request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('options', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.patch","title":"<code>patch(route, **kwargs)</code>","text":"<p>Performs a PATCH request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def patch(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PATCH request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('patch', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.post","title":"<code>post(route, **kwargs)</code>","text":"<p>Performs a POST request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def post(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a POST request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('post', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.put","title":"<code>put(route, **kwargs)</code>","text":"<p>Performs a PUT request with the session details and given headers and tokens.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def put(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PUT request with the session details and given headers and tokens.\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('put', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.update_cookies","title":"<code>update_cookies(cookies=None, cookie_jar=None)</code>","text":"<p>Updates session cookies.</p> <p>Parameters:</p> Name Type Description Default <code>cookies</code> <code>Optional[List]</code> <p>description. Defaults to None.</p> <code>None</code> <code>cookie_jar</code> <code>Optional[RequestsCookieJar]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n    \"\"\"\n    Updates session cookies.\n\n    Args:\n        cookies (Optional[List], optional): _description_. Defaults to None.\n        cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n    \"\"\"\n    if cookies:\n        for c in cookies:\n            self.__session.cookies.set_cookie(c)\n    if cookie_jar:\n        self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.update_token","title":"<code>update_token(token=None)</code>","text":"<p>Updates a session token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_token(self, token: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Updates a session token.\n\n    Args:\n        token (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\n    self.__token = token\n    if token:\n        if self.__token_type == 'Basic':\n            user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n            self.__session.auth = (user, password)\n        else:\n            if len(self.__token_type) == 0:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n            else:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n</code></pre>"},{"location":"reference/common/ark_keyring/","title":"ark_keyring","text":""},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring","title":"<code>ArkKeyring</code>","text":"Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>class ArkKeyring:\n    def __init__(self, service_name: str) -&gt; None:\n        self.__service_name = service_name\n        self.__logger = get_logger(self.__class__.__name__)\n\n    @staticmethod\n    def __is_docker():\n        path = '/proc/self/cgroup'\n        return os.path.exists('/.dockerenv') or os.path.isfile(path) and any('docker' in line for line in open(path, encoding='utf-8'))\n\n    @staticmethod\n    def get_keyring(enforce_basic_keyring: bool = False):\n        try:\n            # Docker or WSL\n            if (\n                ArkKeyring.__is_docker()\n                or 'Microsoft' in uname().release\n                or ARK_BASIC_KEYRING_OVERRIDE_ENV_VAR in os.environ\n                or enforce_basic_keyring\n            ):\n                return BasicKeyring()\n            if sys.platform == 'win32':\n                from keyrings.cryptfile.cryptfile import CryptFileKeyring  # pylint: disable=import-error\n\n                kr = CryptFileKeyring()\n                kr.keyring_key = socket.gethostname()\n                return kr\n            elif sys.platform == 'darwin' or os.path.exists('/etc/redhat-release'):\n                return BasicKeyring()\n            else:\n                if DBUS_SESSION_ENV_VAR not in os.environ:\n                    return BasicKeyring()\n                from keyring.backends import SecretService  # pylint: disable=unused-import\n\n                return SecretService.Keyring()\n        except Exception:\n            return BasicKeyring()\n\n    def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n        \"\"\"\n        Saves the specified token for a profile in the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n        Args:\n            profile (ArkProfile): _description_\n            token (ArkToken): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n        \"\"\"\n        try:\n            self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            kr = self.get_keyring(enforce_basic_keyring)\n            kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n            self.__logger.info('Saved token successfully')\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n                return self.save_token(profile, token, postfix, True)\n            self.__logger.warning(f'Failed to save token [{str(ex)}]')\n\n    def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads a token for a profile from the keyring.\n        The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n        When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n        When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n        Args:\n            profile (ArkProfile): _description_\n            postfix (str): _description_\n            enforce_basic_keyring (bool): _description_\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        try:\n            kr = self.get_keyring(enforce_basic_keyring)\n            self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            if not token_val:\n                self.__logger.info('No token found')\n                return None\n            token = ArkToken.parse_raw(token_val)\n            if token.expires_in:\n                if (\n                    not token.refresh_token\n                    and token.token_type != ArkTokenType.Internal\n                    and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and no refresh token exists')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n                elif (\n                    token.refresh_token\n                    and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n            self.__logger.info('Loaded token successfully')\n            return token\n        except Exception as ex:\n            # Last resort fallback to basic keyring\n            if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n                self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n                return self.load_token(profile, postfix, True)\n            self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n            try:\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            except Exception as ex_deletion:\n                self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n            return None\n</code></pre>"},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring.load_token","title":"<code>load_token(profile, postfix, enforce_basic_keyring=False)</code>","text":"<p>Loads a token for a profile from the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used. When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned. When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def load_token(self, profile: ArkProfile, postfix: str, enforce_basic_keyring: bool = False) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads a token for a profile from the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n    When the token has expired and no refresh token exists, the token is deleted from the keyring and nothing is returned.\n    When the token has expired but a refresh token exists, the token is only deleted if the max token time has passed (48 hours).\n\n    Args:\n        profile (ArkProfile): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    try:\n        kr = self.get_keyring(enforce_basic_keyring)\n        self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        if not token_val:\n            self.__logger.info('No token found')\n            return None\n        token = ArkToken.parse_raw(token_val)\n        if token.expires_in:\n            if (\n                not token.refresh_token\n                and token.token_type != ArkTokenType.Internal\n                and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and no refresh token exists')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n            elif (\n                token.refresh_token\n                and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n        self.__logger.info('Loaded token successfully')\n        return token\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to load token with keyring [{str(kr)}]')\n            return self.load_token(profile, postfix, True)\n        self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n        try:\n            kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        except Exception as ex_deletion:\n            self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n        return None\n</code></pre>"},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring.save_token","title":"<code>save_token(profile, token, postfix, enforce_basic_keyring=False)</code>","text":"<p>Saves the specified token for a profile in the keyring. The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <code>enforce_basic_keyring</code> <code>bool</code> <p>description</p> <code>False</code> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str, enforce_basic_keyring: bool = False) -&gt; None:\n    \"\"\"\n    Saves the specified token for a profile in the keyring.\n    The keyring is the OS-based implementation or, when unavailable, a fallback to BasicKeyring is used.\n\n    Args:\n        profile (ArkProfile): _description_\n        token (ArkToken): _description_\n        postfix (str): _description_\n        enforce_basic_keyring (bool): _description_\n    \"\"\"\n    try:\n        self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        kr = self.get_keyring(enforce_basic_keyring)\n        kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n        self.__logger.info('Saved token successfully')\n    except Exception as ex:\n        # Last resort fallback to basic keyring\n        if not isinstance(kr, BasicKeyring) or not enforce_basic_keyring:\n            self.__logger.warning(f'Falling back to basic keyring as we failed to save token with keyring [{str(kr)}]')\n            return self.save_token(profile, token, postfix, True)\n        self.__logger.warning(f'Failed to save token [{str(ex)}]')\n</code></pre>"},{"location":"reference/common/ark_logger/","title":"ark_logger","text":""},{"location":"reference/common/ark_page/","title":"ark_page","text":""},{"location":"reference/common/ark_pollers/","title":"ark_pollers","text":""},{"location":"reference/common/ark_random_utils/","title":"ark_random_utils","text":""},{"location":"reference/common/ark_system_config/","title":"ark_system_config","text":""},{"location":"reference/common/env/","title":"env","text":""},{"location":"reference/common/env/ark_env_mapping/","title":"ark_env_mapping","text":""},{"location":"reference/common/isp/","title":"isp","text":""},{"location":"reference/common/isp/ark_isp_service_client/","title":"ark_isp_service_client","text":""},{"location":"reference/models/","title":"models","text":""},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader","title":"<code>ArkProfileLoader</code>","text":"Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>class ArkProfileLoader:\n    @staticmethod\n    def profiles_folder() -&gt; str:\n        \"\"\"\n        Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n\n    @staticmethod\n    def default_profile_name() -&gt; str:\n        \"\"\"\n        Getter for the default profile name.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return 'ark'\n\n    @staticmethod\n    def deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Deduces the profile name from the env.\n\n        Args:\n            profile_name (Optional[str], optional): Defaults to `None`\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n            return profile_name\n        if 'ARK_PROFILE' in os.environ:\n            return os.environ['ARK_PROFILE']\n        if profile_name:\n            return profile_name\n        return ArkProfileLoader.default_profile_name()\n\n    @staticmethod\n    def load_default_profile() -&gt; ArkProfile:\n        \"\"\"\n        Loads the default profile, either from the OS or creates a new one.\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        profile_name = ArkProfileLoader.deduce_profile_name()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return ArkProfile()\n\n    @staticmethod\n    def load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n        \"\"\"\n        Loads the specified profile from the OS.\n        Returns `None` when a profile is not found with the specified name.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            Optional[ArkProfile]: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return None\n\n    @staticmethod\n    def save_profile(profile: ArkProfile) -&gt; None:\n        \"\"\"\n        Saves the profile to the profiles folder on the filesystem.\n\n        Args:\n            profile (ArkProfile): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n            f.write(profile.json(indent=4, by_alias=False))\n\n    @staticmethod\n    def load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n        \"\"\"\n        Loads all the profiles that exist on the machine.\n\n        Returns:\n            Optional[List[ArkProfile]]: _description_\n        \"\"\"\n        logger = get_logger('load_all_profiles')\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        profiles: List[ArkProfile] = []\n        for profile_name in os.listdir(folder):\n            try:\n                profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n            except Exception as ex:\n                logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n                continue\n        return profiles\n\n    @staticmethod\n    def delete_profile(profile_name: str) -&gt; None:\n        \"\"\"\n        Deletes the specified profile.\n\n        Args:\n            profile_name (str): The name of the profile to delete\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        if os.path.exists(os.path.join(folder, profile_name)):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def clear_all_profiles() -&gt; None:\n        \"\"\"\n        Clears all profiles.\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        for profile_name in os.listdir(folder):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def profile_exists(profile_name: str) -&gt; bool:\n        \"\"\"\n        Checks if the specified profile exists.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return False\n        return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.clear_all_profiles","title":"<code>clear_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Clears all profiles.</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef clear_all_profiles() -&gt; None:\n    \"\"\"\n    Clears all profiles.\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    for profile_name in os.listdir(folder):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.deduce_profile_name","title":"<code>deduce_profile_name(profile_name=None)</code>  <code>staticmethod</code>","text":"<p>Deduces the profile name from the env.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>Optional[str]</code> <p>Defaults to <code>None</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Deduces the profile name from the env.\n\n    Args:\n        profile_name (Optional[str], optional): Defaults to `None`\n\n    Returns:\n        str: _description_\n    \"\"\"\n    if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n        return profile_name\n    if 'ARK_PROFILE' in os.environ:\n        return os.environ['ARK_PROFILE']\n    if profile_name:\n        return profile_name\n    return ArkProfileLoader.default_profile_name()\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.default_profile_name","title":"<code>default_profile_name()</code>  <code>staticmethod</code>","text":"<p>Getter for the default profile name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef default_profile_name() -&gt; str:\n    \"\"\"\n    Getter for the default profile name.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return 'ark'\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.delete_profile","title":"<code>delete_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>The name of the profile to delete</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef delete_profile(profile_name: str) -&gt; None:\n    \"\"\"\n    Deletes the specified profile.\n\n    Args:\n        profile_name (str): The name of the profile to delete\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    if os.path.exists(os.path.join(folder, profile_name)):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_all_profiles","title":"<code>load_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Loads all the profiles that exist on the machine.</p> <p>Returns:</p> Type Description <code>Optional[List[ArkProfile]]</code> <p>Optional[List[ArkProfile]]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n    \"\"\"\n    Loads all the profiles that exist on the machine.\n\n    Returns:\n        Optional[List[ArkProfile]]: _description_\n    \"\"\"\n    logger = get_logger('load_all_profiles')\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    profiles: List[ArkProfile] = []\n    for profile_name in os.listdir(folder):\n        try:\n            profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n        except Exception as ex:\n            logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n            continue\n    return profiles\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_default_profile","title":"<code>load_default_profile()</code>  <code>staticmethod</code>","text":"<p>Loads the default profile, either from the OS or creates a new one.</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_default_profile() -&gt; ArkProfile:\n    \"\"\"\n    Loads the default profile, either from the OS or creates a new one.\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    profile_name = ArkProfileLoader.deduce_profile_name()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return ArkProfile()\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_profile","title":"<code>load_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Loads the specified profile from the OS. Returns <code>None</code> when a profile is not found with the specified name.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkProfile]</code> <p>Optional[ArkProfile]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n    \"\"\"\n    Loads the specified profile from the OS.\n    Returns `None` when a profile is not found with the specified name.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        Optional[ArkProfile]: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return None\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.profile_exists","title":"<code>profile_exists(profile_name)</code>  <code>staticmethod</code>","text":"<p>Checks if the specified profile exists.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profile_exists(profile_name: str) -&gt; bool:\n    \"\"\"\n    Checks if the specified profile exists.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return False\n    return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.profiles_folder","title":"<code>profiles_folder()</code>  <code>staticmethod</code>","text":"<p>Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profiles_folder() -&gt; str:\n    \"\"\"\n    Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.save_profile","title":"<code>save_profile(profile)</code>  <code>staticmethod</code>","text":"<p>Saves the profile to the profiles folder on the filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef save_profile(profile: ArkProfile) -&gt; None:\n    \"\"\"\n    Saves the profile to the profiles folder on the filesystem.\n\n    Args:\n        profile (ArkProfile): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n        f.write(profile.json(indent=4, by_alias=False))\n</code></pre>"},{"location":"reference/models/ark_exceptions/","title":"ark_exceptions","text":""},{"location":"reference/models/ark_model/","title":"ark_model","text":""},{"location":"reference/models/ark_profile/","title":"ark_profile","text":""},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader","title":"<code>ArkProfileLoader</code>","text":"Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>class ArkProfileLoader:\n    @staticmethod\n    def profiles_folder() -&gt; str:\n        \"\"\"\n        Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n\n    @staticmethod\n    def default_profile_name() -&gt; str:\n        \"\"\"\n        Getter for the default profile name.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return 'ark'\n\n    @staticmethod\n    def deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Deduces the profile name from the env.\n\n        Args:\n            profile_name (Optional[str], optional): Defaults to `None`\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n            return profile_name\n        if 'ARK_PROFILE' in os.environ:\n            return os.environ['ARK_PROFILE']\n        if profile_name:\n            return profile_name\n        return ArkProfileLoader.default_profile_name()\n\n    @staticmethod\n    def load_default_profile() -&gt; ArkProfile:\n        \"\"\"\n        Loads the default profile, either from the OS or creates a new one.\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        profile_name = ArkProfileLoader.deduce_profile_name()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return ArkProfile()\n\n    @staticmethod\n    def load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n        \"\"\"\n        Loads the specified profile from the OS.\n        Returns `None` when a profile is not found with the specified name.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            Optional[ArkProfile]: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return None\n\n    @staticmethod\n    def save_profile(profile: ArkProfile) -&gt; None:\n        \"\"\"\n        Saves the profile to the profiles folder on the filesystem.\n\n        Args:\n            profile (ArkProfile): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n            f.write(profile.json(indent=4, by_alias=False))\n\n    @staticmethod\n    def load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n        \"\"\"\n        Loads all the profiles that exist on the machine.\n\n        Returns:\n            Optional[List[ArkProfile]]: _description_\n        \"\"\"\n        logger = get_logger('load_all_profiles')\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        profiles: List[ArkProfile] = []\n        for profile_name in os.listdir(folder):\n            try:\n                profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n            except Exception as ex:\n                logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n                continue\n        return profiles\n\n    @staticmethod\n    def delete_profile(profile_name: str) -&gt; None:\n        \"\"\"\n        Deletes the specified profile.\n\n        Args:\n            profile_name (str): The name of the profile to delete\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        if os.path.exists(os.path.join(folder, profile_name)):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def clear_all_profiles() -&gt; None:\n        \"\"\"\n        Clears all profiles.\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        for profile_name in os.listdir(folder):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def profile_exists(profile_name: str) -&gt; bool:\n        \"\"\"\n        Checks if the specified profile exists.\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return False\n        return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.clear_all_profiles","title":"<code>clear_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Clears all profiles.</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef clear_all_profiles() -&gt; None:\n    \"\"\"\n    Clears all profiles.\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    for profile_name in os.listdir(folder):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.deduce_profile_name","title":"<code>deduce_profile_name(profile_name=None)</code>  <code>staticmethod</code>","text":"<p>Deduces the profile name from the env.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>Optional[str]</code> <p>Defaults to <code>None</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Deduces the profile name from the env.\n\n    Args:\n        profile_name (Optional[str], optional): Defaults to `None`\n\n    Returns:\n        str: _description_\n    \"\"\"\n    if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n        return profile_name\n    if 'ARK_PROFILE' in os.environ:\n        return os.environ['ARK_PROFILE']\n    if profile_name:\n        return profile_name\n    return ArkProfileLoader.default_profile_name()\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.default_profile_name","title":"<code>default_profile_name()</code>  <code>staticmethod</code>","text":"<p>Getter for the default profile name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef default_profile_name() -&gt; str:\n    \"\"\"\n    Getter for the default profile name.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return 'ark'\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.delete_profile","title":"<code>delete_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Deletes the specified profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>The name of the profile to delete</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef delete_profile(profile_name: str) -&gt; None:\n    \"\"\"\n    Deletes the specified profile.\n\n    Args:\n        profile_name (str): The name of the profile to delete\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    if os.path.exists(os.path.join(folder, profile_name)):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_all_profiles","title":"<code>load_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Loads all the profiles that exist on the machine.</p> <p>Returns:</p> Type Description <code>Optional[List[ArkProfile]]</code> <p>Optional[List[ArkProfile]]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n    \"\"\"\n    Loads all the profiles that exist on the machine.\n\n    Returns:\n        Optional[List[ArkProfile]]: _description_\n    \"\"\"\n    logger = get_logger('load_all_profiles')\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    profiles: List[ArkProfile] = []\n    for profile_name in os.listdir(folder):\n        try:\n            profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n        except Exception as ex:\n            logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n            continue\n    return profiles\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_default_profile","title":"<code>load_default_profile()</code>  <code>staticmethod</code>","text":"<p>Loads the default profile, either from the OS or creates a new one.</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_default_profile() -&gt; ArkProfile:\n    \"\"\"\n    Loads the default profile, either from the OS or creates a new one.\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    profile_name = ArkProfileLoader.deduce_profile_name()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return ArkProfile()\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_profile","title":"<code>load_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Loads the specified profile from the OS. Returns <code>None</code> when a profile is not found with the specified name.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkProfile]</code> <p>Optional[ArkProfile]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n    \"\"\"\n    Loads the specified profile from the OS.\n    Returns `None` when a profile is not found with the specified name.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        Optional[ArkProfile]: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return None\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.profile_exists","title":"<code>profile_exists(profile_name)</code>  <code>staticmethod</code>","text":"<p>Checks if the specified profile exists.</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profile_exists(profile_name: str) -&gt; bool:\n    \"\"\"\n    Checks if the specified profile exists.\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return False\n    return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.profiles_folder","title":"<code>profiles_folder()</code>  <code>staticmethod</code>","text":"<p>Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profiles_folder() -&gt; str:\n    \"\"\"\n    Retrieves the profiles folder pathname, from the environment variable when set; otherwise, from the default location.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.save_profile","title":"<code>save_profile(profile)</code>  <code>staticmethod</code>","text":"<p>Saves the profile to the profiles folder on the filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef save_profile(profile: ArkProfile) -&gt; None:\n    \"\"\"\n    Saves the profile to the profiles folder on the filesystem.\n\n    Args:\n        profile (ArkProfile): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n        f.write(profile.json(indent=4, by_alias=False))\n</code></pre>"},{"location":"reference/models/actions/","title":"actions","text":""},{"location":"reference/models/actions/ark_configure_action_consts/","title":"ark_configure_action_consts","text":""},{"location":"reference/models/actions/ark_service_action_definition/","title":"ark_service_action_definition","text":""},{"location":"reference/models/actions/services/","title":"services","text":""},{"location":"reference/models/actions/services/ark_dpa_exec_action_consts/","title":"ark_dpa_exec_action_consts","text":""},{"location":"reference/models/actions/services/ark_sm_exec_action_consts/","title":"ark_sm_exec_action_consts","text":""},{"location":"reference/models/auth/","title":"auth","text":""},{"location":"reference/models/auth/ark_auth_method/","title":"ark_auth_method","text":""},{"location":"reference/models/auth/ark_auth_profile/","title":"ark_auth_profile","text":""},{"location":"reference/models/auth/ark_secret/","title":"ark_secret","text":""},{"location":"reference/models/auth/ark_token/","title":"ark_token","text":""},{"location":"reference/models/cli_services/","title":"cli_services","text":""},{"location":"reference/models/cli_services/dpa/","title":"dpa","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/","title":"policies_editor","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/","title":"common","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_base_generate_policy/","title":"ark_dpa_base_generate_policy","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_commit_policies/","title":"ark_dpa_commit_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_edit_policies/","title":"ark_dpa_edit_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_get_policies_status/","title":"ark_dpa_get_policies_status","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_load_policies/","title":"ark_dpa_load_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_loaded_policies/","title":"ark_dpa_loaded_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_policies_diff/","title":"ark_dpa_policies_diff","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_policies_status/","title":"ark_dpa_policies_status","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_remove_policies/","title":"ark_dpa_remove_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_reset_policies/","title":"ark_dpa_reset_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_view_policies/","title":"ark_dpa_view_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/db/","title":"db","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/db/ark_dpa_db_generate_policy/","title":"ark_dpa_db_generate_policy","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/vm/","title":"vm","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/vm/ark_dpa_vm_generate_policy/","title":"ark_dpa_vm_generate_policy","text":""},{"location":"reference/models/common/","title":"common","text":""},{"location":"reference/models/common/ark_access_method/","title":"ark_access_method","text":""},{"location":"reference/models/common/ark_application_code/","title":"ark_application_code","text":""},{"location":"reference/models/common/ark_async_request_settings/","title":"ark_async_request_settings","text":""},{"location":"reference/models/common/ark_async_status/","title":"ark_async_status","text":""},{"location":"reference/models/common/ark_async_task/","title":"ark_async_task","text":""},{"location":"reference/models/common/ark_connection_method/","title":"ark_connection_method","text":""},{"location":"reference/models/common/ark_connector_type/","title":"ark_connector_type","text":""},{"location":"reference/models/common/ark_counted_values/","title":"ark_counted_values","text":""},{"location":"reference/models/common/ark_network_entity_type/","title":"ark_network_entity_type","text":""},{"location":"reference/models/common/ark_os_type/","title":"ark_os_type","text":""},{"location":"reference/models/common/ark_protocol_type/","title":"ark_protocol_type","text":""},{"location":"reference/models/common/ark_region/","title":"ark_region","text":""},{"location":"reference/models/common/ark_status/","title":"ark_status","text":""},{"location":"reference/models/common/ark_status_stats/","title":"ark_status_stats","text":""},{"location":"reference/models/common/ark_validations/","title":"ark_validations","text":""},{"location":"reference/models/common/ark_workspace_type/","title":"ark_workspace_type","text":""},{"location":"reference/models/common/aws/","title":"aws","text":""},{"location":"reference/models/common/aws/ark_cfn_async_task/","title":"ark_cfn_async_task","text":""},{"location":"reference/models/common/connections/","title":"connections","text":""},{"location":"reference/models/common/connections/ark_connection_command/","title":"ark_connection_command","text":""},{"location":"reference/models/common/connections/ark_connection_credentials/","title":"ark_connection_credentials","text":""},{"location":"reference/models/common/connections/ark_connection_details/","title":"ark_connection_details","text":""},{"location":"reference/models/common/connections/ark_connection_result/","title":"ark_connection_result","text":""},{"location":"reference/models/common/connections/connection_data/","title":"connection_data","text":""},{"location":"reference/models/common/connections/connection_data/ark_ssh_connection_data/","title":"ark_ssh_connection_data","text":""},{"location":"reference/models/common/connections/connection_data/ark_winrm_connection_data/","title":"ark_winrm_connection_data","text":""},{"location":"reference/models/common/identity/","title":"identity","text":""},{"location":"reference/models/common/identity/ark_identity_auth_schemas/","title":"ark_identity_auth_schemas","text":""},{"location":"reference/models/common/identity/ark_identity_common_schemas/","title":"ark_identity_common_schemas","text":""},{"location":"reference/models/common/identity/ark_identity_directory_schemas/","title":"ark_identity_directory_schemas","text":""},{"location":"reference/models/common/isp/","title":"isp","text":""},{"location":"reference/models/common/isp/ark_platform_discovery_schemas/","title":"ark_platform_discovery_schemas","text":""},{"location":"reference/models/services/","title":"services","text":""},{"location":"reference/models/services/ark_service_config/","title":"ark_service_config","text":""},{"location":"reference/models/services/dpa/","title":"dpa","text":""},{"location":"reference/models/services/dpa/certificates/","title":"certificates","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_certificate/","title":"ark_dpa_certificates_certificate","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_delete_certificate/","title":"ark_dpa_certificates_delete_certificate","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_filter/","title":"ark_dpa_certificates_filter","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_get_certificate/","title":"ark_dpa_certificates_get_certificate","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_update_certificate/","title":"ark_dpa_certificates_update_certificate","text":""},{"location":"reference/models/services/dpa/db/","title":"db","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_base_execution/","title":"ark_dpa_db_base_execution","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_base_generate_assets/","title":"ark_dpa_db_base_generate_assets","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_generated_assets/","title":"ark_dpa_db_generated_assets","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_mysql_execution/","title":"ark_dpa_db_mysql_execution","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_oracle_generate_assets/","title":"ark_dpa_db_oracle_generate_assets","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_psql_execution/","title":"ark_dpa_db_psql_execution","text":""},{"location":"reference/models/services/dpa/k8s/","title":"k8s","text":""},{"location":"reference/models/services/dpa/k8s/ark_dpa_k8s_generate_kubeconfig/","title":"ark_dpa_k8s_generate_kubeconfig","text":""},{"location":"reference/models/services/dpa/policies/","title":"policies","text":""},{"location":"reference/models/services/dpa/policies/common/","title":"common","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_add_policy/","title":"ark_dpa_base_add_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_authorization_rule/","title":"ark_dpa_base_authorization_rule","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_connection_information/","title":"ark_dpa_base_connection_information","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policies_filter/","title":"ark_dpa_base_policies_filter","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policies_stats/","title":"ark_dpa_base_policies_stats","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policy/","title":"ark_dpa_base_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policy_list_item/","title":"ark_dpa_base_policy_list_item","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_update_policy/","title":"ark_dpa_base_update_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_delete_policy/","title":"ark_dpa_delete_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_get_policy/","title":"ark_dpa_get_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_rule_status/","title":"ark_dpa_rule_status","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_update_policy_status/","title":"ark_dpa_update_policy_status","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_user_data/","title":"ark_dpa_user_data","text":""},{"location":"reference/models/services/dpa/policies/db/","title":"db","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_add_policy/","title":"ark_dpa_db_add_policy","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_authorization_rule/","title":"ark_dpa_db_authorization_rule","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_connection_data/","title":"ark_dpa_db_connection_data","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policies_filter/","title":"ark_dpa_db_policies_filter","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policies_stats/","title":"ark_dpa_db_policies_stats","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policies_workspace_type_serializer/","title":"ark_dpa_db_policies_workspace_type_serializer","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policy/","title":"ark_dpa_db_policy","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policy_list_item/","title":"ark_dpa_db_policy_list_item","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_providers/","title":"ark_dpa_db_providers","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_update_policy/","title":"ark_dpa_db_update_policy","text":""},{"location":"reference/models/services/dpa/policies/vm/","title":"vm","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_add_policy/","title":"ark_dpa_vm_add_policy","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_authorization_rule/","title":"ark_dpa_vm_authorization_rule","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_connection_data/","title":"ark_dpa_vm_connection_data","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_filter/","title":"ark_dpa_vm_policies_filter","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_protocol_type_serializer/","title":"ark_dpa_vm_policies_protocol_type_serializer","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_stats/","title":"ark_dpa_vm_policies_stats","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_workspace_type_serializer/","title":"ark_dpa_vm_policies_workspace_type_serializer","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policy/","title":"ark_dpa_vm_policy","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policy_list_item/","title":"ark_dpa_vm_policy_list_item","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_providers/","title":"ark_dpa_vm_providers","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_update_policy/","title":"ark_dpa_vm_update_policy","text":""},{"location":"reference/models/services/dpa/secrets/","title":"secrets","text":""},{"location":"reference/models/services/dpa/secrets/db/","title":"db","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_add_secret/","title":"ark_dpa_db_add_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_delete_secret/","title":"ark_dpa_db_delete_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_disable_secret/","title":"ark_dpa_db_disable_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_enable_secret/","title":"ark_dpa_db_enable_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_get_secret/","title":"ark_dpa_db_get_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secret_metadata/","title":"ark_dpa_db_secret_metadata","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secret_type/","title":"ark_dpa_db_secret_type","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secrets_filter/","title":"ark_dpa_db_secrets_filter","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secrets_stats/","title":"ark_dpa_db_secrets_stats","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_store_descriptor/","title":"ark_dpa_db_store_descriptor","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_store_type/","title":"ark_dpa_db_store_type","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_update_secret/","title":"ark_dpa_db_update_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/secret_links/","title":"secret_links","text":""},{"location":"reference/models/services/dpa/secrets/db/secret_links/ark_dpa_db_pam_account_secret_link/","title":"ark_dpa_db_pam_account_secret_link","text":""},{"location":"reference/models/services/dpa/secrets/db/secrets_data/","title":"secrets_data","text":""},{"location":"reference/models/services/dpa/secrets/db/secrets_data/ark_dpa_db_user_password_secret_data/","title":"ark_dpa_db_user_password_secret_data","text":""},{"location":"reference/models/services/dpa/sso/","title":"sso","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_acquire_token_response/","title":"ark_dpa_sso_acquire_token_response","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_get_short_lived_client_certificate/","title":"ark_dpa_sso_get_short_lived_client_certificate","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_get_short_lived_oracle_wallet/","title":"ark_dpa_sso_get_short_lived_oracle_wallet","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_get_short_lived_password/","title":"ark_dpa_sso_get_short_lived_password","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_get_short_lived_rdp_file/","title":"ark_dpa_sso_get_short_lived_rdp_file","text":""},{"location":"reference/models/services/dpa/workspaces/","title":"workspaces","text":""},{"location":"reference/models/services/dpa/workspaces/db/","title":"db","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_add_database/","title":"ark_dpa_db_add_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_database/","title":"ark_dpa_db_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_database_info/","title":"ark_dpa_db_database_info","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_databases_filter/","title":"ark_dpa_db_databases_filter","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_databases_stats/","title":"ark_dpa_db_databases_stats","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_delete_database/","title":"ark_dpa_db_delete_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_get_database/","title":"ark_dpa_db_get_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_platform_type_serializer/","title":"ark_dpa_db_platform_type_serializer","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_provider/","title":"ark_dpa_db_provider","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_tag/","title":"ark_dpa_db_tag","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_update_database/","title":"ark_dpa_db_update_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_warning/","title":"ark_dpa_db_warning","text":""},{"location":"reference/models/services/sm/","title":"sm","text":""},{"location":"reference/models/services/sm/ark_sm_get_session/","title":"ark_sm_get_session","text":""},{"location":"reference/models/services/sm/ark_sm_get_session_activities/","title":"ark_sm_get_session_activities","text":""},{"location":"reference/models/services/sm/ark_sm_protocol_type_serializer/","title":"ark_sm_protocol_type_serializer","text":""},{"location":"reference/models/services/sm/ark_sm_session/","title":"ark_sm_session","text":""},{"location":"reference/models/services/sm/ark_sm_session_activity/","title":"ark_sm_session_activity","text":""},{"location":"reference/models/services/sm/ark_sm_session_activity_filter/","title":"ark_sm_session_activity_filter","text":""},{"location":"reference/models/services/sm/ark_sm_sessions_filter/","title":"ark_sm_sessions_filter","text":""},{"location":"reference/models/services/sm/ark_sm_sessions_stats/","title":"ark_sm_sessions_stats","text":""},{"location":"reference/models/services/sm/ark_sm_workspace_type_serializer/","title":"ark_sm_workspace_type_serializer","text":""},{"location":"reference/services/","title":"services","text":""},{"location":"reference/services/ark_service/","title":"ark_service","text":""},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService","title":"<code>ArkService</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>class ArkService(ABC):\n    def __init__(self, *authenticators: Any) -&gt; None:\n        self._logger = get_logger(self.__class__.__name__)\n        self._authenticators = [auth for auth in authenticators if issubclass(type(auth), ArkAuth)]\n        given_auth_names = [auth.authenticator_name() for auth in self._authenticators]\n        if any(a not in given_auth_names for a in self.service_config().required_authenticator_names):\n            raise ArkValidationException(f'{self.service_config().service_name} missing required authenticators for service')\n\n    @property\n    def authenticators(self) -&gt; List[ArkAuth]:\n        \"\"\"\n        Returns all the authenticators for the service.\n\n        Returns:\n            List[ArkAuth]: _description_\n        \"\"\"\n        return self._authenticators\n\n    def authenticator(self, auth_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Finds the appropriate Ark authenticator class for the specified authenticator.\n\n        Args:\n            auth_name (str): _description_\n\n        Raises:\n            ArkNotFoundException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.authenticators:\n            if auth.authenticator_name() == auth_name:\n                return auth\n        raise ArkNotFoundException(f'{self.service_config().service_name} Failed to find authenticator {auth_name}')\n\n    def has_authenticator(self, auth_name: str) -&gt; bool:\n        \"\"\"\n        Checks whether the specified authenticator name exists.\n\n        Args:\n            auth_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return any(auth.authenticator_name() == auth_name for auth in self.authenticators)\n\n    @staticmethod\n    @abstractmethod\n    def service_config() -&gt; ArkServiceConfig:\n        \"\"\"\n        Returns the service configuration, which includes the service name, and its required and optional authenticators.\n\n        Returns:\n            ArkServiceConfig: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.authenticators","title":"<code>authenticators: List[ArkAuth]</code>  <code>property</code>","text":"<p>Returns all the authenticators for the service.</p> <p>Returns:</p> Type Description <code>List[ArkAuth]</code> <p>List[ArkAuth]: description</p>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.authenticator","title":"<code>authenticator(auth_name)</code>","text":"<p>Finds the appropriate Ark authenticator class for the specified authenticator.</p> <p>Parameters:</p> Name Type Description Default <code>auth_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkNotFoundException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>def authenticator(self, auth_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Finds the appropriate Ark authenticator class for the specified authenticator.\n\n    Args:\n        auth_name (str): _description_\n\n    Raises:\n        ArkNotFoundException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.authenticators:\n        if auth.authenticator_name() == auth_name:\n            return auth\n    raise ArkNotFoundException(f'{self.service_config().service_name} Failed to find authenticator {auth_name}')\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.has_authenticator","title":"<code>has_authenticator(auth_name)</code>","text":"<p>Checks whether the specified authenticator name exists.</p> <p>Parameters:</p> Name Type Description Default <code>auth_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>def has_authenticator(self, auth_name: str) -&gt; bool:\n    \"\"\"\n    Checks whether the specified authenticator name exists.\n\n    Args:\n        auth_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return any(auth.authenticator_name() == auth_name for auth in self.authenticators)\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.service_config","title":"<code>service_config()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the service configuration, which includes the service name, and its required and optional authenticators.</p> <p>Returns:</p> Name Type Description <code>ArkServiceConfig</code> <code>ArkServiceConfig</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef service_config() -&gt; ArkServiceConfig:\n    \"\"\"\n    Returns the service configuration, which includes the service name, and its required and optional authenticators.\n\n    Returns:\n        ArkServiceConfig: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/services/dpa/","title":"dpa","text":""},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI","title":"<code>ArkDPAAPI</code>","text":"Source code in <code>ark_sdk_python/services/dpa/ark_dpa_api.py</code> <pre><code>class ArkDPAAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__db_workspace_service = ArkDPADBWorkspaceService(isp_auth)\n        self.__vm_policies_service = ArkDPAVMPoliciesService(isp_auth)\n        self.__db_policies_service = ArkDPADBPoliciesService(isp_auth)\n        self.__db_secrets_service = ArkDPADBSecretsService(isp_auth)\n        self.__sso_service = ArkDPASSOService(isp_auth)\n        self.__db_service = ArkDPADBService(isp_auth)\n        self.__certificates_service = ArkDPACertificatesService(isp_auth)\n        self.__k8s_service = ArkDPAK8SService(isp_auth)\n\n    @property\n    def workspace_db(self) -&gt; ArkDPADBWorkspaceService:\n        \"\"\"\n        Getter for the DB workspace service.\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        return self.__db_workspace_service\n\n    @property\n    def policies_vm(self) -&gt; ArkDPAVMPoliciesService:\n        \"\"\"\n        Getter for the VM policies service.\n\n        Returns:\n            ArkDPAVMPoliciesService: _description_\n        \"\"\"\n        return self.__vm_policies_service\n\n    @property\n    def policies_db(self) -&gt; ArkDPADBPoliciesService:\n        \"\"\"\n        Getter for the DB policies service.\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        return self.__db_policies_service\n\n    @property\n    def secrets_db(self) -&gt; ArkDPADBSecretsService:\n        \"\"\"\n        Getter for the DB secrets service.\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        return self.__db_secrets_service\n\n    @property\n    def sso(self) -&gt; ArkDPASSOService:\n        \"\"\"\n        Getter for the SSO service.\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        return self.__sso_service\n\n    @property\n    def db(self) -&gt; ArkDPADBService:\n        \"\"\"\n        Getter for the DB service.\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        return self.__db_service\n\n    @property\n    def certificates(self) -&gt; ArkDPACertificatesService:\n        \"\"\"\n        Getter for the certificates service.\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        return self.__certificates_service\n\n    @property\n    def k8s(self) -&gt; ArkDPAK8SService:\n        \"\"\"\n        Getter for the K8s service.\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        return self.__k8s_service\n</code></pre>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.certificates","title":"<code>certificates: ArkDPACertificatesService</code>  <code>property</code>","text":"<p>Getter for the certificates service.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>ArkDPACertificatesService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.db","title":"<code>db: ArkDPADBService</code>  <code>property</code>","text":"<p>Getter for the DB service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>ArkDPADBService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.k8s","title":"<code>k8s: ArkDPAK8SService</code>  <code>property</code>","text":"<p>Getter for the K8s service.</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>ArkDPAK8SService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.policies_db","title":"<code>policies_db: ArkDPADBPoliciesService</code>  <code>property</code>","text":"<p>Getter for the DB policies service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>ArkDPADBPoliciesService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.policies_vm","title":"<code>policies_vm: ArkDPAVMPoliciesService</code>  <code>property</code>","text":"<p>Getter for the VM policies service.</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesService</code> <code>ArkDPAVMPoliciesService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.secrets_db","title":"<code>secrets_db: ArkDPADBSecretsService</code>  <code>property</code>","text":"<p>Getter for the DB secrets service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>ArkDPADBSecretsService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.sso","title":"<code>sso: ArkDPASSOService</code>  <code>property</code>","text":"<p>Getter for the SSO service.</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>ArkDPASSOService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.workspace_db","title":"<code>workspace_db: ArkDPADBWorkspaceService</code>  <code>property</code>","text":"<p>Getter for the DB workspace service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>ArkDPADBWorkspaceService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/","title":"ark_dpa_api","text":""},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI","title":"<code>ArkDPAAPI</code>","text":"Source code in <code>ark_sdk_python/services/dpa/ark_dpa_api.py</code> <pre><code>class ArkDPAAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__db_workspace_service = ArkDPADBWorkspaceService(isp_auth)\n        self.__vm_policies_service = ArkDPAVMPoliciesService(isp_auth)\n        self.__db_policies_service = ArkDPADBPoliciesService(isp_auth)\n        self.__db_secrets_service = ArkDPADBSecretsService(isp_auth)\n        self.__sso_service = ArkDPASSOService(isp_auth)\n        self.__db_service = ArkDPADBService(isp_auth)\n        self.__certificates_service = ArkDPACertificatesService(isp_auth)\n        self.__k8s_service = ArkDPAK8SService(isp_auth)\n\n    @property\n    def workspace_db(self) -&gt; ArkDPADBWorkspaceService:\n        \"\"\"\n        Getter for the DB workspace service.\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        return self.__db_workspace_service\n\n    @property\n    def policies_vm(self) -&gt; ArkDPAVMPoliciesService:\n        \"\"\"\n        Getter for the VM policies service.\n\n        Returns:\n            ArkDPAVMPoliciesService: _description_\n        \"\"\"\n        return self.__vm_policies_service\n\n    @property\n    def policies_db(self) -&gt; ArkDPADBPoliciesService:\n        \"\"\"\n        Getter for the DB policies service.\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        return self.__db_policies_service\n\n    @property\n    def secrets_db(self) -&gt; ArkDPADBSecretsService:\n        \"\"\"\n        Getter for the DB secrets service.\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        return self.__db_secrets_service\n\n    @property\n    def sso(self) -&gt; ArkDPASSOService:\n        \"\"\"\n        Getter for the SSO service.\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        return self.__sso_service\n\n    @property\n    def db(self) -&gt; ArkDPADBService:\n        \"\"\"\n        Getter for the DB service.\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        return self.__db_service\n\n    @property\n    def certificates(self) -&gt; ArkDPACertificatesService:\n        \"\"\"\n        Getter for the certificates service.\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        return self.__certificates_service\n\n    @property\n    def k8s(self) -&gt; ArkDPAK8SService:\n        \"\"\"\n        Getter for the K8s service.\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        return self.__k8s_service\n</code></pre>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.certificates","title":"<code>certificates: ArkDPACertificatesService</code>  <code>property</code>","text":"<p>Getter for the certificates service.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>ArkDPACertificatesService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.db","title":"<code>db: ArkDPADBService</code>  <code>property</code>","text":"<p>Getter for the DB service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>ArkDPADBService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.k8s","title":"<code>k8s: ArkDPAK8SService</code>  <code>property</code>","text":"<p>Getter for the K8s service.</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>ArkDPAK8SService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.policies_db","title":"<code>policies_db: ArkDPADBPoliciesService</code>  <code>property</code>","text":"<p>Getter for the DB policies service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>ArkDPADBPoliciesService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.policies_vm","title":"<code>policies_vm: ArkDPAVMPoliciesService</code>  <code>property</code>","text":"<p>Getter for the VM policies service.</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesService</code> <code>ArkDPAVMPoliciesService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.secrets_db","title":"<code>secrets_db: ArkDPADBSecretsService</code>  <code>property</code>","text":"<p>Getter for the DB secrets service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>ArkDPADBSecretsService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.sso","title":"<code>sso: ArkDPASSOService</code>  <code>property</code>","text":"<p>Getter for the SSO service.</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>ArkDPASSOService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.workspace_db","title":"<code>workspace_db: ArkDPADBWorkspaceService</code>  <code>property</code>","text":"<p>Getter for the DB workspace service.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>ArkDPADBWorkspaceService</code> <p>description</p>"},{"location":"reference/services/dpa/certificates/","title":"certificates","text":""},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService","title":"<code>ArkDPACertificatesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>class ArkDPACertificatesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Adds a new certificate through the Access Certificates Service.\n\n        Args:\n            create_certificate (ArkDPACreateCertificate): The certificate to add\n\n        Raises:\n            ArkServiceException: When the certificate could not be added\n\n        Returns:\n            ArkDPACertificate: The added certificate\n        \"\"\"\n        self._logger.info(\"Adding new certificate.\")\n        cert_body = ''\n        try:\n            with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n        create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n        resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                cert_id = resp.json()['certificate_id']\n                return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n                raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n        raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n\n    def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Retrieves a certificate from the Access Certificates Service.\n\n        Args:\n            get_certificate (ArkDPAGetCertificate): The ID of the certificate to retrieve\n\n        Raises:\n            ArkServiceException: When the certificate could not be retrieved\n\n        Returns:\n            ArkDPACertificate: The retrieved certificate\n        \"\"\"\n        self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n        resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n        try:\n            return ArkDPACertificate.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n        \"\"\"\n        Deletes an existing certificate.\n\n        Args:\n            cert (ArkDPADeleteCertificate): The ID of the certificate to delete\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n        resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n\n    def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n        \"\"\"\n        Updates an existing certificate.\n\n        Args:\n            update_certificate (ArkDPAUpdateCertificate): The ID of the certificate to update\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n        try:\n            with open(update_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n        update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n        resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n\n    def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        Lists all certificates.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            list[ArkDPACertificate]: _description_\n        \"\"\"\n        self._logger.info(\"Listing certificates.\")\n        resp = self.__client.get(CERTIFICATES_API)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n        try:\n            return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n\n    def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        Lists certificates matching the specified filters.\n\n        Args:\n            certificates_filter (ArkDPACertificatesFilter): _description_\n\n        Returns:\n            List[ArkDPAShortCertificate]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n        certs = self.list_certificates()\n\n        if certificates_filter.domain_name:\n            certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n        if certificates_filter.cert_name:\n            certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n        return certs\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.add_certificate","title":"<code>add_certificate(create_certificate)</code>","text":"<p>Adds a new certificate through the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>create_certificate</code> <code>ArkDPACreateCertificate</code> <p>The certificate to add</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be added</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The added certificate</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Adds a new certificate through the Access Certificates Service.\n\n    Args:\n        create_certificate (ArkDPACreateCertificate): The certificate to add\n\n    Raises:\n        ArkServiceException: When the certificate could not be added\n\n    Returns:\n        ArkDPACertificate: The added certificate\n    \"\"\"\n    self._logger.info(\"Adding new certificate.\")\n    cert_body = ''\n    try:\n        with open(create_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n    create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n    resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            cert_id = resp.json()['certificate_id']\n            return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n            raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n    raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.certificate","title":"<code>certificate(get_certificate)</code>","text":"<p>Retrieves a certificate from the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>get_certificate</code> <code>ArkDPAGetCertificate</code> <p>The ID of the certificate to retrieve</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be retrieved</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The retrieved certificate</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Retrieves a certificate from the Access Certificates Service.\n\n    Args:\n        get_certificate (ArkDPAGetCertificate): The ID of the certificate to retrieve\n\n    Raises:\n        ArkServiceException: When the certificate could not be retrieved\n\n    Returns:\n        ArkDPACertificate: The retrieved certificate\n    \"\"\"\n    self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n    resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n    try:\n        return ArkDPACertificate.parse_obj(resp.json())\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.delete_certificate","title":"<code>delete_certificate(cert)</code>","text":"<p>Deletes an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>cert</code> <code>ArkDPADeleteCertificate</code> <p>The ID of the certificate to delete</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n    \"\"\"\n    Deletes an existing certificate.\n\n    Args:\n        cert (ArkDPADeleteCertificate): The ID of the certificate to delete\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n    resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.list_certificates","title":"<code>list_certificates()</code>","text":"<p>Lists all certificates.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>list[ArkDPACertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    Lists all certificates.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        list[ArkDPACertificate]: _description_\n    \"\"\"\n    self._logger.info(\"Listing certificates.\")\n    resp = self.__client.get(CERTIFICATES_API)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n    try:\n        return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.list_certificates_by","title":"<code>list_certificates_by(certificates_filter)</code>","text":"<p>Lists certificates matching the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>certificates_filter</code> <code>ArkDPACertificatesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>List[ArkDPAShortCertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    Lists certificates matching the specified filters.\n\n    Args:\n        certificates_filter (ArkDPACertificatesFilter): _description_\n\n    Returns:\n        List[ArkDPAShortCertificate]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n    certs = self.list_certificates()\n\n    if certificates_filter.domain_name:\n        certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n    if certificates_filter.cert_name:\n        certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n    return certs\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.update_certificate","title":"<code>update_certificate(update_certificate)</code>","text":"<p>Updates an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>update_certificate</code> <code>ArkDPAUpdateCertificate</code> <p>The ID of the certificate to update</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n    \"\"\"\n    Updates an existing certificate.\n\n    Args:\n        update_certificate (ArkDPAUpdateCertificate): The ID of the certificate to update\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n    try:\n        with open(update_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n    update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n    resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/","title":"ark_dpa_certificates_service","text":""},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService","title":"<code>ArkDPACertificatesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>class ArkDPACertificatesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Adds a new certificate through the Access Certificates Service.\n\n        Args:\n            create_certificate (ArkDPACreateCertificate): The certificate to add\n\n        Raises:\n            ArkServiceException: When the certificate could not be added\n\n        Returns:\n            ArkDPACertificate: The added certificate\n        \"\"\"\n        self._logger.info(\"Adding new certificate.\")\n        cert_body = ''\n        try:\n            with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n        create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n        resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                cert_id = resp.json()['certificate_id']\n                return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n                raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n        raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n\n    def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Retrieves a certificate from the Access Certificates Service.\n\n        Args:\n            get_certificate (ArkDPAGetCertificate): The ID of the certificate to retrieve\n\n        Raises:\n            ArkServiceException: When the certificate could not be retrieved\n\n        Returns:\n            ArkDPACertificate: The retrieved certificate\n        \"\"\"\n        self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n        resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n        try:\n            return ArkDPACertificate.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n        \"\"\"\n        Deletes an existing certificate.\n\n        Args:\n            cert (ArkDPADeleteCertificate): The ID of the certificate to delete\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n        resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n\n    def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n        \"\"\"\n        Updates an existing certificate.\n\n        Args:\n            update_certificate (ArkDPAUpdateCertificate): The ID of the certificate to update\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n        try:\n            with open(update_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n        update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n        resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n\n    def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        Lists all certificates.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            list[ArkDPACertificate]: _description_\n        \"\"\"\n        self._logger.info(\"Listing certificates.\")\n        resp = self.__client.get(CERTIFICATES_API)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n        try:\n            return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n\n    def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        Lists certificates matching the specified filters.\n\n        Args:\n            certificates_filter (ArkDPACertificatesFilter): _description_\n\n        Returns:\n            List[ArkDPAShortCertificate]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n        certs = self.list_certificates()\n\n        if certificates_filter.domain_name:\n            certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n        if certificates_filter.cert_name:\n            certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n        return certs\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.add_certificate","title":"<code>add_certificate(create_certificate)</code>","text":"<p>Adds a new certificate through the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>create_certificate</code> <code>ArkDPACreateCertificate</code> <p>The certificate to add</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be added</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The added certificate</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Adds a new certificate through the Access Certificates Service.\n\n    Args:\n        create_certificate (ArkDPACreateCertificate): The certificate to add\n\n    Raises:\n        ArkServiceException: When the certificate could not be added\n\n    Returns:\n        ArkDPACertificate: The added certificate\n    \"\"\"\n    self._logger.info(\"Adding new certificate.\")\n    cert_body = ''\n    try:\n        with open(create_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n    create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n    resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            cert_id = resp.json()['certificate_id']\n            return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n            raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n    raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.certificate","title":"<code>certificate(get_certificate)</code>","text":"<p>Retrieves a certificate from the Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>get_certificate</code> <code>ArkDPAGetCertificate</code> <p>The ID of the certificate to retrieve</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>When the certificate could not be retrieved</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The retrieved certificate</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Retrieves a certificate from the Access Certificates Service.\n\n    Args:\n        get_certificate (ArkDPAGetCertificate): The ID of the certificate to retrieve\n\n    Raises:\n        ArkServiceException: When the certificate could not be retrieved\n\n    Returns:\n        ArkDPACertificate: The retrieved certificate\n    \"\"\"\n    self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n    resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n    try:\n        return ArkDPACertificate.parse_obj(resp.json())\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.delete_certificate","title":"<code>delete_certificate(cert)</code>","text":"<p>Deletes an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>cert</code> <code>ArkDPADeleteCertificate</code> <p>The ID of the certificate to delete</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n    \"\"\"\n    Deletes an existing certificate.\n\n    Args:\n        cert (ArkDPADeleteCertificate): The ID of the certificate to delete\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n    resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.list_certificates","title":"<code>list_certificates()</code>","text":"<p>Lists all certificates.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>list[ArkDPACertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    Lists all certificates.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        list[ArkDPACertificate]: _description_\n    \"\"\"\n    self._logger.info(\"Listing certificates.\")\n    resp = self.__client.get(CERTIFICATES_API)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n    try:\n        return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.list_certificates_by","title":"<code>list_certificates_by(certificates_filter)</code>","text":"<p>Lists certificates matching the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>certificates_filter</code> <code>ArkDPACertificatesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>List[ArkDPAShortCertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    Lists certificates matching the specified filters.\n\n    Args:\n        certificates_filter (ArkDPACertificatesFilter): _description_\n\n    Returns:\n        List[ArkDPAShortCertificate]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n    certs = self.list_certificates()\n\n    if certificates_filter.domain_name:\n        certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n    if certificates_filter.cert_name:\n        certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n    return certs\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.update_certificate","title":"<code>update_certificate(update_certificate)</code>","text":"<p>Updates an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>update_certificate</code> <code>ArkDPAUpdateCertificate</code> <p>The ID of the certificate to update</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n    \"\"\"\n    Updates an existing certificate.\n\n    Args:\n        update_certificate (ArkDPAUpdateCertificate): The ID of the certificate to update\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n    try:\n        with open(update_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n    update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n    resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/db/","title":"db","text":""},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService","title":"<code>ArkDPADBService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>class ArkDPADBService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__sso_service = ArkDPASSOService(self.__isp_auth)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __proxy_address(self, db_type: str):\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        return f'{claims[\"subdomain\"]}.{db_type}.{claims[\"platform_domain\"]}'\n\n    def __connection_string(self, target_address: str, target_username: Optional[str] = None) -&gt; None:\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        if target_username:\n            # Standing\n            return f'{claims[\"unique_name\"]}@{target_username}@{target_address}'\n        # Dynamic\n        return f'{claims[\"unique_name\"]}@{target_address}'\n\n    def __create_mylogin_cnf(self, username: str, address: str, password: str) -&gt; str:\n        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8')\n        temp_file.write('[client]\\n' f'user = {username}\\n' f'password = {password}\\n' f'host = {address}\\n')\n        temp_file.close()\n        os.chmod(temp_file.name, 0o600)\n        return temp_file.name\n\n    def __add_to_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        flags = 'r+'\n        change_chomd = False\n        path = f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'\n        if not os.path.exists(path):\n            flags = 'w+'\n            change_chomd = True\n        with open(path, flags, encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            for line in lines:\n                if line == pass_format:\n                    return\n            lines.append(pass_format)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(lines)\n        if change_chomd:\n            os.chmod(path, 0o600)\n\n    def __remove_from_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        if not os.path.exists(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'):\n            return\n        with open(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass', 'r+', encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            updated_lines = []\n            for line in lines:\n                if line == pass_format:\n                    continue\n                updated_lines.append(line)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(updated_lines)\n\n    def __execute(self, command_line: str) -&gt; None:\n        p = subprocess.Popen(command_line, shell=True)\n        p.communicate()\n\n    def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n        \"\"\"\n        Executes a Postgres psql command via CyberArk's Database Proxy.\n\n        Args:\n            psql_execution (ArkDPADBPsqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"postgres\")\n        connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n        self.__add_to_pgpass(connection_string, proxy_address, password)\n        try:\n            self.__execute(execution_action)\n        finally:\n            self.__remove_from_pgpass(connection_string, proxy_address, password)\n\n    def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n        \"\"\"\n        Executes a MySQL command line via CyberArk's Database Proxy.\n\n        Args:\n            mysql_execution (ArkDPADBMysqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"mysql\")\n        connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n        execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n        try:\n            self.__execute(execution_action)\n        finally:\n            os.unlink(temp_cnf_login)\n\n    def __generate_assets(\n        self,\n        resource_type: ArkDPADBDatabaseFamilyType,\n        connection_method: ArkConnectionMethod,\n        response_format: ArkDPADBAssetsResponseFormat,\n        include_sso: bool,\n        generation_hints: Dict[str, Any],\n    ) -&gt; ArkDPADBGeneratedAssets:\n        resp: Response = self.__client.post(\n            ASSETS_API,\n            json={\n                'resource_type': resource_type.value,\n                'os_type': running_os().value,\n                'connection_method': connection_method.value,\n                'response_format': response_format.value,\n                'include_sso': include_sso,\n                'generation_hints': generation_hints,\n            },\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                if response_format == ArkDPADBAssetsResponseFormat.RAW:\n                    return resp.text\n                return ArkDPADBGeneratedAssets.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to generate assets [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to generate assets [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate assets [{resp.text}] - [{resp.status_code}]')\n\n    def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n        Args:\n            generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating oracle tns names')\n        assets_data = self.__generate_assets(\n            ArkDPADBDatabaseFamilyType.Oracle,\n            generate_oracle_assets.connection_method,\n            generate_oracle_assets.response_format,\n            generate_oracle_assets.include_sso,\n            {'folder': generate_oracle_assets.folder},\n        )\n        if isinstance(assets_data, ArkDPADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        assets_data = base64.b64decode(assets_data)\n        if not os.path.exists(generate_oracle_assets.folder):\n            os.makedirs(generate_oracle_assets.folder)\n        if not generate_oracle_assets.unzip:\n            with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n                file_handle.write(assets_data)\n        else:\n            assets_bytes = BytesIO(assets_data)\n            with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n                zipf.extractall(generate_oracle_assets.folder)\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService.generate_oracle_tnsnames","title":"<code>generate_oracle_tnsnames(generate_oracle_assets)</code>","text":"<p>Generates an Oracle <code>tnsnames</code> file and, optionally, an Oracle Wallet (if permitted).</p> <p>Parameters:</p> Name Type Description Default <code>generate_oracle_assets</code> <code>ArkDPADBOracleGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n    Args:\n        generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating oracle tns names')\n    assets_data = self.__generate_assets(\n        ArkDPADBDatabaseFamilyType.Oracle,\n        generate_oracle_assets.connection_method,\n        generate_oracle_assets.response_format,\n        generate_oracle_assets.include_sso,\n        {'folder': generate_oracle_assets.folder},\n    )\n    if isinstance(assets_data, ArkDPADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    assets_data = base64.b64decode(assets_data)\n    if not os.path.exists(generate_oracle_assets.folder):\n        os.makedirs(generate_oracle_assets.folder)\n    if not generate_oracle_assets.unzip:\n        with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n            file_handle.write(assets_data)\n    else:\n        assets_bytes = BytesIO(assets_data)\n        with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n            zipf.extractall(generate_oracle_assets.folder)\n</code></pre>"},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService.mysql","title":"<code>mysql(mysql_execution)</code>","text":"<p>Executes a MySQL command line via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>mysql_execution</code> <code>ArkDPADBMysqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n    \"\"\"\n    Executes a MySQL command line via CyberArk's Database Proxy.\n\n    Args:\n        mysql_execution (ArkDPADBMysqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"mysql\")\n    connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n    execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n    try:\n        self.__execute(execution_action)\n    finally:\n        os.unlink(temp_cnf_login)\n</code></pre>"},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService.psql","title":"<code>psql(psql_execution)</code>","text":"<p>Executes a Postgres psql command via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>psql_execution</code> <code>ArkDPADBPsqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n    \"\"\"\n    Executes a Postgres psql command via CyberArk's Database Proxy.\n\n    Args:\n        psql_execution (ArkDPADBPsqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"postgres\")\n    connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n    self.__add_to_pgpass(connection_string, proxy_address, password)\n    try:\n        self.__execute(execution_action)\n    finally:\n        self.__remove_from_pgpass(connection_string, proxy_address, password)\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/","title":"ark_dpa_db_service","text":""},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService","title":"<code>ArkDPADBService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>class ArkDPADBService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__sso_service = ArkDPASSOService(self.__isp_auth)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __proxy_address(self, db_type: str):\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        return f'{claims[\"subdomain\"]}.{db_type}.{claims[\"platform_domain\"]}'\n\n    def __connection_string(self, target_address: str, target_username: Optional[str] = None) -&gt; None:\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        if target_username:\n            # Standing\n            return f'{claims[\"unique_name\"]}@{target_username}@{target_address}'\n        # Dynamic\n        return f'{claims[\"unique_name\"]}@{target_address}'\n\n    def __create_mylogin_cnf(self, username: str, address: str, password: str) -&gt; str:\n        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8')\n        temp_file.write('[client]\\n' f'user = {username}\\n' f'password = {password}\\n' f'host = {address}\\n')\n        temp_file.close()\n        os.chmod(temp_file.name, 0o600)\n        return temp_file.name\n\n    def __add_to_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        flags = 'r+'\n        change_chomd = False\n        path = f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'\n        if not os.path.exists(path):\n            flags = 'w+'\n            change_chomd = True\n        with open(path, flags, encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            for line in lines:\n                if line == pass_format:\n                    return\n            lines.append(pass_format)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(lines)\n        if change_chomd:\n            os.chmod(path, 0o600)\n\n    def __remove_from_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        if not os.path.exists(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'):\n            return\n        with open(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass', 'r+', encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            updated_lines = []\n            for line in lines:\n                if line == pass_format:\n                    continue\n                updated_lines.append(line)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(updated_lines)\n\n    def __execute(self, command_line: str) -&gt; None:\n        p = subprocess.Popen(command_line, shell=True)\n        p.communicate()\n\n    def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n        \"\"\"\n        Executes a Postgres psql command via CyberArk's Database Proxy.\n\n        Args:\n            psql_execution (ArkDPADBPsqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"postgres\")\n        connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n        self.__add_to_pgpass(connection_string, proxy_address, password)\n        try:\n            self.__execute(execution_action)\n        finally:\n            self.__remove_from_pgpass(connection_string, proxy_address, password)\n\n    def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n        \"\"\"\n        Executes a MySQL command line via CyberArk's Database Proxy.\n\n        Args:\n            mysql_execution (ArkDPADBMysqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"mysql\")\n        connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n        execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n        try:\n            self.__execute(execution_action)\n        finally:\n            os.unlink(temp_cnf_login)\n\n    def __generate_assets(\n        self,\n        resource_type: ArkDPADBDatabaseFamilyType,\n        connection_method: ArkConnectionMethod,\n        response_format: ArkDPADBAssetsResponseFormat,\n        include_sso: bool,\n        generation_hints: Dict[str, Any],\n    ) -&gt; ArkDPADBGeneratedAssets:\n        resp: Response = self.__client.post(\n            ASSETS_API,\n            json={\n                'resource_type': resource_type.value,\n                'os_type': running_os().value,\n                'connection_method': connection_method.value,\n                'response_format': response_format.value,\n                'include_sso': include_sso,\n                'generation_hints': generation_hints,\n            },\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                if response_format == ArkDPADBAssetsResponseFormat.RAW:\n                    return resp.text\n                return ArkDPADBGeneratedAssets.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to generate assets [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to generate assets [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate assets [{resp.text}] - [{resp.status_code}]')\n\n    def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n        Args:\n            generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating oracle tns names')\n        assets_data = self.__generate_assets(\n            ArkDPADBDatabaseFamilyType.Oracle,\n            generate_oracle_assets.connection_method,\n            generate_oracle_assets.response_format,\n            generate_oracle_assets.include_sso,\n            {'folder': generate_oracle_assets.folder},\n        )\n        if isinstance(assets_data, ArkDPADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        assets_data = base64.b64decode(assets_data)\n        if not os.path.exists(generate_oracle_assets.folder):\n            os.makedirs(generate_oracle_assets.folder)\n        if not generate_oracle_assets.unzip:\n            with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n                file_handle.write(assets_data)\n        else:\n            assets_bytes = BytesIO(assets_data)\n            with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n                zipf.extractall(generate_oracle_assets.folder)\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService.generate_oracle_tnsnames","title":"<code>generate_oracle_tnsnames(generate_oracle_assets)</code>","text":"<p>Generates an Oracle <code>tnsnames</code> file and, optionally, an Oracle Wallet (if permitted).</p> <p>Parameters:</p> Name Type Description Default <code>generate_oracle_assets</code> <code>ArkDPADBOracleGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates an Oracle `tnsnames` file and, optionally, an Oracle Wallet (if permitted).\n\n    Args:\n        generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating oracle tns names')\n    assets_data = self.__generate_assets(\n        ArkDPADBDatabaseFamilyType.Oracle,\n        generate_oracle_assets.connection_method,\n        generate_oracle_assets.response_format,\n        generate_oracle_assets.include_sso,\n        {'folder': generate_oracle_assets.folder},\n    )\n    if isinstance(assets_data, ArkDPADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    assets_data = base64.b64decode(assets_data)\n    if not os.path.exists(generate_oracle_assets.folder):\n        os.makedirs(generate_oracle_assets.folder)\n    if not generate_oracle_assets.unzip:\n        with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n            file_handle.write(assets_data)\n    else:\n        assets_bytes = BytesIO(assets_data)\n        with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n            zipf.extractall(generate_oracle_assets.folder)\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService.mysql","title":"<code>mysql(mysql_execution)</code>","text":"<p>Executes a MySQL command line via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>mysql_execution</code> <code>ArkDPADBMysqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n    \"\"\"\n    Executes a MySQL command line via CyberArk's Database Proxy.\n\n    Args:\n        mysql_execution (ArkDPADBMysqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"mysql\")\n    connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n    execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n    try:\n        self.__execute(execution_action)\n    finally:\n        os.unlink(temp_cnf_login)\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService.psql","title":"<code>psql(psql_execution)</code>","text":"<p>Executes a Postgres psql command via CyberArk's Database Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>psql_execution</code> <code>ArkDPADBPsqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n    \"\"\"\n    Executes a Postgres psql command via CyberArk's Database Proxy.\n\n    Args:\n        psql_execution (ArkDPADBPsqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"postgres\")\n    connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n    self.__add_to_pgpass(connection_string, proxy_address, password)\n    try:\n        self.__execute(execution_action)\n    finally:\n        self.__remove_from_pgpass(connection_string, proxy_address, password)\n</code></pre>"},{"location":"reference/services/dpa/k8s/","title":"k8s","text":""},{"location":"reference/services/dpa/k8s/#ark_sdk_python.services.dpa.k8s.ArkDPAK8SService","title":"<code>ArkDPAK8SService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>class ArkDPAK8SService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @staticmethod\n    def _save_kube_config_file(folder: str, result: str) -&gt; None:\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(f'{folder}{os.path.sep}config', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result)\n\n    def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n        \"\"\"\n        Builds a Kube config file used to connect to a K8s cluster.\n\n        Args:\n            generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Building kube config file')\n        response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n        result = response.text\n        if generate_kubeconfig.folder:\n            ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n            return None\n        return result\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/k8s/#ark_sdk_python.services.dpa.k8s.ArkDPAK8SService.generate_kubeconfig","title":"<code>generate_kubeconfig(generate_kubeconfig)</code>","text":"<p>Builds a Kube config file used to connect to a K8s cluster.</p> <p>Parameters:</p> Name Type Description Default <code>generate_kubeconfig</code> <code>ArkDPAK8SGenerateKubeConfig</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n    \"\"\"\n    Builds a Kube config file used to connect to a K8s cluster.\n\n    Args:\n        generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Building kube config file')\n    response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n    result = response.text\n    if generate_kubeconfig.folder:\n        ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n        return None\n    return result\n</code></pre>"},{"location":"reference/services/dpa/k8s/ark_dpa_k8s_service/","title":"ark_dpa_k8s_service","text":""},{"location":"reference/services/dpa/k8s/ark_dpa_k8s_service/#ark_sdk_python.services.dpa.k8s.ark_dpa_k8s_service.ArkDPAK8SService","title":"<code>ArkDPAK8SService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>class ArkDPAK8SService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @staticmethod\n    def _save_kube_config_file(folder: str, result: str) -&gt; None:\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(f'{folder}{os.path.sep}config', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result)\n\n    def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n        \"\"\"\n        Builds a Kube config file used to connect to a K8s cluster.\n\n        Args:\n            generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Building kube config file')\n        response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n        result = response.text\n        if generate_kubeconfig.folder:\n            ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n            return None\n        return result\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/k8s/ark_dpa_k8s_service/#ark_sdk_python.services.dpa.k8s.ark_dpa_k8s_service.ArkDPAK8SService.generate_kubeconfig","title":"<code>generate_kubeconfig(generate_kubeconfig)</code>","text":"<p>Builds a Kube config file used to connect to a K8s cluster.</p> <p>Parameters:</p> Name Type Description Default <code>generate_kubeconfig</code> <code>ArkDPAK8SGenerateKubeConfig</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n    \"\"\"\n    Builds a Kube config file used to connect to a K8s cluster.\n\n    Args:\n        generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Building kube config file')\n    response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n    result = response.text\n    if generate_kubeconfig.folder:\n        ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n        return None\n    return result\n</code></pre>"},{"location":"reference/services/dpa/policies/","title":"policies","text":""},{"location":"reference/services/dpa/policies/db/","title":"db","text":""},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService","title":"<code>ArkDPADBPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>class ArkDPADBPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPADBPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find db policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Adds a new DB policy with the specified information.\n\n        Args:\n            add_policy (ArkDPADBAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n        resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) DB policy.\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates a DB policy.\n\n        Args:\n            update_policy (ArkDPADBUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) DB policy.\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists all of the tenants's DB policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all db policies')\n        resp: Response = self.__client.get(DB_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists DB policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkDPADBPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Retrieves a DB policy by ID.\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n        \"\"\"\n        Calculates policy statistics.\n\n        Returns:\n            ArkDPADBPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating db policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPADBPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.providers:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new DB policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPADBAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Adds a new DB policy with the specified information.\n\n    Args:\n        add_policy (ArkDPADBAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n    resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) DB policy.\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all of the tenants's DB policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists all of the tenants's DB policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all db policies')\n    resp: Response = self.__client.get(DB_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists DB policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPADBPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists DB policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkDPADBPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesStats</code> <code>ArkDPADBPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n    \"\"\"\n    Calculates policy statistics.\n\n    Returns:\n        ArkDPADBPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating db policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPADBPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.providers:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a DB policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Retrieves a DB policy by ID.\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPADBUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates a DB policy.\n\n    Args:\n        update_policy (ArkDPADBUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) DB policy.\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/","title":"ark_dpa_db_policies_service","text":""},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService","title":"<code>ArkDPADBPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>class ArkDPADBPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPADBPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find db policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Adds a new DB policy with the specified information.\n\n        Args:\n            add_policy (ArkDPADBAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n        resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) DB policy.\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates a DB policy.\n\n        Args:\n            update_policy (ArkDPADBUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) DB policy.\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists all of the tenants's DB policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all db policies')\n        resp: Response = self.__client.get(DB_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists DB policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkDPADBPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Retrieves a DB policy by ID.\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n        \"\"\"\n        Calculates policy statistics.\n\n        Returns:\n            ArkDPADBPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating db policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPADBPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.providers:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new DB policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPADBAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Adds a new DB policy with the specified information.\n\n    Args:\n        add_policy (ArkDPADBAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n    resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) DB policy.\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all of the tenants's DB policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists all of the tenants's DB policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all db policies')\n    resp: Response = self.__client.get(DB_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists DB policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPADBPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists DB policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkDPADBPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesStats</code> <code>ArkDPADBPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n    \"\"\"\n    Calculates policy statistics.\n\n    Returns:\n        ArkDPADBPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating db policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPADBPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.providers:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a DB policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Retrieves a DB policy by ID.\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPADBUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates a DB policy.\n\n    Args:\n        update_policy (ArkDPADBUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) DB policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) DB policy.\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/","title":"vm","text":""},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService","title":"<code>ArkDPAVMPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>class ArkDPAVMPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPAVMPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find vm policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    @staticmethod\n    def __serialize_providers_dict(providers_data: ArkDPAVMProvidersDict) -&gt; Dict:\n        serialized_providers_data = {}\n        for k in list(providers_data.keys()):\n            serialized_providers_data[serialize_dpa_vm_policies_workspace_type(k)] = providers_data[k].dict(by_alias=True)\n        return serialized_providers_data\n\n    @staticmethod\n    def __serialize_authorization_rules_dict(authorization_rules: List[Dict]) -&gt; None:\n        for rule in authorization_rules:\n            for k in list(rule['connectionInformation']['connectAs'].keys()):\n                for pk in list(rule['connectionInformation']['connectAs'][k].keys()):\n                    item = rule['connectionInformation']['connectAs'][k][pk]\n                    del rule['connectionInformation']['connectAs'][k][pk]\n                    rule['connectionInformation']['connectAs'][k][serialize_dpa_vm_policies_protocol_type(pk)] = item\n                item = rule['connectionInformation']['connectAs'][k]\n                del rule['connectionInformation']['connectAs'][k]\n                rule['connectionInformation']['connectAs'][serialize_dpa_vm_policies_workspace_type(k)] = item\n\n    def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Adds a new VM policy with the specified information.\n\n        Args:\n            add_policy (ArkDPVMAAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True)\n        add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n        self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n        resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) VM policy.\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates a VM policy.\n\n        Args:\n            update_policy (ArkDPAVMUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        if update_policy.providers_data:\n            update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n        if 'userAccessRules' in update_dict:\n            self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n        resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) VM policy.\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists all of the tenants's VM policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all vm policies')\n        resp: Response = self.__client.get(VM_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists VM policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Retrieves a VM policy by ID.\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n        \"\"\"\n        Calculates VM policy statistics.\n\n        Returns:\n            ArkDPAVMPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPAVMPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.platforms:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new VM policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPVMAAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Adds a new VM policy with the specified information.\n\n    Args:\n        add_policy (ArkDPVMAAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True)\n    add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n    self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n    resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) VM policy.\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all of the tenants's VM policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists all of the tenants's VM policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all vm policies')\n    resp: Response = self.__client.get(VM_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists VM policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPAVMPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists VM policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates VM policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesStats</code> <code>ArkDPAVMPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n    \"\"\"\n    Calculates VM policy statistics.\n\n    Returns:\n        ArkDPAVMPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPAVMPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.platforms:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a VM policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Retrieves a VM policy by ID.\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPAVMUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates a VM policy.\n\n    Args:\n        update_policy (ArkDPAVMUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    if update_policy.providers_data:\n        update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n    if 'userAccessRules' in update_dict:\n        self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n    resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) VM policy.\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/","title":"ark_dpa_vm_policies_service","text":""},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService","title":"<code>ArkDPAVMPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>class ArkDPAVMPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPAVMPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find vm policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    @staticmethod\n    def __serialize_providers_dict(providers_data: ArkDPAVMProvidersDict) -&gt; Dict:\n        serialized_providers_data = {}\n        for k in list(providers_data.keys()):\n            serialized_providers_data[serialize_dpa_vm_policies_workspace_type(k)] = providers_data[k].dict(by_alias=True)\n        return serialized_providers_data\n\n    @staticmethod\n    def __serialize_authorization_rules_dict(authorization_rules: List[Dict]) -&gt; None:\n        for rule in authorization_rules:\n            for k in list(rule['connectionInformation']['connectAs'].keys()):\n                for pk in list(rule['connectionInformation']['connectAs'][k].keys()):\n                    item = rule['connectionInformation']['connectAs'][k][pk]\n                    del rule['connectionInformation']['connectAs'][k][pk]\n                    rule['connectionInformation']['connectAs'][k][serialize_dpa_vm_policies_protocol_type(pk)] = item\n                item = rule['connectionInformation']['connectAs'][k]\n                del rule['connectionInformation']['connectAs'][k]\n                rule['connectionInformation']['connectAs'][serialize_dpa_vm_policies_workspace_type(k)] = item\n\n    def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Adds a new VM policy with the specified information.\n\n        Args:\n            add_policy (ArkDPVMAAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True)\n        add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n        self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n        resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes the specified (ID or name) VM policy.\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates a VM policy.\n\n        Args:\n            update_policy (ArkDPAVMUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        if update_policy.providers_data:\n            update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n        if 'userAccessRules' in update_dict:\n            self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n        resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates the status of the specified (by ID) VM policy.\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists all of the tenants's VM policies.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all vm policies')\n        resp: Response = self.__client.get(VM_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists VM policies that match the specified filters.\n\n        Args:\n            policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Retrieves a VM policy by ID.\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n        \"\"\"\n        Calculates VM policy statistics.\n\n        Returns:\n            ArkDPAVMPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPAVMPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.platforms:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new VM policy with the specified information.</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPVMAAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Adds a new VM policy with the specified information.\n\n    Args:\n        add_policy (ArkDPVMAAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True)\n    add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n    self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n    resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes the specified (ID or name) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes the specified (ID or name) VM policy.\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all of the tenants's VM policies.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists all of the tenants's VM policies.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all vm policies')\n    resp: Response = self.__client.get(VM_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists VM policies that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPAVMPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists VM policies that match the specified filters.\n\n    Args:\n        policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates VM policy statistics.</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesStats</code> <code>ArkDPAVMPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n    \"\"\"\n    Calculates VM policy statistics.\n\n    Returns:\n        ArkDPAVMPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPAVMPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.platforms:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a VM policy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Retrieves a VM policy by ID.\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPAVMUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates a VM policy.\n\n    Args:\n        update_policy (ArkDPAVMUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    if update_policy.providers_data:\n        update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n    if 'userAccessRules' in update_dict:\n        self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n    resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the specified (by ID) VM policy.</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates the status of the specified (by ID) VM policy.\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/","title":"secrets","text":""},{"location":"reference/services/dpa/secrets/db/","title":"db","text":""},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService","title":"<code>ArkDPADBSecretsService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>class ArkDPADBSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkDPADBSecretType] = None,\n        tags: Optional[List[ArkDPADBTag]] = None,\n    ) -&gt; ArkDPADBSecretMetadataList:\n        params = {}\n        if secret_type:\n            params['secret_type'] = secret_type.value\n        if tags:\n            params.update({t.key: t.value for t in tags})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadataList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Adds a new DB secret to the secret store.\n\n        Args:\n            add_secret (ArkDPADBAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        self._logger.info('Adding new db secret')\n        add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n        if not add_secret.store_type:\n            add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n        add_secret_dict['secret_store'] = {\n            'store_type': add_secret.store_type.value,\n        }\n        if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n            if not add_secret.username or not add_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password type, both username and password parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'username': add_secret.username,\n                'password': add_secret.password.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n            if not add_secret.pam_account_name or not add_secret.pam_safe:\n                raise ArkServiceException(\n                    'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n                )\n            add_secret_dict['secret_link'] = {\n                'safe': add_secret.pam_safe,\n                'account_name': add_secret.pam_account_name,\n            }\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json=add_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n\n    def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Updates a DB secret.\n\n        Args:\n            update_secret (ArkDPADBUpdateSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if update_secret.secret_name and not update_secret.secret_id:\n            update_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n        update_secret_dict = update_secret.dict(\n            exclude_none=True,\n            exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n        )\n        if update_secret.new_secret_name:\n            update_secret_dict['secret_name'] = update_secret.new_secret_name\n        if update_secret.pam_account_name or update_secret.pam_safe:\n            if not update_secret.pam_account_name or not update_secret.pam_safe:\n                raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n            update_secret_dict['secret_link'] = {\n                'safe': update_secret.pam_safe,\n                'account_name': update_secret.pam_account_name,\n            }\n        if update_secret.username or update_secret.password:\n            if not update_secret.username or not update_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password secret, both username and password name parameters must be supplied'\n                )\n            update_secret_dict['secret_data'] = {\n                'username': update_secret.username,\n                'password': update_secret.password.get_secret_value(),\n            }\n        resp: Response = self.__client.post(\n            SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n            json=update_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n        raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a DB secret.\n\n        Args:\n            delete_secret (ArkDPADBDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_secret.secret_name and not delete_secret.secret_id:\n            delete_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists all tenant DB secrets.\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info('Listing all db secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists DB secrets that match the specified filters.\n\n        Args:\n            secrets_filter (ArkDPADBSecretsFilter): _description_\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n        secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n        # Filter by secret types\n        if secrets_filter.store_type:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n        # Filter by name\n        if secrets_filter.secret_name:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n        secrets.total_count = len(secrets.secrets)\n\n        return secrets\n\n    def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Enables a DB secret.\n\n        Args:\n            enable_secret (ArkDPADBEnableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if enable_secret.secret_name and not enable_secret.secret_id:\n            enable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n        resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Disables a DB secret.\n\n        Args:\n            disable_secret (ArkDPADBDisableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if disable_secret.secret_name and not disable_secret.secret_id:\n            disable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n        resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Retrieves a DB secret.\n\n        Args:\n            get_secret (ArkDPADBGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if get_secret.secret_name and not get_secret.secret_id:\n            get_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n        \"\"\"\n        Calculates DB secrets statistics.\n\n        Returns:\n            ArkDPADBSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkDPADBSecretsStats.construct()\n        secrets_stats.secrets_count = len(secrets.secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n        # Count secrets per secret type\n        secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n        secrets_stats.secrets_count_by_secret_type = {\n            st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        # Count secrets per store type\n        store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n        secrets_stats.secrets_count_by_store_type = {\n            st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new DB secret to the secret store.</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkDPADBAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Adds a new DB secret to the secret store.\n\n    Args:\n        add_secret (ArkDPADBAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    self._logger.info('Adding new db secret')\n    add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n    if not add_secret.store_type:\n        add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n    add_secret_dict['secret_store'] = {\n        'store_type': add_secret.store_type.value,\n    }\n    if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n        if not add_secret.username or not add_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password type, both username and password parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'username': add_secret.username,\n            'password': add_secret.password.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n        if not add_secret.pam_account_name or not add_secret.pam_safe:\n            raise ArkServiceException(\n                'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n            )\n        add_secret_dict['secret_link'] = {\n            'safe': add_secret.pam_safe,\n            'account_name': add_secret.pam_account_name,\n        }\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json=add_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkDPADBDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a DB secret.\n\n    Args:\n        delete_secret (ArkDPADBDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_secret.secret_name and not delete_secret.secret_id:\n        delete_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.disable_secret","title":"<code>disable_secret(disable_secret)</code>","text":"<p>Disables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>disable_secret</code> <code>ArkDPADBDisableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Disables a DB secret.\n\n    Args:\n        disable_secret (ArkDPADBDisableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if disable_secret.secret_name and not disable_secret.secret_id:\n        disable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n    resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.enable_secret","title":"<code>enable_secret(enable_secret)</code>","text":"<p>Enables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>enable_secret</code> <code>ArkDPADBEnableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Enables a DB secret.\n\n    Args:\n        enable_secret (ArkDPADBEnableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if enable_secret.secret_name and not enable_secret.secret_id:\n        enable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n    resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant DB secrets.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists all tenant DB secrets.\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info('Listing all db secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists DB secrets that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkDPADBSecretsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists DB secrets that match the specified filters.\n\n    Args:\n        secrets_filter (ArkDPADBSecretsFilter): _description_\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n    secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n    # Filter by secret types\n    if secrets_filter.store_type:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n    # Filter by name\n    if secrets_filter.secret_name:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n    secrets.total_count = len(secrets.secrets)\n\n    return secrets\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkDPADBGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Retrieves a DB secret.\n\n    Args:\n        get_secret (ArkDPADBGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if get_secret.secret_name and not get_secret.secret_id:\n        get_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates DB secrets statistics.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsStats</code> <code>ArkDPADBSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n    \"\"\"\n    Calculates DB secrets statistics.\n\n    Returns:\n        ArkDPADBSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkDPADBSecretsStats.construct()\n    secrets_stats.secrets_count = len(secrets.secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n    # Count secrets per secret type\n    secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n    secrets_stats.secrets_count_by_secret_type = {\n        st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    # Count secrets per store type\n    store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n    secrets_stats.secrets_count_by_store_type = {\n        st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.update_secret","title":"<code>update_secret(update_secret)</code>","text":"<p>Updates a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>update_secret</code> <code>ArkDPADBUpdateSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Updates a DB secret.\n\n    Args:\n        update_secret (ArkDPADBUpdateSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if update_secret.secret_name and not update_secret.secret_id:\n        update_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n    update_secret_dict = update_secret.dict(\n        exclude_none=True,\n        exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n    )\n    if update_secret.new_secret_name:\n        update_secret_dict['secret_name'] = update_secret.new_secret_name\n    if update_secret.pam_account_name or update_secret.pam_safe:\n        if not update_secret.pam_account_name or not update_secret.pam_safe:\n            raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n        update_secret_dict['secret_link'] = {\n            'safe': update_secret.pam_safe,\n            'account_name': update_secret.pam_account_name,\n        }\n    if update_secret.username or update_secret.password:\n        if not update_secret.username or not update_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password secret, both username and password name parameters must be supplied'\n            )\n        update_secret_dict['secret_data'] = {\n            'username': update_secret.username,\n            'password': update_secret.password.get_secret_value(),\n        }\n    resp: Response = self.__client.post(\n        SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n        json=update_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n    raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/","title":"ark_dpa_db_secrets_service","text":""},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService","title":"<code>ArkDPADBSecretsService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>class ArkDPADBSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkDPADBSecretType] = None,\n        tags: Optional[List[ArkDPADBTag]] = None,\n    ) -&gt; ArkDPADBSecretMetadataList:\n        params = {}\n        if secret_type:\n            params['secret_type'] = secret_type.value\n        if tags:\n            params.update({t.key: t.value for t in tags})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadataList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Adds a new DB secret to the secret store.\n\n        Args:\n            add_secret (ArkDPADBAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        self._logger.info('Adding new db secret')\n        add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n        if not add_secret.store_type:\n            add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n        add_secret_dict['secret_store'] = {\n            'store_type': add_secret.store_type.value,\n        }\n        if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n            if not add_secret.username or not add_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password type, both username and password parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'username': add_secret.username,\n                'password': add_secret.password.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n            if not add_secret.pam_account_name or not add_secret.pam_safe:\n                raise ArkServiceException(\n                    'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n                )\n            add_secret_dict['secret_link'] = {\n                'safe': add_secret.pam_safe,\n                'account_name': add_secret.pam_account_name,\n            }\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json=add_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n\n    def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Updates a DB secret.\n\n        Args:\n            update_secret (ArkDPADBUpdateSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if update_secret.secret_name and not update_secret.secret_id:\n            update_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n        update_secret_dict = update_secret.dict(\n            exclude_none=True,\n            exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n        )\n        if update_secret.new_secret_name:\n            update_secret_dict['secret_name'] = update_secret.new_secret_name\n        if update_secret.pam_account_name or update_secret.pam_safe:\n            if not update_secret.pam_account_name or not update_secret.pam_safe:\n                raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n            update_secret_dict['secret_link'] = {\n                'safe': update_secret.pam_safe,\n                'account_name': update_secret.pam_account_name,\n            }\n        if update_secret.username or update_secret.password:\n            if not update_secret.username or not update_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password secret, both username and password name parameters must be supplied'\n                )\n            update_secret_dict['secret_data'] = {\n                'username': update_secret.username,\n                'password': update_secret.password.get_secret_value(),\n            }\n        resp: Response = self.__client.post(\n            SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n            json=update_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n        raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a DB secret.\n\n        Args:\n            delete_secret (ArkDPADBDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_secret.secret_name and not delete_secret.secret_id:\n            delete_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists all tenant DB secrets.\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info('Listing all db secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists DB secrets that match the specified filters.\n\n        Args:\n            secrets_filter (ArkDPADBSecretsFilter): _description_\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n        secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n        # Filter by secret types\n        if secrets_filter.store_type:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n        # Filter by name\n        if secrets_filter.secret_name:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n        secrets.total_count = len(secrets.secrets)\n\n        return secrets\n\n    def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Enables a DB secret.\n\n        Args:\n            enable_secret (ArkDPADBEnableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if enable_secret.secret_name and not enable_secret.secret_id:\n            enable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n        resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Disables a DB secret.\n\n        Args:\n            disable_secret (ArkDPADBDisableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if disable_secret.secret_name and not disable_secret.secret_id:\n            disable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n        resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Retrieves a DB secret.\n\n        Args:\n            get_secret (ArkDPADBGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if get_secret.secret_name and not get_secret.secret_id:\n            get_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n        \"\"\"\n        Calculates DB secrets statistics.\n\n        Returns:\n            ArkDPADBSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkDPADBSecretsStats.construct()\n        secrets_stats.secrets_count = len(secrets.secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n        # Count secrets per secret type\n        secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n        secrets_stats.secrets_count_by_secret_type = {\n            st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        # Count secrets per store type\n        store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n        secrets_stats.secrets_count_by_store_type = {\n            st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new DB secret to the secret store.</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkDPADBAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Adds a new DB secret to the secret store.\n\n    Args:\n        add_secret (ArkDPADBAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    self._logger.info('Adding new db secret')\n    add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n    if not add_secret.store_type:\n        add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n    add_secret_dict['secret_store'] = {\n        'store_type': add_secret.store_type.value,\n    }\n    if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n        if not add_secret.username or not add_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password type, both username and password parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'username': add_secret.username,\n            'password': add_secret.password.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n        if not add_secret.pam_account_name or not add_secret.pam_safe:\n            raise ArkServiceException(\n                'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n            )\n        add_secret_dict['secret_link'] = {\n            'safe': add_secret.pam_safe,\n            'account_name': add_secret.pam_account_name,\n        }\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json=add_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkDPADBDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a DB secret.\n\n    Args:\n        delete_secret (ArkDPADBDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_secret.secret_name and not delete_secret.secret_id:\n        delete_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.disable_secret","title":"<code>disable_secret(disable_secret)</code>","text":"<p>Disables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>disable_secret</code> <code>ArkDPADBDisableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Disables a DB secret.\n\n    Args:\n        disable_secret (ArkDPADBDisableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if disable_secret.secret_name and not disable_secret.secret_id:\n        disable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n    resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.enable_secret","title":"<code>enable_secret(enable_secret)</code>","text":"<p>Enables a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>enable_secret</code> <code>ArkDPADBEnableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Enables a DB secret.\n\n    Args:\n        enable_secret (ArkDPADBEnableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if enable_secret.secret_name and not enable_secret.secret_id:\n        enable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n    resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant DB secrets.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists all tenant DB secrets.\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info('Listing all db secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists DB secrets that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkDPADBSecretsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists DB secrets that match the specified filters.\n\n    Args:\n        secrets_filter (ArkDPADBSecretsFilter): _description_\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n    secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n    # Filter by secret types\n    if secrets_filter.store_type:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n    # Filter by name\n    if secrets_filter.secret_name:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n    secrets.total_count = len(secrets.secrets)\n\n    return secrets\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkDPADBGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Retrieves a DB secret.\n\n    Args:\n        get_secret (ArkDPADBGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if get_secret.secret_name and not get_secret.secret_id:\n        get_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates DB secrets statistics.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsStats</code> <code>ArkDPADBSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n    \"\"\"\n    Calculates DB secrets statistics.\n\n    Returns:\n        ArkDPADBSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkDPADBSecretsStats.construct()\n    secrets_stats.secrets_count = len(secrets.secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n    # Count secrets per secret type\n    secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n    secrets_stats.secrets_count_by_secret_type = {\n        st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    # Count secrets per store type\n    store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n    secrets_stats.secrets_count_by_store_type = {\n        st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.update_secret","title":"<code>update_secret(update_secret)</code>","text":"<p>Updates a DB secret.</p> <p>Parameters:</p> Name Type Description Default <code>update_secret</code> <code>ArkDPADBUpdateSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Updates a DB secret.\n\n    Args:\n        update_secret (ArkDPADBUpdateSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if update_secret.secret_name and not update_secret.secret_id:\n        update_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n    update_secret_dict = update_secret.dict(\n        exclude_none=True,\n        exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n    )\n    if update_secret.new_secret_name:\n        update_secret_dict['secret_name'] = update_secret.new_secret_name\n    if update_secret.pam_account_name or update_secret.pam_safe:\n        if not update_secret.pam_account_name or not update_secret.pam_safe:\n            raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n        update_secret_dict['secret_link'] = {\n            'safe': update_secret.pam_safe,\n            'account_name': update_secret.pam_account_name,\n        }\n    if update_secret.username or update_secret.password:\n        if not update_secret.username or not update_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password secret, both username and password name parameters must be supplied'\n            )\n        update_secret_dict['secret_data'] = {\n            'username': update_secret.username,\n            'password': update_secret.password.get_secret_value(),\n        }\n    resp: Response = self.__client.post(\n        SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n        json=update_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n    raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/","title":"sso","text":""},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService","title":"<code>ArkDPASSOService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>class ArkDPASSOService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n        self.__cache_keyring = ArkKeyring(self.service_config().service_name)\n\n    def __load_from_cache(self, token_type: str) -&gt; Optional[ArkDPASSOAcquireTokenResponse]:\n        claims = get_unverified_claims(self.__client.session_token)\n        token = self.__cache_keyring.load_token(\n            ArkProfileLoader.load_default_profile(),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n        if token:\n            return ArkDPASSOAcquireTokenResponse.parse_raw(token.token.get_secret_value())\n        return None\n\n    def __save_to_cache(self, result: ArkDPASSOAcquireTokenResponse, token_type: str) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        expires_in = datetime.now() + (parse(result.metadata['expires_at']) - parse(result.metadata['created_at']))\n        self.__cache_keyring.save_token(\n            ArkProfileLoader.load_default_profile(),\n            ArkToken(\n                token=result.json(),\n                token_type=ArkTokenType.Token,\n                expires_in=expires_in,\n            ),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n\n    def __output_client_certificate(\n        self, folder: str, output_format: ArkDPASSOShortLiveClientCertificateFormat, result: ArkDPASSOAcquireTokenResponse\n    ) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        client_certificate = result.token['client_certificate']\n        private_key = result.token['private_key']\n\n        if output_format == ArkDPASSOShortLiveClientCertificateFormat.RAW:\n            ArkArgsFormatter.print_normal(f'client-certificate-data: {client_certificate}')\n            ArkArgsFormatter.print_normal(f'client-key-data: {private_key}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.BASE64:\n            ArkArgsFormatter.print_normal(\n                f'client-certificate-data: {base64.b64encode(client_certificate.encode(\"utf-8\")).decode(\"utf-8\")}'\n            )\n            ArkArgsFormatter.print_normal(f'client-key-data: {base64.b64encode(private_key.encode(\"utf-8\")).decode(\"utf-8\")}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkDPASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder):\n                os.makedirs(folder)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_cert.crt', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_key.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(private_key)\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.SINGLE_FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkDPASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder):\n                os.makedirs(folder)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_cert.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n                file_handle.write('\\n')\n                file_handle.write(private_key)\n        else:\n            raise ArkServiceException(f'Unknown format {output_format}')\n\n    def __save_oracle_wallet(self, folder: str, unzip_wallet: bool, result: ArkDPASSOAcquireTokenResponse) -&gt; None:\n        result.token['wallet'] = base64.b64decode(result.token['wallet'])\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        if not unzip_wallet:\n            with open(f'{folder}{os.path.sep}wallet.zip', 'wb') as file_handle:\n                file_handle.write(result.token['wallet'])\n        else:\n            wallet_bytes = BytesIO(result.token['wallet'])\n            with zipfile.ZipFile(wallet_bytes, 'r') as zipf:\n                zipf.extractall(folder)\n\n    def __save_rdp_file(self, get_short_lived_rdp_file: ArkDPASSOGetShortLivedRDPFile, result: ArkDPASSOAcquireTokenResponse) -&gt; None:\n        if not os.path.exists(get_short_lived_rdp_file.folder):\n            os.makedirs(get_short_lived_rdp_file.folder)\n        filename: str = f'dpa _a {get_short_lived_rdp_file.target_address}'\n        if get_short_lived_rdp_file.target_domain:\n            filename += f' _d {get_short_lived_rdp_file.target_domain}'\n        with open(f'{get_short_lived_rdp_file.folder}{filename}.rdp', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result.token['text'])\n\n    def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n        \"\"\"\n        Generates a short-lived password used to connect to DPA services.\n\n        Args:\n            get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived password token')\n        if get_short_lived_password.allow_caching:\n            result = self.__load_from_cache('password')\n            if result:\n                return result.token['key']\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'password',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'key' in result.token:\n            if get_short_lived_password.allow_caching:\n                self.__save_to_cache(result, 'password')\n            return result.token['key']\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n        \"\"\"\n        Generates a short-lived client certificate used to connect to DPA services.\n\n        Args:\n            get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived client certificate')\n        if get_short_lived_client_certificate.allow_caching:\n            result = self.__load_from_cache('client_certificate')\n            if result:\n                self.__output_client_certificate(\n                    get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n                )\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'client_certificate',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'client_certificate' in result.token and 'private_key' in result.token:\n            if get_short_lived_client_certificate.allow_caching:\n                self.__save_to_cache(result, 'client_certificate')\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n        \"\"\"\n        Generates a short-lived Oracle Wallet used to connect via DPA to Oracle databases.\n\n        Args:\n            get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived oracle wallet')\n        if get_short_lived_oracle_wallet.allow_caching:\n            result = self.__load_from_cache('oracle_wallet')\n            if result:\n                self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'oracle_wallet',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'wallet' in result.token:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkDPASSOGetShortLivedRDPFile) -&gt; None:\n        \"\"\"\n        Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n        Args:\n            get_short_lived_rdp_file (ArkDPASSOGetShortLivedRDPFile): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived rdp file')\n        if get_short_lived_rdp_file.allow_caching:\n            result = self.__load_from_cache('rdp_file')\n            if result:\n                self.__save_rdp_file(get_short_lived_rdp_file, result)\n        token_parameters: Dict[str, Any] = {\n            'targetAddress': get_short_lived_rdp_file.target_address,\n            'targetDomain': get_short_lived_rdp_file.target_domain,\n            'targetUser': get_short_lived_rdp_file.target_user,\n            'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n        }\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'rdp_file',\n                'service': 'DPA-RDP',\n                'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n                'token_response_format': 'extended',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'text' in result.token:\n            if get_short_lived_rdp_file.allow_caching:\n                self.__save_to_cache(result, 'rdp_file')\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n            return\n        raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService.short_lived_client_certificate","title":"<code>short_lived_client_certificate(get_short_lived_client_certificate)</code>","text":"<p>Generates a short-lived client certificate used to connect to DPA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_client_certificate</code> <code>ArkDPASSOGetShortLivedClientCertificate</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n    \"\"\"\n    Generates a short-lived client certificate used to connect to DPA services.\n\n    Args:\n        get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived client certificate')\n    if get_short_lived_client_certificate.allow_caching:\n        result = self.__load_from_cache('client_certificate')\n        if result:\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'client_certificate',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'client_certificate' in result.token and 'private_key' in result.token:\n        if get_short_lived_client_certificate.allow_caching:\n            self.__save_to_cache(result, 'client_certificate')\n        self.__output_client_certificate(\n            get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n        )\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService.short_lived_oracle_wallet","title":"<code>short_lived_oracle_wallet(get_short_lived_oracle_wallet)</code>","text":"<p>Generates a short-lived Oracle Wallet used to connect via DPA to Oracle databases.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_oracle_wallet</code> <code>ArkDPASSOGetShortLivedOracleWallet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n    \"\"\"\n    Generates a short-lived Oracle Wallet used to connect via DPA to Oracle databases.\n\n    Args:\n        get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived oracle wallet')\n    if get_short_lived_oracle_wallet.allow_caching:\n        result = self.__load_from_cache('oracle_wallet')\n        if result:\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'oracle_wallet',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'wallet' in result.token:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService.short_lived_password","title":"<code>short_lived_password(get_short_lived_password)</code>","text":"<p>Generates a short-lived password used to connect to DPA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_password</code> <code>ArkDPASSOGetShortLivedPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n    \"\"\"\n    Generates a short-lived password used to connect to DPA services.\n\n    Args:\n        get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived password token')\n    if get_short_lived_password.allow_caching:\n        result = self.__load_from_cache('password')\n        if result:\n            return result.token['key']\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'password',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'key' in result.token:\n        if get_short_lived_password.allow_caching:\n            self.__save_to_cache(result, 'password')\n        return result.token['key']\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService.short_lived_rdp_file","title":"<code>short_lived_rdp_file(get_short_lived_rdp_file)</code>","text":"<p>Generates a short-lived RDP file used to connect via RDP to Windows machines.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_rdp_file</code> <code>ArkDPASSOGetShortLivedRDPFile</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkDPASSOGetShortLivedRDPFile) -&gt; None:\n    \"\"\"\n    Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n    Args:\n        get_short_lived_rdp_file (ArkDPASSOGetShortLivedRDPFile): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived rdp file')\n    if get_short_lived_rdp_file.allow_caching:\n        result = self.__load_from_cache('rdp_file')\n        if result:\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n    token_parameters: Dict[str, Any] = {\n        'targetAddress': get_short_lived_rdp_file.target_address,\n        'targetDomain': get_short_lived_rdp_file.target_domain,\n        'targetUser': get_short_lived_rdp_file.target_user,\n        'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n    }\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'rdp_file',\n            'service': 'DPA-RDP',\n            'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n            'token_response_format': 'extended',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'text' in result.token:\n        if get_short_lived_rdp_file.allow_caching:\n            self.__save_to_cache(result, 'rdp_file')\n        self.__save_rdp_file(get_short_lived_rdp_file, result)\n        return\n    raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/","title":"ark_dpa_sso_service","text":""},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService","title":"<code>ArkDPASSOService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>class ArkDPASSOService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n        self.__cache_keyring = ArkKeyring(self.service_config().service_name)\n\n    def __load_from_cache(self, token_type: str) -&gt; Optional[ArkDPASSOAcquireTokenResponse]:\n        claims = get_unverified_claims(self.__client.session_token)\n        token = self.__cache_keyring.load_token(\n            ArkProfileLoader.load_default_profile(),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n        if token:\n            return ArkDPASSOAcquireTokenResponse.parse_raw(token.token.get_secret_value())\n        return None\n\n    def __save_to_cache(self, result: ArkDPASSOAcquireTokenResponse, token_type: str) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        expires_in = datetime.now() + (parse(result.metadata['expires_at']) - parse(result.metadata['created_at']))\n        self.__cache_keyring.save_token(\n            ArkProfileLoader.load_default_profile(),\n            ArkToken(\n                token=result.json(),\n                token_type=ArkTokenType.Token,\n                expires_in=expires_in,\n            ),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n\n    def __output_client_certificate(\n        self, folder: str, output_format: ArkDPASSOShortLiveClientCertificateFormat, result: ArkDPASSOAcquireTokenResponse\n    ) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        client_certificate = result.token['client_certificate']\n        private_key = result.token['private_key']\n\n        if output_format == ArkDPASSOShortLiveClientCertificateFormat.RAW:\n            ArkArgsFormatter.print_normal(f'client-certificate-data: {client_certificate}')\n            ArkArgsFormatter.print_normal(f'client-key-data: {private_key}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.BASE64:\n            ArkArgsFormatter.print_normal(\n                f'client-certificate-data: {base64.b64encode(client_certificate.encode(\"utf-8\")).decode(\"utf-8\")}'\n            )\n            ArkArgsFormatter.print_normal(f'client-key-data: {base64.b64encode(private_key.encode(\"utf-8\")).decode(\"utf-8\")}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkDPASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder):\n                os.makedirs(folder)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_cert.crt', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_key.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(private_key)\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.SINGLE_FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkDPASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder):\n                os.makedirs(folder)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_cert.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n                file_handle.write('\\n')\n                file_handle.write(private_key)\n        else:\n            raise ArkServiceException(f'Unknown format {output_format}')\n\n    def __save_oracle_wallet(self, folder: str, unzip_wallet: bool, result: ArkDPASSOAcquireTokenResponse) -&gt; None:\n        result.token['wallet'] = base64.b64decode(result.token['wallet'])\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        if not unzip_wallet:\n            with open(f'{folder}{os.path.sep}wallet.zip', 'wb') as file_handle:\n                file_handle.write(result.token['wallet'])\n        else:\n            wallet_bytes = BytesIO(result.token['wallet'])\n            with zipfile.ZipFile(wallet_bytes, 'r') as zipf:\n                zipf.extractall(folder)\n\n    def __save_rdp_file(self, get_short_lived_rdp_file: ArkDPASSOGetShortLivedRDPFile, result: ArkDPASSOAcquireTokenResponse) -&gt; None:\n        if not os.path.exists(get_short_lived_rdp_file.folder):\n            os.makedirs(get_short_lived_rdp_file.folder)\n        filename: str = f'dpa _a {get_short_lived_rdp_file.target_address}'\n        if get_short_lived_rdp_file.target_domain:\n            filename += f' _d {get_short_lived_rdp_file.target_domain}'\n        with open(f'{get_short_lived_rdp_file.folder}{filename}.rdp', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result.token['text'])\n\n    def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n        \"\"\"\n        Generates a short-lived password used to connect to DPA services.\n\n        Args:\n            get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived password token')\n        if get_short_lived_password.allow_caching:\n            result = self.__load_from_cache('password')\n            if result:\n                return result.token['key']\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'password',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'key' in result.token:\n            if get_short_lived_password.allow_caching:\n                self.__save_to_cache(result, 'password')\n            return result.token['key']\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n        \"\"\"\n        Generates a short-lived client certificate used to connect to DPA services.\n\n        Args:\n            get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived client certificate')\n        if get_short_lived_client_certificate.allow_caching:\n            result = self.__load_from_cache('client_certificate')\n            if result:\n                self.__output_client_certificate(\n                    get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n                )\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'client_certificate',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'client_certificate' in result.token and 'private_key' in result.token:\n            if get_short_lived_client_certificate.allow_caching:\n                self.__save_to_cache(result, 'client_certificate')\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n        \"\"\"\n        Generates a short-lived Oracle Wallet used to connect via DPA to Oracle databases.\n\n        Args:\n            get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived oracle wallet')\n        if get_short_lived_oracle_wallet.allow_caching:\n            result = self.__load_from_cache('oracle_wallet')\n            if result:\n                self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'oracle_wallet',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'wallet' in result.token:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkDPASSOGetShortLivedRDPFile) -&gt; None:\n        \"\"\"\n        Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n        Args:\n            get_short_lived_rdp_file (ArkDPASSOGetShortLivedRDPFile): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived rdp file')\n        if get_short_lived_rdp_file.allow_caching:\n            result = self.__load_from_cache('rdp_file')\n            if result:\n                self.__save_rdp_file(get_short_lived_rdp_file, result)\n        token_parameters: Dict[str, Any] = {\n            'targetAddress': get_short_lived_rdp_file.target_address,\n            'targetDomain': get_short_lived_rdp_file.target_domain,\n            'targetUser': get_short_lived_rdp_file.target_user,\n            'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n        }\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'rdp_file',\n                'service': 'DPA-RDP',\n                'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n                'token_response_format': 'extended',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'text' in result.token:\n            if get_short_lived_rdp_file.allow_caching:\n                self.__save_to_cache(result, 'rdp_file')\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n            return\n        raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService.short_lived_client_certificate","title":"<code>short_lived_client_certificate(get_short_lived_client_certificate)</code>","text":"<p>Generates a short-lived client certificate used to connect to DPA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_client_certificate</code> <code>ArkDPASSOGetShortLivedClientCertificate</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n    \"\"\"\n    Generates a short-lived client certificate used to connect to DPA services.\n\n    Args:\n        get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived client certificate')\n    if get_short_lived_client_certificate.allow_caching:\n        result = self.__load_from_cache('client_certificate')\n        if result:\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'client_certificate',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'client_certificate' in result.token and 'private_key' in result.token:\n        if get_short_lived_client_certificate.allow_caching:\n            self.__save_to_cache(result, 'client_certificate')\n        self.__output_client_certificate(\n            get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n        )\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService.short_lived_oracle_wallet","title":"<code>short_lived_oracle_wallet(get_short_lived_oracle_wallet)</code>","text":"<p>Generates a short-lived Oracle Wallet used to connect via DPA to Oracle databases.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_oracle_wallet</code> <code>ArkDPASSOGetShortLivedOracleWallet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n    \"\"\"\n    Generates a short-lived Oracle Wallet used to connect via DPA to Oracle databases.\n\n    Args:\n        get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived oracle wallet')\n    if get_short_lived_oracle_wallet.allow_caching:\n        result = self.__load_from_cache('oracle_wallet')\n        if result:\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'oracle_wallet',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'wallet' in result.token:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService.short_lived_password","title":"<code>short_lived_password(get_short_lived_password)</code>","text":"<p>Generates a short-lived password used to connect to DPA services.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_password</code> <code>ArkDPASSOGetShortLivedPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n    \"\"\"\n    Generates a short-lived password used to connect to DPA services.\n\n    Args:\n        get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived password token')\n    if get_short_lived_password.allow_caching:\n        result = self.__load_from_cache('password')\n        if result:\n            return result.token['key']\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'password',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'key' in result.token:\n        if get_short_lived_password.allow_caching:\n            self.__save_to_cache(result, 'password')\n        return result.token['key']\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService.short_lived_rdp_file","title":"<code>short_lived_rdp_file(get_short_lived_rdp_file)</code>","text":"<p>Generates a short-lived RDP file used to connect via RDP to Windows machines.</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_rdp_file</code> <code>ArkDPASSOGetShortLivedRDPFile</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_rdp_file(self, get_short_lived_rdp_file: ArkDPASSOGetShortLivedRDPFile) -&gt; None:\n    \"\"\"\n    Generates a short-lived RDP file used to connect via RDP to Windows machines.\n\n    Args:\n        get_short_lived_rdp_file (ArkDPASSOGetShortLivedRDPFile): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived rdp file')\n    if get_short_lived_rdp_file.allow_caching:\n        result = self.__load_from_cache('rdp_file')\n        if result:\n            self.__save_rdp_file(get_short_lived_rdp_file, result)\n    token_parameters: Dict[str, Any] = {\n        'targetAddress': get_short_lived_rdp_file.target_address,\n        'targetDomain': get_short_lived_rdp_file.target_domain,\n        'targetUser': get_short_lived_rdp_file.target_user,\n        'elevatedPrivileges': get_short_lived_rdp_file.elevated_privileges,\n    }\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'rdp_file',\n            'service': 'DPA-RDP',\n            'token_parameters': {k: v for k, v in token_parameters.items() if v is not None},\n            'token_response_format': 'extended',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived rdp file - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'text' in result.token:\n        if get_short_lived_rdp_file.allow_caching:\n            self.__save_to_cache(result, 'rdp_file')\n        self.__save_rdp_file(get_short_lived_rdp_file, result)\n        return\n    raise ArkServiceException(f'Failed to generate short rdp file - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/","title":"workspaces","text":""},{"location":"reference/services/dpa/workspaces/db/","title":"db","text":""},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService","title":"<code>ArkDPADBWorkspaceService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>class ArkDPADBWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_databases_with_filters(\n        self, provider_family: Optional[ArkDPADBDatabaseFamilyType] = None, tags: Optional[List[ArkDPADBTag]] = None\n    ) -&gt; ArkDPADBDatabaseInfoList:\n        params = {}\n        if provider_family:\n            params['provider-family'] = provider_family.value\n        if tags:\n            for tag in tags:\n                params[f'key.{tag.key}'] = tag.value\n        resp: Response = self.__client.get(RESOURCES_API, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabaseInfoList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list databases response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list databases response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list databases [{resp.text}] - [{resp.status_code}]')\n\n    def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Adds a new database.\n\n        Args:\n            add_database (ArkDPADBAddDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        self._logger.info(f'Adding database [{add_database.name}]')\n        if not add_database.port:\n            add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n        add_database_dict = add_database.dict(exclude_none=True)\n        add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n        resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                database_id = resp.json()['target_id']\n                return self.database(ArkDPADBGetDatabase(id=database_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n\n    def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n        \"\"\"\n        Deletes a database.\n\n        Args:\n            delete_database (ArkDPADBDeleteDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_database.name and not delete_database.id:\n            delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n        self._logger.info(f'Deleting database [{delete_database.id}]')\n        resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n\n    def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Updates a database.\n\n        Args:\n            update_database (ArkDPADBUpdateDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if update_database.name and not update_database.id:\n            update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n        self._logger.info(f'Updating database [{update_database.id}]')\n        update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_database.new_name:\n            update_database_dict[\"name\"] = update_database.new_name\n        resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return self.database(ArkDPADBGetDatabase(id=update_database.id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n\n    def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        Lists all databases.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info('Listing all databases')\n        return self.__list_databases_with_filters()\n\n    def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        Lists databases that match the specified filters.\n\n        Args:\n            databases_filter (ArkDPADBDatabasesFilter): _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info(f'Listing databases by filters [{databases_filter}]')\n        databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n        if databases_filter.name:\n            databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n        if databases_filter.provider_engine:\n            databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n        if databases_filter.provider_workspace:\n            databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n        if databases_filter.db_warnings_filter:\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoCertificates,\n            ):\n                databases.items = [d for d in databases.items if not d.certificate]\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoSecrets,\n            ):\n                databases.items = [d for d in databases.items if not d.secret_id]\n        databases.total_count = len(databases.items)\n        return databases\n\n    def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Gets a specific database.\n\n        Args:\n            get_database (ArkDPADBGetDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if get_database.name and not get_database.id:\n            get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n        self._logger.info(f'Getting database [{get_database.id}]')\n        resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabase.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n\n    def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n        \"\"\"\n        Calculate statistics about the tenant's databases.\n\n        Returns:\n            ArkDPADBDatabasesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating databases stats')\n        databases = self.list_databases()\n        databases_stats = ArkDPADBDatabasesStats.construct()\n        databases_stats.databases_count = len(databases.items)\n\n        # Get databases per engine\n        engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n        databases_stats.databases_count_by_engine = {\n            et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n        }\n\n        # Get databases per workspace\n        workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n        databases_stats.databases_count_by_workspace = {\n            wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n        }\n\n        # Get databases per family\n        family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n        databases_stats.databases_count_by_family = {\n            ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n        }\n\n        # Get databases per db warning\n        databases_stats.databases_count_by_warning = {\n            ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n            ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n        }\n\n        return databases_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.add_database","title":"<code>add_database(add_database)</code>","text":"<p>Adds a new database.</p> <p>Parameters:</p> Name Type Description Default <code>add_database</code> <code>ArkDPADBAddDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Adds a new database.\n\n    Args:\n        add_database (ArkDPADBAddDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    self._logger.info(f'Adding database [{add_database.name}]')\n    if not add_database.port:\n        add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n    add_database_dict = add_database.dict(exclude_none=True)\n    add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n    resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            database_id = resp.json()['target_id']\n            return self.database(ArkDPADBGetDatabase(id=database_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.database","title":"<code>database(get_database)</code>","text":"<p>Gets a specific database.</p> <p>Parameters:</p> Name Type Description Default <code>get_database</code> <code>ArkDPADBGetDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Gets a specific database.\n\n    Args:\n        get_database (ArkDPADBGetDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if get_database.name and not get_database.id:\n        get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n    self._logger.info(f'Getting database [{get_database.id}]')\n    resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBDatabase.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.databases_stats","title":"<code>databases_stats()</code>","text":"<p>Calculate statistics about the tenant's databases.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabasesStats</code> <code>ArkDPADBDatabasesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n    \"\"\"\n    Calculate statistics about the tenant's databases.\n\n    Returns:\n        ArkDPADBDatabasesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating databases stats')\n    databases = self.list_databases()\n    databases_stats = ArkDPADBDatabasesStats.construct()\n    databases_stats.databases_count = len(databases.items)\n\n    # Get databases per engine\n    engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n    databases_stats.databases_count_by_engine = {\n        et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n    }\n\n    # Get databases per workspace\n    workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n    databases_stats.databases_count_by_workspace = {\n        wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n    }\n\n    # Get databases per family\n    family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n    databases_stats.databases_count_by_family = {\n        ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n    }\n\n    # Get databases per db warning\n    databases_stats.databases_count_by_warning = {\n        ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n        ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n    }\n\n    return databases_stats\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.delete_database","title":"<code>delete_database(delete_database)</code>","text":"<p>Deletes a database.</p> <p>Parameters:</p> Name Type Description Default <code>delete_database</code> <code>ArkDPADBDeleteDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n    \"\"\"\n    Deletes a database.\n\n    Args:\n        delete_database (ArkDPADBDeleteDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_database.name and not delete_database.id:\n        delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n    self._logger.info(f'Deleting database [{delete_database.id}]')\n    resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.list_databases","title":"<code>list_databases()</code>","text":"<p>Lists all databases.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    Lists all databases.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info('Listing all databases')\n    return self.__list_databases_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.list_databases_by","title":"<code>list_databases_by(databases_filter)</code>","text":"<p>Lists databases that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>databases_filter</code> <code>ArkDPADBDatabasesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    Lists databases that match the specified filters.\n\n    Args:\n        databases_filter (ArkDPADBDatabasesFilter): _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info(f'Listing databases by filters [{databases_filter}]')\n    databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n    if databases_filter.name:\n        databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n    if databases_filter.provider_engine:\n        databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n    if databases_filter.provider_workspace:\n        databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n    if databases_filter.db_warnings_filter:\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoCertificates,\n        ):\n            databases.items = [d for d in databases.items if not d.certificate]\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoSecrets,\n        ):\n            databases.items = [d for d in databases.items if not d.secret_id]\n    databases.total_count = len(databases.items)\n    return databases\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.update_database","title":"<code>update_database(update_database)</code>","text":"<p>Updates a database.</p> <p>Parameters:</p> Name Type Description Default <code>update_database</code> <code>ArkDPADBUpdateDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Updates a database.\n\n    Args:\n        update_database (ArkDPADBUpdateDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if update_database.name and not update_database.id:\n        update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n    self._logger.info(f'Updating database [{update_database.id}]')\n    update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_database.new_name:\n        update_database_dict[\"name\"] = update_database.new_name\n    resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return self.database(ArkDPADBGetDatabase(id=update_database.id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/","title":"ark_dpa_db_workspace_service","text":""},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService","title":"<code>ArkDPADBWorkspaceService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>class ArkDPADBWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_databases_with_filters(\n        self, provider_family: Optional[ArkDPADBDatabaseFamilyType] = None, tags: Optional[List[ArkDPADBTag]] = None\n    ) -&gt; ArkDPADBDatabaseInfoList:\n        params = {}\n        if provider_family:\n            params['provider-family'] = provider_family.value\n        if tags:\n            for tag in tags:\n                params[f'key.{tag.key}'] = tag.value\n        resp: Response = self.__client.get(RESOURCES_API, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabaseInfoList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list databases response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list databases response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list databases [{resp.text}] - [{resp.status_code}]')\n\n    def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Adds a new database.\n\n        Args:\n            add_database (ArkDPADBAddDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        self._logger.info(f'Adding database [{add_database.name}]')\n        if not add_database.port:\n            add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n        add_database_dict = add_database.dict(exclude_none=True)\n        add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n        resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                database_id = resp.json()['target_id']\n                return self.database(ArkDPADBGetDatabase(id=database_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n\n    def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n        \"\"\"\n        Deletes a database.\n\n        Args:\n            delete_database (ArkDPADBDeleteDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_database.name and not delete_database.id:\n            delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n        self._logger.info(f'Deleting database [{delete_database.id}]')\n        resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n\n    def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Updates a database.\n\n        Args:\n            update_database (ArkDPADBUpdateDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if update_database.name and not update_database.id:\n            update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n        self._logger.info(f'Updating database [{update_database.id}]')\n        update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_database.new_name:\n            update_database_dict[\"name\"] = update_database.new_name\n        resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return self.database(ArkDPADBGetDatabase(id=update_database.id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n\n    def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        Lists all databases.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info('Listing all databases')\n        return self.__list_databases_with_filters()\n\n    def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        Lists databases that match the specified filters.\n\n        Args:\n            databases_filter (ArkDPADBDatabasesFilter): _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info(f'Listing databases by filters [{databases_filter}]')\n        databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n        if databases_filter.name:\n            databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n        if databases_filter.provider_engine:\n            databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n        if databases_filter.provider_workspace:\n            databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n        if databases_filter.db_warnings_filter:\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoCertificates,\n            ):\n                databases.items = [d for d in databases.items if not d.certificate]\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoSecrets,\n            ):\n                databases.items = [d for d in databases.items if not d.secret_id]\n        databases.total_count = len(databases.items)\n        return databases\n\n    def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Gets a specific database.\n\n        Args:\n            get_database (ArkDPADBGetDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if get_database.name and not get_database.id:\n            get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n        self._logger.info(f'Getting database [{get_database.id}]')\n        resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabase.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n\n    def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n        \"\"\"\n        Calculate statistics about the tenant's databases.\n\n        Returns:\n            ArkDPADBDatabasesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating databases stats')\n        databases = self.list_databases()\n        databases_stats = ArkDPADBDatabasesStats.construct()\n        databases_stats.databases_count = len(databases.items)\n\n        # Get databases per engine\n        engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n        databases_stats.databases_count_by_engine = {\n            et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n        }\n\n        # Get databases per workspace\n        workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n        databases_stats.databases_count_by_workspace = {\n            wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n        }\n\n        # Get databases per family\n        family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n        databases_stats.databases_count_by_family = {\n            ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n        }\n\n        # Get databases per db warning\n        databases_stats.databases_count_by_warning = {\n            ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n            ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n        }\n\n        return databases_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.add_database","title":"<code>add_database(add_database)</code>","text":"<p>Adds a new database.</p> <p>Parameters:</p> Name Type Description Default <code>add_database</code> <code>ArkDPADBAddDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Adds a new database.\n\n    Args:\n        add_database (ArkDPADBAddDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    self._logger.info(f'Adding database [{add_database.name}]')\n    if not add_database.port:\n        add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n    add_database_dict = add_database.dict(exclude_none=True)\n    add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n    resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            database_id = resp.json()['target_id']\n            return self.database(ArkDPADBGetDatabase(id=database_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.database","title":"<code>database(get_database)</code>","text":"<p>Gets a specific database.</p> <p>Parameters:</p> Name Type Description Default <code>get_database</code> <code>ArkDPADBGetDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Gets a specific database.\n\n    Args:\n        get_database (ArkDPADBGetDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if get_database.name and not get_database.id:\n        get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n    self._logger.info(f'Getting database [{get_database.id}]')\n    resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBDatabase.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.databases_stats","title":"<code>databases_stats()</code>","text":"<p>Calculate statistics about the tenant's databases.</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabasesStats</code> <code>ArkDPADBDatabasesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n    \"\"\"\n    Calculate statistics about the tenant's databases.\n\n    Returns:\n        ArkDPADBDatabasesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating databases stats')\n    databases = self.list_databases()\n    databases_stats = ArkDPADBDatabasesStats.construct()\n    databases_stats.databases_count = len(databases.items)\n\n    # Get databases per engine\n    engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n    databases_stats.databases_count_by_engine = {\n        et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n    }\n\n    # Get databases per workspace\n    workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n    databases_stats.databases_count_by_workspace = {\n        wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n    }\n\n    # Get databases per family\n    family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n    databases_stats.databases_count_by_family = {\n        ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n    }\n\n    # Get databases per db warning\n    databases_stats.databases_count_by_warning = {\n        ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n        ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n    }\n\n    return databases_stats\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.delete_database","title":"<code>delete_database(delete_database)</code>","text":"<p>Deletes a database.</p> <p>Parameters:</p> Name Type Description Default <code>delete_database</code> <code>ArkDPADBDeleteDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n    \"\"\"\n    Deletes a database.\n\n    Args:\n        delete_database (ArkDPADBDeleteDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_database.name and not delete_database.id:\n        delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n    self._logger.info(f'Deleting database [{delete_database.id}]')\n    resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.list_databases","title":"<code>list_databases()</code>","text":"<p>Lists all databases.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    Lists all databases.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info('Listing all databases')\n    return self.__list_databases_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.list_databases_by","title":"<code>list_databases_by(databases_filter)</code>","text":"<p>Lists databases that match the specified filters.</p> <p>Parameters:</p> Name Type Description Default <code>databases_filter</code> <code>ArkDPADBDatabasesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    Lists databases that match the specified filters.\n\n    Args:\n        databases_filter (ArkDPADBDatabasesFilter): _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info(f'Listing databases by filters [{databases_filter}]')\n    databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n    if databases_filter.name:\n        databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n    if databases_filter.provider_engine:\n        databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n    if databases_filter.provider_workspace:\n        databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n    if databases_filter.db_warnings_filter:\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoCertificates,\n        ):\n            databases.items = [d for d in databases.items if not d.certificate]\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoSecrets,\n        ):\n            databases.items = [d for d in databases.items if not d.secret_id]\n    databases.total_count = len(databases.items)\n    return databases\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.update_database","title":"<code>update_database(update_database)</code>","text":"<p>Updates a database.</p> <p>Parameters:</p> Name Type Description Default <code>update_database</code> <code>ArkDPADBUpdateDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Updates a database.\n\n    Args:\n        update_database (ArkDPADBUpdateDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if update_database.name and not update_database.id:\n        update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n    self._logger.info(f'Updating database [{update_database.id}]')\n    update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_database.new_name:\n        update_database_dict[\"name\"] = update_database.new_name\n    resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return self.database(ArkDPADBGetDatabase(id=update_database.id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/sm/","title":"sm","text":""},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService","title":"<code>ArkSMService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>class ArkSMService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'sessionmonitoring')\n\n    @validate_arguments\n    def __search_params_from_filter(self, sessions_filter: ArkSMSessionsFilter):\n        return {'search': sessions_filter.search}\n\n    @validate_arguments\n    def __call_sessions_api(self, params: Optional[dict] = None) -&gt; ArkSMSessions:\n        params_dict = {}\n        if params:\n            params_dict['params'] = params\n        resp = self.__client.get(SESSIONS_API_URL, **params_dict)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}] {params=}')\n        return ArkSMSessions.parse_obj(resp.json())\n\n    @validate_arguments\n    def __call_activities_api(self, session_id: str, params: Optional[dict] = None) -&gt; ArkSMSessionActivities:\n        endpoint = SESSION_ACTIVITIES_API_URL.format(session_id=session_id)\n        resp = self.__client.get(endpoint, params=params)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list activities [{resp.text}]')\n        return ArkSMSessionActivities.parse_obj(resp.json())\n\n    @validate_arguments\n    def __list_sessions(self, params: Optional[Dict] = None) -&gt; Iterator[ArkSMPage]:\n        params = params or {}\n        sessions: ArkSMSessions = self.__call_sessions_api(params)\n        offset = 0\n        while sessions.returned_count &gt; 0:\n            yield ArkSMPage(items=sessions.sessions)\n            offset += sessions.returned_count\n            params['offset'] = offset\n            sessions = self.__call_sessions_api(params)\n\n    @validate_arguments\n    def __list_activities(self, session_id: str, params: Optional[Dict] = None) -&gt; Iterator[ArkSMActivitiesPage]:\n        params = params or {}\n        activities: ArkSMSessionActivities = self.__call_activities_api(session_id=session_id, params=params)\n        offset = 0\n        while activities.returned_count &gt; 0:\n            yield ArkSMActivitiesPage(items=activities.activities)\n            offset += activities.returned_count\n            params['offset'] = offset\n            activities = self.__call_activities_api(session_id=session_id, params=params)\n\n    def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions done on the last 24 hours\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all session')\n        yield from self.__list_sessions()\n\n    def count_sessions(self) -&gt; int:\n        \"\"\"\n        Counts all sessions done on the last 24 hours\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api().filtered_count\n\n    def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info('Listing sessions by filter', search=sessions_filter.search)\n        yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n\n    def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n        \"\"\"\n        Counts all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n\n    def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n        \"\"\"\n        Retrieves a session by id\n\n        Args:\n            get_session (ArkSMGetSession): _description_\n\n        Raises:\n            ArkServiceException: _description_\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSMSession: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n        resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n        session = resp.json()\n        if len(session) == 0:\n            raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n        return ArkSMSession.parse_obj(session)\n\n    def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n        yield from self.__list_activities(session_id=get_session_activities.session_id)\n\n    def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n        \"\"\"\n        Count all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n        return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n\n    def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n        for page in self.__list_activities(session_id=session_activities_filter.session_id):\n            yield ArkSMActivitiesPage(\n                items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n            )\n\n    def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n        \"\"\"\n        Count all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        count = 0\n        self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n        for page in self.list_session_activities_by(session_activities_filter):\n            count += len(page.items)\n        return count\n\n    def sessions_stats(self) -&gt; ArkSMSessionsStats:\n        \"\"\"\n        Returns statistics about the sessions in the last 30 days\n\n        Returns:\n            ArkSMSessionsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating sessions stats for the last 30 days')\n        start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n        sessions = list(\n            itertools.chain.from_iterable(\n                [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n            )\n        )\n        sessions_stats = ArkSMSessionsStats.construct()\n        sessions_stats.sessions_count = len(sessions)\n        sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n        # Get sessions per application code\n        app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n        sessions_stats.sessions_count_per_application_code = {\n            ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n        }\n\n        # Get sessions per platform\n        platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n        sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n        # Get sessions per protocol\n        protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n        sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n        # Get sessions per status\n        statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n        sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n        return sessions_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_session_activities","title":"<code>count_session_activities(get_session_activities)</code>","text":"<p>Count all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n    \"\"\"\n    Count all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n    return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_session_activities_by","title":"<code>count_session_activities_by(session_activities_filter)</code>","text":"<p>Count all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n    \"\"\"\n    Count all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    count = 0\n    self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n    for page in self.list_session_activities_by(session_activities_filter):\n        count += len(page.items)\n    return count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_sessions","title":"<code>count_sessions()</code>","text":"<p>Counts all sessions done on the last 24 hours</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions(self) -&gt; int:\n    \"\"\"\n    Counts all sessions done on the last 24 hours\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api().filtered_count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.count_sessions_by","title":"<code>count_sessions_by(sessions_filter)</code>","text":"<p>Counts all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n    \"\"\"\n    Counts all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_session_activities","title":"<code>list_session_activities(get_session_activities)</code>","text":"<p>Lists all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n    yield from self.__list_activities(session_id=get_session_activities.session_id)\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_session_activities_by","title":"<code>list_session_activities_by(session_activities_filter)</code>","text":"<p>Lists all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n    for page in self.__list_activities(session_id=session_activities_filter.session_id):\n        yield ArkSMActivitiesPage(\n            items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n        )\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_sessions","title":"<code>list_sessions()</code>","text":"<p>Lists all sessions done on the last 24 hours</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions done on the last 24 hours\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all session')\n    yield from self.__list_sessions()\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.list_sessions_by","title":"<code>list_sessions_by(sessions_filter)</code>","text":"<p>Lists all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info('Listing sessions by filter', search=sessions_filter.search)\n    yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.session","title":"<code>session(get_session)</code>","text":"<p>Retrieves a session by id</p> <p>Parameters:</p> Name Type Description Default <code>get_session</code> <code>ArkSMGetSession</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSMSession</code> <code>ArkSMSession</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n    \"\"\"\n    Retrieves a session by id\n\n    Args:\n        get_session (ArkSMGetSession): _description_\n\n    Raises:\n        ArkServiceException: _description_\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSMSession: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n    resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n    session = resp.json()\n    if len(session) == 0:\n        raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n    return ArkSMSession.parse_obj(session)\n</code></pre>"},{"location":"reference/services/sm/#ark_sdk_python.services.sm.ArkSMService.sessions_stats","title":"<code>sessions_stats()</code>","text":"<p>Returns statistics about the sessions in the last 30 days</p> <p>Returns:</p> Name Type Description <code>ArkSMSessionsStats</code> <code>ArkSMSessionsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def sessions_stats(self) -&gt; ArkSMSessionsStats:\n    \"\"\"\n    Returns statistics about the sessions in the last 30 days\n\n    Returns:\n        ArkSMSessionsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating sessions stats for the last 30 days')\n    start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n    sessions = list(\n        itertools.chain.from_iterable(\n            [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n        )\n    )\n    sessions_stats = ArkSMSessionsStats.construct()\n    sessions_stats.sessions_count = len(sessions)\n    sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n    # Get sessions per application code\n    app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n    sessions_stats.sessions_count_per_application_code = {\n        ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n    }\n\n    # Get sessions per platform\n    platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n    sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n    # Get sessions per protocol\n    protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n    sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n    # Get sessions per status\n    statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n    sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n    return sessions_stats\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/","title":"ark_sm_service","text":""},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService","title":"<code>ArkSMService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>class ArkSMService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'sessionmonitoring')\n\n    @validate_arguments\n    def __search_params_from_filter(self, sessions_filter: ArkSMSessionsFilter):\n        return {'search': sessions_filter.search}\n\n    @validate_arguments\n    def __call_sessions_api(self, params: Optional[dict] = None) -&gt; ArkSMSessions:\n        params_dict = {}\n        if params:\n            params_dict['params'] = params\n        resp = self.__client.get(SESSIONS_API_URL, **params_dict)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}] {params=}')\n        return ArkSMSessions.parse_obj(resp.json())\n\n    @validate_arguments\n    def __call_activities_api(self, session_id: str, params: Optional[dict] = None) -&gt; ArkSMSessionActivities:\n        endpoint = SESSION_ACTIVITIES_API_URL.format(session_id=session_id)\n        resp = self.__client.get(endpoint, params=params)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list activities [{resp.text}]')\n        return ArkSMSessionActivities.parse_obj(resp.json())\n\n    @validate_arguments\n    def __list_sessions(self, params: Optional[Dict] = None) -&gt; Iterator[ArkSMPage]:\n        params = params or {}\n        sessions: ArkSMSessions = self.__call_sessions_api(params)\n        offset = 0\n        while sessions.returned_count &gt; 0:\n            yield ArkSMPage(items=sessions.sessions)\n            offset += sessions.returned_count\n            params['offset'] = offset\n            sessions = self.__call_sessions_api(params)\n\n    @validate_arguments\n    def __list_activities(self, session_id: str, params: Optional[Dict] = None) -&gt; Iterator[ArkSMActivitiesPage]:\n        params = params or {}\n        activities: ArkSMSessionActivities = self.__call_activities_api(session_id=session_id, params=params)\n        offset = 0\n        while activities.returned_count &gt; 0:\n            yield ArkSMActivitiesPage(items=activities.activities)\n            offset += activities.returned_count\n            params['offset'] = offset\n            activities = self.__call_activities_api(session_id=session_id, params=params)\n\n    def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions done on the last 24 hours\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info('Listing all session')\n        yield from self.__list_sessions()\n\n    def count_sessions(self) -&gt; int:\n        \"\"\"\n        Counts all sessions done on the last 24 hours\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api().filtered_count\n\n    def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n        \"\"\"\n        Lists all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Raises:\n            ArkServiceException: _description_\n\n        Yields:\n            Iterator[ArkSMPage]: _description_\n        \"\"\"\n        self._logger.info('Listing sessions by filter', search=sessions_filter.search)\n        yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n\n    def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n        \"\"\"\n        Counts all sessions with given filter\n\n        Args:\n            sessions_filter (ArkSMSessionsFilter): _description_\n        Examples:\n            ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n            ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n            ArkSMSessionsFilter(search='command STARTSWITH ls')\n            ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n\n    def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n        \"\"\"\n        Retrieves a session by id\n\n        Args:\n            get_session (ArkSMGetSession): _description_\n\n        Raises:\n            ArkServiceException: _description_\n            ArkServiceException: _description_\n\n        Returns:\n            ArkSMSession: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n        resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n        session = resp.json()\n        if len(session) == 0:\n            raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n        return ArkSMSession.parse_obj(session)\n\n    def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n        yield from self.__list_activities(session_id=get_session_activities.session_id)\n\n    def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n        \"\"\"\n        Count all session activities by session id\n\n        Args:\n            get_session_activities (ArkSMGetSessionActivities): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n        return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n\n    def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n        \"\"\"\n        Lists all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Yields:\n            Iterator[ArkSMActivitiesPage]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n        for page in self.__list_activities(session_id=session_activities_filter.session_id):\n            yield ArkSMActivitiesPage(\n                items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n            )\n\n    def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n        \"\"\"\n        Count all session activities for session id by filter\n\n        Args:\n            session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n        Returns:\n            int: _description_\n        \"\"\"\n        count = 0\n        self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n        for page in self.list_session_activities_by(session_activities_filter):\n            count += len(page.items)\n        return count\n\n    def sessions_stats(self) -&gt; ArkSMSessionsStats:\n        \"\"\"\n        Returns statistics about the sessions in the last 30 days\n\n        Returns:\n            ArkSMSessionsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating sessions stats for the last 30 days')\n        start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n        sessions = list(\n            itertools.chain.from_iterable(\n                [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n            )\n        )\n        sessions_stats = ArkSMSessionsStats.construct()\n        sessions_stats.sessions_count = len(sessions)\n        sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n        # Get sessions per application code\n        app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n        sessions_stats.sessions_count_per_application_code = {\n            ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n        }\n\n        # Get sessions per platform\n        platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n        sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n        # Get sessions per protocol\n        protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n        sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n        # Get sessions per status\n        statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n        sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n        return sessions_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_session_activities","title":"<code>count_session_activities(get_session_activities)</code>","text":"<p>Count all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; int:\n    \"\"\"\n    Count all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    self._logger.info(f'Counting session activities by id [{get_session_activities.session_id}]')\n    return self.__call_activities_api(session_id=get_session_activities.session_id).filtered_count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_session_activities_by","title":"<code>count_session_activities_by(session_activities_filter)</code>","text":"<p>Count all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; int:\n    \"\"\"\n    Count all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Returns:\n        int: _description_\n    \"\"\"\n    count = 0\n    self._logger.info(f'Counting session activities by id [{session_activities_filter.session_id}] and filter')\n    for page in self.list_session_activities_by(session_activities_filter):\n        count += len(page.items)\n    return count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_sessions","title":"<code>count_sessions()</code>","text":"<p>Counts all sessions done on the last 24 hours</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions(self) -&gt; int:\n    \"\"\"\n    Counts all sessions done on the last 24 hours\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api().filtered_count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.count_sessions_by","title":"<code>count_sessions_by(sessions_filter)</code>","text":"<p>Counts all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def count_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; int:\n    \"\"\"\n    Counts all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.__call_sessions_api(self.__search_params_from_filter(sessions_filter)).filtered_count\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_session_activities","title":"<code>list_session_activities(get_session_activities)</code>","text":"<p>Lists all session activities by session id</p> <p>Parameters:</p> Name Type Description Default <code>get_session_activities</code> <code>ArkSMGetSessionActivities</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities(self, get_session_activities: ArkSMGetSessionActivities) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities by session id\n\n    Args:\n        get_session_activities (ArkSMGetSessionActivities): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{get_session_activities.session_id}]')\n    yield from self.__list_activities(session_id=get_session_activities.session_id)\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_session_activities_by","title":"<code>list_session_activities_by(session_activities_filter)</code>","text":"<p>Lists all session activities for session id by filter</p> <p>Parameters:</p> Name Type Description Default <code>session_activities_filter</code> <code>ArkSMSessionActivitiesFilter</code> <p>description</p> required <p>Yields:</p> Type Description <code>ArkSMActivitiesPage</code> <p>Iterator[ArkSMActivitiesPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_session_activities_by(self, session_activities_filter: ArkSMSessionActivitiesFilter) -&gt; Iterator[ArkSMActivitiesPage]:\n    \"\"\"\n    Lists all session activities for session id by filter\n\n    Args:\n        session_activities_filter (ArkSMSessionActivitiesFilter): _description_\n\n    Yields:\n        Iterator[ArkSMActivitiesPage]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session activities by id [{session_activities_filter.session_id}]')\n    for page in self.__list_activities(session_id=session_activities_filter.session_id):\n        yield ArkSMActivitiesPage(\n            items=[activity for activity in page.items if session_activities_filter.command_contains in activity.command]\n        )\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_sessions","title":"<code>list_sessions()</code>","text":"<p>Lists all sessions done on the last 24 hours</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions(self) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions done on the last 24 hours\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info('Listing all session')\n    yield from self.__list_sessions()\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.list_sessions_by","title":"<code>list_sessions_by(sessions_filter)</code>","text":"<p>Lists all sessions with given filter</p> <p>Parameters:</p> Name Type Description Default <code>sessions_filter</code> <code>ArkSMSessionsFilter</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Yields:</p> Type Description <code>ArkSMPage</code> <p>Iterator[ArkSMPage]: description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def list_sessions_by(self, sessions_filter: ArkSMSessionsFilter) -&gt; Iterator[ArkSMPage]:\n    \"\"\"\n    Lists all sessions with given filter\n\n    Args:\n        sessions_filter (ArkSMSessionsFilter): _description_\n    Examples:\n        ArkSMSessionsFilter(search='startTime GE 2023-12-03T08:55:29Z AND sessionDuration GE 00:00:01')\n        ArkSMSessionsFilter(search='sessionStatus IN Failed,Ended AND endReason STARTSWITH Err008')\n        ArkSMSessionsFilter(search='command STARTSWITH ls')\n        ArkSMSessionsFilter(search='protocol IN SSH,RDP,Database')\n\n    Raises:\n        ArkServiceException: _description_\n\n    Yields:\n        Iterator[ArkSMPage]: _description_\n    \"\"\"\n    self._logger.info('Listing sessions by filter', search=sessions_filter.search)\n    yield from self.__list_sessions(self.__search_params_from_filter(sessions_filter))\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.session","title":"<code>session(get_session)</code>","text":"<p>Retrieves a session by id</p> <p>Parameters:</p> Name Type Description Default <code>get_session</code> <code>ArkSMGetSession</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkSMSession</code> <code>ArkSMSession</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def session(self, get_session: ArkSMGetSession) -&gt; ArkSMSession:\n    \"\"\"\n    Retrieves a session by id\n\n    Args:\n        get_session (ArkSMGetSession): _description_\n\n    Raises:\n        ArkServiceException: _description_\n        ArkServiceException: _description_\n\n    Returns:\n        ArkSMSession: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving session by id [{get_session.session_id}]')\n    resp = self.__client.get(SESSION_API_URL.format(session_id=get_session.session_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list sessions [{resp.text}]')\n    session = resp.json()\n    if len(session) == 0:\n        raise ArkServiceException(f'No session found for requested session id [{get_session.session_id}]')\n    return ArkSMSession.parse_obj(session)\n</code></pre>"},{"location":"reference/services/sm/ark_sm_service/#ark_sdk_python.services.sm.ark_sm_service.ArkSMService.sessions_stats","title":"<code>sessions_stats()</code>","text":"<p>Returns statistics about the sessions in the last 30 days</p> <p>Returns:</p> Name Type Description <code>ArkSMSessionsStats</code> <code>ArkSMSessionsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/sm/ark_sm_service.py</code> <pre><code>def sessions_stats(self) -&gt; ArkSMSessionsStats:\n    \"\"\"\n    Returns statistics about the sessions in the last 30 days\n\n    Returns:\n        ArkSMSessionsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating sessions stats for the last 30 days')\n    start_time_from = (datetime.now() - timedelta(days=30)).isoformat(timespec='seconds') + 'Z'\n    sessions = list(\n        itertools.chain.from_iterable(\n            [p.items for p in self.list_sessions_by(ArkSMSessionsFilter(search=f'startTime ge {start_time_from}'))]\n        )\n    )\n    sessions_stats = ArkSMSessionsStats.construct()\n    sessions_stats.sessions_count = len(sessions)\n    sessions_stats.sessions_failure_count = len([s for s in sessions if s.session_status == ArkSMSessionStatus.FAILED])\n\n    # Get sessions per application code\n    app_codes: Set[ArkApplicationCode] = {s.application_code for s in sessions}\n    sessions_stats.sessions_count_per_application_code = {\n        ac: len([s for s in sessions if s.application_code == ac]) for ac in app_codes\n    }\n\n    # Get sessions per platform\n    platforms: Set[ArkWorkspaceType] = {s.platform for s in sessions}\n    sessions_stats.sessions_count_per_platform = {p: len([s for s in sessions if s.platform == p]) for p in platforms}\n\n    # Get sessions per protocol\n    protocols: Set[ArkProtocolType] = {s.protocol for s in sessions}\n    sessions_stats.sessions_count_per_protocol = {p: len([s for s in sessions if s.protocol == p]) for p in protocols}\n\n    # Get sessions per status\n    statuses: Set[ArkSMSessionStatus] = {s.session_status for s in sessions}\n    sessions_stats.sessions_count_per_status = {st: len([s for s in sessions if s.session_status == st]) for st in statuses}\n\n    return sessions_stats\n</code></pre>"},{"location":"sdk/async_requests/","title":"Async requests","text":"<p>To support async requests, relevant methods return an ArkAsyncRequest type with the following interfaces:</p> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request is finished or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request failed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request has timed out\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls for the async request until it is finished\n    Progress callbacks may also be used to be notified whats the async request status\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre> <p>You can call these methods for polling the service to check the request's status. </p> <p>Async requests also inherits the ArkPollableModel type, which contains information about whether or not to poll the request and how long to wait until the request times out. Additionally, when the request's authenticator can be refreshed, it is refreshed during the polling cycle.</p>"},{"location":"sdk/async_requests/#predefined-pollers","title":"Predefined pollers","text":"<p>These predefined pollers can be used (see ark_pollers.py):</p> <ul> <li>default_poller (default console logger polling)</li> <li>line_spinner_poller</li> <li>pixel_spinner_poller</li> <li>moon_spinner_poller</li> <li>spinner_poller</li> <li>pie_spinner_poller</li> </ul>"},{"location":"sdk/authenticators/","title":"Authenticators","text":"<p>An authenticator provides the ability to authenticate to a CyberArk Identity Security Platform (ISP) resource. The authentication is based on authentication profiles, where the authentication profile defines the authentication method and its associated settings.</p> <p>Here's an example of initialize an authenticator:</p> <pre><code>from ark_sdk_python.auth import ArkISPAuth\n\nauth = ArkISPAuth(cache_authentication=False)\n</code></pre> <p>Note</p> <p>When you call the constructor, you can determine whether or not the authentication credentials are cached.</p> <p>The Authenticators have a base authenticate method that receives a profile as an input and returns an auth token. Additionally, the ArkISPAuth class exposes functions to retrieve a profile's authentication methods and settings. Although the returned token can be used as a return value, it can normally be ignored as it is saved internally.</p> <p>These are the different types of authenticator types and auth methods:</p>"},{"location":"sdk/authenticators/#authenticator-types","title":"Authenticator types","text":"<p>Currently, ArkISPAuth is the only supported authenticator type, which is derived from the ArkISPAuth class and accepts the <code>Identity</code> (default) and <code>IdentityServiceUser</code> auth methods.</p>"},{"location":"sdk/authenticators/#auth-methods","title":"Auth methods","text":"<ul> <li>Identity (<code>identity</code>) - Identity authentication to a tenant or to an application within the Identity tenant, used with the IdentityArkAuthMethodSettings class</li> <li>IdentityServiceUser (<code>identity_service_user</code>) - Identity authentication with a service user, used with IdentityServiceUserArkAuthMethodSettings class</li> <li>Direct (<code>direct</code>) - Direct authentication to an endpoint, used with the DirectArkAuthMethodSettings class</li> <li>Default (<code>default</code>) - Default authenticator auth method for the authenticator</li> <li>Other (<code>other</code>) - For custom implementations</li> </ul> <p>See ark_auth_method.py for more information about auth methods.</p>"},{"location":"sdk/authenticators/#sdk-authenticate-example","title":"SDK authenticate example","text":"<p>Here is an example authentication flow that uses implements the ArkISPAuth class:</p> <pre><code>from ark_sdk_python.auth import ArkISPAuth\n\nisp_auth = ArkISPAuth(cache_authentication=False)\nisp_auth.authenticate(\n    auth_profile=ArkAuthProfile(\n        username='smarom@cyberark.cloud.84573',\n        auth_method=ArkAuthMethod.Identity,\n        auth_method_settings=IdentityArkAuthMethodSettings(),\n    ),\n    secret=ArkSecret(secret=\"CoolPassword\"),\n)\ndpa_api = ArkDPAAPI(isp_auth=isp_auth)\n</code></pre> <p>The example above initializes an instance of the ArkISPAuth class and authenticates to the specified ISP tenant, using the <code>Identity</code> authentication type with the provided username and password.</p> <p>The <code>authenticate</code> method returns a token, which be ignored because it is stored internally.</p> <p>After authenticating, the authenticator can be used passed to the services you want to access.</p>"},{"location":"sdk/pagination/","title":"Pagination","text":"<p>When a response returns many items or is paginated, the response contains an page iterator instead of all the items. This ensures fast response times and the ability to just retrieve a required subset of items.</p> <p>Responses that do return paginated results contain an item iterator.</p>"},{"location":"sdk/schemas/","title":"Schemas","text":"<p>Ark SDK is entirely based on schemas constructed from Pydantic. Pydantic is a schema and data validation library that also provides settings management and uses Python type annotations.</p> <p>All <code>exec</code> actions in the Ark SDK receive a model parsed from the CLI or from the SDK in code and, some of them, return a model or set of models. All of these models inherit from ArkModel:</p> <pre><code>class ArkModel(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n</code></pre> <p>Derived from the model above, there are different model types that serve different purposes, such as aliasing attributes with camelCase and adding polling parameters.</p>"},{"location":"sdk/schemas/#example","title":"Example","text":"<p>Any request can be called with a defined model, for example:</p> <pre><code>policies_service = ArkDPADBPoliciesService(isp_auth)\npolicies = policies_service.list_policies()\n</code></pre> <p>The above example creates a DB policies service and calls <code>list_policies()</code> to retrieve a list of all tenant DB polices. The returned list items contain <code>policy_id</code> and <code>policy_name</code> fields, which can be used with the ArkDPAGetPolicy model:</p> <pre><code>class ArkDPAGetPolicy(ArkModel):\n    policy_id: Optional[str] = Field(description='Policy id to get')\n    policy_name: Optional[str] = Field(description='Policy name to get')\n</code></pre> <p>All models can be found here and are separated to folders based on topic, from auth to services</p>"},{"location":"sdk/services/","title":"Services","text":"<p>SDK services are defined to execute requests on available ISP services (such as DPA). When a service is initialized, a valid authenticator is required to authorize access to the ISP service. To perform service actions, each service exposes a set of classes and methods.</p> <p>Here's an example that initializes the <code>ArkDPADBPoliciesService</code> service:</p> <pre><code>import pprint\n\nfrom ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.auth import ArkAuthMethod, ArkAuthProfile, ArkSecret, IdentityArkAuthMethodSettings\nfrom ark_sdk_python.services.dpa.policies import ArkDPAPoliciesService\n\nif __name__ == '__main__':\n    isp_auth = ArkISPAuth(cache_authentication=False)\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='tina@cyberark.cloud.12345',\n            auth_method=ArkAuthMethod.Identity,\n            auth_method_settings=IdentityArkAuthMethodSettings(),\n        ),\n        secret=ArkSecret(secret=\"CoolPassword\"),\n    )\n    policies_service = ArkDPADBPoliciesService(isp_auth=isp_auth)\n    policies = policies_service.list_policies()\n    for policy in policies:\n        pprint.pprint(policy.json(indent=4))\n</code></pre> <p>The above example authenticates to the specified ISP tenant, initializes a DPA policies service using the authorized authenticator, and then uses the service to list the policies.</p>"},{"location":"sdk/services/#dynamic-privilege-access-service","title":"Dynamic Privilege Access service","text":"<p>The Dynamic Privilege Access (DPA) service requires the ArkISPAuth authenticator, and exposes these service classes:</p> <ul> <li>ArkDPACertificatesService (certificates) - DPA certificates service</li> <li>ArkDPASSOService (sso) - DPA end-user SSO service</li> <li>ArkDPAK8SService (kubernetes) - DPA end-user Kubernetes service</li> <li>ArkDPADatabasesService (databases) - DPA end-user databases service</li> <li>ArkDPAPoliciesService (policies) - DPA policies management<ul> <li>ArkDPADBPoliciesService (db) - DPA DB policies management<ul> <li>ArkDPADBPoliciesEditorService (editor) - DPA DB policies interactive</li> </ul> </li> <li>ArkDPAVMPoliciesService (vm) - DPA VM policies management<ul> <li>ArkDPAVMPoliciesEditorService (editor) - DPA VM policies interactive</li> </ul> </li> </ul> </li> <li>ArkDPASecretsService (secrets) - DPA secrets management<ul> <li>ArkDPADBSecretsService (db) - DPA DB secrets services</li> </ul> </li> <li>ArkDPAWorkspacesService (workspaces) - DPA workspaces management<ul> <li>ArkDPADBWorkspaceService (db) - DPA DB workspace management</li> </ul> </li> </ul>"},{"location":"sdk/services/#session-monitoring-service","title":"Session monitoring service","text":"<p>The Session Monitoring (SM) service requires ArkISPAuth authenticator, and exposes these service classes: - ArkSMService (sm) - Session Monitoring Service</p>"}]}