{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ark SDK","text":"<p>CyberArk's Official SDK and CLI for different services operations written in python</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Ark SDK is an API first library, widely used to automate different set of operations in order to ease day to day development</p> <p>It is used both as a CLI, for a general purpose automation and human access, and code via the SDK in python, to further enhance capabilities of automation</p>"},{"location":"#tldr","title":"TL;DR","text":""},{"location":"#enduser","title":"Enduser","text":""},{"location":"#admin","title":"Admin","text":""},{"location":"#license","title":"License","text":"<p>This project is licensed under Apache License 2.0 - see <code>LICENSE</code> for more details</p> <p>Copyright (c) 2023 CyberArk Software Ltd. All rights reserved.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>The design of the library is as follows:</p> <p></p>"},{"location":"architecture/#design-perspectives","title":"Design Perspectives","text":"<p>We define the main entities as follows:</p> <ul> <li>Profile - A profile defines a set of properties and information about the authentication methods of the user, the profile is saved on the filesystem to be used for consecutive actions</li> <li>Authenticators - An integration with some authentication method, in order to be able to interact with a service in an authenticated manner, an authentication method can be one of the following or custom implemented:<ul> <li>Identity (User / Service User)</li> </ul> </li> <li>Services - The actual service that gives some capabilities, and requires one or more authenticators in order to perform actions, such service can be for example the audit service, exposing different api's of the audit service in an authenticated manner</li> <li>Services Model Schemes - Each service also exposes different models and structures to be able to work with the service actions</li> <li>CLI Actions - All of the above defines the layers for the SDK, on top of that, the CLI actions gives a layer of interaction with the user via his shell, for the following actions:<ul> <li>configure - Configures a profile with all the details</li> <li>login - Logins to the profile authenticators, with fitting required passwords etc, the logged in details are stored on the machine in a secure manner for consecutive actions</li> <li>exec - Executes different services actions</li> </ul> </li> </ul>"},{"location":"architecture/#typical-flow","title":"Typical Flow","text":"<p>A typical workflow would be to define a profile using the configure command, an then login to the profile authenticators.</p> <p>Once logged in, execute actions based on the logged in authenticators</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>One can install the SDK via the community pypi with the following command: <pre><code>pip3 install ark-sdk-python\n</code></pre></p>"},{"location":"getting_started/#cli-usage","title":"CLI Usage","text":"<p>Both the SDK and the CLI works with profiles</p> <p>The profiles can be configured upon need and be used for the consecutive actions</p> <p>The CLI has the following basic commands:</p> <ul> <li>configure - Configures profiles and their respective authentication methods</li> <li>login - Logs into the profile authentication methods</li> <li>exec - Executes different commands based on the supported services</li> <li>profiles - Manage multiple profiles on the machine</li> <li>cache - Manage ark cache on the machine</li> </ul>"},{"location":"getting_started/#tldr-basic-flow","title":"TL;DR - Basic flow","text":"<p>A basic flow for an end user would look something as follows</p> <p>The user, after installing ark-sdk, would first configure a profile, interactively or silently</p> <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre> <p>Once configured, he can login <pre><code>ark login --silent --isp-secret mysecret\n</code></pre></p> <p>Now that the user is logged in, he may execute actions, one of them being generating a short lived sso password <pre><code>ark exec dpa sso short-lived-password\n</code></pre></p>"},{"location":"license/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <pre><code> APPENDIX: How to apply the Apache License to your work.\n\n  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"{}\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright \u00a9 2023 CyberArk Software Ltd</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"commands/cache/","title":"Cache","text":""},{"location":"commands/cache/#motivation","title":"Motivation","text":"<p>As the CLI is mostly managed in a cached fashion, we can use the ark cache command in order to clear / control the cache</p> <p>Right now, only clearing the entire cache is supported and only for local filesystem cache type</p>"},{"location":"commands/cache/#running","title":"Running","text":"<pre><code>ark cache\n</code></pre>"},{"location":"commands/cache/#usage","title":"Usage","text":"<pre><code>usage: ark cache [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}] [-dcv] [-tc TRUSTED_CERT] {clear} ...\n\npositional arguments:\n  {clear}\n    clear               Clears all profiles cache\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n</code></pre>"},{"location":"commands/configure/","title":"Configure","text":""},{"location":"commands/configure/#motivation","title":"Motivation","text":"<p>The configure command is used to create a profile to work on The profile consists of infomration regarding which authentication methods to use and what are their method settings, along with other related information such as MFA</p>"},{"location":"commands/configure/#running","title":"Running","text":"<pre><code>ark configure\n</code></pre> <p>The profiles are saved to ~/.ark_profiles</p> <p>No arguments are required, and interactive questions will be asked</p> <p>If you wish to only supply arguments in a silent fashion, --silent can be added along with the arugments</p>"},{"location":"commands/configure/#usage","title":"Usage","text":"<pre><code>usage: ark configure [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                     [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-pd PROFILE_DESCRIPTION] [-wwis]\n                     [-isam {identity,identity_service_user}] [-iu ISP_USERNAME]\n                     [-iimm {pf,sms,email,otp}] [-iiu ISP_IDENTITY_URL]\n                     [-iiaa ISP_IDENTITY_AUTHORIZATION_APPLICATION]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name for storage\n  -pd PROFILE_DESCRIPTION, --profile-description PROFILE_DESCRIPTION\n                        Info about the profile\n  -wwis, --work-with-isp\n                        Whether to work with Identity Security Platform services\n  -isam {identity,identity_service_user}, --isp-auth-method {identity,identity_service_user}\n  -iu ISP_USERNAME, --isp-username ISP_USERNAME\n                        Username to authenticate with\n  -iimm {pf,sms,email,otp}, --isp-identity-mfa-method {pf,sms,email,otp}\n                        MFA method if mfa is needed\n  -iiu ISP_IDENTITY_URL, --isp-identity-url ISP_IDENTITY_URL\n                        Identity url to use for authentication instead of fqdn resolving\n  -iiaa ISP_IDENTITY_AUTHORIZATION_APPLICATION, --isp-identity-authorization-application ISP_IDENTITY_AUTHORIZATION_APPLICATION\n                        Identity application to authorize once logged in with the service user\n</code></pre>"},{"location":"commands/exec/","title":"Exec","text":""},{"location":"commands/exec/#motivation","title":"Motivation","text":"<p>The exec command is used to execute various commands based on supported services for the fitting logged in authenticators</p> <p>The following services and commands are supported:</p> <ul> <li>dpa - Dynamic Privilege Access Services<ul> <li>policies - DPA Policies Management<ul> <li>db - DPA DB Policies<ul> <li>editor - DPA DB Policies Interactive Editor</li> </ul> </li> <li>vm - DPA VM Policies<ul> <li>editor - DPA VM Policies Interactive Editor</li> </ul> </li> </ul> </li> <li>certificates - DPA Certificates Management</li> <li>db - DPA DB Enduser Operations</li> <li>sso - DPA SSO Enduser Operations</li> <li>secrets - DPA Secrets Services<ul> <li>db - DPA DB Secrets Service</li> </ul> </li> <li>workspaces - DPA Workspaces Management<ul> <li>db - DPA DB Workspace Management</li> </ul> </li> <li>k8s - DPA kubernetes service</li> </ul> </li> </ul> <p>Any command has its own subcommands, with respective arguments</p>"},{"location":"commands/exec/#running","title":"Running","text":"<pre><code>ark exec\n</code></pre>"},{"location":"commands/exec/#usage","title":"Usage","text":"<pre><code>usage: ark exec [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-op OUTPUT_PATH] [-rf REQUEST_FILE]\n                [-rc RETRY_COUNT] [-ra]\n                {dpa} ...\n\npositional arguments:\n  {dpa}\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name to load\n  -op OUTPUT_PATH, --output-path OUTPUT_PATH\n                        Output file to write data to\n  -rf REQUEST_FILE, --request-file REQUEST_FILE\n                        Request file containing the parameters for the exec action\n  -rc RETRY_COUNT, --retry-count RETRY_COUNT\n                        Retry count for execution\n  -ra, --refresh-auth   If possible, will try to refresh the active authentication before running the\n                        actual command\n</code></pre>"},{"location":"commands/login/","title":"Login","text":""},{"location":"commands/login/#motivation","title":"Motivation","text":"<p>The login command is used to login to the authentication methods configured for the profile</p> <p>You will be asked to write a password for each respective authentication method that supports password, and alongside that, any needed MFA prompt</p> <p>Once the login is done, the access tokens are stored on the computer keystore for their lifetime</p> <p>Once they are expired, a consecutive login will be required</p>"},{"location":"commands/login/#running","title":"Running","text":"<pre><code>ark login\n</code></pre>"},{"location":"commands/login/#usage","title":"Usage","text":"<pre><code>usage: ark login [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}]\n                 [-dcv] [-tc TRUSTED_CERT] [-pn PROFILE_NAME] [-f] [-nss] [-st] [-ra]\n                 [-isu ISP_USERNAME] [-iss ISP_SECRET]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n  -pn PROFILE_NAME, --profile-name PROFILE_NAME\n                        Profile name to load\n  -f, --force           Whether to force login even thou token has not expired yet\n  -nss, --no-shared-secrets\n                        Do not share secrets between different authenticators with the\n                        same username\n  -st, --show-tokens    Print out tokens as well if not silent\n  -ra, --refresh-auth   If a cache exists, will also try to refresh it\n  -isu ISP_USERNAME, --isp-username ISP_USERNAME\n                        Username to authenticate with to Identity Security Platform\n  -iss ISP_SECRET, --isp-secret ISP_SECRET\n                        Secret to authenticate with to Identity Security Platform\n</code></pre>"},{"location":"commands/profiles/","title":"Profiles","text":""},{"location":"commands/profiles/#motivation","title":"Motivation","text":"<p>As one may have multiple environments to manage, this would also imply that multiple profiles are required, either for multiple users in the same environment or multiple tenants</p> <p>Therefore, the profiles command manages those profiles as a convenice set of methods</p>"},{"location":"commands/profiles/#running","title":"Running","text":"<pre><code>ark profiles\n</code></pre>"},{"location":"commands/profiles/#usage","title":"Usage","text":"<pre><code>usage: ark profiles [-h] [-r] [-s] [-ao] [-v] [-ls {default}] [-ll {DEBUG,INFO,WARN,ERROR,CRITICAL}] [-dcv] [-tc TRUSTED_CERT]\n                    {list,show,delete,clear,clone,add} ...\n\npositional arguments:\n  {list,show,delete,clear,clone,add}\n    list                List all profiles\n    show                Show a profile\n    delete              Delete a specific profile\n    clear               Clear all profiles\n    clone               Clones a profile\n    add                 Adds a profile to the profiles folder from a given path\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -r, --raw             Whether to raw output\n  -s, --silent          Silent execution, no interactiveness\n  -ao, --allow-output   Allow stdout / stderr even when silent and not interactive\n  -v, --verbose         Whether to verbose log\n  -ls {default}, --logger-style {default}\n                        Which verbose logger style to use\n  -ll {DEBUG,INFO,WARN,ERROR,CRITICAL}, --log-level {DEBUG,INFO,WARN,ERROR,CRITICAL}\n                        Log level to use while verbose\n  -dcv, --disable-cert-verification\n                        Disables certificate verification on HTTPS calls, unsafe!\n  -tc TRUSTED_CERT, --trusted-cert TRUSTED_CERT\n                        Certificate to use for HTTPS calls\n</code></pre>"},{"location":"examples/commands_examples/","title":"Commands Examples","text":"<p>As a CLI user, there are many different actions that can be done under many different services</p>"},{"location":"examples/commands_examples/#configure-commands-examples","title":"Configure Commands Examples","text":"<p>The configure command can work interactive or silent, an example of configuring ISP in a silent fashion:</p> <pre><code>ark configure --profile-name=\"PROD\" --work-with-isp --isp-username=\"tina@cyberark.cloud.12345\" --silent --allow-output\n</code></pre>"},{"location":"examples/commands_examples/#login-commands-examples","title":"Login Commands Examples","text":"<p>The login command can work interactive or silent, example of logging in in a silent fashion to the above configure example: <pre><code>ark login -s --isp-secret=CoolPassword\n</code></pre></p>"},{"location":"examples/commands_examples/#exec-commands-examples","title":"Exec Commands Examples","text":"<p>Add DPA Database Secret <pre><code>ark exec dpa secrets db add-secret --secret-name mysecret --secret-type username_password --username user --password mypass\n</code></pre></p> <p>Delete DPA Database Secret <pre><code>ark exec dpa secrets db delete-secret --secret-name mysecret\n</code></pre></p> <p>Add DPA Database <pre><code>ark exec dpa workspaces db add-database --name mydb --provider-engine postgres-sh --read-write-endpoint myendpoint.domain.com\n</code></pre></p> <p>List DPA Databases <pre><code>ark exec dpa workspaces db list-databases\n</code></pre></p> <p>Get VM policies stats <pre><code>ark exec dpa policies vm policies-stats\n</code></pre></p> <p>Edit policies interactively</p> <p>This gives the ability to locally work with a policies workspace, and edit / reset / create policies, applied to both databases and vm policies</p> <p>When they are ready, once can commit all the policies changes to the remote</p> <p>Initially, the policies can be loaded and reloaded using</p> <pre><code>ark exec dpa policies vm editor load-policies\n</code></pre> <p>Once they are loaded locally, they can be edited using the following commands <pre><code>ark exec dpa policies vm editor edit-policies\nark exec dpa policies vm editor view-policies\nark exec dpa policies vm editor reset-policies\nark exec dpa policies vm editor generate-policy\nark exec dpa policies vm editor remove-policies\nark exec dpa policies vm editor policies diff\n</code></pre></p> <p>Evantually, they can be committed using <pre><code>ark exec dpa policies vm editor commit-policies\n</code></pre></p> <p>Generate a short lived SSO password for databases connection <pre><code>ark exec dpa sso short-lived-password\n</code></pre></p> <p>Generate a short lived SSO oracle wallet for oracle database connection <pre><code>ark exec dpa sso short-lived-oracle-wallet --folder ~/wallet\n</code></pre></p> <p>Generate kubectl config file  <pre><code>ark exec dpa k8s generate-kubeconfig \n</code></pre></p> <p>Generate kubectl config file and save on specific path <pre><code>ark exec dpa k8s generate-kubeconfig --folder=/Users/My.User/.kube\n</code></pre></p> <p>You can view all of the commands via the --help for each respective exec action</p> <p>Notes:</p> <ul> <li>You may disable certificate validation for login to different authenticators using the --disable-certificate-verification or supply a certificate to be used, not recommended to disable</li> </ul> <p>Useful Env Vars:</p> <ul> <li>ARK_PROFILE - Sets the profile to be used across the CLI</li> <li>ARK_DISABLE_CERTIFICATE_VERIFICATION - Disables certificate verification on REST API's</li> </ul>"},{"location":"examples/sdk_examples/","title":"SDK Examples","text":"<p>Using the SDK is similar to using the CLI</p>"},{"location":"examples/sdk_examples/#read-tenant-db-policies","title":"Read tenant db policies","text":"<pre><code>from ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.auth import ArkSecret, ArkAuthMethod, ArkAuthProfile, IdentityArkAuthMethodSettings\nfrom ark_sdk_python.services.dpa.policies.db import ArkDPADBPoliciesService\n\nif __name__ == \"__main__\":\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='tina@cyberark.cloud.12345', auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n    db_policies_service = ArkDPADBPoliciesService(isp_auth)\n    policies = db_policies_service.list_policies()\n</code></pre>"},{"location":"examples/sdk_examples/#provision-dpa-databases-and-policy","title":"Provision dpa databases and policy","text":"<pre><code>if __name__ == '__main__':\n    ArkSystemConfig.disable_verbose_logging()\n    # Authenticate to the tenant with an auth profile to configure DPA\n    username = 'user@cyberark.cloud.12345'\n    print(f'Authenticating to the created tenant with user [{username}]')\n    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n\n    # Create DPA DB Secret, Database, Connector and DB Policy\n    dpa_service = ArkDPAAPI(isp_auth)\n    print('Adding DPA DB User Secret')\n    secret = dpa_service.secrets_db.add_secret(\n        ArkDPADBAddSecret(secret_type=ArkDPADBSecretType.UsernamePassword, username='Administrator', password='CoolPassword')\n    )\n    print('Adding DPA Database')\n    dpa_service.workspace_db.add_database(\n        ArkDPADBAddDatabase(\n            name='mydomain.com',\n            provider_engine=ArkDPADBDatabaseEngineType.PostgresSH,\n            secret_id=secret.secret_id,\n            read_write_endpoint=\"myendpoint.mydomain.com\",\n        )\n    )\n    print('Adding DPA DB Policy')\n    dpa_service.policies_db.add_policy(\n        ArkDPADBAddPolicy(\n            policy_name='IT Policy',\n            status=ArkDPARuleStatus.Active,\n            description='IT Policy',\n            providers_data=ArkDPADBProvidersData(\n                postgres=ArkDPADBPostgres(\n                    resources=['postgres-onboarded-asset'],\n                ),\n            ),\n            user_access_rules=[\n                ArkDPADBAuthorizationRule(\n                    rule_name='IT Rule',\n                    user_data=ArkDPAUserData(roles=['DpaAdmin'], groups=[], users=[]),\n                    connection_information=ArkDPADBConnectionInformation(\n                        grant_access=2,\n                        idle_time=10,\n                        full_days=True,\n                        hours_from='07:00',\n                        hours_to='17:00',\n                        time_zone='Asia/Jerusalem',\n                        connect_as=ArkDPADBConnectAs(\n                            db_auth=[\n                                ArkDPADBLocalDBAuth(\n                                    roles=['rds_superuser'],\n                                    applied_to=[\n                                        ArkDPADBAppliedTo(\n                                            name='postgres-onboarded-asset',\n                                            type=ArkDPADBResourceIdentifierType.RESOURCE,\n                                        )\n                                    ],\n                                ),\n                            ],\n                        ),\n                    ),\n                )\n            ],\n        )\n    )\n</code></pre>"},{"location":"examples/sdk_examples/#provision-dpa-vm-policies","title":"Provision dpa vm policies","text":"<pre><code>    isp_auth = ArkISPAuth()\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n        ),\n        secret=ArkSecret(secret='CoolPassword'),\n    )\n    print('Adding DPA Policy')\n    dpa_service.policies.add_policy(\n        ArkDPAVMAddPolicy(\n            policy_name='IT Policy',\n            description='IT Policy',\n            status=ArkDPARuleStatus.Enabled,\n            providers_data={\n                ArkWorkspaceType.AWS: ArkDPAVMAWSProviderData(\n                    account_ids=['965428623928'], tags=[{'key': 'team', 'value': 'IT'}], regions=[], vpc_ids=[]\n                )\n            },\n            user_access_rules=[\n                ArkDPAVMAuthorizationRule(\n                    rule_name='IT Rule',\n                    user_data=ArkDPAUserData(roles=['IT']),\n                    connection_information=ArkDPAVMConnectionInformation(\n                        full_days=True,\n                        days_of_week=[],\n                        time_zone='Asia/Jerusalem',\n                        connect_as={\n                            ArkWorkspaceType.AWS: {\n                                ArkProtocolType.SSH: 'root',\n                                ArkProtocolType.RDP: ArkDPAVMRDPLocalEphemeralUserConnectionData(\n                                    local_ephemeral_user=ArkDPAVMLocalEphemeralUserConnectionMethodData(assign_groups={'Administrators'})\n                                ),\n                            }\n                        },\n                    ),\n                )\n            ],\n        )\n    )\n</code></pre>"},{"location":"howto/enduser_databases_workflow/","title":"Enduser Databases Workflow","text":"<p>Say an end user wants to connect to a database to do so, he would perform the following steps:</p> <p>First, he would install ark-sdk-python using pip if he did not do so already</p> <p>Afterwards, he would configure a profile once as follows interactivaly: <pre><code>ark configure\n</code></pre> Or silently: <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></p> <p>Now that we configured a profile, we may log into it <pre><code>ark login --silent --isp-secret mysecret\n</code></pre></p> <p>Now that the user is logged in, he may execute actions, one of them being generating a short lived sso password <pre><code>ark exec dpa sso short-lived-password\n</code></pre></p> <p>The user will receive a secret which he can use to connect to his database of choice, for example postgres <pre><code>psql \"host=mytenant.postgres.cyberark.cloud user=user@cyberark.cloud.12345@postgres@mypostgres.fqdn.com\"\n</code></pre></p> <p>Or, using ark <pre><code>ark exec dpa db psql --target-username postgres --target-address mypostgres.fqdn.com\n</code></pre></p>"},{"location":"howto/enduser_kubernetes_workflow/","title":"Enduser Kubernetes Workflow","text":"<p>In order to securely access to Kubernetes cluster the user will follow below steps.</p> <p>First, he would install ark-sdk-python using pip if he did not do so already.</p> <p>Afterwards, he would configure a profile once as follows interactivaly: <pre><code>ark configure\n</code></pre> Or silently: <pre><code>ark configure --silent --work-with-isp --isp-username myuser\n</code></pre></p> <p>Now that the profile is configured, the user can login. <pre><code>ark login --silent --isp-secret mysecret\n</code></pre></p> <p>Now that the user is logged in, the user may generate a kubectl kubeconfig file, that contain all the clusters that are accessbile to the user, based on its permissions. <pre><code>ark exec dpa k8s generate-kubeconfig\n</code></pre></p> <p>Alternatively, by adding an optional flag and path, the config file will be generated in the provided path, overriding any existing file with the same name. <pre><code>ark exec dpa k8s generate-kubeconfig -f ~/.kube\n</code></pre></p>"},{"location":"howto/enduser_kubernetes_workflow/#refresh-sso-certificate-data-workflow","title":"Refresh SSO certificate data Workflow","text":"<p>Refreshing the certificate allows the user to keep using its existing generated kubeconfig file and only refresh the MFA authentication data. The command expect a flag that indicates the output format: \"-of\" with one of the following arguments:</p> <ol> <li> <p>File - generating 2 files for certificate and private key. if chosen, a flag -f with path is mandatory <pre><code>ark exec dpa sso short-lived-client-certificate -of file -f ~/home\n</code></pre></p> </li> <li> <p>raw - the certificate and the private key will be  printed to the client as plaintext: <pre><code>ark exec dpa sso short-lived-client-certificate -of raw\n</code></pre></p> </li> <li> <p>base64 - the certificate and the private key will be encoded to Base64 format and will be printed to the client: <pre><code>ark ark exec dpa sso short-lived-client-certificate -of base64\n</code></pre></p> </li> </ol>"},{"location":"howto/refreshing_authentication/","title":"Refreshing Authentication","text":"<p>In cases where we would like to continue working directly with existing authentications, we can perform a refresh to the existing authentication that we have</p> <p>The refresh authentication is possible in the following 4 use cases: - The login command - The exec command - During polling operation - Via the SDK when working with it</p>"},{"location":"howto/refreshing_authentication/#login","title":"Login","text":"<p>When we would like to login to our authenticators, but instead of writing our passwords again, or any other tokens, but only to refresh the existing login if possible and the refresh time has not expired as well, we can perform the following command for example with the CLI paran -ra / --refresh-auth:</p> <pre><code>ark login -ra\n</code></pre> <p>The above command will try and refresh the authentication of the existing profile, and if it has failed, it will fallback to the normal authentication and ask the user for fitting details</p>"},{"location":"howto/refreshing_authentication/#exec","title":"Exec","text":"<p>When we would like to execute a command, if any kind, we can try and refresh the authentication before running the command, This will cause it so the Ark CLI will perform refresh to the authenticator if possible and if it has failed, an exception will be thrown. This can be used as follows for example with the CLI paran -ra / --refresh-auth</p> <pre><code>ark exec -ra dpa policies list-policies\n</code></pre>"},{"location":"howto/refreshing_authentication/#polling-operations","title":"Polling Operations","text":"<p>When polling, on any async command, we might hit a timeout before the polling operation has ended. to compensate that, we can add an automatic refresh during the polling operation, this will make it so that if an unauthorized (401) response of different polling operations arrives, we will try to refresh the fitting authentication before continuing to poll If it has failed, will report it as a timeout error in the CLI. This can be used as follows for example with the CLI param -parc / --poll-allow-refresh-connection</p>"},{"location":"howto/refreshing_authentication/#sdk","title":"SDK","text":"<p>In the SDK, this is similar to the CLI, where we can call an existing authenticator \"load_authentication\" command This will try if caching is enabled to load auth from cache, and if given, also try and refresh the authentication either from the loaded cache or from the existing auth in memory, as seen in the following example:</p> <pre><code>isp_auth = ArkISPAuth()\nisp_auth.authenticate(\n    auth_profile=ArkAuthProfile(\n        username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n    ),\n    secret=ArkSecret(secret='CoolPassword'),\n)\n...\nisp_auth.load_authentication(refresh_auth=True)\n</code></pre> <p>Or if we are talking about polling operation, we can use poll_allow_refreshable_connection arg</p> <pre><code>isp_auth = ArkISPAuth()\nisp_auth.authenticate(\n    auth_profile=ArkAuthProfile(\n        username=username, auth_method=ArkAuthMethod.Identity, auth_method_settings=IdentityArkAuthMethodSettings()\n    ),\n    secret=ArkSecret(secret='CoolPassword'),\n)\ndpa_service = ArkDPAAPI(isp_auth)\n...\n</code></pre>"},{"location":"howto/simple_commands_workflow/","title":"Simple Commands Workflow","text":"<p>Let's configure a profile to login to that respective tenant and perform DPA actions om:</p> <pre><code>ark configure --work-with-isp --isp-username=username\nark login -s --isp-secret=secret\n</code></pre> <p>Actions such as configuring a database, secret and generating a policy can be done as follows:</p> <pre><code>ark exec dpa secrets db add-secret -sn name -st username_password -u user -pa coolpassword\nark exec dpa workspaces db add-database -n somedb -pe postgres-sh -rwe myendpoint.domain.com\nark exec dpa policies db editor generate-policy\n</code></pre>"},{"location":"howto/simple_sdk_workflow/","title":"Simple SDK Workflow","text":"<p>Let's say we want to create a demo environment containing all needed DPA DB assets</p> <p>To do so, we can use the following script:</p> <pre><code>ArkSystemConfig.disable_verbose_logging()\n# Authenticate to the tenant with an auth profile to configure DPA\nprint(f'Authenticating to the created tenant with user [{username}]')\nisp_auth = ArkISPAuth()\nisp_auth.authenticate(auth_profile=ArkAuthProfile(\n    username='user@cyberark.cloud.12345',\n    auth_method=ArkAuthMethod.Identity,\n    auth_method_settings=IdentityArkAuthMethodSettings()\n), secret=ArkSecret(secret='CoolPassword'))\n\n# Create DPA DB Secret, Database, Connector and DB Policy\ndpa_service = ArkDPAAPI(isp_auth)\nprint('Adding DPA DB User Secret')\nsecret = dpa_service.secrets_db.add_secret(ArkDPADBAddSecret(\n    secret_type=ArkDPADBSecretType.UsernamePassword,\n    username='Administrator',\n    password='CoolPassword'\n))\nprint('Adding DPA Database')\ndpa_service.workspace_db.add_database(ArkDPADBAddDatabase(\n    name='mydomain.com',\n    provider_engine=ArkDPADBDatabaseEngineType.PosgresSH,\n    secret_id=secret.secret_id,\n    read_write_endpoint=\"myendpoint.mydomain.com\"\n))\nprint('Adding DPA DB Policy')\ndpa_service.policies_db.add_policy(\n    ArkDPADBAddPolicy(\n        policy_name='IT Policy',\n        status=ArkDPARuleStatus.Active,\n        description='IT Policy',\n        providers_data=ArkDPADBProvidersData(\n            postgres=ArkDPADBPostgres(\n                resources=['postgres-onboarded-asset'],\n            ),\n        ),\n        user_access_rules=[\n            ArkDPADBAuthorizationRule(\n                rule_name='IT Rule',\n                user_data=ArkDPAUserData(roles=['DpaAdmin'], groups=[], users=[]),\n                connection_information=ArkDPADBConnectionInformation(\n                    grant_access=2,\n                    idle_time=10,\n                    full_days=True,\n                    hours_from='07:00',\n                    hours_to='17:00',\n                    time_zone='Asia/Jerusalem',\n                    connect_as=ArkDPADBConnectAs(\n                        db_auth=[\n                            ArkDPADBLocalDBAuth(\n                                roles=['rds_superuser'],\n                                applied_to=[\n                                    ArkDPADBAppliedTo(\n                                        name='postgres-onboarded-asset',\n                                        type=ArkDPADBResourceIdentifierType.RESOURCE,\n                                    )\n                                ],\n                            ),\n                        ],\n                    ),\n                ),\n            )\n        ],\n    )\n)\nprint('Finished Successfully')\n</code></pre> <p>Where in the above the following flow occurres: - We login to the admin user in order to perform actions on the tenant - we then configure DPA's secret, database and policy</p>"},{"location":"howto/working_with_ark_cache/","title":"Working With Ark Cache","text":"<p>Both the CLI and the SDK work cache of the machine or a fallback encrypted folder located in $HOME/.ark_cache</p> <p>The cache is used to store login information in an encrypted manner, that can be used later on for execution of commands until the authentication tokens are expired or invalid</p> <p>Machines such as windows support keyrings inside the windows certificate store and linux support keyring on the machine</p> <p>Other machines may fallback if not supported to an encrypted folder on the system</p> <p>The cache keyring folder can be set via the ARK_KEYRING_FOLDER env var, and the ark sdk can be forced to only work with the filesystem using the ARK_BASIC_KEYRING environment variable</p> <p>When performing the ark login operation, one can force the login to ignore the cache like this: <pre><code>ark login -f\n</code></pre></p> <p>Alongside that, caching can be disabled in the SDK for authenticators like this: <pre><code>isp_auth = ArkISPAuth(cache_authentication=False)\n</code></pre></p> <p>Lastly, cache can be completely cleared by running 'ark cache clear' or if working with the basic keyring, simply removing it from the filesystem under $HOME/.ark_cache</p>"},{"location":"howto/working_with_profiles/","title":"Working With Profiles","text":"<p>Profiles are the way to work with the CLI (and the SDK, but less dominant)</p> <p>As such, each profile can be configured seperatly via ark configure command</p> <p>Each subsequent command can receive --profile-name to work with the specific configured profile</p> <p>Alongside that, ARK_PROFILE environment variable can be set to globally work with a profile instead of passing it as a parameter all the times</p> <p>All of the profiles are json files that reside on $HOME/.ark_profiles folder</p> <p>A profile looks as follows:</p> <pre><code>{\n    \"profile_name\": \"ark\",\n    \"profile_description\": \"Default Ark Profile\",\n    \"auth_profiles\": {\n        \"isp\": {\n            \"username\": \"tina@cyberark.cloud.1234567\",\n            \"auth_method\": \"identity\",\n            \"auth_method_settings\": {\n                \"identity_mfa_method\": \"email\",\n                \"identity_mfa_interactive\": true,\n                \"identity_application\": null,\n                \"identity_url\": null\n            }\n        }\n    }\n}\n</code></pre> <p>Profiles can be added / removed via the configure command, or manipulating the profiles folder</p>"},{"location":"reference/","title":".","text":""},{"location":"reference/#ark_sdk_python.ArkAPI","title":"<code>ArkAPI</code>","text":"Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>class ArkAPI:\n    def __init__(self, authenticators: List[ArkAuth], profile: Optional[ArkProfile] = None) -&gt; None:\n        self.__authenticators = authenticators\n        self.__lazy_loaded_services: Dict[str, ArkService] = {}\n        self.__profile = profile or ArkProfileLoader.load_default_profile()\n\n    def __lazy_load_service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        service_name = service_type.service_config().service_name\n        required_auth_names = service_type.service_config().required_authenticator_names\n        required_autheneticators = [auth for auth in self.__authenticators if auth.authenticator_name() in required_auth_names]\n        optional_authenticators = [\n            auth\n            for auth in self.__authenticators\n            if auth.authenticator_name() in service_type.service_config().optional_authenticator_names\n        ]\n        if len(required_autheneticators) == len(required_auth_names):\n            authenticators = {f'{a.authenticator_name()}_auth': a for a in required_autheneticators + optional_authenticators}\n            self.__lazy_loaded_services[service_name] = service_type(**authenticators)\n        else:\n            raise ArkServiceException(\n                f'{service_name.title()} is not supported or missing fitting authenticators, please make sure you are logged in'\n            )\n        return self.__lazy_loaded_services[service_name]\n\n    def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Returns an authenticator by given name\n\n        Args:\n            authenticator_name (str): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.__authenticators:\n            if auth.authenticator_name() == authenticator_name:\n                return auth\n        raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n\n    def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        \"\"\"\n        Returns a service by its given name\n        Only if the authenticators were given that fit the service, will it be supported\n\n        Args:\n            service_type (Type[ArkService]): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkService: _description_\n        \"\"\"\n        if not issubclass(service_type, ArkService):\n            raise ArkServiceException(f\"Type {service_type} is invalid\")\n        service_name = service_type.service_config().service_name\n        if service_name in self.__lazy_loaded_services:\n            return self.__lazy_loaded_services[service_name]\n        return self.__lazy_load_service(service_type)\n\n    @property\n    def profile(self) -&gt; ArkProfile:\n        \"\"\"\n        Gets the API profile\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        return self.__profile\n\n    @property\n    def dpa_workspaces_db(self) -&gt; \"ArkDPADBWorkspaceService\":\n        \"\"\"\n        Returns the DPA DB Workspace service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.workspaces.db import ArkDPADBWorkspaceService\n\n        return cast(ArkDPADBWorkspaceService, self.service(ArkDPADBWorkspaceService))\n\n    @property\n    def dpa_policies_vm(self) -&gt; \"ArkDPAVMPoliciesService\":\n        \"\"\"\n        Returns the DPA VM Policies service if the fitting authenticators were given\n\n        Returns:\n            ArkDPAVMPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.vm import ArkDPAVMPoliciesService\n\n        return cast(ArkDPAVMPoliciesService, self.service(ArkDPAVMPoliciesService))\n\n    @property\n    def dpa_policies_db(self) -&gt; \"ArkDPADBPoliciesService\":\n        \"\"\"\n        Returns the DPA DB Policies service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.db import ArkDPADBPoliciesService\n\n        return cast(ArkDPADBPoliciesService, self.service(ArkDPADBPoliciesService))\n\n    @property\n    def dpa_secrets_db(self) -&gt; \"ArkDPADBSecretsService\":\n        \"\"\"\n        Returns the DPA DB Secrets service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.secrets.db import ArkDPADBSecretsService\n\n        return cast(ArkDPADBSecretsService, self.service(ArkDPADBSecretsService))\n\n    @property\n    def dpa_sso(self) -&gt; \"ArkDPASSOService\":\n        \"\"\"\n        Returns the DPA sso service if the fitting authenticators were given\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.sso import ArkDPASSOService\n\n        return cast(ArkDPASSOService, self.service(ArkDPASSOService))\n\n    @property\n    def dpa_db(self) -&gt; \"ArkDPADBService\":\n        \"\"\"\n        Returns the DPA DB service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.db import ArkDPADBService\n\n        return cast(ArkDPADBService, self.service(ArkDPADBService))\n\n    @property\n    def dpa_certificates(self) -&gt; \"ArkDPACertificatesService\":\n        \"\"\"\n        Returns the DPA certificates service if the fitting authenticators were given\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.certificates import ArkDPACertificatesService\n\n        return cast(ArkDPACertificatesService, self.service(ArkDPACertificatesService))\n\n    @property\n    def dpa_k8s(self) -&gt; \"ArkDPAK8SService\":\n        \"\"\"\n        Returns the DPA Policies service if the fitting authenticators were given\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.k8s import ArkDPAK8SService\n\n        return cast(ArkDPAK8SService, self.service(ArkDPAK8SService))\n</code></pre>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_certificates","title":"<code>dpa_certificates: 'ArkDPACertificatesService'</code>  <code>property</code>","text":"<p>Returns the DPA certificates service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>'ArkDPACertificatesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_db","title":"<code>dpa_db: 'ArkDPADBService'</code>  <code>property</code>","text":"<p>Returns the DPA DB service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>'ArkDPADBService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_k8s","title":"<code>dpa_k8s: 'ArkDPAK8SService'</code>  <code>property</code>","text":"<p>Returns the DPA Policies service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>'ArkDPAK8SService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_policies_db","title":"<code>dpa_policies_db: 'ArkDPADBPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Policies service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>'ArkDPADBPoliciesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_policies_vm","title":"<code>dpa_policies_vm: 'ArkDPAVMPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA VM Policies service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesService</code> <code>'ArkDPAVMPoliciesService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_secrets_db","title":"<code>dpa_secrets_db: 'ArkDPADBSecretsService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Secrets service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>'ArkDPADBSecretsService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_sso","title":"<code>dpa_sso: 'ArkDPASSOService'</code>  <code>property</code>","text":"<p>Returns the DPA sso service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>'ArkDPASSOService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.dpa_workspaces_db","title":"<code>dpa_workspaces_db: 'ArkDPADBWorkspaceService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Workspace service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>'ArkDPADBWorkspaceService'</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.profile","title":"<code>profile: ArkProfile</code>  <code>property</code>","text":"<p>Gets the API profile</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p>"},{"location":"reference/#ark_sdk_python.ArkAPI.authenticator","title":"<code>authenticator(authenticator_name)</code>","text":"<p>Returns an authenticator by given name</p> <p>Parameters:</p> Name Type Description Default <code>authenticator_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Returns an authenticator by given name\n\n    Args:\n        authenticator_name (str): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.__authenticators:\n        if auth.authenticator_name() == authenticator_name:\n            return auth\n    raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n</code></pre>"},{"location":"reference/#ark_sdk_python.ArkAPI.service","title":"<code>service(service_type)</code>","text":"<p>Returns a service by its given name Only if the authenticators were given that fit the service, will it be supported</p> <p>Parameters:</p> Name Type Description Default <code>service_type</code> <code>Type[ArkService]</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkService</code> <code>ArkService</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n    \"\"\"\n    Returns a service by its given name\n    Only if the authenticators were given that fit the service, will it be supported\n\n    Args:\n        service_type (Type[ArkService]): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkService: _description_\n    \"\"\"\n    if not issubclass(service_type, ArkService):\n        raise ArkServiceException(f\"Type {service_type} is invalid\")\n    service_name = service_type.service_config().service_name\n    if service_name in self.__lazy_loaded_services:\n        return self.__lazy_loaded_services[service_name]\n    return self.__lazy_load_service(service_type)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>.</li> <li>actions<ul> <li>ark_action</li> <li>ark_cache_action</li> <li>ark_configure_action</li> <li>ark_exec_action</li> <li>ark_login_action</li> <li>ark_profiles_action</li> <li>ark_service_exec_action</li> </ul> </li> <li>args<ul> <li>ark_args_formatter</li> <li>ark_pydantic_argparse</li> </ul> </li> <li>ark</li> <li>ark_api</li> <li>auth<ul> <li>ark_auth</li> <li>ark_isp_auth</li> <li>identity<ul> <li>ark_identity</li> <li>ark_identity_fqdn_resolver</li> <li>ark_identity_service_user</li> </ul> </li> </ul> </li> <li>cli_services<ul> <li>ark_cli_api</li> <li>dpa<ul> <li>common<ul> <li>ark_dpa_base_policies_editor_service</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_policies_editor_service</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_policies_editor_service</li> </ul> </li> </ul> </li> </ul> </li> <li>common<ul> <li>ark_async_client</li> <li>ark_async_request</li> <li>ark_client</li> <li>ark_keyring</li> <li>ark_logger</li> <li>ark_page</li> <li>ark_pollers</li> <li>ark_random_utils</li> <li>ark_system_config</li> <li>env<ul> <li>ark_env_mapping</li> </ul> </li> <li>isp<ul> <li>ark_isp_service_client</li> </ul> </li> </ul> </li> <li>models<ul> <li>actions<ul> <li>ark_configure_action_consts</li> <li>ark_service_action_definition</li> <li>services<ul> <li>ark_dpa_exec_action_consts</li> </ul> </li> </ul> </li> <li>ark_exceptions</li> <li>ark_model</li> <li>ark_profile</li> <li>auth<ul> <li>ark_auth_method</li> <li>ark_auth_profile</li> <li>ark_secret</li> <li>ark_token</li> </ul> </li> <li>cli_services<ul> <li>dpa<ul> <li>policies_editor<ul> <li>common<ul> <li>ark_dpa_base_generate_policy</li> <li>ark_dpa_commit_policies</li> <li>ark_dpa_edit_policies</li> <li>ark_dpa_get_policies_status</li> <li>ark_dpa_load_policies</li> <li>ark_dpa_loaded_policies</li> <li>ark_dpa_policies_diff</li> <li>ark_dpa_policies_status</li> <li>ark_dpa_remove_policies</li> <li>ark_dpa_reset_policies</li> <li>ark_dpa_view_policies</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_generate_policy</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_generate_policy</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>common<ul> <li>ark_async_request_settings</li> <li>ark_async_status</li> <li>ark_async_task</li> <li>ark_connection_method</li> <li>ark_connector_type</li> <li>ark_counted_values</li> <li>ark_network_entity_type</li> <li>ark_os_type</li> <li>ark_protocol_type</li> <li>ark_region</li> <li>ark_status</li> <li>ark_status_stats</li> <li>ark_validations</li> <li>ark_workspace_type</li> <li>aws<ul> <li>ark_cfn_async_task</li> </ul> </li> <li>connections<ul> <li>ark_connection_command</li> <li>ark_connection_credentials</li> <li>ark_connection_details</li> <li>ark_connection_result</li> <li>connection_data<ul> <li>ark_ssh_connection_data</li> <li>ark_winrm_connection_data</li> </ul> </li> </ul> </li> <li>identity<ul> <li>ark_identity_auth_schemas</li> <li>ark_identity_common_schemas</li> <li>ark_identity_directory_schemas</li> </ul> </li> <li>isp<ul> <li>ark_platform_discovery_schemas</li> </ul> </li> </ul> </li> <li>services<ul> <li>ark_service_config</li> <li>dpa<ul> <li>certificates<ul> <li>ark_dpa_certificates_certificate</li> <li>ark_dpa_certificates_delete_certificate</li> <li>ark_dpa_certificates_filter</li> <li>ark_dpa_certificates_get_certificate</li> <li>ark_dpa_certificates_update_certificate</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_base_execution</li> <li>ark_dpa_db_base_generate_assets</li> <li>ark_dpa_db_generated_assets</li> <li>ark_dpa_db_mysql_execution</li> <li>ark_dpa_db_oracle_generate_assets</li> <li>ark_dpa_db_psql_execution</li> </ul> </li> <li>k8s<ul> <li>ark_dpa_k8s_generate_kubeconfig</li> </ul> </li> <li>policies<ul> <li>common<ul> <li>ark_dpa_base_add_policy</li> <li>ark_dpa_base_authorization_rule</li> <li>ark_dpa_base_connection_information</li> <li>ark_dpa_base_policies_filter</li> <li>ark_dpa_base_policies_stats</li> <li>ark_dpa_base_policy</li> <li>ark_dpa_base_policy_list_item</li> <li>ark_dpa_base_update_policy</li> <li>ark_dpa_delete_policy</li> <li>ark_dpa_get_policy</li> <li>ark_dpa_rule_status</li> <li>ark_dpa_update_policy_status</li> <li>ark_dpa_user_data</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_add_policy</li> <li>ark_dpa_db_authorization_rule</li> <li>ark_dpa_db_connection_data</li> <li>ark_dpa_db_policies_filter</li> <li>ark_dpa_db_policies_stats</li> <li>ark_dpa_db_policies_workspace_type_serializer</li> <li>ark_dpa_db_policy</li> <li>ark_dpa_db_policy_list_item</li> <li>ark_dpa_db_providers</li> <li>ark_dpa_db_update_policy</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_add_policy</li> <li>ark_dpa_vm_authorization_rule</li> <li>ark_dpa_vm_connection_data</li> <li>ark_dpa_vm_policies_filter</li> <li>ark_dpa_vm_policies_protocol_type_serializer</li> <li>ark_dpa_vm_policies_stats</li> <li>ark_dpa_vm_policies_workspace_type_serializer</li> <li>ark_dpa_vm_policy</li> <li>ark_dpa_vm_policy_list_item</li> <li>ark_dpa_vm_providers</li> <li>ark_dpa_vm_update_policy</li> </ul> </li> </ul> </li> <li>secrets<ul> <li>db<ul> <li>ark_dpa_db_add_secret</li> <li>ark_dpa_db_delete_secret</li> <li>ark_dpa_db_disable_secret</li> <li>ark_dpa_db_enable_secret</li> <li>ark_dpa_db_get_secret</li> <li>ark_dpa_db_secret_metadata</li> <li>ark_dpa_db_secret_type</li> <li>ark_dpa_db_secrets_filter</li> <li>ark_dpa_db_secrets_stats</li> <li>ark_dpa_db_store_descriptor</li> <li>ark_dpa_db_store_type</li> <li>ark_dpa_db_update_secret</li> <li>secret_links<ul> <li>ark_dpa_db_pam_account_secret_link</li> </ul> </li> <li>secrets_data<ul> <li>ark_dpa_db_user_password_secret_data</li> </ul> </li> </ul> </li> </ul> </li> <li>sso<ul> <li>ark_dpa_sso_acquire_token_response</li> <li>ark_dpa_sso_get_short_lived_client_certificate</li> <li>ark_dpa_sso_get_short_lived_oracle_wallet</li> <li>ark_dpa_sso_get_short_lived_password</li> </ul> </li> <li>workspaces<ul> <li>db<ul> <li>ark_dpa_db_add_database</li> <li>ark_dpa_db_database</li> <li>ark_dpa_db_database_info</li> <li>ark_dpa_db_databases_filter</li> <li>ark_dpa_db_databases_stats</li> <li>ark_dpa_db_delete_database</li> <li>ark_dpa_db_get_database</li> <li>ark_dpa_db_platform_type_serializer</li> <li>ark_dpa_db_provider</li> <li>ark_dpa_db_tag</li> <li>ark_dpa_db_update_database</li> <li>ark_dpa_db_warning</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>services<ul> <li>ark_service</li> <li>dpa<ul> <li>ark_dpa_api</li> <li>certificates<ul> <li>ark_dpa_certificates_service</li> </ul> </li> <li>db<ul> <li>ark_dpa_db_service</li> </ul> </li> <li>k8s<ul> <li>ark_dpa_k8s_service</li> </ul> </li> <li>policies<ul> <li>db<ul> <li>ark_dpa_db_policies_service</li> </ul> </li> <li>vm<ul> <li>ark_dpa_vm_policies_service</li> </ul> </li> </ul> </li> <li>secrets<ul> <li>db<ul> <li>ark_dpa_db_secrets_service</li> </ul> </li> </ul> </li> <li>sso<ul> <li>ark_dpa_sso_service</li> </ul> </li> <li>workspaces<ul> <li>db<ul> <li>ark_dpa_db_workspace_service</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/ark/","title":"ark","text":""},{"location":"reference/ark_api/","title":"ark_api","text":""},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI","title":"<code>ArkAPI</code>","text":"Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>class ArkAPI:\n    def __init__(self, authenticators: List[ArkAuth], profile: Optional[ArkProfile] = None) -&gt; None:\n        self.__authenticators = authenticators\n        self.__lazy_loaded_services: Dict[str, ArkService] = {}\n        self.__profile = profile or ArkProfileLoader.load_default_profile()\n\n    def __lazy_load_service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        service_name = service_type.service_config().service_name\n        required_auth_names = service_type.service_config().required_authenticator_names\n        required_autheneticators = [auth for auth in self.__authenticators if auth.authenticator_name() in required_auth_names]\n        optional_authenticators = [\n            auth\n            for auth in self.__authenticators\n            if auth.authenticator_name() in service_type.service_config().optional_authenticator_names\n        ]\n        if len(required_autheneticators) == len(required_auth_names):\n            authenticators = {f'{a.authenticator_name()}_auth': a for a in required_autheneticators + optional_authenticators}\n            self.__lazy_loaded_services[service_name] = service_type(**authenticators)\n        else:\n            raise ArkServiceException(\n                f'{service_name.title()} is not supported or missing fitting authenticators, please make sure you are logged in'\n            )\n        return self.__lazy_loaded_services[service_name]\n\n    def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n        \"\"\"\n        Returns an authenticator by given name\n\n        Args:\n            authenticator_name (str): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.__authenticators:\n            if auth.authenticator_name() == authenticator_name:\n                return auth\n        raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n\n    def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n        \"\"\"\n        Returns a service by its given name\n        Only if the authenticators were given that fit the service, will it be supported\n\n        Args:\n            service_type (Type[ArkService]): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkService: _description_\n        \"\"\"\n        if not issubclass(service_type, ArkService):\n            raise ArkServiceException(f\"Type {service_type} is invalid\")\n        service_name = service_type.service_config().service_name\n        if service_name in self.__lazy_loaded_services:\n            return self.__lazy_loaded_services[service_name]\n        return self.__lazy_load_service(service_type)\n\n    @property\n    def profile(self) -&gt; ArkProfile:\n        \"\"\"\n        Gets the API profile\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        return self.__profile\n\n    @property\n    def dpa_workspaces_db(self) -&gt; \"ArkDPADBWorkspaceService\":\n        \"\"\"\n        Returns the DPA DB Workspace service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.workspaces.db import ArkDPADBWorkspaceService\n\n        return cast(ArkDPADBWorkspaceService, self.service(ArkDPADBWorkspaceService))\n\n    @property\n    def dpa_policies_vm(self) -&gt; \"ArkDPAVMPoliciesService\":\n        \"\"\"\n        Returns the DPA VM Policies service if the fitting authenticators were given\n\n        Returns:\n            ArkDPAVMPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.vm import ArkDPAVMPoliciesService\n\n        return cast(ArkDPAVMPoliciesService, self.service(ArkDPAVMPoliciesService))\n\n    @property\n    def dpa_policies_db(self) -&gt; \"ArkDPADBPoliciesService\":\n        \"\"\"\n        Returns the DPA DB Policies service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.policies.db import ArkDPADBPoliciesService\n\n        return cast(ArkDPADBPoliciesService, self.service(ArkDPADBPoliciesService))\n\n    @property\n    def dpa_secrets_db(self) -&gt; \"ArkDPADBSecretsService\":\n        \"\"\"\n        Returns the DPA DB Secrets service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.secrets.db import ArkDPADBSecretsService\n\n        return cast(ArkDPADBSecretsService, self.service(ArkDPADBSecretsService))\n\n    @property\n    def dpa_sso(self) -&gt; \"ArkDPASSOService\":\n        \"\"\"\n        Returns the DPA sso service if the fitting authenticators were given\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.sso import ArkDPASSOService\n\n        return cast(ArkDPASSOService, self.service(ArkDPASSOService))\n\n    @property\n    def dpa_db(self) -&gt; \"ArkDPADBService\":\n        \"\"\"\n        Returns the DPA DB service if the fitting authenticators were given\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.db import ArkDPADBService\n\n        return cast(ArkDPADBService, self.service(ArkDPADBService))\n\n    @property\n    def dpa_certificates(self) -&gt; \"ArkDPACertificatesService\":\n        \"\"\"\n        Returns the DPA certificates service if the fitting authenticators were given\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.certificates import ArkDPACertificatesService\n\n        return cast(ArkDPACertificatesService, self.service(ArkDPACertificatesService))\n\n    @property\n    def dpa_k8s(self) -&gt; \"ArkDPAK8SService\":\n        \"\"\"\n        Returns the DPA Policies service if the fitting authenticators were given\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        from ark_sdk_python.services.dpa.k8s import ArkDPAK8SService\n\n        return cast(ArkDPAK8SService, self.service(ArkDPAK8SService))\n</code></pre>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_certificates","title":"<code>dpa_certificates: 'ArkDPACertificatesService'</code>  <code>property</code>","text":"<p>Returns the DPA certificates service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>'ArkDPACertificatesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_db","title":"<code>dpa_db: 'ArkDPADBService'</code>  <code>property</code>","text":"<p>Returns the DPA DB service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>'ArkDPADBService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_k8s","title":"<code>dpa_k8s: 'ArkDPAK8SService'</code>  <code>property</code>","text":"<p>Returns the DPA Policies service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>'ArkDPAK8SService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_policies_db","title":"<code>dpa_policies_db: 'ArkDPADBPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Policies service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>'ArkDPADBPoliciesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_policies_vm","title":"<code>dpa_policies_vm: 'ArkDPAVMPoliciesService'</code>  <code>property</code>","text":"<p>Returns the DPA VM Policies service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesService</code> <code>'ArkDPAVMPoliciesService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_secrets_db","title":"<code>dpa_secrets_db: 'ArkDPADBSecretsService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Secrets service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>'ArkDPADBSecretsService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_sso","title":"<code>dpa_sso: 'ArkDPASSOService'</code>  <code>property</code>","text":"<p>Returns the DPA sso service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>'ArkDPASSOService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.dpa_workspaces_db","title":"<code>dpa_workspaces_db: 'ArkDPADBWorkspaceService'</code>  <code>property</code>","text":"<p>Returns the DPA DB Workspace service if the fitting authenticators were given</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>'ArkDPADBWorkspaceService'</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.profile","title":"<code>profile: ArkProfile</code>  <code>property</code>","text":"<p>Gets the API profile</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.authenticator","title":"<code>authenticator(authenticator_name)</code>","text":"<p>Returns an authenticator by given name</p> <p>Parameters:</p> Name Type Description Default <code>authenticator_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def authenticator(self, authenticator_name: str) -&gt; ArkAuth:\n    \"\"\"\n    Returns an authenticator by given name\n\n    Args:\n        authenticator_name (str): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.__authenticators:\n        if auth.authenticator_name() == authenticator_name:\n            return auth\n    raise ArkServiceException(f'{authenticator_name} is not supported or not found')\n</code></pre>"},{"location":"reference/ark_api/#ark_sdk_python.ark_api.ArkAPI.service","title":"<code>service(service_type)</code>","text":"<p>Returns a service by its given name Only if the authenticators were given that fit the service, will it be supported</p> <p>Parameters:</p> Name Type Description Default <code>service_type</code> <code>Type[ArkService]</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkService</code> <code>ArkService</code> <p>description</p> Source code in <code>ark_sdk_python/ark_api.py</code> <pre><code>def service(self, service_type: Type[ArkService]) -&gt; ArkService:\n    \"\"\"\n    Returns a service by its given name\n    Only if the authenticators were given that fit the service, will it be supported\n\n    Args:\n        service_type (Type[ArkService]): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkService: _description_\n    \"\"\"\n    if not issubclass(service_type, ArkService):\n        raise ArkServiceException(f\"Type {service_type} is invalid\")\n    service_name = service_type.service_config().service_name\n    if service_name in self.__lazy_loaded_services:\n        return self.__lazy_loaded_services[service_name]\n    return self.__lazy_load_service(service_type)\n</code></pre>"},{"location":"reference/actions/","title":"actions","text":""},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction","title":"<code>ArkAction</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>class ArkAction(ABC):\n    def __init__(self):\n        self._logger = get_logger(app=self.__class__.__name__)\n\n    def _common_actions_configuration(self, parser: argparse.ArgumentParser) -&gt; None:\n        parser.add_argument('-r', '--raw', action='store_true', help='Whether to raw output')\n        parser.add_argument('-s', '--silent', action='store_true', help='Silent execution, no interactiveness')\n        parser.add_argument('-ao', '--allow-output', action='store_true', help='Allow stdout / stderr even when silent and not interactive')\n        parser.add_argument('-v', '--verbose', action='store_true', help='Whether to verbose log')\n        parser.add_argument('-ls', '--logger-style', choices=['default'], help='Which verbose logger style to use', default='default')\n        parser.add_argument(\n            '-ll',\n            '--log-level',\n            help='Log level to use while verbose',\n            choices=['DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL'],\n            default='INFO',\n        )\n        parser.add_argument(\n            '-dcv', '--disable-cert-verification', action='store_true', help='Disables certificate verification on HTTPS calls, unsafe!'\n        )\n        parser.add_argument('-tc', '--trusted-cert', help='Certificate to use for HTTPS calls')\n\n    def _common_actions_execution(self, args: argparse.Namespace) -&gt; None:\n        ArkSystemConfig.enable_color()\n        ArkSystemConfig.enable_interactive()\n        ArkSystemConfig.disable_verbose_logging()\n        ArkSystemConfig.disallow_output()\n        ArkSystemConfig.set_logger_style(args.logger_style)\n        ArkSystemConfig.enable_certificate_verification()\n        if args.raw:\n            ArkSystemConfig.disable_color()\n        if args.silent:\n            ArkSystemConfig.disable_interactive()\n        if args.verbose:\n            ArkSystemConfig.enable_verbose_logging(args.log_level)\n        if args.allow_output:\n            ArkSystemConfig.allow_output()\n        if args.disable_cert_verification:\n            ArkSystemConfig.disable_certificate_verification()\n        elif args.trusted_cert is not None:\n            ArkSystemConfig.set_trusted_certificate(args.trusted_cert)\n        self._logger = get_logger(app=self.__class__.__name__)\n        if 'profile-name' in args:\n            args.profile_name = ArkProfileLoader.deduce_profile_name(args.profile_name)\n        if 'DEPLOY_ENV' not in os.environ:\n            # Last fallback on deploy env\n            os.environ['DEPLOY_ENV'] = 'prod'\n\n    @abstractmethod\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the action as part of the subparsers group\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the actual action for the given arguments\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the given action can be ran with the name and args\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the given action can be ran with the name and args</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the given action can be ran with the name and args\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.define_action","title":"<code>define_action(subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines the action as part of the subparsers group</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the action as part of the subparsers group\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkAction.run_action","title":"<code>run_action(args)</code>  <code>abstractmethod</code>","text":"<p>Runs the actual action for the given arguments</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the actual action for the given arguments\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction","title":"<code>ArkCacheAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>class ArkCacheAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the cache CLI action\n        Adds action for clearing cache\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n        self._common_actions_configuration(cache_parser)\n        cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n        cache_cmd_subparsers.required = True\n        cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n\n    def __run_clear_cache_action(self) -&gt; None:\n        if isinstance(ArkKeyring.get_keyring(), BasicKeyring):\n            cache_folder_path = os.path.join(os.path.expanduser('~'), DEFAULT_BASIC_KEYRING_FOLDER)\n            if ARK_BASIC_KEYRING_FOLDER_ENV_VAR in os.environ:\n                cache_folder_path = os.environ[ARK_BASIC_KEYRING_FOLDER_ENV_VAR]\n            os.unlink(f'{cache_folder_path}{os.sep}keyring')\n            os.unlink(f'{cache_folder_path}{os.sep}mac')\n        else:\n            ArkArgsFormatter.print_normal('Cache clear is only valid for basic keyring implementation at the moment')\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Perform the actual cache action\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.cache_cmd == 'clear':\n            self.__run_clear_cache_action()\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is profile\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is profile</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is profile\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the cache CLI action Adds action for clearing cache</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the cache CLI action\n    Adds action for clearing cache\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n    self._common_actions_configuration(cache_parser)\n    cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n    cache_cmd_subparsers.required = True\n    cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkCacheAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Perform the actual cache action</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Perform the actual cache action\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.cache_cmd == 'clear':\n        self.__run_clear_cache_action()\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction","title":"<code>ArkConfigureAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>class ArkConfigureAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the configuration CLI action\n        Adds for each supported authenticator, its fitting parameters and whether to work with it\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n        self._common_actions_configuration(conf_parser)\n\n        # Add the profile settings to the arguments\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n        )\n\n        # Add the supported authenticator settings and whether to work with them or not\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            conf_parser.add_argument(\n                f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n                f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n                action='store_true',\n                help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                conf_parser.add_argument(\n                    f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                    f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                    choices=[am.value for am in authenticator.supported_auth_methods()],\n                    default=ArkAuthMethod.Default.value,\n                )\n            # Add the rest of the ark auth profile params\n            ArkPydanticArgparse.schema_to_argparse(\n                ArkAuthProfile.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n            )\n\n            # Add the supported authentication methods settings of the authenticators\n            for auth_method in authenticator.supported_auth_methods():\n                auth_settings = ArkAuthMethodSettingsMap[auth_method]\n                ArkPydanticArgparse.schema_to_argparse(\n                    auth_settings.schema(by_alias=False),\n                    conf_parser,\n                    key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                    ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n                )\n\n    def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Performs an interactivr configuration\n        Each ark profile setting will be asked by the user, with defaults / supplied cli args\n        Each picked authenticator will also be configured for his auth method and settings\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile first with the given profile name from the user\n        profile_name = ArkArgsFormatter.get_arg(\n            args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n        )\n        profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n        # Fill the rest of the profile settings\n        profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n            ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n        )\n        profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n        if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n            work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n        else:\n            work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n                args,\n                [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n                'Which authenticators would you like to connect to',\n                [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n                {\n                    f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                    for a in SUPPORTED_AUTHENTICATORS_LIST\n                    if a.authenticator_name() in profile.auth_profiles\n                },\n                True,\n            )\n        for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n            # Find out if we are working with the authenticator\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n                # Get the authenticator auth method\n                ArkArgsFormatter.print_success_bright(\n                    ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n                )\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    auth_method = ArkArgsFormatter.get_switch_arg(\n                        args,\n                        f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                        'Authentication Method',\n                        [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                        ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                        if authenticator.authenticator_name() in profile.auth_profiles\n                        else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                        prioritize_existing_val=True,\n                    )\n                    auth_method = next(\n                        filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                    )\n                    # If the default is chosen, override it by the authenticator's default\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n                ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                    authenticator.authenticator_name(), []\n                )\n                # Get the auth profile general settings\n                auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    ArkAuthProfile.schema(by_alias=False),\n                    args,\n                    ignored_keys=ignored_keys,\n                    existing_values=auth_profile.dict(),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    auth_profile_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignore_keys=['auth_method_settings'],\n                )\n\n                # Get the auth method settings and fill them\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    method_settings.schema(by_alias=False),\n                    args,\n                    existing_values=method_settings.dict(),\n                    override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                    empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                    default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n                )\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Runs the configuration action silently, only from the command line with no user interaction\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile based on the cli params and merge the rest of the params\n        profile = ArkPydanticArgparse.merge_by_model(\n            ArkProfile,\n            ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n            ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n        )\n\n        # Load the authenticators\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    # Load the auth method\n                    auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                    # If default, fallback to default auth method of the authenticator\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n\n                # Load the rest of the auth profile\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    ArkPydanticArgparse.argparse_to_schema(\n                        ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                    ),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n\n                # Make sure if the type requires credentials, a username was supplied\n                if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                    raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n                # Load the method settings\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n                # Parse and merge the method settings from the cli\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                    method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                )\n\n                # Remove the postfix\n                method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    defaults={\n                        k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                        for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                        if k.startswith(f'{authenticator.authenticator_name()}_')\n                    },\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Executes the configuration action\n        Will ask the user questions if interactive based on the authenticators\n        Will save the configured profile once done\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n        # Parse the profile\n        self._common_actions_execution(args)\n        profile: Optional[ArkProfile] = None\n        if ArkSystemConfig.is_interactive():\n            profile = self.__run_interactive_action(args)\n        else:\n            profile = self.__run_silent_action(args)\n\n        # Store it\n        ArkProfileLoader.save_profile(profile)\n\n        # Print out results\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n        ArkArgsFormatter.print_success_bright(\n            f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is configure\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.__run_interactive_action","title":"<code>__run_interactive_action(args)</code>","text":"<p>Performs an interactivr configuration Each ark profile setting will be asked by the user, with defaults / supplied cli args Each picked authenticator will also be configured for his auth method and settings</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Performs an interactivr configuration\n    Each ark profile setting will be asked by the user, with defaults / supplied cli args\n    Each picked authenticator will also be configured for his auth method and settings\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile first with the given profile name from the user\n    profile_name = ArkArgsFormatter.get_arg(\n        args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n    )\n    profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n    # Fill the rest of the profile settings\n    profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n        ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n    )\n    profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n    if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n        work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n    else:\n        work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n            args,\n            [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n            'Which authenticators would you like to connect to',\n            [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n            {\n                f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                for a in SUPPORTED_AUTHENTICATORS_LIST\n                if a.authenticator_name() in profile.auth_profiles\n            },\n            True,\n        )\n    for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n        # Find out if we are working with the authenticator\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n            # Get the authenticator auth method\n            ArkArgsFormatter.print_success_bright(\n                ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                auth_method = ArkArgsFormatter.get_switch_arg(\n                    args,\n                    f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                    'Authentication Method',\n                    [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                    ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                    if authenticator.authenticator_name() in profile.auth_profiles\n                    else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                    prioritize_existing_val=True,\n                )\n                auth_method = next(\n                    filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                )\n                # If the default is chosen, override it by the authenticator's default\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n            ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                authenticator.authenticator_name(), []\n            )\n            # Get the auth profile general settings\n            auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                ArkAuthProfile.schema(by_alias=False),\n                args,\n                ignored_keys=ignored_keys,\n                existing_values=auth_profile.dict(),\n                key_prefix=authenticator.authenticator_name(),\n            )\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                auth_profile_vals,\n                key_prefix=authenticator.authenticator_name(),\n                ignore_keys=['auth_method_settings'],\n            )\n\n            # Get the auth method settings and fill them\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                method_settings.schema(by_alias=False),\n                args,\n                existing_values=method_settings.dict(),\n                override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                key_prefix=authenticator.authenticator_name(),\n                ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n            )\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.__run_silent_action","title":"<code>__run_silent_action(args)</code>","text":"<p>Runs the configuration action silently, only from the command line with no user interaction</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Runs the configuration action silently, only from the command line with no user interaction\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile based on the cli params and merge the rest of the params\n    profile = ArkPydanticArgparse.merge_by_model(\n        ArkProfile,\n        ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n        ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n    )\n\n    # Load the authenticators\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                # Load the auth method\n                auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                # If default, fallback to default auth method of the authenticator\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n\n            # Load the rest of the auth profile\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                ArkPydanticArgparse.argparse_to_schema(\n                    ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                ),\n                key_prefix=authenticator.authenticator_name(),\n            )\n\n            # Make sure if the type requires credentials, a username was supplied\n            if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n            # Load the method settings\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n            # Parse and merge the method settings from the cli\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n            )\n\n            # Remove the postfix\n            method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n                defaults={\n                    k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                    for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                    if k.startswith(f'{authenticator.authenticator_name()}_')\n                },\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is configure</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is configure\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the configuration CLI action Adds for each supported authenticator, its fitting parameters and whether to work with it</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the configuration CLI action\n    Adds for each supported authenticator, its fitting parameters and whether to work with it\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n    self._common_actions_configuration(conf_parser)\n\n    # Add the profile settings to the arguments\n    ArkPydanticArgparse.schema_to_argparse(\n        ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n    )\n\n    # Add the supported authenticator settings and whether to work with them or not\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        conf_parser.add_argument(\n            f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n            f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n            action='store_true',\n            help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n        )\n        if len(authenticator.supported_auth_methods()) &gt; 1:\n            conf_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                choices=[am.value for am in authenticator.supported_auth_methods()],\n                default=ArkAuthMethod.Default.value,\n            )\n        # Add the rest of the ark auth profile params\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkAuthProfile.schema(by_alias=False),\n            conf_parser,\n            key_prefix=authenticator.authenticator_name().replace('_', '-'),\n            ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n        )\n\n        # Add the supported authentication methods settings of the authenticators\n        for auth_method in authenticator.supported_auth_methods():\n            auth_settings = ArkAuthMethodSettingsMap[auth_method]\n            ArkPydanticArgparse.schema_to_argparse(\n                auth_settings.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n            )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkConfigureAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Executes the configuration action Will ask the user questions if interactive based on the authenticators Will save the configured profile once done</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Executes the configuration action\n    Will ask the user questions if interactive based on the authenticators\n    Will save the configured profile once done\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n    # Parse the profile\n    self._common_actions_execution(args)\n    profile: Optional[ArkProfile] = None\n    if ArkSystemConfig.is_interactive():\n        profile = self.__run_interactive_action(args)\n    else:\n        profile = self.__run_silent_action(args)\n\n    # Store it\n    ArkProfileLoader.save_profile(profile)\n\n    # Print out results\n    ArkArgsFormatter.print_success(profile.json(indent=4))\n    ArkArgsFormatter.print_success_bright(\n        f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction","title":"<code>ArkExecAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>class ArkExecAction(ArkAction):\n    def _serialize_output(self, output: Optional[Union[List, Dict, ArkModel, Generator, Tuple, Any]]) -&gt; str:\n        if output is None:\n            return ''\n        if isinstance(output, Generator):\n            return self._serialize_output(list(itertools.chain.from_iterable([p.items for p in output])))\n        if isinstance(output, list):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, tuple):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, dict):\n            return json.dumps(\n                {\n                    k: json.loads(v.json(indent=4, by_alias=False, exclude={'poll_progress_callback'}))\n                    for k, v in output.items()\n                    if k is not None and v is not None\n                },\n                indent=4,\n            )\n        elif issubclass(type(output), ArkModel):\n            return output.json(indent=4, by_alias=False, exclude={'poll_progress_callback'})\n        elif issubclass(type(output), ArkAsyncRequest):\n            return output.async_task.json(indent=4, by_alias=False)\n        return str(output)\n\n    def _write_output_to_file(self, output_path: str, serialized_output: str) -&gt; None:\n        output_path = os.path.abspath(output_path)\n        if not os.path.exists(os.path.dirname(output_path)):\n            os.makedirs(os.path.dirname(output_path), exist_ok=True)\n        with open(output_path, 'w', encoding='utf-8') as f:\n            f.write(serialized_output)\n\n    def _run_async_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            model: ArkPollableModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n            model.poll_progress_callback = ArkPollers.default_poller()\n            output = getattr(service, action.replace('-', '_'))(model)\n            async_req = None\n            if issubclass(type(output), ArkAsyncRequest):\n                async_req = output\n            elif isinstance(output, tuple):\n                for a in output:\n                    if issubclass(type(a), ArkAsyncRequest):\n                        async_req = a\n                        break\n            if async_req is not None:\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path, async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})\n                    )\n                if async_req.task_failed():\n                    if async_req.task_timeout():\n                        ArkArgsFormatter.print_warning(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                    else:\n                        ArkArgsFormatter.print_failure(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                else:\n                    ArkArgsFormatter.print_success(self._serialize_output(output))\n            elif isinstance(output, list) and all(issubclass(type(ar), ArkAsyncRequest) for ar in output):\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path,\n                        json.dumps([ar.async_task.dict(indent=4, by_alias=False, exclude={\"poll_progress_callback\"}) for ar in output]),\n                    )\n                for ar in output:\n                    if ar.task_failed():\n                        if ar.task_timeout():\n                            ArkArgsFormatter.print_warning(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                        else:\n                            ArkArgsFormatter.print_failure(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                    else:\n                        ArkArgsFormatter.print_success(self._serialize_output(ar))\n            elif output is not None:\n                ArkArgsFormatter.print_success(self._serialize_output(output))\n        except Exception as ex:\n            self._logger.exception(f'Failed running async command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute async command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _run_sync_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            if model_type:\n                model: ArkModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n                output = getattr(service, action.replace('-', '_'))(model)\n            else:\n                output = getattr(service, action.replace('-', '_'))()\n            if output is not None:\n                serialized_output: str = self._serialize_output(output)\n                if args.output_path:\n                    self._write_output_to_file(args.output_path, serialized_output)\n                ArkArgsFormatter.print_success(serialized_output)\n            else:\n                ArkArgsFormatter.print_success(f'{action.replace(\"-\", \" \").title()} finished successfully')\n        except Exception as ex:\n            self._logger.exception(f'Failed running command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _define_actions_by_schemas(\n        self,\n        subparsers: argparse._SubParsersAction,\n        schemas_map: Dict[str, Optional[Type[ArkModel]]],\n        defaults_map: Optional[Dict[str, Dict[str, Any]]] = None,\n    ):\n        for action, schema in schemas_map.items():\n            parser = subparsers.add_parser(action)\n            if schema:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema.schema(), parser, defaults=defaults_map.get(action, None) if defaults_map else None\n                )\n\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the exec action, with subparsers exec for each service\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        exec_parser = None\n        exec_subparsers = None\n        # Check if the exec subparser already exists from previous definitions of a service\n        if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n            # Retrieve the existing exec parser\n            exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n            exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n        else:\n            # Create a new exec parser\n            exec_parser = subparsers.add_parser('exec')\n            self._common_actions_configuration(exec_parser)\n            exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n            exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n            exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n            exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n            exec_parser.add_argument(\n                '-ra',\n                '--refresh-auth',\n                action='store_true',\n                help='If possible, will try to refresh the active authentication before running the actual command',\n            )\n            exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n            exec_subparsers.required = True\n        self.define_exec_action(exec_subparsers)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the action\n        Loads the authenticators from the cache and creates the API with the authenticators\n        Each service will be created on the API based on the given authenticators\n        Runs the actual exec action afterwards with the API\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile and login before trying to exec')\n\n        # Load token from cache for each auth profile\n        authenticators: List[ArkAuth] = []\n        for authenticator_name in profile.auth_profiles.keys():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n            if not authenticator.load_authentication(profile, args.refresh_auth):\n                continue\n            authenticators.append(authenticator)\n\n        if len(authenticators) == 0:\n            raise ArkException(\n                'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n            )\n        if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n            ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n        # Create the CLI API with the authenticators\n        api = ArkCLIAPI(authenticators, profile)\n\n        # Run the actual exec fitting action with the api\n        # Run it with retries as per defined by user\n        retry_call(\n            self.run_exec_action,\n            fargs=[api, args],\n            tries=args.retry_count,\n            delay=1,\n            logger=namedtuple(\"logger\", (\"warning\"))(\n                warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n            ),\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is exec\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n\n    @abstractmethod\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines an exec action for a service with its configurations and args\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action for a service with its arguments and API\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the specific exec service action can be ran\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is exec</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is exec\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the specific exec service action can be ran</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the specific exec service action can be ran\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the exec action, with subparsers exec for each service</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the exec action, with subparsers exec for each service\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    exec_parser = None\n    exec_subparsers = None\n    # Check if the exec subparser already exists from previous definitions of a service\n    if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n        # Retrieve the existing exec parser\n        exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n        exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n    else:\n        # Create a new exec parser\n        exec_parser = subparsers.add_parser('exec')\n        self._common_actions_configuration(exec_parser)\n        exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n        exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n        exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n        exec_parser.add_argument(\n            '-ra',\n            '--refresh-auth',\n            action='store_true',\n            help='If possible, will try to refresh the active authentication before running the actual command',\n        )\n        exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n        exec_subparsers.required = True\n    self.define_exec_action(exec_subparsers)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines an exec action for a service with its configurations and args</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines an exec action for a service with its configurations and args\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the action Loads the authenticators from the cache and creates the API with the authenticators Each service will be created on the API based on the given authenticators Runs the actual exec action afterwards with the API</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the action\n    Loads the authenticators from the cache and creates the API with the authenticators\n    Each service will be created on the API based on the given authenticators\n    Runs the actual exec action afterwards with the API\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile and login before trying to exec')\n\n    # Load token from cache for each auth profile\n    authenticators: List[ArkAuth] = []\n    for authenticator_name in profile.auth_profiles.keys():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n        if not authenticator.load_authentication(profile, args.refresh_auth):\n            continue\n        authenticators.append(authenticator)\n\n    if len(authenticators) == 0:\n        raise ArkException(\n            'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n        )\n    if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n        ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n    # Create the CLI API with the authenticators\n    api = ArkCLIAPI(authenticators, profile)\n\n    # Run the actual exec fitting action with the api\n    # Run it with retries as per defined by user\n    retry_call(\n        self.run_exec_action,\n        fargs=[api, args],\n        tries=args.retry_count,\n        delay=1,\n        logger=namedtuple(\"logger\", (\"warning\"))(\n            warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n        ),\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>  <code>abstractmethod</code>","text":"<p>Runs the exec action for a service with its arguments and API</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action for a service with its arguments and API\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction","title":"<code>ArkLoginAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>class ArkLoginAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the configuration CLI action\n        Adds for each supported authenticator, its username / secret params for login\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n        self._common_actions_configuration(login_parser)\n        login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n        login_parser.add_argument(\n            '-nss',\n            '--no-shared-secrets',\n            action='store_true',\n            help='Do not share secrets between different authenticators with the same username',\n        )\n        login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n        login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n        # Add username and secret for each authenticator for logging in\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n                help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n                help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Perform the actual login for each authenticator\n        Once logged in, store its credentials in the keyring for later use\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        # Load up the profile\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile before trying to login')\n\n        # Login for each auth profile\n        # Share secrets between authenticators for allowed auth methods\n        shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n        # Save tokens for finalization output\n        tokens_map: Dict[str, ArkToken] = dict()\n        for authenticator_name, auth_profile in profile.auth_profiles.items():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n            # Only perform the authentication if not already authenticated and not forced\n            if authenticator.is_authenticated(profile) and not args.force:\n                try:\n                    if args.refresh_auth:\n                        token = authenticator.load_authentication(profile, True)\n                        if token:\n                            ArkArgsFormatter.print_success(\n                                f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                            )\n                        else:\n                            raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                    else:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                        )\n                    continue\n                except Exception as ex:\n                    self._logger.info(\n                        f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                    )\n            secret = (\n                ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n            )\n            auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n            # Ask the user for the user and secret if interactive\n            if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n                auth_profile.username = ArkArgsFormatter.get_arg(\n                    args,\n                    f'{authenticator_name}_username',\n                    f'{authenticator.authenticator_human_readable_name()} Username',\n                    auth_profile.username,\n                )\n                # Check if there is an existing secret who is sharable\n                if (\n                    auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                    and auth_profile.auth_method in shared_secrets_map\n                    and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                    and not args.__dict__[f'{authenticator_name}_secret']\n                    and not args.no_shared_secrets\n                ):\n                    secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n                else:\n                    if not args.force and (\n                        (\n                            auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                        )\n                    ):\n                        # Check if there is a secret already cached, if there is, no need to ask for password\n                        secret = ArkSecret(secret='')\n                    else:\n                        # Check if we really need to ask for a password in specific use cases\n                        if (\n                            authenticator_name == 'isp'\n                            and auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.is_idp_user(auth_profile.username)\n                        ):\n                            secret = ArkSecret(secret='')\n                        else:\n                            secret = ArkSecret(\n                                secret=ArkArgsFormatter.get_arg(\n                                    args,\n                                    f'{authenticator_name}_secret',\n                                    f'{authenticator.authenticator_human_readable_name()} Secret',\n                                    hidden=True,\n                                )\n                            )\n            elif (\n                not ArkSystemConfig.is_interactive()\n                and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n                and not args.__dict__[f'{authenticator_name}_secret']\n            ):\n                raise ArkException(\n                    f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n                )\n            # Perform the authentication, will also cache the token\n            token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n            if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n                shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n            tokens_map[authenticator.authenticator_human_readable_name()] = token\n        if not args.show_tokens and tokens_map:\n            ArkArgsFormatter.print_success('Login tokens are hidden')\n        for k, v in tokens_map.items():\n            if 'cookies' in v.metadata:\n                del v.metadata['cookies']\n            ArkArgsFormatter.print_success(\n                f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n            )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is login\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is login</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is login\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the configuration CLI action Adds for each supported authenticator, its username / secret params for login</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the configuration CLI action\n    Adds for each supported authenticator, its username / secret params for login\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n    self._common_actions_configuration(login_parser)\n    login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n    login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n    login_parser.add_argument(\n        '-nss',\n        '--no-shared-secrets',\n        action='store_true',\n        help='Do not share secrets between different authenticators with the same username',\n    )\n    login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n    login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n    # Add username and secret for each authenticator for logging in\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n            help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n            help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkLoginAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Perform the actual login for each authenticator Once logged in, store its credentials in the keyring for later use</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Perform the actual login for each authenticator\n    Once logged in, store its credentials in the keyring for later use\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    # Load up the profile\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile before trying to login')\n\n    # Login for each auth profile\n    # Share secrets between authenticators for allowed auth methods\n    shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n    # Save tokens for finalization output\n    tokens_map: Dict[str, ArkToken] = dict()\n    for authenticator_name, auth_profile in profile.auth_profiles.items():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n        # Only perform the authentication if not already authenticated and not forced\n        if authenticator.is_authenticated(profile) and not args.force:\n            try:\n                if args.refresh_auth:\n                    token = authenticator.load_authentication(profile, True)\n                    if token:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                        )\n                    else:\n                        raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                else:\n                    ArkArgsFormatter.print_success(\n                        f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                    )\n                continue\n            except Exception as ex:\n                self._logger.info(\n                    f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                )\n        secret = (\n            ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n        )\n        auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n        # Ask the user for the user and secret if interactive\n        if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n            auth_profile.username = ArkArgsFormatter.get_arg(\n                args,\n                f'{authenticator_name}_username',\n                f'{authenticator.authenticator_human_readable_name()} Username',\n                auth_profile.username,\n            )\n            # Check if there is an existing secret who is sharable\n            if (\n                auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                and auth_profile.auth_method in shared_secrets_map\n                and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                and not args.__dict__[f'{authenticator_name}_secret']\n                and not args.no_shared_secrets\n            ):\n                secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n            else:\n                if not args.force and (\n                    (\n                        auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                    )\n                ):\n                    # Check if there is a secret already cached, if there is, no need to ask for password\n                    secret = ArkSecret(secret='')\n                else:\n                    # Check if we really need to ask for a password in specific use cases\n                    if (\n                        authenticator_name == 'isp'\n                        and auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.is_idp_user(auth_profile.username)\n                    ):\n                        secret = ArkSecret(secret='')\n                    else:\n                        secret = ArkSecret(\n                            secret=ArkArgsFormatter.get_arg(\n                                args,\n                                f'{authenticator_name}_secret',\n                                f'{authenticator.authenticator_human_readable_name()} Secret',\n                                hidden=True,\n                            )\n                        )\n        elif (\n            not ArkSystemConfig.is_interactive()\n            and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n            and not args.__dict__[f'{authenticator_name}_secret']\n        ):\n            raise ArkException(\n                f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n            )\n        # Perform the authentication, will also cache the token\n        token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n        if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n            shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n        tokens_map[authenticator.authenticator_human_readable_name()] = token\n    if not args.show_tokens and tokens_map:\n        ArkArgsFormatter.print_success('Login tokens are hidden')\n    for k, v in tokens_map.items():\n        if 'cookies' in v.metadata:\n            del v.metadata['cookies']\n        ArkArgsFormatter.print_success(\n            f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n        )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction","title":"<code>ArkProfilesAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>class ArkProfilesAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the profile CLI action\n        Adds actions for managing multiple profiles\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n        self._common_actions_configuration(profile_parser)\n        profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n        profile_cmd_subparsers.required = True\n        list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n        list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n        list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n        list_profiles_parser.add_argument(\n            '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n        )\n        show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n        show_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n        )\n        delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n        delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n        delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n        clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n        clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n        clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n        clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n        clone_profile_parser.add_argument(\n            '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n        )\n        clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n        add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n        add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n        edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n        edit_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n        )\n\n    def __run_list_action(self, args: argparse.Namespace) -&gt; None:\n        # Start by loading all the profiles\n        profiles: Optional[List[ArkProfile]] = ArkProfileLoader.load_all_profiles()\n        if not profiles:\n            ArkArgsFormatter.print_warning(\n                'No profiles were found',\n            )\n            return\n        # Filter profiles\n        if args.name:\n            profiles = [p for p in profiles if fnmatch(p.profile_name, args.name)]\n        if args.auth_profile:\n            profiles = [p for p in profiles if args.auth_profile in list(p.auth_profiles.keys())]\n        # Print them based on request\n        if args.all:\n            ArkArgsFormatter.print_success(json.dumps([p.dict() for p in profiles], indent=4))\n        else:\n            ArkArgsFormatter.print_success(json.dumps([p.profile_name for p in profiles], indent=4))\n\n    def __run_show_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n\n    def __run_delete_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message=f'Are you sure you want to delete profile {args.profile_name}')],\n                render=ArkInquirerRender(),\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.delete_profile(args.profile_name)\n\n    def __run_clear_action(self, args: argparse.Namespace) -&gt; None:\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message='Are you sure you want to clear all profiles')], render=ArkInquirerRender()\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.clear_all_profiles()\n\n    def __run_clone_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        cloned_profile: ArkProfile = profile.copy(update={'profile_name': args.new_profile_name or f'{profile.profile_name}_clone'})\n        if ArkProfileLoader.profile_exists(cloned_profile.profile_name):\n            if not args.yes:\n                answer = inquirer.prompt(\n                    [\n                        inquirer.Confirm(\n                            'answer', message=f'Are you sure you want to override existing profile {cloned_profile.profile_name}'\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answer or not answer['answer']:\n                    return\n        ArkProfileLoader.save_profile(cloned_profile)\n\n    def __run_add_action(self, args: argparse.Namespace) -&gt; None:\n        if not os.path.exists(args.profile_path):\n            ArkArgsFormatter.print_warning(\n                f'Profile path [{args.profile_path}] does not exist, ignoring',\n            )\n            return\n        try:\n            profile: ArkProfile = ArkProfile.parse_file(args.profile_path)\n            ArkProfileLoader.save_profile(profile)\n        except Exception as ex:\n            self._logger.exception(f'Failed to parser profile [{str(ex)}]')\n            ArkArgsFormatter.print_failure(\n                f'Profile path [{args.profile_path}] failed to be parsed, aborting',\n            )\n            return\n\n    def __run_edit_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        answer = inquirer.prompt(\n            [inquirer.Editor('profile_edit', message=f'Chosen profile [{profile_name}] is about to be edited')],\n            render=ArkInquirerRender(),\n            answers={'profile_edit': profile.json(indent=4)},\n        )\n        edited_profile = ArkProfile.parse_raw(answer['profile_edit'])\n        ArkProfileLoader.save_profile(edited_profile)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Perform the actual profile action\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.profile_cmd == 'list':\n            self.__run_list_action(args)\n        elif args.profile_cmd == 'show':\n            self.__run_show_action(args)\n        elif args.profile_cmd == 'delete':\n            self.__run_delete_action(args)\n        elif args.profile_cmd == 'clear':\n            self.__run_clear_action(args)\n        elif args.profile_cmd == 'clone':\n            self.__run_clone_action(args)\n        elif args.profile_cmd == 'add':\n            self.__run_add_action(args)\n        elif args.profile_cmd == 'edit':\n            self.__run_edit_action(args)\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is profile\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is profile</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is profile\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the profile CLI action Adds actions for managing multiple profiles</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the profile CLI action\n    Adds actions for managing multiple profiles\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n    self._common_actions_configuration(profile_parser)\n    profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n    profile_cmd_subparsers.required = True\n    list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n    list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n    list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n    list_profiles_parser.add_argument(\n        '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n    )\n    show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n    show_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n    )\n    delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n    delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n    delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n    clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n    clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n    clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n    clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n    clone_profile_parser.add_argument(\n        '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n    )\n    clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n    add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n    add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n    edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n    edit_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n    )\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkProfilesAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Perform the actual profile action</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Perform the actual profile action\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.profile_cmd == 'list':\n        self.__run_list_action(args)\n    elif args.profile_cmd == 'show':\n        self.__run_show_action(args)\n    elif args.profile_cmd == 'delete':\n        self.__run_delete_action(args)\n    elif args.profile_cmd == 'clear':\n        self.__run_clear_action(args)\n    elif args.profile_cmd == 'clone':\n        self.__run_clone_action(args)\n    elif args.profile_cmd == 'add':\n        self.__run_add_action(args)\n    elif args.profile_cmd == 'edit':\n        self.__run_edit_action(args)\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction","title":"<code>ArkServiceExecAction</code>","text":"<p>             Bases: <code>ArkExecAction</code></p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>class ArkServiceExecAction(ArkExecAction):\n    def __define_service_exec_action(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; argparse._SubParsersAction:\n        action_parser = subparsers.add_parser(action_def.action_name)\n        action_dest = action_def.action_name\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}'\n        action_subparsers = action_parser.add_subparsers(dest=f\"{action_dest}_action\")\n        action_subparsers.required = True\n        if action_def.schemas:\n            self._define_actions_by_schemas(action_subparsers, action_def.schemas, action_def.defaults)\n        return action_subparsers\n\n    def __define_service_exec_actions(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; None:\n        action_subparsers = self.__define_service_exec_action(action_def, subparsers, parent_actions_def)\n        if action_def.subactions:\n            for subaction in action_def.subactions:\n                self.__define_service_exec_actions(\n                    subaction, action_subparsers, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                )\n\n    def __deduce_action_def(\n        self,\n        args: argparse.Namespace,\n        action_def: ArkServiceActionDefinition,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        action_dest = f'{action_def.action_name}_action'\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}_action'\n        if action_dest in args.__dict__:\n            action_value = args.__dict__[action_dest]\n            if action_def.subactions:\n                for subaction in action_def.subactions:\n                    if subaction.action_name == action_value:\n                        return self.__deduce_action_def(\n                            args, subaction, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                        )\n            return action_def, action_dest\n\n    def __deduce_action_command_def(self, command_name: str, args: argparse.Namespace) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        for action_def in SUPPORTED_SERVICE_ACTIONS:\n            if action_def.action_name == command_name:\n                # Find the fitting action\n                return self.__deduce_action_def(args, action_def)\n\n    @overrides\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines all the supported service actions as cli actions / arguments and schemas\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        for actions in SUPPORTED_SERVICE_ACTIONS:\n            self.__define_service_exec_actions(actions, exec_subparsers)\n\n    @overrides\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Deduces from the arguments the fitting action definition and action\n        Finds the fitting service using the defintinion and executes the sync or async service action\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n        action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n        action_value = args.__dict__[action_dest]\n        api_name = action_dest.replace('_action', '')\n        while '_' in api_name and not hasattr(api, api_name):\n            api_name = api_name.rsplit('_', 1)[0]\n        service = getattr(api, api_name)\n        if action_def.async_actions and action_value in action_def.async_actions:\n            self._run_async_action(service, action_def.schemas, action_value, args)\n        else:\n            self._run_sync_action(service, action_def.schemas, action_value, args)\n\n    @overrides\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether theres a service definition for the command and actions\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>","text":"<p>Checks whether theres a service definition for the command and actions</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether theres a service definition for the command and actions\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>","text":"<p>Defines all the supported service actions as cli actions / arguments and schemas</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines all the supported service actions as cli actions / arguments and schemas\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    for actions in SUPPORTED_SERVICE_ACTIONS:\n        self.__define_service_exec_actions(actions, exec_subparsers)\n</code></pre>"},{"location":"reference/actions/#ark_sdk_python.actions.ArkServiceExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>","text":"<p>Deduces from the arguments the fitting action definition and action Finds the fitting service using the defintinion and executes the sync or async service action</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Deduces from the arguments the fitting action definition and action\n    Finds the fitting service using the defintinion and executes the sync or async service action\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n    action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n    action_value = args.__dict__[action_dest]\n    api_name = action_dest.replace('_action', '')\n    while '_' in api_name and not hasattr(api, api_name):\n        api_name = api_name.rsplit('_', 1)[0]\n    service = getattr(api, api_name)\n    if action_def.async_actions and action_value in action_def.async_actions:\n        self._run_async_action(service, action_def.schemas, action_value, args)\n    else:\n        self._run_sync_action(service, action_def.schemas, action_value, args)\n</code></pre>"},{"location":"reference/actions/ark_action/","title":"ark_action","text":""},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction","title":"<code>ArkAction</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>class ArkAction(ABC):\n    def __init__(self):\n        self._logger = get_logger(app=self.__class__.__name__)\n\n    def _common_actions_configuration(self, parser: argparse.ArgumentParser) -&gt; None:\n        parser.add_argument('-r', '--raw', action='store_true', help='Whether to raw output')\n        parser.add_argument('-s', '--silent', action='store_true', help='Silent execution, no interactiveness')\n        parser.add_argument('-ao', '--allow-output', action='store_true', help='Allow stdout / stderr even when silent and not interactive')\n        parser.add_argument('-v', '--verbose', action='store_true', help='Whether to verbose log')\n        parser.add_argument('-ls', '--logger-style', choices=['default'], help='Which verbose logger style to use', default='default')\n        parser.add_argument(\n            '-ll',\n            '--log-level',\n            help='Log level to use while verbose',\n            choices=['DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL'],\n            default='INFO',\n        )\n        parser.add_argument(\n            '-dcv', '--disable-cert-verification', action='store_true', help='Disables certificate verification on HTTPS calls, unsafe!'\n        )\n        parser.add_argument('-tc', '--trusted-cert', help='Certificate to use for HTTPS calls')\n\n    def _common_actions_execution(self, args: argparse.Namespace) -&gt; None:\n        ArkSystemConfig.enable_color()\n        ArkSystemConfig.enable_interactive()\n        ArkSystemConfig.disable_verbose_logging()\n        ArkSystemConfig.disallow_output()\n        ArkSystemConfig.set_logger_style(args.logger_style)\n        ArkSystemConfig.enable_certificate_verification()\n        if args.raw:\n            ArkSystemConfig.disable_color()\n        if args.silent:\n            ArkSystemConfig.disable_interactive()\n        if args.verbose:\n            ArkSystemConfig.enable_verbose_logging(args.log_level)\n        if args.allow_output:\n            ArkSystemConfig.allow_output()\n        if args.disable_cert_verification:\n            ArkSystemConfig.disable_certificate_verification()\n        elif args.trusted_cert is not None:\n            ArkSystemConfig.set_trusted_certificate(args.trusted_cert)\n        self._logger = get_logger(app=self.__class__.__name__)\n        if 'profile-name' in args:\n            args.profile_name = ArkProfileLoader.deduce_profile_name(args.profile_name)\n        if 'DEPLOY_ENV' not in os.environ:\n            # Last fallback on deploy env\n            os.environ['DEPLOY_ENV'] = 'prod'\n\n    @abstractmethod\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the action as part of the subparsers group\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the actual action for the given arguments\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the given action can be ran with the name and args\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the given action can be ran with the name and args</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the given action can be ran with the name and args\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.define_action","title":"<code>define_action(subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines the action as part of the subparsers group</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the action as part of the subparsers group\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_action/#ark_sdk_python.actions.ark_action.ArkAction.run_action","title":"<code>run_action(args)</code>  <code>abstractmethod</code>","text":"<p>Runs the actual action for the given arguments</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_action.py</code> <pre><code>@abstractmethod\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the actual action for the given arguments\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_cache_action/","title":"ark_cache_action","text":""},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction","title":"<code>ArkCacheAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>class ArkCacheAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the cache CLI action\n        Adds action for clearing cache\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n        self._common_actions_configuration(cache_parser)\n        cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n        cache_cmd_subparsers.required = True\n        cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n\n    def __run_clear_cache_action(self) -&gt; None:\n        if isinstance(ArkKeyring.get_keyring(), BasicKeyring):\n            cache_folder_path = os.path.join(os.path.expanduser('~'), DEFAULT_BASIC_KEYRING_FOLDER)\n            if ARK_BASIC_KEYRING_FOLDER_ENV_VAR in os.environ:\n                cache_folder_path = os.environ[ARK_BASIC_KEYRING_FOLDER_ENV_VAR]\n            os.unlink(f'{cache_folder_path}{os.sep}keyring')\n            os.unlink(f'{cache_folder_path}{os.sep}mac')\n        else:\n            ArkArgsFormatter.print_normal('Cache clear is only valid for basic keyring implementation at the moment')\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Perform the actual cache action\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.cache_cmd == 'clear':\n            self.__run_clear_cache_action()\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is profile\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is profile</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is profile\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'cache'\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the cache CLI action Adds action for clearing cache</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the cache CLI action\n    Adds action for clearing cache\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    cache_parser: argparse.ArgumentParser = subparsers.add_parser('cache')\n    self._common_actions_configuration(cache_parser)\n    cache_cmd_subparsers = cache_parser.add_subparsers(dest=\"cache_cmd\")\n    cache_cmd_subparsers.required = True\n    cache_cmd_subparsers.add_parser('clear', help='Clears all profiles cache')\n</code></pre>"},{"location":"reference/actions/ark_cache_action/#ark_sdk_python.actions.ark_cache_action.ArkCacheAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Perform the actual cache action</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_cache_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Perform the actual cache action\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.cache_cmd == 'clear':\n        self.__run_clear_cache_action()\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/ark_configure_action/","title":"ark_configure_action","text":""},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction","title":"<code>ArkConfigureAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>class ArkConfigureAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the configuration CLI action\n        Adds for each supported authenticator, its fitting parameters and whether to work with it\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n        self._common_actions_configuration(conf_parser)\n\n        # Add the profile settings to the arguments\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n        )\n\n        # Add the supported authenticator settings and whether to work with them or not\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            conf_parser.add_argument(\n                f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n                f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n                action='store_true',\n                help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                conf_parser.add_argument(\n                    f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                    f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                    choices=[am.value for am in authenticator.supported_auth_methods()],\n                    default=ArkAuthMethod.Default.value,\n                )\n            # Add the rest of the ark auth profile params\n            ArkPydanticArgparse.schema_to_argparse(\n                ArkAuthProfile.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n            )\n\n            # Add the supported authentication methods settings of the authenticators\n            for auth_method in authenticator.supported_auth_methods():\n                auth_settings = ArkAuthMethodSettingsMap[auth_method]\n                ArkPydanticArgparse.schema_to_argparse(\n                    auth_settings.schema(by_alias=False),\n                    conf_parser,\n                    key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                    ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n                )\n\n    def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Performs an interactivr configuration\n        Each ark profile setting will be asked by the user, with defaults / supplied cli args\n        Each picked authenticator will also be configured for his auth method and settings\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile first with the given profile name from the user\n        profile_name = ArkArgsFormatter.get_arg(\n            args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n        )\n        profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n        # Fill the rest of the profile settings\n        profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n            ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n        )\n        profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n        if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n            work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n        else:\n            work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n                args,\n                [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n                'Which authenticators would you like to connect to',\n                [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n                {\n                    f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                    for a in SUPPORTED_AUTHENTICATORS_LIST\n                    if a.authenticator_name() in profile.auth_profiles\n                },\n                True,\n            )\n        for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n            # Find out if we are working with the authenticator\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n                # Get the authenticator auth method\n                ArkArgsFormatter.print_success_bright(\n                    ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n                )\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    auth_method = ArkArgsFormatter.get_switch_arg(\n                        args,\n                        f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                        'Authentication Method',\n                        [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                        ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                        if authenticator.authenticator_name() in profile.auth_profiles\n                        else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                        prioritize_existing_val=True,\n                    )\n                    auth_method = next(\n                        filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                    )\n                    # If the default is chosen, override it by the authenticator's default\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n                ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                    authenticator.authenticator_name(), []\n                )\n                # Get the auth profile general settings\n                auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    ArkAuthProfile.schema(by_alias=False),\n                    args,\n                    ignored_keys=ignored_keys,\n                    existing_values=auth_profile.dict(),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    auth_profile_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignore_keys=['auth_method_settings'],\n                )\n\n                # Get the auth method settings and fill them\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                    method_settings.schema(by_alias=False),\n                    args,\n                    existing_values=method_settings.dict(),\n                    override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                    key_prefix=authenticator.authenticator_name(),\n                    ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                    + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                    empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                    default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n                )\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n        \"\"\"\n        Runs the configuration action silently, only from the command line with no user interaction\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        # Load the profile based on the cli params and merge the rest of the params\n        profile = ArkPydanticArgparse.merge_by_model(\n            ArkProfile,\n            ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n            ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n        )\n\n        # Load the authenticators\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n            if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n                if len(authenticator.supported_auth_methods()) &gt; 1:\n                    # Load the auth method\n                    auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                    # If default, fallback to default auth method of the authenticator\n                    if auth_method == ArkAuthMethod.Default:\n                        auth_method, _ = authenticator.default_auth_method()\n                else:\n                    auth_method, _ = authenticator.default_auth_method()\n\n                # Load the rest of the auth profile\n                auth_profile = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthProfile,\n                    auth_profile,\n                    ArkPydanticArgparse.argparse_to_schema(\n                        ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                    ),\n                    key_prefix=authenticator.authenticator_name(),\n                )\n\n                # Make sure if the type requires credentials, a username was supplied\n                if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                    raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n                # Load the method settings\n                method_settings = auth_profile.auth_method_settings\n                if auth_method != auth_profile.auth_method:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method]()\n                else:\n                    method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n                # Parse and merge the method settings from the cli\n                method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                    method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                )\n\n                # Remove the postfix\n                method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n                # Finalize the auth profile\n                auth_profile.auth_method = auth_method\n                auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                    ArkAuthMethodSettingsMap[auth_method],\n                    method_settings,\n                    method_settings_vals,\n                    key_prefix=authenticator.authenticator_name(),\n                    defaults={\n                        k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                        for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                        if k.startswith(f'{authenticator.authenticator_name()}_')\n                    },\n                )\n                profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n            elif authenticator.authenticator_name() in profile.auth_profiles:\n                del profile.auth_profiles[authenticator.authenticator_name()]\n        return profile\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Executes the configuration action\n        Will ask the user questions if interactive based on the authenticators\n        Will save the configured profile once done\n\n        Args:\n            args (argparse.Namespace): _description_\n        \"\"\"\n        # Parse the profile\n        self._common_actions_execution(args)\n        profile: Optional[ArkProfile] = None\n        if ArkSystemConfig.is_interactive():\n            profile = self.__run_interactive_action(args)\n        else:\n            profile = self.__run_silent_action(args)\n\n        # Store it\n        ArkProfileLoader.save_profile(profile)\n\n        # Print out results\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n        ArkArgsFormatter.print_success_bright(\n            f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is configure\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.__run_interactive_action","title":"<code>__run_interactive_action(args)</code>","text":"<p>Performs an interactivr configuration Each ark profile setting will be asked by the user, with defaults / supplied cli args Each picked authenticator will also be configured for his auth method and settings</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_interactive_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Performs an interactivr configuration\n    Each ark profile setting will be asked by the user, with defaults / supplied cli args\n    Each picked authenticator will also be configured for his auth method and settings\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile first with the given profile name from the user\n    profile_name = ArkArgsFormatter.get_arg(\n        args, 'profile_name', 'Profile Name', ArkProfileLoader.deduce_profile_name(), prioritize_existing_val=True\n    )\n    profile = ArkProfileLoader.load_profile(profile_name) or ArkProfile(profile_name=profile_name)\n\n    # Fill the rest of the profile settings\n    profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n        ArkProfile.schema(by_alias=False), args, ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS, existing_values=profile.dict()\n    )\n    profile = ArkPydanticArgparse.merge_by_model(ArkProfile, profile, profile_vals)\n    if len(SUPPORTED_AUTHENTICATORS_LIST) == 1:\n        work_with_authenticators = [SUPPORTED_AUTHENTICATORS_LIST[0].authenticator_human_readable_name()]\n    else:\n        work_with_authenticators = ArkArgsFormatter.get_checkbox_args(\n            args,\n            [f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}' for a in SUPPORTED_AUTHENTICATORS_LIST],\n            'Which authenticators would you like to connect to',\n            [a.authenticator_human_readable_name() for a in SUPPORTED_AUTHENTICATORS_LIST],\n            {\n                f'work_with_{a.authenticator_name().replace(\"-\", \"_\")}': a.authenticator_human_readable_name()\n                for a in SUPPORTED_AUTHENTICATORS_LIST\n                if a.authenticator_name() in profile.auth_profiles\n            },\n            True,\n        )\n    for idx, authenticator in enumerate(SUPPORTED_AUTHENTICATORS_LIST):\n        # Find out if we are working with the authenticator\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if authenticator.authenticator_human_readable_name() in work_with_authenticators:\n            # Get the authenticator auth method\n            ArkArgsFormatter.print_success_bright(\n                ('\\n' if idx != 0 else '') + f'\u25c9 Configuring {authenticator.authenticator_human_readable_name()}',\n            )\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                auth_method = ArkArgsFormatter.get_switch_arg(\n                    args,\n                    f'{authenticator.authenticator_name().replace(\"-\", \"_\")}_auth_method',\n                    'Authentication Method',\n                    [ArkAuthMethodsDescriptionMap[m] for m in authenticator.supported_auth_methods()],\n                    ArkAuthMethodsDescriptionMap[auth_profile.auth_method]\n                    if authenticator.authenticator_name() in profile.auth_profiles\n                    else ArkAuthMethodsDescriptionMap[authenticator.default_auth_method()[0]],\n                    prioritize_existing_val=True,\n                )\n                auth_method = next(\n                    filter(lambda k: ArkAuthMethodsDescriptionMap[k] == auth_method, ArkAuthMethodsDescriptionMap.keys())\n                )\n                # If the default is chosen, override it by the authenticator's default\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n            ignored_keys = CONFIGURATION_IGNORED_INTERACTIVE_KEYS + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(\n                authenticator.authenticator_name(), []\n            )\n            # Get the auth profile general settings\n            auth_profile_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                ArkAuthProfile.schema(by_alias=False),\n                args,\n                ignored_keys=ignored_keys,\n                existing_values=auth_profile.dict(),\n                key_prefix=authenticator.authenticator_name(),\n            )\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                auth_profile_vals,\n                key_prefix=authenticator.authenticator_name(),\n                ignore_keys=['auth_method_settings'],\n            )\n\n            # Get the auth method settings and fill them\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(auth_profile.auth_method_settings)\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema_interactive(\n                method_settings.schema(by_alias=False),\n                args,\n                existing_values=method_settings.dict(),\n                override_aliases=CONFIGURATION_OVERRIDE_ALIASES,\n                key_prefix=authenticator.authenticator_name(),\n                ignored_keys=CONFIGURATION_IGNORED_INTERACTIVE_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_INTERACTIVE_KEYS.get(authenticator.authenticator_name(), []),\n                empty_allowed_keys=CONFIGURATION_ALLOWED_EMPTY_VALUES,\n                default_values=CONFIGURATION_AUTHENTICATORS_DEFAULTS,\n            )\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.__run_silent_action","title":"<code>__run_silent_action(args)</code>","text":"<p>Runs the configuration action silently, only from the command line with no user interaction</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>def __run_silent_action(self, args: argparse.Namespace) -&gt; ArkProfile:\n    \"\"\"\n    Runs the configuration action silently, only from the command line with no user interaction\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    # Load the profile based on the cli params and merge the rest of the params\n    profile = ArkPydanticArgparse.merge_by_model(\n        ArkProfile,\n        ArkProfileLoader.load_profile(args.profile_name) or ArkProfile(profile_name=args.profile_name),\n        ArkPydanticArgparse.argparse_to_schema(ArkProfile.schema(by_alias=False), args),\n    )\n\n    # Load the authenticators\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        auth_profile = profile.auth_profiles.get(authenticator.authenticator_name(), None) or ArkAuthProfile()\n        if args.__dict__[f'work_with_{authenticator.authenticator_name()}']:\n            if len(authenticator.supported_auth_methods()) &gt; 1:\n                # Load the auth method\n                auth_method = ArkAuthMethod(args.__dict__[f'{authenticator.authenticator_name()}_auth_method'])\n\n                # If default, fallback to default auth method of the authenticator\n                if auth_method == ArkAuthMethod.Default:\n                    auth_method, _ = authenticator.default_auth_method()\n            else:\n                auth_method, _ = authenticator.default_auth_method()\n\n            # Load the rest of the auth profile\n            auth_profile = ArkPydanticArgparse.merge_by_model(\n                ArkAuthProfile,\n                auth_profile,\n                ArkPydanticArgparse.argparse_to_schema(\n                    ArkAuthProfile.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n                ),\n                key_prefix=authenticator.authenticator_name(),\n            )\n\n            # Make sure if the type requires credentials, a username was supplied\n            if auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n                raise ArkException(f'Missing username for authenticator [{authenticator.authenticator_human_readable_name()}]')\n\n            # Load the method settings\n            method_settings = auth_profile.auth_method_settings\n            if auth_method != auth_profile.auth_method:\n                method_settings = ArkAuthMethodSettingsMap[auth_method]()\n            else:\n                method_settings = ArkAuthMethodSettingsMap[auth_method].parse_obj(method_settings)\n\n            # Parse and merge the method settings from the cli\n            method_settings_vals = ArkPydanticArgparse.argparse_to_schema(\n                method_settings.schema(by_alias=False), args, key_prefix=authenticator.authenticator_name()\n            )\n\n            # Remove the postfix\n            method_settings_vals = {k.replace(f'{authenticator.authenticator_name()}_', ''): v for k, v in method_settings_vals.items()}\n\n            # Finalize the auth profile\n            auth_profile.auth_method = auth_method\n            auth_profile.auth_method_settings = ArkPydanticArgparse.merge_by_model(\n                ArkAuthMethodSettingsMap[auth_method],\n                method_settings,\n                method_settings_vals,\n                key_prefix=authenticator.authenticator_name(),\n                defaults={\n                    k.replace(f'{authenticator.authenticator_name()}_', ''): v\n                    for k, v in CONFIGURATION_AUTHENTICATORS_DEFAULTS.items()\n                    if k.startswith(f'{authenticator.authenticator_name()}_')\n                },\n            )\n            profile.auth_profiles[authenticator.authenticator_name()] = auth_profile\n        elif authenticator.authenticator_name() in profile.auth_profiles:\n            del profile.auth_profiles[authenticator.authenticator_name()]\n    return profile\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is configure</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is configure\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'configure'\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the configuration CLI action Adds for each supported authenticator, its fitting parameters and whether to work with it</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the configuration CLI action\n    Adds for each supported authenticator, its fitting parameters and whether to work with it\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    conf_parser: argparse.ArgumentParser = subparsers.add_parser('configure')\n    self._common_actions_configuration(conf_parser)\n\n    # Add the profile settings to the arguments\n    ArkPydanticArgparse.schema_to_argparse(\n        ArkProfile.schema(by_alias=False), conf_parser, ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n    )\n\n    # Add the supported authenticator settings and whether to work with them or not\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        conf_parser.add_argument(\n            f'-ww{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}',\n            f'--work-with-{authenticator.authenticator_name().replace(\"_\", \"-\")}',\n            action='store_true',\n            help=f'Whether to work with {authenticator.authenticator_human_readable_name()} services',\n        )\n        if len(authenticator.supported_auth_methods()) &gt; 1:\n            conf_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}am',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-auth-method',\n                choices=[am.value for am in authenticator.supported_auth_methods()],\n                default=ArkAuthMethod.Default.value,\n            )\n        # Add the rest of the ark auth profile params\n        ArkPydanticArgparse.schema_to_argparse(\n            ArkAuthProfile.schema(by_alias=False),\n            conf_parser,\n            key_prefix=authenticator.authenticator_name().replace('_', '-'),\n            ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS,\n        )\n\n        # Add the supported authentication methods settings of the authenticators\n        for auth_method in authenticator.supported_auth_methods():\n            auth_settings = ArkAuthMethodSettingsMap[auth_method]\n            ArkPydanticArgparse.schema_to_argparse(\n                auth_settings.schema(by_alias=False),\n                conf_parser,\n                key_prefix=authenticator.authenticator_name().replace('_', '-'),\n                ignore_keys=CONFIGURATION_IGNORED_DEFINITION_KEYS\n                + CONFIGURATION_AUTHENTICATOR_IGNORED_DEFNITION_KEYS.get(authenticator.authenticator_name(), []),\n            )\n</code></pre>"},{"location":"reference/actions/ark_configure_action/#ark_sdk_python.actions.ark_configure_action.ArkConfigureAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Executes the configuration action Will ask the user questions if interactive based on the authenticators Will save the configured profile once done</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_configure_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Executes the configuration action\n    Will ask the user questions if interactive based on the authenticators\n    Will save the configured profile once done\n\n    Args:\n        args (argparse.Namespace): _description_\n    \"\"\"\n    # Parse the profile\n    self._common_actions_execution(args)\n    profile: Optional[ArkProfile] = None\n    if ArkSystemConfig.is_interactive():\n        profile = self.__run_interactive_action(args)\n    else:\n        profile = self.__run_silent_action(args)\n\n    # Store it\n    ArkProfileLoader.save_profile(profile)\n\n    # Print out results\n    ArkArgsFormatter.print_success(profile.json(indent=4))\n    ArkArgsFormatter.print_success_bright(\n        f\"Profile has been saved to {ArkProfileLoader.profiles_folder()}\",\n    )\n</code></pre>"},{"location":"reference/actions/ark_exec_action/","title":"ark_exec_action","text":""},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction","title":"<code>ArkExecAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>class ArkExecAction(ArkAction):\n    def _serialize_output(self, output: Optional[Union[List, Dict, ArkModel, Generator, Tuple, Any]]) -&gt; str:\n        if output is None:\n            return ''\n        if isinstance(output, Generator):\n            return self._serialize_output(list(itertools.chain.from_iterable([p.items for p in output])))\n        if isinstance(output, list):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, tuple):\n            return json.dumps(\n                [json.loads(a.json(by_alias=False, exclude={'poll_progress_callback'})) for a in output if a is not None], indent=4\n            )\n        elif isinstance(output, dict):\n            return json.dumps(\n                {\n                    k: json.loads(v.json(indent=4, by_alias=False, exclude={'poll_progress_callback'}))\n                    for k, v in output.items()\n                    if k is not None and v is not None\n                },\n                indent=4,\n            )\n        elif issubclass(type(output), ArkModel):\n            return output.json(indent=4, by_alias=False, exclude={'poll_progress_callback'})\n        elif issubclass(type(output), ArkAsyncRequest):\n            return output.async_task.json(indent=4, by_alias=False)\n        return str(output)\n\n    def _write_output_to_file(self, output_path: str, serialized_output: str) -&gt; None:\n        output_path = os.path.abspath(output_path)\n        if not os.path.exists(os.path.dirname(output_path)):\n            os.makedirs(os.path.dirname(output_path), exist_ok=True)\n        with open(output_path, 'w', encoding='utf-8') as f:\n            f.write(serialized_output)\n\n    def _run_async_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            model: ArkPollableModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n            model.poll_progress_callback = ArkPollers.default_poller()\n            output = getattr(service, action.replace('-', '_'))(model)\n            async_req = None\n            if issubclass(type(output), ArkAsyncRequest):\n                async_req = output\n            elif isinstance(output, tuple):\n                for a in output:\n                    if issubclass(type(a), ArkAsyncRequest):\n                        async_req = a\n                        break\n            if async_req is not None:\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path, async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})\n                    )\n                if async_req.task_failed():\n                    if async_req.task_timeout():\n                        ArkArgsFormatter.print_warning(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command due to timeout, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                    else:\n                        ArkArgsFormatter.print_failure(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                        raise ArkException(\n                            f'Failed to execute async command, error:\\n{async_req.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                        )\n                else:\n                    ArkArgsFormatter.print_success(self._serialize_output(output))\n            elif isinstance(output, list) and all(issubclass(type(ar), ArkAsyncRequest) for ar in output):\n                if args.output_path:\n                    self._write_output_to_file(\n                        args.output_path,\n                        json.dumps([ar.async_task.dict(indent=4, by_alias=False, exclude={\"poll_progress_callback\"}) for ar in output]),\n                    )\n                for ar in output:\n                    if ar.task_failed():\n                        if ar.task_timeout():\n                            ArkArgsFormatter.print_warning(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command due to timeout, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                        else:\n                            ArkArgsFormatter.print_failure(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                            raise ArkException(\n                                f'Failed to execute async command, error:\\n{ar.async_task.json(indent=4, by_alias=False, exclude={\"poll_progress_callback\"})}',\n                            )\n                    else:\n                        ArkArgsFormatter.print_success(self._serialize_output(ar))\n            elif output is not None:\n                ArkArgsFormatter.print_success(self._serialize_output(output))\n        except Exception as ex:\n            self._logger.exception(f'Failed running async command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute async command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _run_sync_action(\n        self, service: ArkService, schemas_map: Dict[str, Optional[Type[ArkModel]]], action: str, args: argparse.Namespace\n    ) -&gt; None:\n        try:\n            model_type: Type[ArkPollableModel] = schemas_map[action.replace('_', '-')]\n            if model_type:\n                model: ArkModel = model_type.parse_obj(ArkPydanticArgparse.argparse_to_schema(model_type.schema(), args))\n                output = getattr(service, action.replace('-', '_'))(model)\n            else:\n                output = getattr(service, action.replace('-', '_'))()\n            if output is not None:\n                serialized_output: str = self._serialize_output(output)\n                if args.output_path:\n                    self._write_output_to_file(args.output_path, serialized_output)\n                ArkArgsFormatter.print_success(serialized_output)\n            else:\n                ArkArgsFormatter.print_success(f'{action.replace(\"-\", \" \").title()} finished successfully')\n        except Exception as ex:\n            self._logger.exception(f'Failed running command {action}')\n            ArkArgsFormatter.print_failure(f'Failed to execute command, error:\\n{str(ex)}')\n            self._logger.debug(traceback.format_exc())\n            raise ex\n\n    def _define_actions_by_schemas(\n        self,\n        subparsers: argparse._SubParsersAction,\n        schemas_map: Dict[str, Optional[Type[ArkModel]]],\n        defaults_map: Optional[Dict[str, Dict[str, Any]]] = None,\n    ):\n        for action, schema in schemas_map.items():\n            parser = subparsers.add_parser(action)\n            if schema:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema.schema(), parser, defaults=defaults_map.get(action, None) if defaults_map else None\n                )\n\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the exec action, with subparsers exec for each service\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        exec_parser = None\n        exec_subparsers = None\n        # Check if the exec subparser already exists from previous definitions of a service\n        if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n            # Retrieve the existing exec parser\n            exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n            exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n        else:\n            # Create a new exec parser\n            exec_parser = subparsers.add_parser('exec')\n            self._common_actions_configuration(exec_parser)\n            exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n            exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n            exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n            exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n            exec_parser.add_argument(\n                '-ra',\n                '--refresh-auth',\n                action='store_true',\n                help='If possible, will try to refresh the active authentication before running the actual command',\n            )\n            exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n            exec_subparsers.required = True\n        self.define_exec_action(exec_subparsers)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the action\n        Loads the authenticators from the cache and creates the API with the authenticators\n        Each service will be created on the API based on the given authenticators\n        Runs the actual exec action afterwards with the API\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile and login before trying to exec')\n\n        # Load token from cache for each auth profile\n        authenticators: List[ArkAuth] = []\n        for authenticator_name in profile.auth_profiles.keys():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n            if not authenticator.load_authentication(profile, args.refresh_auth):\n                continue\n            authenticators.append(authenticator)\n\n        if len(authenticators) == 0:\n            raise ArkException(\n                'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n            )\n        if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n            ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n        # Create the CLI API with the authenticators\n        api = ArkCLIAPI(authenticators, profile)\n\n        # Run the actual exec fitting action with the api\n        # Run it with retries as per defined by user\n        retry_call(\n            self.run_exec_action,\n            fargs=[api, args],\n            tries=args.retry_count,\n            delay=1,\n            logger=namedtuple(\"logger\", (\"warning\"))(\n                warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n            ),\n        )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is exec\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n\n    @abstractmethod\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines an exec action for a service with its configurations and args\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n\n    @abstractmethod\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Runs the exec action for a service with its arguments and API\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n\n    @abstractmethod\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether the specific exec service action can be ran\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is exec</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is exec\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'exec' and self.can_run_exec_action(args.command, args)\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>  <code>abstractmethod</code>","text":"<p>Checks whether the specific exec service action can be ran</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether the specific exec service action can be ran\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the exec action, with subparsers exec for each service</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the exec action, with subparsers exec for each service\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    exec_parser = None\n    exec_subparsers = None\n    # Check if the exec subparser already exists from previous definitions of a service\n    if 'exec' in subparsers._name_parser_map.keys():  # pylint: disable=protected-access\n        # Retrieve the existing exec parser\n        exec_parser = subparsers._name_parser_map['exec']  # pylint: disable=protected-access\n        exec_subparsers = exec_parser._subparsers._group_actions[0]  # pylint: disable=protected-access\n    else:\n        # Create a new exec parser\n        exec_parser = subparsers.add_parser('exec')\n        self._common_actions_configuration(exec_parser)\n        exec_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        exec_parser.add_argument('-op', '--output-path', help='Output file to write data to')\n        exec_parser.add_argument('-rf', '--request-file', help='Request file containing the parameters for the exec action')\n        exec_parser.add_argument('-rc', '--retry-count', type=int, help='Retry count for execution', default=1)\n        exec_parser.add_argument(\n            '-ra',\n            '--refresh-auth',\n            action='store_true',\n            help='If possible, will try to refresh the active authentication before running the actual command',\n        )\n        exec_subparsers = exec_parser.add_subparsers(dest=\"command\")\n        exec_subparsers.required = True\n    self.define_exec_action(exec_subparsers)\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>  <code>abstractmethod</code>","text":"<p>Defines an exec action for a service with its configurations and args</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines an exec action for a service with its configurations and args\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Runs the action Loads the authenticators from the cache and creates the API with the authenticators Each service will be created on the API based on the given authenticators Runs the actual exec action afterwards with the API</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the action\n    Loads the authenticators from the cache and creates the API with the authenticators\n    Each service will be created on the API based on the given authenticators\n    Runs the actual exec action afterwards with the API\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile and login before trying to exec')\n\n    # Load token from cache for each auth profile\n    authenticators: List[ArkAuth] = []\n    for authenticator_name in profile.auth_profiles.keys():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n        if not authenticator.load_authentication(profile, args.refresh_auth):\n            continue\n        authenticators.append(authenticator)\n\n    if len(authenticators) == 0:\n        raise ArkException(\n            'Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first'\n        )\n    if len(authenticators) != len(profile.auth_profiles) and ArkSystemConfig.is_interactive():\n        ArkArgsFormatter.print_colored('Not all authenticators are logged in, some of the functionality will be disabled')\n\n    # Create the CLI API with the authenticators\n    api = ArkCLIAPI(authenticators, profile)\n\n    # Run the actual exec fitting action with the api\n    # Run it with retries as per defined by user\n    retry_call(\n        self.run_exec_action,\n        fargs=[api, args],\n        tries=args.retry_count,\n        delay=1,\n        logger=namedtuple(\"logger\", (\"warning\"))(\n            warning=lambda _1, _2, delay: ArkArgsFormatter.print_failure(f\"Retrying in {delay} seconds\")\n        ),\n    )\n</code></pre>"},{"location":"reference/actions/ark_exec_action/#ark_sdk_python.actions.ark_exec_action.ArkExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>  <code>abstractmethod</code>","text":"<p>Runs the exec action for a service with its arguments and API</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_exec_action.py</code> <pre><code>@abstractmethod\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Runs the exec action for a service with its arguments and API\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/actions/ark_login_action/","title":"ark_login_action","text":""},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction","title":"<code>ArkLoginAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>class ArkLoginAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the configuration CLI action\n        Adds for each supported authenticator, its username / secret params for login\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n        self._common_actions_configuration(login_parser)\n        login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n        login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n        login_parser.add_argument(\n            '-nss',\n            '--no-shared-secrets',\n            action='store_true',\n            help='Do not share secrets between different authenticators with the same username',\n        )\n        login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n        login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n        # Add username and secret for each authenticator for logging in\n        for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n                help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n            login_parser.add_argument(\n                f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n                f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n                help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n            )\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Perform the actual login for each authenticator\n        Once logged in, store its credentials in the keyring for later use\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        self._common_actions_execution(args)\n        # Load up the profile\n        profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n        if not profile:\n            raise ArkException('Please configure a profile before trying to login')\n\n        # Login for each auth profile\n        # Share secrets between authenticators for allowed auth methods\n        shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n        # Save tokens for finalization output\n        tokens_map: Dict[str, ArkToken] = dict()\n        for authenticator_name, auth_profile in profile.auth_profiles.items():\n            authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n            # Only perform the authentication if not already authenticated and not forced\n            if authenticator.is_authenticated(profile) and not args.force:\n                try:\n                    if args.refresh_auth:\n                        token = authenticator.load_authentication(profile, True)\n                        if token:\n                            ArkArgsFormatter.print_success(\n                                f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                            )\n                        else:\n                            raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                    else:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                        )\n                    continue\n                except Exception as ex:\n                    self._logger.info(\n                        f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                    )\n            secret = (\n                ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n            )\n            auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n            # Ask the user for the user and secret if interactive\n            if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n                auth_profile.username = ArkArgsFormatter.get_arg(\n                    args,\n                    f'{authenticator_name}_username',\n                    f'{authenticator.authenticator_human_readable_name()} Username',\n                    auth_profile.username,\n                )\n                # Check if there is an existing secret who is sharable\n                if (\n                    auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                    and auth_profile.auth_method in shared_secrets_map\n                    and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                    and not args.__dict__[f'{authenticator_name}_secret']\n                    and not args.no_shared_secrets\n                ):\n                    secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n                else:\n                    if not args.force and (\n                        (\n                            auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                        )\n                    ):\n                        # Check if there is a secret already cached, if there is, no need to ask for password\n                        secret = ArkSecret(secret='')\n                    else:\n                        # Check if we really need to ask for a password in specific use cases\n                        if (\n                            authenticator_name == 'isp'\n                            and auth_profile.auth_method == ArkAuthMethod.Identity\n                            and ArkIdentity.is_idp_user(auth_profile.username)\n                        ):\n                            secret = ArkSecret(secret='')\n                        else:\n                            secret = ArkSecret(\n                                secret=ArkArgsFormatter.get_arg(\n                                    args,\n                                    f'{authenticator_name}_secret',\n                                    f'{authenticator.authenticator_human_readable_name()} Secret',\n                                    hidden=True,\n                                )\n                            )\n            elif (\n                not ArkSystemConfig.is_interactive()\n                and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n                and not args.__dict__[f'{authenticator_name}_secret']\n            ):\n                raise ArkException(\n                    f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n                )\n            # Perform the authentication, will also cache the token\n            token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n            if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n                shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n            tokens_map[authenticator.authenticator_human_readable_name()] = token\n        if not args.show_tokens and tokens_map:\n            ArkArgsFormatter.print_success('Login tokens are hidden')\n        for k, v in tokens_map.items():\n            if 'cookies' in v.metadata:\n                del v.metadata['cookies']\n            ArkArgsFormatter.print_success(\n                f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n            )\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is login\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is login</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is login\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'login'\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the configuration CLI action Adds for each supported authenticator, its username / secret params for login</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the configuration CLI action\n    Adds for each supported authenticator, its username / secret params for login\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    login_parser: argparse.ArgumentParser = subparsers.add_parser('login')\n    self._common_actions_configuration(login_parser)\n    login_parser.add_argument('-pn', '--profile-name', default=ArkProfileLoader.default_profile_name(), help='Profile name to load')\n    login_parser.add_argument('-f', '--force', action='store_true', help='Whether to force login even thou token has not expired yet')\n    login_parser.add_argument(\n        '-nss',\n        '--no-shared-secrets',\n        action='store_true',\n        help='Do not share secrets between different authenticators with the same username',\n    )\n    login_parser.add_argument('-st', '--show-tokens', action='store_true', help='Print out tokens as well if not silent')\n    login_parser.add_argument('-ra', '--refresh-auth', action='store_true', help='If a cache exists, will also try to refresh it')\n\n    # Add username and secret for each authenticator for logging in\n    for authenticator in SUPPORTED_AUTHENTICATORS_LIST:\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}u',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-username',\n            help=f'Username to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n        login_parser.add_argument(\n            f'-{\"\".join([s[:2] for s in authenticator.authenticator_name().split(\"_\")])}s',\n            f'--{authenticator.authenticator_name().replace(\"_\", \"-\")}-secret',\n            help=f'Secret to authenticate with to {authenticator.authenticator_human_readable_name()}',\n        )\n</code></pre>"},{"location":"reference/actions/ark_login_action/#ark_sdk_python.actions.ark_login_action.ArkLoginAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Perform the actual login for each authenticator Once logged in, store its credentials in the keyring for later use</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_login_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Perform the actual login for each authenticator\n    Once logged in, store its credentials in the keyring for later use\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    self._common_actions_execution(args)\n    # Load up the profile\n    profile = ArkProfileLoader.load_profile(ArkProfileLoader.deduce_profile_name(args.profile_name))\n    if not profile:\n        raise ArkException('Please configure a profile before trying to login')\n\n    # Login for each auth profile\n    # Share secrets between authenticators for allowed auth methods\n    shared_secrets_map: Dict[ArkAuthMethod, List[Tuple[str, ArkSecret]]] = {k: [] for k in ArkAuthMethodSharableCredentials}\n    # Save tokens for finalization output\n    tokens_map: Dict[str, ArkToken] = dict()\n    for authenticator_name, auth_profile in profile.auth_profiles.items():\n        authenticator = SUPPORTED_AUTHENTICATORS[authenticator_name]()\n\n        # Only perform the authentication if not already authenticated and not forced\n        if authenticator.is_authenticated(profile) and not args.force:\n            try:\n                if args.refresh_auth:\n                    token = authenticator.load_authentication(profile, True)\n                    if token:\n                        ArkArgsFormatter.print_success(\n                            f'{authenticator.authenticator_human_readable_name()} Authentication Refreshed',\n                        )\n                    else:\n                        raise ArkException(f'{authenticator.authenticator_name()} authentication failed to be refreshed')\n                else:\n                    ArkArgsFormatter.print_success(\n                        f'{authenticator.authenticator_human_readable_name()} Already Authenticated',\n                    )\n                continue\n            except Exception as ex:\n                self._logger.info(\n                    f'{authenticator.authenticator_human_readable_name()} Failed to refresh token, performing normal login [{str(ex)}]'\n                )\n        secret = (\n            ArkSecret(secret=args.__dict__[f'{authenticator_name}_secret']) if args.__dict__[f'{authenticator_name}_secret'] else None\n        )\n        auth_profile.username = args.__dict__[f'{authenticator_name}_username'] or auth_profile.username\n\n        # Ask the user for the user and secret if interactive\n        if ArkSystemConfig.is_interactive() and auth_profile.auth_method in ArkAuthMethodsRequireCredentials:\n            auth_profile.username = ArkArgsFormatter.get_arg(\n                args,\n                f'{authenticator_name}_username',\n                f'{authenticator.authenticator_human_readable_name()} Username',\n                auth_profile.username,\n            )\n            # Check if there is an existing secret who is sharable\n            if (\n                auth_profile.auth_method in ArkAuthMethodSharableCredentials\n                and auth_profile.auth_method in shared_secrets_map\n                and any(auth_profile.username == s[0] for s in shared_secrets_map[auth_profile.auth_method])\n                and not args.__dict__[f'{authenticator_name}_secret']\n                and not args.no_shared_secrets\n            ):\n                secret = next(filter(lambda s: auth_profile.username == s[0], shared_secrets_map[auth_profile.auth_method]))[1]\n            else:\n                if not args.force and (\n                    (\n                        auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.has_cache_record(profile, auth_profile.username, args.refresh_auth)\n                    )\n                ):\n                    # Check if there is a secret already cached, if there is, no need to ask for password\n                    secret = ArkSecret(secret='')\n                else:\n                    # Check if we really need to ask for a password in specific use cases\n                    if (\n                        authenticator_name == 'isp'\n                        and auth_profile.auth_method == ArkAuthMethod.Identity\n                        and ArkIdentity.is_idp_user(auth_profile.username)\n                    ):\n                        secret = ArkSecret(secret='')\n                    else:\n                        secret = ArkSecret(\n                            secret=ArkArgsFormatter.get_arg(\n                                args,\n                                f'{authenticator_name}_secret',\n                                f'{authenticator.authenticator_human_readable_name()} Secret',\n                                hidden=True,\n                            )\n                        )\n        elif (\n            not ArkSystemConfig.is_interactive()\n            and auth_profile.auth_method in ArkAuthMethodsRequireCredentials\n            and not args.__dict__[f'{authenticator_name}_secret']\n        ):\n            raise ArkException(\n                f'{authenticator_name}-secret argument is required if authenticating to {authenticator.authenticator_human_readable_name()}'\n            )\n        # Perform the authentication, will also cache the token\n        token = authenticator.authenticate(profile=profile, secret=secret, force=args.force, refresh_auth=args.refresh_auth)\n        if not args.no_shared_secrets and auth_profile.auth_method in ArkAuthMethodSharableCredentials:\n            shared_secrets_map[auth_profile.auth_method].append((auth_profile.username, secret))\n        tokens_map[authenticator.authenticator_human_readable_name()] = token\n    if not args.show_tokens and tokens_map:\n        ArkArgsFormatter.print_success('Login tokens are hidden')\n    for k, v in tokens_map.items():\n        if 'cookies' in v.metadata:\n            del v.metadata['cookies']\n        ArkArgsFormatter.print_success(\n            f'{k} Token\\n{v.json(indent=4, exclude={} if args.show_tokens else {\"token\", \"refresh_token\"})}',\n        )\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/","title":"ark_profiles_action","text":""},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction","title":"<code>ArkProfilesAction</code>","text":"<p>             Bases: <code>ArkAction</code></p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>class ArkProfilesAction(ArkAction):\n    @overrides\n    def define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines the profile CLI action\n        Adds actions for managing multiple profiles\n\n        Args:\n            subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n        self._common_actions_configuration(profile_parser)\n        profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n        profile_cmd_subparsers.required = True\n        list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n        list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n        list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n        list_profiles_parser.add_argument(\n            '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n        )\n        show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n        show_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n        )\n        delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n        delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n        delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n        clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n        clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n        clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n        clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n        clone_profile_parser.add_argument(\n            '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n        )\n        clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n        add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n        add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n        edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n        edit_profile_parser.add_argument(\n            '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n        )\n\n    def __run_list_action(self, args: argparse.Namespace) -&gt; None:\n        # Start by loading all the profiles\n        profiles: Optional[List[ArkProfile]] = ArkProfileLoader.load_all_profiles()\n        if not profiles:\n            ArkArgsFormatter.print_warning(\n                'No profiles were found',\n            )\n            return\n        # Filter profiles\n        if args.name:\n            profiles = [p for p in profiles if fnmatch(p.profile_name, args.name)]\n        if args.auth_profile:\n            profiles = [p for p in profiles if args.auth_profile in list(p.auth_profiles.keys())]\n        # Print them based on request\n        if args.all:\n            ArkArgsFormatter.print_success(json.dumps([p.dict() for p in profiles], indent=4))\n        else:\n            ArkArgsFormatter.print_success(json.dumps([p.profile_name for p in profiles], indent=4))\n\n    def __run_show_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        ArkArgsFormatter.print_success(profile.json(indent=4))\n\n    def __run_delete_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message=f'Are you sure you want to delete profile {args.profile_name}')],\n                render=ArkInquirerRender(),\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.delete_profile(args.profile_name)\n\n    def __run_clear_action(self, args: argparse.Namespace) -&gt; None:\n        if not args.yes:\n            answer = inquirer.prompt(\n                [inquirer.Confirm('answer', message='Are you sure you want to clear all profiles')], render=ArkInquirerRender()\n            )\n            if not answer or not answer['answer']:\n                return\n        ArkProfileLoader.clear_all_profiles()\n\n    def __run_clone_action(self, args: argparse.Namespace) -&gt; None:\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(args.profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {args.profile_name}',\n            )\n            return\n        cloned_profile: ArkProfile = profile.copy(update={'profile_name': args.new_profile_name or f'{profile.profile_name}_clone'})\n        if ArkProfileLoader.profile_exists(cloned_profile.profile_name):\n            if not args.yes:\n                answer = inquirer.prompt(\n                    [\n                        inquirer.Confirm(\n                            'answer', message=f'Are you sure you want to override existing profile {cloned_profile.profile_name}'\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answer or not answer['answer']:\n                    return\n        ArkProfileLoader.save_profile(cloned_profile)\n\n    def __run_add_action(self, args: argparse.Namespace) -&gt; None:\n        if not os.path.exists(args.profile_path):\n            ArkArgsFormatter.print_warning(\n                f'Profile path [{args.profile_path}] does not exist, ignoring',\n            )\n            return\n        try:\n            profile: ArkProfile = ArkProfile.parse_file(args.profile_path)\n            ArkProfileLoader.save_profile(profile)\n        except Exception as ex:\n            self._logger.exception(f'Failed to parser profile [{str(ex)}]')\n            ArkArgsFormatter.print_failure(\n                f'Profile path [{args.profile_path}] failed to be parsed, aborting',\n            )\n            return\n\n    def __run_edit_action(self, args: argparse.Namespace) -&gt; None:\n        profile_name = args.profile_name or ArkProfileLoader.deduce_profile_name()\n        profile: Optional[ArkProfile] = ArkProfileLoader.load_profile(profile_name)\n        if not profile:\n            ArkArgsFormatter.print_warning(\n                f'No profile was found for the name {profile_name}',\n            )\n            return\n        answer = inquirer.prompt(\n            [inquirer.Editor('profile_edit', message=f'Chosen profile [{profile_name}] is about to be edited')],\n            render=ArkInquirerRender(),\n            answers={'profile_edit': profile.json(indent=4)},\n        )\n        edited_profile = ArkProfile.parse_raw(answer['profile_edit'])\n        ArkProfileLoader.save_profile(edited_profile)\n\n    @overrides\n    def run_action(self, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Perform the actual profile action\n\n        Args:\n            args (argparse.Namespace): _description_\n\n        Raises:\n            ArkException: _description_\n            ArkException: _description_\n        \"\"\"\n        if args.profile_cmd == 'list':\n            self.__run_list_action(args)\n        elif args.profile_cmd == 'show':\n            self.__run_show_action(args)\n        elif args.profile_cmd == 'delete':\n            self.__run_delete_action(args)\n        elif args.profile_cmd == 'clear':\n            self.__run_clear_action(args)\n        elif args.profile_cmd == 'clone':\n            self.__run_clone_action(args)\n        elif args.profile_cmd == 'add':\n            self.__run_add_action(args)\n        elif args.profile_cmd == 'edit':\n            self.__run_edit_action(args)\n        else:\n            raise ArkException(f'Invalid command {args.profile_cmd} given')\n\n    @overrides\n    def can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Asserts the action is profile\n\n        Args:\n            action_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.can_run_action","title":"<code>can_run_action(action_name, args)</code>","text":"<p>Asserts the action is profile</p> <p>Parameters:</p> Name Type Description Default <code>action_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef can_run_action(self, action_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Asserts the action is profile\n\n    Args:\n        action_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return action_name == 'profiles'\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.define_action","title":"<code>define_action(subparsers)</code>","text":"<p>Defines the profile CLI action Adds actions for managing multiple profiles</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef define_action(self, subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines the profile CLI action\n    Adds actions for managing multiple profiles\n\n    Args:\n        subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    profile_parser: argparse.ArgumentParser = subparsers.add_parser('profiles')\n    self._common_actions_configuration(profile_parser)\n    profile_cmd_subparsers = profile_parser.add_subparsers(dest=\"profile_cmd\")\n    profile_cmd_subparsers.required = True\n    list_profiles_parser = profile_cmd_subparsers.add_parser('list', help='List all profiles')\n    list_profiles_parser.add_argument('-n', '--name', help='Profile name to filter with by wildcard')\n    list_profiles_parser.add_argument('-ap', '--auth-profile', help='Filter profiles by auth types')\n    list_profiles_parser.add_argument(\n        '-a', '--all', action='store_true', help='Whether to show all profiles data as well and not only their names'\n    )\n    show_profile_parser = profile_cmd_subparsers.add_parser('show', help='Show a profile')\n    show_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to show, if not given, shows the current one'\n    )\n    delete_profile_parser = profile_cmd_subparsers.add_parser('delete', help='Delete a specific profile')\n    delete_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to delete')\n    delete_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve deletion non interactively')\n    clear_profiles_parser = profile_cmd_subparsers.add_parser('clear', help='Clear all profiles')\n    clear_profiles_parser.add_argument('-y', '--yes', action='store_true', help='Whether to approve clear non interactively')\n    clone_profile_parser = profile_cmd_subparsers.add_parser('clone', help='Clones a profile')\n    clone_profile_parser.add_argument('-pn', '--profile-name', required=True, help='Profile name to clone')\n    clone_profile_parser.add_argument(\n        '-npn', '--new-profile-name', help='New cloned profile name, if not given, will add _clone as part of the name'\n    )\n    clone_profile_parser.add_argument('-y', '--yes', action='store_true', help='Whether to override existing profile if exists')\n    add_profile_parser = profile_cmd_subparsers.add_parser('add', help='Adds a profile to the profiles folder from a given path')\n    add_profile_parser.add_argument('-pp', '--profile-path', required=True, help='Profile file path to be added')\n    edit_profile_parser = profile_cmd_subparsers.add_parser('edit', help='Edits a profile interactively')\n    edit_profile_parser.add_argument(\n        '-pn', '--profile-name', required=False, help='Profile name to edit, if not given, edits the current one'\n    )\n</code></pre>"},{"location":"reference/actions/ark_profiles_action/#ark_sdk_python.actions.ark_profiles_action.ArkProfilesAction.run_action","title":"<code>run_action(args)</code>","text":"<p>Perform the actual profile action</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_profiles_action.py</code> <pre><code>@overrides\ndef run_action(self, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Perform the actual profile action\n\n    Args:\n        args (argparse.Namespace): _description_\n\n    Raises:\n        ArkException: _description_\n        ArkException: _description_\n    \"\"\"\n    if args.profile_cmd == 'list':\n        self.__run_list_action(args)\n    elif args.profile_cmd == 'show':\n        self.__run_show_action(args)\n    elif args.profile_cmd == 'delete':\n        self.__run_delete_action(args)\n    elif args.profile_cmd == 'clear':\n        self.__run_clear_action(args)\n    elif args.profile_cmd == 'clone':\n        self.__run_clone_action(args)\n    elif args.profile_cmd == 'add':\n        self.__run_add_action(args)\n    elif args.profile_cmd == 'edit':\n        self.__run_edit_action(args)\n    else:\n        raise ArkException(f'Invalid command {args.profile_cmd} given')\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/","title":"ark_service_exec_action","text":""},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction","title":"<code>ArkServiceExecAction</code>","text":"<p>             Bases: <code>ArkExecAction</code></p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>class ArkServiceExecAction(ArkExecAction):\n    def __define_service_exec_action(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; argparse._SubParsersAction:\n        action_parser = subparsers.add_parser(action_def.action_name)\n        action_dest = action_def.action_name\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}'\n        action_subparsers = action_parser.add_subparsers(dest=f\"{action_dest}_action\")\n        action_subparsers.required = True\n        if action_def.schemas:\n            self._define_actions_by_schemas(action_subparsers, action_def.schemas, action_def.defaults)\n        return action_subparsers\n\n    def __define_service_exec_actions(\n        self,\n        action_def: ArkServiceActionDefinition,\n        subparsers: argparse._SubParsersAction,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; None:\n        action_subparsers = self.__define_service_exec_action(action_def, subparsers, parent_actions_def)\n        if action_def.subactions:\n            for subaction in action_def.subactions:\n                self.__define_service_exec_actions(\n                    subaction, action_subparsers, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                )\n\n    def __deduce_action_def(\n        self,\n        args: argparse.Namespace,\n        action_def: ArkServiceActionDefinition,\n        parent_actions_def: Optional[List[ArkServiceActionDefinition]] = None,\n    ) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        action_dest = f'{action_def.action_name}_action'\n        if parent_actions_def:\n            action_dest = '_'.join([p.action_name for p in parent_actions_def]) + f'_{action_def.action_name}_action'\n        if action_dest in args.__dict__:\n            action_value = args.__dict__[action_dest]\n            if action_def.subactions:\n                for subaction in action_def.subactions:\n                    if subaction.action_name == action_value:\n                        return self.__deduce_action_def(\n                            args, subaction, parent_actions_def + [action_def] if parent_actions_def else [action_def]\n                        )\n            return action_def, action_dest\n\n    def __deduce_action_command_def(self, command_name: str, args: argparse.Namespace) -&gt; Tuple[ArkServiceActionDefinition, str]:\n        for action_def in SUPPORTED_SERVICE_ACTIONS:\n            if action_def.action_name == command_name:\n                # Find the fitting action\n                return self.__deduce_action_def(args, action_def)\n\n    @overrides\n    def define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n        \"\"\"\n        Defines all the supported service actions as cli actions / arguments and schemas\n\n        Args:\n            exec_subparsers (argparse._SubParsersAction): _description_\n        \"\"\"\n        for actions in SUPPORTED_SERVICE_ACTIONS:\n            self.__define_service_exec_actions(actions, exec_subparsers)\n\n    @overrides\n    def run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n        \"\"\"\n        Deduces from the arguments the fitting action definition and action\n        Finds the fitting service using the defintinion and executes the sync or async service action\n\n        Args:\n            api (ArkCLIAPI): _description_\n            args (argparse.Namespace): _description_\n        \"\"\"\n        action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n        action_value = args.__dict__[action_dest]\n        api_name = action_dest.replace('_action', '')\n        while '_' in api_name and not hasattr(api, api_name):\n            api_name = api_name.rsplit('_', 1)[0]\n        service = getattr(api, api_name)\n        if action_def.async_actions and action_value in action_def.async_actions:\n            self._run_async_action(service, action_def.schemas, action_value, args)\n        else:\n            self._run_sync_action(service, action_def.schemas, action_value, args)\n\n    @overrides\n    def can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n        \"\"\"\n        Checks whether theres a service definition for the command and actions\n\n        Args:\n            command_name (str): _description_\n            args (argparse.Namespace): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.can_run_exec_action","title":"<code>can_run_exec_action(command_name, args)</code>","text":"<p>Checks whether theres a service definition for the command and actions</p> <p>Parameters:</p> Name Type Description Default <code>command_name</code> <code>str</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef can_run_exec_action(self, command_name: str, args: argparse.Namespace) -&gt; bool:\n    \"\"\"\n    Checks whether theres a service definition for the command and actions\n\n    Args:\n        command_name (str): _description_\n        args (argparse.Namespace): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return self.__deduce_action_command_def(command_name, args) is not None\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.define_exec_action","title":"<code>define_exec_action(exec_subparsers)</code>","text":"<p>Defines all the supported service actions as cli actions / arguments and schemas</p> <p>Parameters:</p> Name Type Description Default <code>exec_subparsers</code> <code>_SubParsersAction</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef define_exec_action(self, exec_subparsers: argparse._SubParsersAction) -&gt; None:\n    \"\"\"\n    Defines all the supported service actions as cli actions / arguments and schemas\n\n    Args:\n        exec_subparsers (argparse._SubParsersAction): _description_\n    \"\"\"\n    for actions in SUPPORTED_SERVICE_ACTIONS:\n        self.__define_service_exec_actions(actions, exec_subparsers)\n</code></pre>"},{"location":"reference/actions/ark_service_exec_action/#ark_sdk_python.actions.ark_service_exec_action.ArkServiceExecAction.run_exec_action","title":"<code>run_exec_action(api, args)</code>","text":"<p>Deduces from the arguments the fitting action definition and action Finds the fitting service using the defintinion and executes the sync or async service action</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>ArkCLIAPI</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required Source code in <code>ark_sdk_python/actions/ark_service_exec_action.py</code> <pre><code>@overrides\ndef run_exec_action(self, api: ArkCLIAPI, args: argparse.Namespace) -&gt; None:\n    \"\"\"\n    Deduces from the arguments the fitting action definition and action\n    Finds the fitting service using the defintinion and executes the sync or async service action\n\n    Args:\n        api (ArkCLIAPI): _description_\n        args (argparse.Namespace): _description_\n    \"\"\"\n    action_def, action_dest = self.__deduce_action_command_def(args.command, args)\n    action_value = args.__dict__[action_dest]\n    api_name = action_dest.replace('_action', '')\n    while '_' in api_name and not hasattr(api, api_name):\n        api_name = api_name.rsplit('_', 1)[0]\n    service = getattr(api, api_name)\n    if action_def.async_actions and action_value in action_def.async_actions:\n        self._run_async_action(service, action_def.schemas, action_value, args)\n    else:\n        self._run_sync_action(service, action_def.schemas, action_value, args)\n</code></pre>"},{"location":"reference/args/","title":"args","text":""},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse","title":"<code>ArkPydanticArgparse</code>","text":"Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>class ArkPydanticArgparse:\n    @staticmethod\n    def __populate_type(\n        prop_type: str,\n        snake_prop_name: str,\n        default: Optional[str],\n        required: bool,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        description: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        enum: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '-'\n        if ignore_keys != None and snake_prop_name in ignore_keys:\n            return\n        if default != None:\n            required = False\n        if isinstance(default, Enum):\n            default = default.value\n        arg_type = None\n        if prop_type == 'string':\n            arg_type = str\n        elif prop_type == 'integer':\n            arg_type = int\n        elif prop_type == 'boolean':\n            arg_type = bool\n        elif prop_type == 'object':\n            arg_type = object\n        else:\n            arg_type = str\n        long_name = key_prefix + prefix + snake_prop_name\n        shorted_name = ''.join([s[0] for s in long_name.replace('.', '-').split('-')])\n        for i in range(5):\n            for action in parser._actions:  # pylint: disable=protected-access\n                if f'-{shorted_name}' in action.option_strings:\n                    shorted_name = ''.join([s[: i + 1] for s in long_name.split('-')])\n                    break\n        if arg_type == bool:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                action='store_true',\n                help=description,\n            )\n            if long_name != 'poll':\n                parser.add_argument(\n                    '-n' + shorted_name,\n                    '--no-' + long_name,\n                    dest=long_name.replace('-', '_'),\n                    required='--request-file' not in ' '.join(sys.argv) and required,\n                    action='store_false',\n                    help=description,\n                )\n            parser.set_defaults(**{f\"{long_name.replace('-', '_')}\": default})\n        elif arg_type == object:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                metavar=\"KEY=VALUE\",\n                nargs='+',\n                default=default,\n                help=description,\n            )\n        else:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                type=arg_type,\n                default=default,\n                help=description,\n                choices=enum,\n            )\n\n    @staticmethod\n    def __schema_definition_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if not definitions:\n            return\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n        def_prop = definitions[def_prop_name]\n        if 'type' not in def_prop.keys():\n            return\n        prop_type = def_prop['type']\n        desc = ''\n        if 'description' in def_prop.keys():\n            desc = def_prop['description']\n        default: Optional[str] = None\n        if 'default' in def_prop.keys():\n            default = def_prop['default']\n        elif defaults and prefix + snake_prop_name in defaults:\n            default = defaults[snake_prop_name]\n        if prop_type == 'object':\n            ArkPydanticArgparse.schema_to_argparse(\n                def_prop, parser, defaults, f'{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n            )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in def_prop:\n                enum = def_prop\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n\n    @staticmethod\n    def __schema_allof_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        desc = ''\n        default: Optional[str] = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        for item in schema['properties'][prop_name]['allOf']:\n            if '$ref' in item.keys() and definitions:\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                if 'type' not in item.keys():\n                    continue\n                prop_type = item['type']\n                if 'default' in item.keys():\n                    default = item['default']\n                elif defaults and prefix + snake_prop_name in defaults:\n                    default = defaults[snake_prop_name]\n                if 'description' in item.keys():\n                    desc = item['description']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        item, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in item:\n                        enum = item['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n\n    @staticmethod\n    def __arg_in_schema(arg_key: str, schema: Dict[str, Any], definitions: Optional[Dict[str, Any]], prefix: str = '') -&gt; Optional[str]:\n        if 'properties' not in schema:\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if prefix + snake_prop_name == arg_key:\n                return schema['type']\n            else:\n                return None\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if '$ref' in schema['properties'][prop_name].keys():\n                def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        return 'string'\n                    continue\n                if def_prop['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    return def_prop['type']\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                for item in schema['properties'][prop_name]['allOf']:\n                    if '$ref' in item.keys():\n                        def_prop_name = item['$ref'].split('/')[2]\n                        def_prop = definitions[def_prop_name]\n                        if 'type' not in def_prop.keys():\n                            if 'enum' in def_prop.keys():\n                                return 'string'\n                            continue\n                        if def_prop['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                                return def_prop['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return def_prop['type']\n                    if 'type' in item.keys():\n                        if item['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, item, definitions, f'{prefix}{snake_prop_name}.'):\n                                return item['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return item['type']\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                if prefix + snake_prop_name == arg_key:\n                    return 'string'\n            elif 'type' in schema['properties'][prop_name].keys():\n                if prefix + snake_prop_name == arg_key:\n                    return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(\n                        arg_key, schema['properties'][prop_name], definitions, f'{prefix}{snake_prop_name}.'\n                    ):\n                        return schema['properties'][prop_name]['type']\n        return None\n\n    @staticmethod\n    def __arg_to_schema(\n        arg_key: str, arg_val: Any, args_map: Dict[str, Any], arg_type: str, keep_empty_values: bool = False, key_prefix: str = ''\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if '.' in arg_key:\n            args = arg_key.split('.')\n            key = args[0]\n            if key not in args_map.keys() or args_map[key] == None:\n                args_map[key] = {}\n            ArkPydanticArgparse.__arg_to_schema('.'.join(args[1:]), arg_val, args_map[key], arg_type, key_prefix)\n        elif arg_val != None or keep_empty_values:\n            if arg_type == 'array':\n                if isinstance(arg_val, list):\n                    args_map[key_prefix + arg_key] = arg_val\n                elif re.match('({.*},?)+', arg_val) != None:\n                    objs = []\n                    for m in re.finditer('{.*?}', arg_val):\n                        objs.append(json.loads(m.group(0)))\n                    args_map[key_prefix + arg_key] = objs\n                else:\n                    args_map[key_prefix + arg_key] = arg_val.split(',')\n            elif arg_type == 'object' and not isinstance(arg_val, (int, bool, float)):\n                if isinstance(arg_val, list):\n                    arg_val = ','.join(arg_val)\n                if '=' not in arg_val:\n                    args_map[key_prefix + arg_key] = arg_val\n                else:\n                    args_dict = dict(\n                        next(csv.reader([item], delimiter='=', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                        for item in next(csv.reader([arg_val], delimiter=',', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                    )\n                    if len(args_dict) &gt; 0:\n                        args_map[key_prefix + arg_key] = args_dict\n                    elif arg_key != 'extrafields':\n                        args_map[key_prefix + arg_key] = arg_val\n            else:\n                args_map[key_prefix + arg_key] = arg_val\n\n    @staticmethod\n    def schema_to_argparse(\n        schema: Dict[str, Any],\n        parser: argparse.ArgumentParser,\n        defaults: Optional[Dict[str, str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        required: Optional[List[str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        \"\"\"\n        Converts a given schema to argparse parameters\n        Recursivly goes over the json schema and adds parameters to the parser\n        The argparse parameters can later be parsed from the cli and then converted back using argparse_to_schema\n        Does not return anything and changes the parser inplace\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            parser (argparse.ArgumentParser): _description_\n            defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            required (Optional[List[str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n        \"\"\"\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not required and 'required' in schema.keys():\n            required = schema['required']\n        elif not required:\n            required = []\n        if 'properties' not in schema.keys():\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema.keys():\n                default = schema['default']\n            desc = ''\n            if 'description' in schema.keys():\n                desc = schema['description']\n            enum = None\n            if 'enum' in schema:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            return\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if '$ref' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_definition_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_allof_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                is_required = False\n                if prop_name in required:\n                    is_required = True\n                default = None\n                if 'default' in schema['properties'][prop_name].keys():\n                    default = schema['properties'][prop_name]['default']\n                desc = ''\n                if 'description' in schema['properties'][prop_name].keys():\n                    desc = schema['properties'][prop_name]['description']\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n                continue\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            elif defaults and prefix + snake_prop_name in defaults.keys():\n                default = defaults[snake_prop_name]\n            if 'type' not in schema['properties'][prop_name].keys():\n                if 'enum' in schema['properties'][prop_name].keys():\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                continue\n            prop_type = schema['properties'][prop_name]['type']\n            if prop_type == 'object':\n                if (\n                    'properties' not in schema['properties'][prop_name]\n                    and (\n                        'additionalProperties' in schema['properties'][prop_name]\n                        and 'type' in schema['properties'][prop_name]['additionalProperties']\n                        and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                    )\n                    or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n                ):\n                    # Special use case for dicitionary\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                else:\n                    ArkPydanticArgparse.schema_to_argparse(\n                        schema['properties'][prop_name],\n                        parser,\n                        defaults,\n                        f'{prefix}{snake_prop_name}.',\n                        definitions,\n                        required,\n                        ignore_keys,\n                        key_prefix,\n                    )\n            else:\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n\n    @staticmethod\n    def schema_to_aliases(\n        schema: Dict[str, Any],\n        override_aliases: Optional[Dict[str, str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        key_prefix: str = '',\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n        Converts a schema to only a dictionary containing its aliases (title)\n        Returns a string to string dictionary with the aliases\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n\n        Returns:\n            Dict[str, str]: _description_\n        \"\"\"\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if 'properties' not in schema:\n            return {}\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not override_aliases:\n            override_aliases = {}\n        aliases_map: Dict[str, Any] = {}\n        for prop_name in schema['properties']:\n            snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n                continue\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if snake_prop_name in override_aliases:\n                aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n            else:\n                aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n            if 'type' in schema['properties'][prop_name]:\n                if schema['properties'][prop_name]['type'] == 'object':\n                    aliases_map.update(\n                        ArkPydanticArgparse.schema_to_aliases(\n                            schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                        )\n                    )\n        return aliases_map\n\n    @staticmethod\n    def argparse_to_schema(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        keep_empty_values: bool = False,\n        key_prefix: str = '',\n        ignored_keys: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Performs a conversion of given json schema and argparse args into a finalized dictionary\n        The conversion is recursive and converts keys accordingly to snake case\n        Returns a finalized args dicitionary\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            keep_empty_values (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        file_args_map: Dict = {}\n        args_map: Dict = {}\n        definitions: Optional[Dict] = None\n        if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n            request_file = args.__dict__['request_file']\n            with open(request_file, 'r', encoding='utf-8') as f:\n                loaded_args_map = json.load(f)\n                for key, value in loaded_args_map.items():\n                    first, *others = key.split('_')\n                    file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        for arg_key, arg_val in args.__dict__.items():\n            if ignored_keys and arg_key in ignored_keys:\n                continue\n            if key_prefix:\n                arg_key = arg_key.replace(f'{key_prefix}_', '')\n            arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n            if not arg_type:\n                continue\n            ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n        args_map.update(file_args_map)\n        return args_map\n\n    @staticmethod\n    def argparse_to_schema_interactive(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        ignored_keys: Optional[List[str]] = None,\n        existing_values: Optional[Dict[str, Any]] = None,\n        hidden_keys: Optional[List[str]] = None,\n        override_aliases: Optional[Dict[str, str]] = None,\n        key_prefix: str = '',\n        empty_allowed_keys: Optional[List[str]] = None,\n        default_values: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts a given schema and args to a finalized dictionary\n        Alongside conversion, also interacts with the user for args which were not given in the cli\n        Combines the both and finalize a map to return\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        if key_prefix:\n            existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n        args_map = {\n            k: existing_values[k]\n            if existing_values and k in existing_values and existing_values[k] != None\n            else v\n            if v\n            else default_values[k]\n            if default_values and k in default_values\n            else None\n            for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n        }\n        aliases_map = {\n            k: v\n            for k, v in ArkPydanticArgparse.schema_to_aliases(\n                schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n            ).items()\n            if k in args_map\n        }\n        for k, v in aliases_map.items():\n            if ignored_keys and k in ignored_keys:\n                continue\n            args_map[k] = ArkArgsFormatter.get_arg(\n                args=args,\n                key=k,\n                prompt=v,\n                existing_val=args_map[k],\n                hidden=k in hidden_keys if hidden_keys else False,\n                prioritize_existing_val=True,\n                empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n            )\n        if key_prefix:\n            return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n        return args_map\n\n    @staticmethod\n    def merge_by_model(\n        model: Type[BaseModel],\n        existing_model: BaseModel,\n        new_vals: Union[BaseModel, Dict[str, Any]],\n        by_alias: bool = False,\n        key_prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        defaults: Optional[Dict[str, Any]] = None,\n    ) -&gt; BaseModel:\n        \"\"\"\n        Merges a given existing model with new values\n        The new values can be either a base model or dicitionary of vals\n        The merging is based on key prefix if given\n\n        Args:\n            model (Type[BaseModel]): _description_\n            existing_model (BaseModel): _description_\n            new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n            by_alias (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            BaseModel: _description_\n        \"\"\"\n        if key_prefix:\n            new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n        if isinstance(new_vals, BaseModel):\n            new_vals = new_vals.dict(by_alias=by_alias)\n        new_vals = {k: v for k, v in new_vals.items() if v is not None}\n        vals_dict = existing_model.dict(by_alias=by_alias)\n        if ignore_keys:\n            new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n        vals_dict.update(new_vals)\n        if defaults:\n            vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n        return model.parse_obj(vals_dict)\n\n    @staticmethod\n    def schema_to_simple_arguments(\n        schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Exports model's schema as task's input parameters dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        Returns:\n            Dict[str, TaskInputParameter]: _description_\n        \"\"\"\n        definitions: dict = None\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        parser = argparse.ArgumentParser()\n        ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n        input_args = {}\n        if extra_params:\n            input_args.update(extra_params)\n        for action in parser._actions:  # pylint: disable=protected-access\n            if '_HelpAction' not in str(type(action)):\n                arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n                action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n                if 'strtobool' in str(action_type):\n                    action_type = bool\n                if 'format' in arg_info and arg_info['format'] == 'password':\n                    action_type = 'secret'\n                default = action.default\n                name = action.dest\n                input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n                if default is not None:\n                    input_args[name]['default'] = default\n                if action.choices:\n                    input_args[name]['choices'] = action.choices\n        for _, val in input_args.items():\n            if val['type'] == bool:\n                val['type'] = 'boolean'\n            elif 'choices' in val:\n                val['type'] = 'choice'\n                val['choices'] = [str(v) for v in val['choices']]\n            elif val['type'] != 'secret':\n                val['type'] = 'string'\n            if 'default' not in val:\n                val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n            if val['type'] == 'string':\n                val['default'] = str(val['default'])\n        return input_args\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.argparse_to_schema","title":"<code>argparse_to_schema(schema, args, keep_empty_values=False, key_prefix='', ignored_keys=None)</code>  <code>staticmethod</code>","text":"<p>Performs a conversion of given json schema and argparse args into a finalized dictionary The conversion is recursive and converts keys accordingly to snake case Returns a finalized args dicitionary</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>keep_empty_values</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    keep_empty_values: bool = False,\n    key_prefix: str = '',\n    ignored_keys: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Performs a conversion of given json schema and argparse args into a finalized dictionary\n    The conversion is recursive and converts keys accordingly to snake case\n    Returns a finalized args dicitionary\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        keep_empty_values (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    file_args_map: Dict = {}\n    args_map: Dict = {}\n    definitions: Optional[Dict] = None\n    if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n        request_file = args.__dict__['request_file']\n        with open(request_file, 'r', encoding='utf-8') as f:\n            loaded_args_map = json.load(f)\n            for key, value in loaded_args_map.items():\n                first, *others = key.split('_')\n                file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    for arg_key, arg_val in args.__dict__.items():\n        if ignored_keys and arg_key in ignored_keys:\n            continue\n        if key_prefix:\n            arg_key = arg_key.replace(f'{key_prefix}_', '')\n        arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n        if not arg_type:\n            continue\n        ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n    args_map.update(file_args_map)\n    return args_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.argparse_to_schema_interactive","title":"<code>argparse_to_schema_interactive(schema, args, ignored_keys=None, existing_values=None, hidden_keys=None, override_aliases=None, key_prefix='', empty_allowed_keys=None, default_values=None)</code>  <code>staticmethod</code>","text":"<p>Converts a given schema and args to a finalized dictionary Alongside conversion, also interacts with the user for args which were not given in the cli Combines the both and finalize a map to return</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>existing_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>hidden_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>empty_allowed_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>default_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema_interactive(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    ignored_keys: Optional[List[str]] = None,\n    existing_values: Optional[Dict[str, Any]] = None,\n    hidden_keys: Optional[List[str]] = None,\n    override_aliases: Optional[Dict[str, str]] = None,\n    key_prefix: str = '',\n    empty_allowed_keys: Optional[List[str]] = None,\n    default_values: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts a given schema and args to a finalized dictionary\n    Alongside conversion, also interacts with the user for args which were not given in the cli\n    Combines the both and finalize a map to return\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    if key_prefix:\n        existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n    args_map = {\n        k: existing_values[k]\n        if existing_values and k in existing_values and existing_values[k] != None\n        else v\n        if v\n        else default_values[k]\n        if default_values and k in default_values\n        else None\n        for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n    }\n    aliases_map = {\n        k: v\n        for k, v in ArkPydanticArgparse.schema_to_aliases(\n            schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n        ).items()\n        if k in args_map\n    }\n    for k, v in aliases_map.items():\n        if ignored_keys and k in ignored_keys:\n            continue\n        args_map[k] = ArkArgsFormatter.get_arg(\n            args=args,\n            key=k,\n            prompt=v,\n            existing_val=args_map[k],\n            hidden=k in hidden_keys if hidden_keys else False,\n            prioritize_existing_val=True,\n            empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n        )\n    if key_prefix:\n        return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n    return args_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.merge_by_model","title":"<code>merge_by_model(model, existing_model, new_vals, by_alias=False, key_prefix='', ignore_keys=None, defaults=None)</code>  <code>staticmethod</code>","text":"<p>Merges a given existing model with new values The new values can be either a base model or dicitionary of vals The merging is based on key prefix if given</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>description</p> required <code>existing_model</code> <code>BaseModel</code> <p>description</p> required <code>new_vals</code> <code>Union[BaseModel, Dict[str, Any]]</code> <p>description</p> required <code>by_alias</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>defaults</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef merge_by_model(\n    model: Type[BaseModel],\n    existing_model: BaseModel,\n    new_vals: Union[BaseModel, Dict[str, Any]],\n    by_alias: bool = False,\n    key_prefix: str = '',\n    ignore_keys: Optional[List[str]] = None,\n    defaults: Optional[Dict[str, Any]] = None,\n) -&gt; BaseModel:\n    \"\"\"\n    Merges a given existing model with new values\n    The new values can be either a base model or dicitionary of vals\n    The merging is based on key prefix if given\n\n    Args:\n        model (Type[BaseModel]): _description_\n        existing_model (BaseModel): _description_\n        new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n        by_alias (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        BaseModel: _description_\n    \"\"\"\n    if key_prefix:\n        new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n    if isinstance(new_vals, BaseModel):\n        new_vals = new_vals.dict(by_alias=by_alias)\n    new_vals = {k: v for k, v in new_vals.items() if v is not None}\n    vals_dict = existing_model.dict(by_alias=by_alias)\n    if ignore_keys:\n        new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n    vals_dict.update(new_vals)\n    if defaults:\n        vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n    return model.parse_obj(vals_dict)\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_aliases","title":"<code>schema_to_aliases(schema, override_aliases=None, ignore_keys=None, prefix='', definitions=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a schema to only a dictionary containing its aliases (title) Returns a string to string dictionary with the aliases</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_aliases(\n    schema: Dict[str, Any],\n    override_aliases: Optional[Dict[str, str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    key_prefix: str = '',\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Converts a schema to only a dictionary containing its aliases (title)\n    Returns a string to string dictionary with the aliases\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n\n    Returns:\n        Dict[str, str]: _description_\n    \"\"\"\n    if key_prefix:\n        key_prefix = key_prefix + '_'\n    if 'properties' not in schema:\n        return {}\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not override_aliases:\n        override_aliases = {}\n    aliases_map: Dict[str, Any] = {}\n    for prop_name in schema['properties']:\n        snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n        if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n            continue\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if snake_prop_name in override_aliases:\n            aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n        else:\n            aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n        if 'type' in schema['properties'][prop_name]:\n            if schema['properties'][prop_name]['type'] == 'object':\n                aliases_map.update(\n                    ArkPydanticArgparse.schema_to_aliases(\n                        schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                    )\n                )\n    return aliases_map\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_argparse","title":"<code>schema_to_argparse(schema, parser, defaults=None, prefix='', definitions=None, required=None, ignore_keys=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a given schema to argparse parameters Recursivly goes over the json schema and adds parameters to the parser The argparse parameters can later be parsed from the cli and then converted back using argparse_to_schema Does not return anything and changes the parser inplace</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>parser</code> <code>ArgumentParser</code> <p>description</p> required <code>defaults</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>required</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_argparse(\n    schema: Dict[str, Any],\n    parser: argparse.ArgumentParser,\n    defaults: Optional[Dict[str, str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    required: Optional[List[str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    key_prefix: str = '',\n) -&gt; None:\n    \"\"\"\n    Converts a given schema to argparse parameters\n    Recursivly goes over the json schema and adds parameters to the parser\n    The argparse parameters can later be parsed from the cli and then converted back using argparse_to_schema\n    Does not return anything and changes the parser inplace\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        parser (argparse.ArgumentParser): _description_\n        defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        required (Optional[List[str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n    \"\"\"\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not required and 'required' in schema.keys():\n        required = schema['required']\n    elif not required:\n        required = []\n    if 'properties' not in schema.keys():\n        prop_name = schema['title']\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        is_required = False\n        if prop_name in required:\n            is_required = True\n        default = None\n        if 'default' in schema.keys():\n            default = schema['default']\n        desc = ''\n        if 'description' in schema.keys():\n            desc = schema['description']\n        enum = None\n        if 'enum' in schema:\n            enum = schema['enum']\n        ArkPydanticArgparse.__populate_type(\n            schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n        )\n        return\n    for prop_name in schema['properties'].keys():\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if '$ref' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_definition_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif 'allOf' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_allof_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif (\n            'anyOf' in schema['properties'][prop_name].keys()\n            and isinstance(schema['properties'][prop_name]['anyOf'], list)\n            and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n        ):\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            continue\n        desc = ''\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        default = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'type' not in schema['properties'][prop_name].keys():\n            if 'enum' in schema['properties'][prop_name].keys():\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            continue\n        prop_type = schema['properties'][prop_name]['type']\n        if prop_type == 'object':\n            if (\n                'properties' not in schema['properties'][prop_name]\n                and (\n                    'additionalProperties' in schema['properties'][prop_name]\n                    and 'type' in schema['properties'][prop_name]['additionalProperties']\n                    and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                )\n                or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n            ):\n                # Special use case for dicitionary\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            else:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema['properties'][prop_name],\n                    parser,\n                    defaults,\n                    f'{prefix}{snake_prop_name}.',\n                    definitions,\n                    required,\n                    ignore_keys,\n                    key_prefix,\n                )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['properties'][prop_name]['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n</code></pre>"},{"location":"reference/args/#ark_sdk_python.args.ArkPydanticArgparse.schema_to_simple_arguments","title":"<code>schema_to_simple_arguments(schema, ignore_keys=None, extra_params=None)</code>  <code>staticmethod</code>","text":"<p>Exports model's schema as task's input parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_simple_arguments(\n    schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Exports model's schema as task's input parameters dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n    Returns:\n        Dict[str, TaskInputParameter]: _description_\n    \"\"\"\n    definitions: dict = None\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    parser = argparse.ArgumentParser()\n    ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n    input_args = {}\n    if extra_params:\n        input_args.update(extra_params)\n    for action in parser._actions:  # pylint: disable=protected-access\n        if '_HelpAction' not in str(type(action)):\n            arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n            action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n            if 'strtobool' in str(action_type):\n                action_type = bool\n            if 'format' in arg_info and arg_info['format'] == 'password':\n                action_type = 'secret'\n            default = action.default\n            name = action.dest\n            input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n            if default is not None:\n                input_args[name]['default'] = default\n            if action.choices:\n                input_args[name]['choices'] = action.choices\n    for _, val in input_args.items():\n        if val['type'] == bool:\n            val['type'] = 'boolean'\n        elif 'choices' in val:\n            val['type'] = 'choice'\n            val['choices'] = [str(v) for v in val['choices']]\n        elif val['type'] != 'secret':\n            val['type'] = 'string'\n        if 'default' not in val:\n            val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n        if val['type'] == 'string':\n            val['default'] = str(val['default'])\n    return input_args\n</code></pre>"},{"location":"reference/args/ark_args_formatter/","title":"ark_args_formatter","text":""},{"location":"reference/args/ark_pydantic_argparse/","title":"ark_pydantic_argparse","text":""},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse","title":"<code>ArkPydanticArgparse</code>","text":"Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>class ArkPydanticArgparse:\n    @staticmethod\n    def __populate_type(\n        prop_type: str,\n        snake_prop_name: str,\n        default: Optional[str],\n        required: bool,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        description: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        enum: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '-'\n        if ignore_keys != None and snake_prop_name in ignore_keys:\n            return\n        if default != None:\n            required = False\n        if isinstance(default, Enum):\n            default = default.value\n        arg_type = None\n        if prop_type == 'string':\n            arg_type = str\n        elif prop_type == 'integer':\n            arg_type = int\n        elif prop_type == 'boolean':\n            arg_type = bool\n        elif prop_type == 'object':\n            arg_type = object\n        else:\n            arg_type = str\n        long_name = key_prefix + prefix + snake_prop_name\n        shorted_name = ''.join([s[0] for s in long_name.replace('.', '-').split('-')])\n        for i in range(5):\n            for action in parser._actions:  # pylint: disable=protected-access\n                if f'-{shorted_name}' in action.option_strings:\n                    shorted_name = ''.join([s[: i + 1] for s in long_name.split('-')])\n                    break\n        if arg_type == bool:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                action='store_true',\n                help=description,\n            )\n            if long_name != 'poll':\n                parser.add_argument(\n                    '-n' + shorted_name,\n                    '--no-' + long_name,\n                    dest=long_name.replace('-', '_'),\n                    required='--request-file' not in ' '.join(sys.argv) and required,\n                    action='store_false',\n                    help=description,\n                )\n            parser.set_defaults(**{f\"{long_name.replace('-', '_')}\": default})\n        elif arg_type == object:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                metavar=\"KEY=VALUE\",\n                nargs='+',\n                default=default,\n                help=description,\n            )\n        else:\n            parser.add_argument(\n                '-' + shorted_name,\n                '--' + long_name,\n                required='--request-file' not in ' '.join(sys.argv) and required,\n                type=arg_type,\n                default=default,\n                help=description,\n                choices=enum,\n            )\n\n    @staticmethod\n    def __schema_definition_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        if not definitions:\n            return\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n        def_prop = definitions[def_prop_name]\n        if 'type' not in def_prop.keys():\n            return\n        prop_type = def_prop['type']\n        desc = ''\n        if 'description' in def_prop.keys():\n            desc = def_prop['description']\n        default: Optional[str] = None\n        if 'default' in def_prop.keys():\n            default = def_prop['default']\n        elif defaults and prefix + snake_prop_name in defaults:\n            default = defaults[snake_prop_name]\n        if prop_type == 'object':\n            ArkPydanticArgparse.schema_to_argparse(\n                def_prop, parser, defaults, f'{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n            )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in def_prop:\n                enum = def_prop\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n\n    @staticmethod\n    def __schema_allof_to_argparse(\n        schema: Dict[str, Any],\n        defaults: Optional[Dict[str, str]],\n        definitions: Optional[Dict[str, Any]],\n        required: Optional[List[str]],\n        prop_name: str,\n        parser: argparse.ArgumentParser,\n        prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        desc = ''\n        default: Optional[str] = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        for item in schema['properties'][prop_name]['allOf']:\n            if '$ref' in item.keys() and definitions:\n                def_prop_name = item['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        is_required = False\n                        if required and prop_name in required:\n                            is_required = True\n                        enum = def_prop['enum']\n                        ArkPydanticArgparse.__populate_type(\n                            'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                        )\n                    continue\n                prop_type = def_prop['type']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        def_prop, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in def_prop:\n                        enum = def_prop['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n            else:\n                if 'type' not in item.keys():\n                    continue\n                prop_type = item['type']\n                if 'default' in item.keys():\n                    default = item['default']\n                elif defaults and prefix + snake_prop_name in defaults:\n                    default = defaults[snake_prop_name]\n                if 'description' in item.keys():\n                    desc = item['description']\n                if prop_type == 'object':\n                    ArkPydanticArgparse.schema_to_argparse(\n                        item, parser, defaults, f'{prefix}{snake_prop_name}.', definitions, required, ignore_keys, key_prefix\n                    )\n                else:\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in item:\n                        enum = item['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n\n    @staticmethod\n    def __arg_in_schema(arg_key: str, schema: Dict[str, Any], definitions: Optional[Dict[str, Any]], prefix: str = '') -&gt; Optional[str]:\n        if 'properties' not in schema:\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if prefix + snake_prop_name == arg_key:\n                return schema['type']\n            else:\n                return None\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if '$ref' in schema['properties'][prop_name].keys():\n                def_prop_name = schema['properties'][prop_name]['$ref'].split('/')[2]\n                def_prop = definitions[def_prop_name]\n                if 'type' not in def_prop.keys():\n                    if 'enum' in def_prop.keys():\n                        return 'string'\n                    continue\n                if def_prop['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                        return def_prop['type']\n                if prefix + snake_prop_name == arg_key:\n                    return def_prop['type']\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                for item in schema['properties'][prop_name]['allOf']:\n                    if '$ref' in item.keys():\n                        def_prop_name = item['$ref'].split('/')[2]\n                        def_prop = definitions[def_prop_name]\n                        if 'type' not in def_prop.keys():\n                            if 'enum' in def_prop.keys():\n                                return 'string'\n                            continue\n                        if def_prop['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, def_prop, definitions, f'{prefix}{snake_prop_name}.'):\n                                return def_prop['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return def_prop['type']\n                    if 'type' in item.keys():\n                        if item['type'] == 'object':\n                            if ArkPydanticArgparse.__arg_in_schema(arg_key, item, definitions, f'{prefix}{snake_prop_name}.'):\n                                return item['type']\n                        if prefix + snake_prop_name == arg_key:\n                            return item['type']\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                if prefix + snake_prop_name == arg_key:\n                    return 'string'\n            elif 'type' in schema['properties'][prop_name].keys():\n                if prefix + snake_prop_name == arg_key:\n                    return schema['properties'][prop_name]['type']\n                if schema['properties'][prop_name]['type'] == 'object':\n                    if ArkPydanticArgparse.__arg_in_schema(\n                        arg_key, schema['properties'][prop_name], definitions, f'{prefix}{snake_prop_name}.'\n                    ):\n                        return schema['properties'][prop_name]['type']\n        return None\n\n    @staticmethod\n    def __arg_to_schema(\n        arg_key: str, arg_val: Any, args_map: Dict[str, Any], arg_type: str, keep_empty_values: bool = False, key_prefix: str = ''\n    ) -&gt; None:\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if '.' in arg_key:\n            args = arg_key.split('.')\n            key = args[0]\n            if key not in args_map.keys() or args_map[key] == None:\n                args_map[key] = {}\n            ArkPydanticArgparse.__arg_to_schema('.'.join(args[1:]), arg_val, args_map[key], arg_type, key_prefix)\n        elif arg_val != None or keep_empty_values:\n            if arg_type == 'array':\n                if isinstance(arg_val, list):\n                    args_map[key_prefix + arg_key] = arg_val\n                elif re.match('({.*},?)+', arg_val) != None:\n                    objs = []\n                    for m in re.finditer('{.*?}', arg_val):\n                        objs.append(json.loads(m.group(0)))\n                    args_map[key_prefix + arg_key] = objs\n                else:\n                    args_map[key_prefix + arg_key] = arg_val.split(',')\n            elif arg_type == 'object' and not isinstance(arg_val, (int, bool, float)):\n                if isinstance(arg_val, list):\n                    arg_val = ','.join(arg_val)\n                if '=' not in arg_val:\n                    args_map[key_prefix + arg_key] = arg_val\n                else:\n                    args_dict = dict(\n                        next(csv.reader([item], delimiter='=', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                        for item in next(csv.reader([arg_val], delimiter=',', quotechar=\"'\", escapechar=\"\\\\\", skipinitialspace=True))\n                    )\n                    if len(args_dict) &gt; 0:\n                        args_map[key_prefix + arg_key] = args_dict\n                    elif arg_key != 'extrafields':\n                        args_map[key_prefix + arg_key] = arg_val\n            else:\n                args_map[key_prefix + arg_key] = arg_val\n\n    @staticmethod\n    def schema_to_argparse(\n        schema: Dict[str, Any],\n        parser: argparse.ArgumentParser,\n        defaults: Optional[Dict[str, str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        required: Optional[List[str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        key_prefix: str = '',\n    ) -&gt; None:\n        \"\"\"\n        Converts a given schema to argparse parameters\n        Recursivly goes over the json schema and adds parameters to the parser\n        The argparse parameters can later be parsed from the cli and then converted back using argparse_to_schema\n        Does not return anything and changes the parser inplace\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            parser (argparse.ArgumentParser): _description_\n            defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            required (Optional[List[str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n        \"\"\"\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not required and 'required' in schema.keys():\n            required = schema['required']\n        elif not required:\n            required = []\n        if 'properties' not in schema.keys():\n            prop_name = schema['title']\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema.keys():\n                default = schema['default']\n            desc = ''\n            if 'description' in schema.keys():\n                desc = schema['description']\n            enum = None\n            if 'enum' in schema:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            return\n        for prop_name in schema['properties'].keys():\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if '$ref' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_definition_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif 'allOf' in schema['properties'][prop_name].keys():\n                ArkPydanticArgparse.__schema_allof_to_argparse(\n                    schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n                )\n                continue\n            elif (\n                'anyOf' in schema['properties'][prop_name].keys()\n                and isinstance(schema['properties'][prop_name]['anyOf'], list)\n                and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n            ):\n                snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n                is_required = False\n                if prop_name in required:\n                    is_required = True\n                default = None\n                if 'default' in schema['properties'][prop_name].keys():\n                    default = schema['properties'][prop_name]['default']\n                desc = ''\n                if 'description' in schema['properties'][prop_name].keys():\n                    desc = schema['properties'][prop_name]['description']\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n                continue\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            elif defaults and prefix + snake_prop_name in defaults.keys():\n                default = defaults[snake_prop_name]\n            if 'type' not in schema['properties'][prop_name].keys():\n                if 'enum' in schema['properties'][prop_name].keys():\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                continue\n            prop_type = schema['properties'][prop_name]['type']\n            if prop_type == 'object':\n                if (\n                    'properties' not in schema['properties'][prop_name]\n                    and (\n                        'additionalProperties' in schema['properties'][prop_name]\n                        and 'type' in schema['properties'][prop_name]['additionalProperties']\n                        and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                    )\n                    or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n                ):\n                    # Special use case for dicitionary\n                    is_required = False\n                    if required and prop_name in required:\n                        is_required = True\n                    enum = None\n                    if 'enum' in schema['properties'][prop_name]:\n                        enum = schema['properties'][prop_name]['enum']\n                    ArkPydanticArgparse.__populate_type(\n                        prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                    )\n                else:\n                    ArkPydanticArgparse.schema_to_argparse(\n                        schema['properties'][prop_name],\n                        parser,\n                        defaults,\n                        f'{prefix}{snake_prop_name}.',\n                        definitions,\n                        required,\n                        ignore_keys,\n                        key_prefix,\n                    )\n            else:\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n\n    @staticmethod\n    def schema_to_aliases(\n        schema: Dict[str, Any],\n        override_aliases: Optional[Dict[str, str]] = None,\n        ignore_keys: Optional[List[str]] = None,\n        prefix: str = '',\n        definitions: Optional[Dict[str, Any]] = None,\n        key_prefix: str = '',\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n        Converts a schema to only a dictionary containing its aliases (title)\n        Returns a string to string dictionary with the aliases\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            prefix (str, optional): _description_. Defaults to ''.\n            definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n\n        Returns:\n            Dict[str, str]: _description_\n        \"\"\"\n        if key_prefix:\n            key_prefix = key_prefix + '_'\n        if 'properties' not in schema:\n            return {}\n        if not definitions and 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        elif not definitions:\n            definitions = {}\n        if not override_aliases:\n            override_aliases = {}\n        aliases_map: Dict[str, Any] = {}\n        for prop_name in schema['properties']:\n            snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n            if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n                continue\n            if ignore_keys and snake_prop_name in ignore_keys:\n                continue\n            if snake_prop_name in override_aliases:\n                aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n            else:\n                aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n            if 'type' in schema['properties'][prop_name]:\n                if schema['properties'][prop_name]['type'] == 'object':\n                    aliases_map.update(\n                        ArkPydanticArgparse.schema_to_aliases(\n                            schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                        )\n                    )\n        return aliases_map\n\n    @staticmethod\n    def argparse_to_schema(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        keep_empty_values: bool = False,\n        key_prefix: str = '',\n        ignored_keys: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Performs a conversion of given json schema and argparse args into a finalized dictionary\n        The conversion is recursive and converts keys accordingly to snake case\n        Returns a finalized args dicitionary\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            keep_empty_values (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        file_args_map: Dict = {}\n        args_map: Dict = {}\n        definitions: Optional[Dict] = None\n        if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n            request_file = args.__dict__['request_file']\n            with open(request_file, 'r', encoding='utf-8') as f:\n                loaded_args_map = json.load(f)\n                for key, value in loaded_args_map.items():\n                    first, *others = key.split('_')\n                    file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        for arg_key, arg_val in args.__dict__.items():\n            if ignored_keys and arg_key in ignored_keys:\n                continue\n            if key_prefix:\n                arg_key = arg_key.replace(f'{key_prefix}_', '')\n            arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n            if not arg_type:\n                continue\n            ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n        args_map.update(file_args_map)\n        return args_map\n\n    @staticmethod\n    def argparse_to_schema_interactive(\n        schema: Dict[str, Any],\n        args: argparse.Namespace,\n        ignored_keys: Optional[List[str]] = None,\n        existing_values: Optional[Dict[str, Any]] = None,\n        hidden_keys: Optional[List[str]] = None,\n        override_aliases: Optional[Dict[str, str]] = None,\n        key_prefix: str = '',\n        empty_allowed_keys: Optional[List[str]] = None,\n        default_values: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts a given schema and args to a finalized dictionary\n        Alongside conversion, also interacts with the user for args which were not given in the cli\n        Combines the both and finalize a map to return\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            args (argparse.Namespace): _description_\n            ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n            hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            Dict[str, Any]: _description_\n        \"\"\"\n        if key_prefix:\n            existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n        args_map = {\n            k: existing_values[k]\n            if existing_values and k in existing_values and existing_values[k] != None\n            else v\n            if v\n            else default_values[k]\n            if default_values and k in default_values\n            else None\n            for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n        }\n        aliases_map = {\n            k: v\n            for k, v in ArkPydanticArgparse.schema_to_aliases(\n                schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n            ).items()\n            if k in args_map\n        }\n        for k, v in aliases_map.items():\n            if ignored_keys and k in ignored_keys:\n                continue\n            args_map[k] = ArkArgsFormatter.get_arg(\n                args=args,\n                key=k,\n                prompt=v,\n                existing_val=args_map[k],\n                hidden=k in hidden_keys if hidden_keys else False,\n                prioritize_existing_val=True,\n                empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n            )\n        if key_prefix:\n            return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n        return args_map\n\n    @staticmethod\n    def merge_by_model(\n        model: Type[BaseModel],\n        existing_model: BaseModel,\n        new_vals: Union[BaseModel, Dict[str, Any]],\n        by_alias: bool = False,\n        key_prefix: str = '',\n        ignore_keys: Optional[List[str]] = None,\n        defaults: Optional[Dict[str, Any]] = None,\n    ) -&gt; BaseModel:\n        \"\"\"\n        Merges a given existing model with new values\n        The new values can be either a base model or dicitionary of vals\n        The merging is based on key prefix if given\n\n        Args:\n            model (Type[BaseModel]): _description_\n            existing_model (BaseModel): _description_\n            new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n            by_alias (bool, optional): _description_. Defaults to False.\n            key_prefix (str, optional): _description_. Defaults to ''.\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n        Returns:\n            BaseModel: _description_\n        \"\"\"\n        if key_prefix:\n            new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n        if isinstance(new_vals, BaseModel):\n            new_vals = new_vals.dict(by_alias=by_alias)\n        new_vals = {k: v for k, v in new_vals.items() if v is not None}\n        vals_dict = existing_model.dict(by_alias=by_alias)\n        if ignore_keys:\n            new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n        vals_dict.update(new_vals)\n        if defaults:\n            vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n        return model.parse_obj(vals_dict)\n\n    @staticmethod\n    def schema_to_simple_arguments(\n        schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Exports model's schema as task's input parameters dictionary.\n\n        Args:\n            schema (Dict[str, Any]): _description_\n            ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n            extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        Returns:\n            Dict[str, TaskInputParameter]: _description_\n        \"\"\"\n        definitions: dict = None\n        if 'definitions' in schema.keys():\n            definitions = schema['definitions']\n        parser = argparse.ArgumentParser()\n        ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n        input_args = {}\n        if extra_params:\n            input_args.update(extra_params)\n        for action in parser._actions:  # pylint: disable=protected-access\n            if '_HelpAction' not in str(type(action)):\n                arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n                action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n                if 'strtobool' in str(action_type):\n                    action_type = bool\n                if 'format' in arg_info and arg_info['format'] == 'password':\n                    action_type = 'secret'\n                default = action.default\n                name = action.dest\n                input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n                if default is not None:\n                    input_args[name]['default'] = default\n                if action.choices:\n                    input_args[name]['choices'] = action.choices\n        for _, val in input_args.items():\n            if val['type'] == bool:\n                val['type'] = 'boolean'\n            elif 'choices' in val:\n                val['type'] = 'choice'\n                val['choices'] = [str(v) for v in val['choices']]\n            elif val['type'] != 'secret':\n                val['type'] = 'string'\n            if 'default' not in val:\n                val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n            if val['type'] == 'string':\n                val['default'] = str(val['default'])\n        return input_args\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.argparse_to_schema","title":"<code>argparse_to_schema(schema, args, keep_empty_values=False, key_prefix='', ignored_keys=None)</code>  <code>staticmethod</code>","text":"<p>Performs a conversion of given json schema and argparse args into a finalized dictionary The conversion is recursive and converts keys accordingly to snake case Returns a finalized args dicitionary</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>keep_empty_values</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    keep_empty_values: bool = False,\n    key_prefix: str = '',\n    ignored_keys: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Performs a conversion of given json schema and argparse args into a finalized dictionary\n    The conversion is recursive and converts keys accordingly to snake case\n    Returns a finalized args dicitionary\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        keep_empty_values (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    file_args_map: Dict = {}\n    args_map: Dict = {}\n    definitions: Optional[Dict] = None\n    if 'request_file' in args.__dict__.keys() and args.__dict__['request_file']:\n        request_file = args.__dict__['request_file']\n        with open(request_file, 'r', encoding='utf-8') as f:\n            loaded_args_map = json.load(f)\n            for key, value in loaded_args_map.items():\n                first, *others = key.split('_')\n                file_args_map[''.join([first.lower(), *map(str.title, others)])] = value\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    for arg_key, arg_val in args.__dict__.items():\n        if ignored_keys and arg_key in ignored_keys:\n            continue\n        if key_prefix:\n            arg_key = arg_key.replace(f'{key_prefix}_', '')\n        arg_type = ArkPydanticArgparse.__arg_in_schema(arg_key, schema, definitions)\n        if not arg_type:\n            continue\n        ArkPydanticArgparse.__arg_to_schema(arg_key, arg_val, args_map, arg_type, keep_empty_values, key_prefix)\n    args_map.update(file_args_map)\n    return args_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.argparse_to_schema_interactive","title":"<code>argparse_to_schema_interactive(schema, args, ignored_keys=None, existing_values=None, hidden_keys=None, override_aliases=None, key_prefix='', empty_allowed_keys=None, default_values=None)</code>  <code>staticmethod</code>","text":"<p>Converts a given schema and args to a finalized dictionary Alongside conversion, also interacts with the user for args which were not given in the cli Combines the both and finalize a map to return</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>args</code> <code>Namespace</code> <p>description</p> required <code>ignored_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>existing_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>hidden_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>empty_allowed_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>default_values</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef argparse_to_schema_interactive(\n    schema: Dict[str, Any],\n    args: argparse.Namespace,\n    ignored_keys: Optional[List[str]] = None,\n    existing_values: Optional[Dict[str, Any]] = None,\n    hidden_keys: Optional[List[str]] = None,\n    override_aliases: Optional[Dict[str, str]] = None,\n    key_prefix: str = '',\n    empty_allowed_keys: Optional[List[str]] = None,\n    default_values: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts a given schema and args to a finalized dictionary\n    Alongside conversion, also interacts with the user for args which were not given in the cli\n    Combines the both and finalize a map to return\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        args (argparse.Namespace): _description_\n        ignored_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        existing_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        hidden_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        empty_allowed_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        default_values (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: _description_\n    \"\"\"\n    if key_prefix:\n        existing_values = {f'{key_prefix}_{k}': v for k, v in existing_values.items()}\n    args_map = {\n        k: existing_values[k]\n        if existing_values and k in existing_values and existing_values[k] != None\n        else v\n        if v\n        else default_values[k]\n        if default_values and k in default_values\n        else None\n        for k, v in ArkPydanticArgparse.argparse_to_schema(schema, args, True, key_prefix, ignored_keys).items()\n    }\n    aliases_map = {\n        k: v\n        for k, v in ArkPydanticArgparse.schema_to_aliases(\n            schema, override_aliases=override_aliases, key_prefix=key_prefix, ignore_keys=ignored_keys\n        ).items()\n        if k in args_map\n    }\n    for k, v in aliases_map.items():\n        if ignored_keys and k in ignored_keys:\n            continue\n        args_map[k] = ArkArgsFormatter.get_arg(\n            args=args,\n            key=k,\n            prompt=v,\n            existing_val=args_map[k],\n            hidden=k in hidden_keys if hidden_keys else False,\n            prioritize_existing_val=True,\n            empty_value_allowed=k in empty_allowed_keys if empty_allowed_keys is not None else False,\n        )\n    if key_prefix:\n        return {k.replace(f'{key_prefix}_', ''): v for k, v in args_map.items()}\n    return args_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.merge_by_model","title":"<code>merge_by_model(model, existing_model, new_vals, by_alias=False, key_prefix='', ignore_keys=None, defaults=None)</code>  <code>staticmethod</code>","text":"<p>Merges a given existing model with new values The new values can be either a base model or dicitionary of vals The merging is based on key prefix if given</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>description</p> required <code>existing_model</code> <code>BaseModel</code> <p>description</p> required <code>new_vals</code> <code>Union[BaseModel, Dict[str, Any]]</code> <p>description</p> required <code>by_alias</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>defaults</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef merge_by_model(\n    model: Type[BaseModel],\n    existing_model: BaseModel,\n    new_vals: Union[BaseModel, Dict[str, Any]],\n    by_alias: bool = False,\n    key_prefix: str = '',\n    ignore_keys: Optional[List[str]] = None,\n    defaults: Optional[Dict[str, Any]] = None,\n) -&gt; BaseModel:\n    \"\"\"\n    Merges a given existing model with new values\n    The new values can be either a base model or dicitionary of vals\n    The merging is based on key prefix if given\n\n    Args:\n        model (Type[BaseModel]): _description_\n        existing_model (BaseModel): _description_\n        new_vals (Union[BaseModel, Dict[str, Any]]): _description_\n        by_alias (bool, optional): _description_. Defaults to False.\n        key_prefix (str, optional): _description_. Defaults to ''.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        defaults (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n\n    Returns:\n        BaseModel: _description_\n    \"\"\"\n    if key_prefix:\n        new_vals = {k.replace(f'{key_prefix}_', ''): v for k, v in new_vals.items()}\n    if isinstance(new_vals, BaseModel):\n        new_vals = new_vals.dict(by_alias=by_alias)\n    new_vals = {k: v for k, v in new_vals.items() if v is not None}\n    vals_dict = existing_model.dict(by_alias=by_alias)\n    if ignore_keys:\n        new_vals = {k: v for k, v in new_vals.items() if k not in ignore_keys}\n    vals_dict.update(new_vals)\n    if defaults:\n        vals_dict.update({k: v for k, v in defaults.items() if k not in vals_dict or vals_dict[k] is None})\n    return model.parse_obj(vals_dict)\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_aliases","title":"<code>schema_to_aliases(schema, override_aliases=None, ignore_keys=None, prefix='', definitions=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a schema to only a dictionary containing its aliases (title) Returns a string to string dictionary with the aliases</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>override_aliases</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: description</p> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_aliases(\n    schema: Dict[str, Any],\n    override_aliases: Optional[Dict[str, str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    key_prefix: str = '',\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Converts a schema to only a dictionary containing its aliases (title)\n    Returns a string to string dictionary with the aliases\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        override_aliases (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n\n    Returns:\n        Dict[str, str]: _description_\n    \"\"\"\n    if key_prefix:\n        key_prefix = key_prefix + '_'\n    if 'properties' not in schema:\n        return {}\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not override_aliases:\n        override_aliases = {}\n    aliases_map: Dict[str, Any] = {}\n    for prop_name in schema['properties']:\n        snake_prop_name = prefix + re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('-', '_')\n        if 'title' not in schema['properties'][prop_name] and snake_prop_name not in override_aliases:\n            continue\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if snake_prop_name in override_aliases:\n            aliases_map[key_prefix + snake_prop_name] = override_aliases[snake_prop_name]\n        else:\n            aliases_map[key_prefix + snake_prop_name] = schema['properties'][prop_name]['title']\n        if 'type' in schema['properties'][prop_name]:\n            if schema['properties'][prop_name]['type'] == 'object':\n                aliases_map.update(\n                    ArkPydanticArgparse.schema_to_aliases(\n                        schema['properties'][prop_name], ignore_keys, f'{prefix}{snake_prop_name}.', key_prefix\n                    )\n                )\n    return aliases_map\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_argparse","title":"<code>schema_to_argparse(schema, parser, defaults=None, prefix='', definitions=None, required=None, ignore_keys=None, key_prefix='')</code>  <code>staticmethod</code>","text":"<p>Converts a given schema to argparse parameters Recursivly goes over the json schema and adds parameters to the parser The argparse parameters can later be parsed from the cli and then converted back using argparse_to_schema Does not return anything and changes the parser inplace</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>parser</code> <code>ArgumentParser</code> <p>description</p> required <code>defaults</code> <code>Optional[Dict[str, str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> <code>definitions</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>required</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>description. Defaults to ''.</p> <code>''</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_argparse(\n    schema: Dict[str, Any],\n    parser: argparse.ArgumentParser,\n    defaults: Optional[Dict[str, str]] = None,\n    prefix: str = '',\n    definitions: Optional[Dict[str, Any]] = None,\n    required: Optional[List[str]] = None,\n    ignore_keys: Optional[List[str]] = None,\n    key_prefix: str = '',\n) -&gt; None:\n    \"\"\"\n    Converts a given schema to argparse parameters\n    Recursivly goes over the json schema and adds parameters to the parser\n    The argparse parameters can later be parsed from the cli and then converted back using argparse_to_schema\n    Does not return anything and changes the parser inplace\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        parser (argparse.ArgumentParser): _description_\n        defaults (Optional[Dict[str, str]], optional): _description_. Defaults to None.\n        prefix (str, optional): _description_. Defaults to ''.\n        definitions (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n        required (Optional[List[str]], optional): _description_. Defaults to None.\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        key_prefix (str, optional): _description_. Defaults to ''.\n    \"\"\"\n    if not definitions and 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    elif not definitions:\n        definitions = {}\n    if not required and 'required' in schema.keys():\n        required = schema['required']\n    elif not required:\n        required = []\n    if 'properties' not in schema.keys():\n        prop_name = schema['title']\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        is_required = False\n        if prop_name in required:\n            is_required = True\n        default = None\n        if 'default' in schema.keys():\n            default = schema['default']\n        desc = ''\n        if 'description' in schema.keys():\n            desc = schema['description']\n        enum = None\n        if 'enum' in schema:\n            enum = schema['enum']\n        ArkPydanticArgparse.__populate_type(\n            schema['type'], snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n        )\n        return\n    for prop_name in schema['properties'].keys():\n        snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n        if ignore_keys and snake_prop_name in ignore_keys:\n            continue\n        if '$ref' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_definition_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif 'allOf' in schema['properties'][prop_name].keys():\n            ArkPydanticArgparse.__schema_allof_to_argparse(\n                schema, defaults, definitions, required, prop_name, parser, prefix, ignore_keys, key_prefix\n            )\n            continue\n        elif (\n            'anyOf' in schema['properties'][prop_name].keys()\n            and isinstance(schema['properties'][prop_name]['anyOf'], list)\n            and all('type' in t for t in schema['properties'][prop_name]['anyOf'])\n        ):\n            snake_prop_name = re.sub(r'(?&lt;!^)(?=[A-Z])', '_', prop_name).lower().replace('_', '-')\n            is_required = False\n            if prop_name in required:\n                is_required = True\n            default = None\n            if 'default' in schema['properties'][prop_name].keys():\n                default = schema['properties'][prop_name]['default']\n            desc = ''\n            if 'description' in schema['properties'][prop_name].keys():\n                desc = schema['properties'][prop_name]['description']\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['enum']\n            ArkPydanticArgparse.__populate_type(\n                'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n            continue\n        desc = ''\n        if 'description' in schema['properties'][prop_name].keys():\n            desc = schema['properties'][prop_name]['description']\n        default = None\n        if 'default' in schema['properties'][prop_name].keys():\n            default = schema['properties'][prop_name]['default']\n        elif defaults and prefix + snake_prop_name in defaults.keys():\n            default = defaults[snake_prop_name]\n        if 'type' not in schema['properties'][prop_name].keys():\n            if 'enum' in schema['properties'][prop_name].keys():\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    'string', snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            continue\n        prop_type = schema['properties'][prop_name]['type']\n        if prop_type == 'object':\n            if (\n                'properties' not in schema['properties'][prop_name]\n                and (\n                    'additionalProperties' in schema['properties'][prop_name]\n                    and 'type' in schema['properties'][prop_name]['additionalProperties']\n                    and len(schema['properties'][prop_name]['additionalProperties']) == 1\n                )\n                or (all(k in ['title', 'description', 'type'] for k in schema['properties'][prop_name]))\n            ):\n                # Special use case for dicitionary\n                is_required = False\n                if required and prop_name in required:\n                    is_required = True\n                enum = None\n                if 'enum' in schema['properties'][prop_name]:\n                    enum = schema['properties'][prop_name]['enum']\n                ArkPydanticArgparse.__populate_type(\n                    prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n                )\n            else:\n                ArkPydanticArgparse.schema_to_argparse(\n                    schema['properties'][prop_name],\n                    parser,\n                    defaults,\n                    f'{prefix}{snake_prop_name}.',\n                    definitions,\n                    required,\n                    ignore_keys,\n                    key_prefix,\n                )\n        else:\n            is_required = False\n            if required and prop_name in required:\n                is_required = True\n            enum = None\n            if 'enum' in schema['properties'][prop_name]:\n                enum = schema['properties'][prop_name]['enum']\n            ArkPydanticArgparse.__populate_type(\n                prop_type, snake_prop_name, default, is_required, parser, prefix, desc, ignore_keys, enum, key_prefix\n            )\n</code></pre>"},{"location":"reference/args/ark_pydantic_argparse/#ark_sdk_python.args.ark_pydantic_argparse.ArkPydanticArgparse.schema_to_simple_arguments","title":"<code>schema_to_simple_arguments(schema, ignore_keys=None, extra_params=None)</code>  <code>staticmethod</code>","text":"<p>Exports model's schema as task's input parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>description</p> required <code>ignore_keys</code> <code>Optional[List[str]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/args/ark_pydantic_argparse.py</code> <pre><code>@staticmethod\ndef schema_to_simple_arguments(\n    schema: Dict[str, Any], ignore_keys: Optional[List[str]] = None, extra_params: Optional[Dict[str, Any]] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Exports model's schema as task's input parameters dictionary.\n\n    Args:\n        schema (Dict[str, Any]): _description_\n        ignore_keys (Optional[List[str]], optional): _description_. Defaults to None.\n        extra_params (Optional[Dict[str, Any]], optional): _description_. Defaults to None.\n    Returns:\n        Dict[str, TaskInputParameter]: _description_\n    \"\"\"\n    definitions: dict = None\n    if 'definitions' in schema.keys():\n        definitions = schema['definitions']\n    parser = argparse.ArgumentParser()\n    ArkPydanticArgparse.schema_to_argparse(schema, parser, ignore_keys=ignore_keys)\n    input_args = {}\n    if extra_params:\n        input_args.update(extra_params)\n    for action in parser._actions:  # pylint: disable=protected-access\n        if '_HelpAction' not in str(type(action)):\n            arg_info = ArkPydanticArgparse.__arg_in_schema(action.dest, schema, definitions)\n            action_type = action.type if '_StoreTrueAction' not in str(type(action)) else bool\n            if 'strtobool' in str(action_type):\n                action_type = bool\n            if 'format' in arg_info and arg_info['format'] == 'password':\n                action_type = 'secret'\n            default = action.default\n            name = action.dest\n            input_args[name] = {'type': action_type, 'description': action.help if action.help else ''}\n            if default is not None:\n                input_args[name]['default'] = default\n            if action.choices:\n                input_args[name]['choices'] = action.choices\n    for _, val in input_args.items():\n        if val['type'] == bool:\n            val['type'] = 'boolean'\n        elif 'choices' in val:\n            val['type'] = 'choice'\n            val['choices'] = [str(v) for v in val['choices']]\n        elif val['type'] != 'secret':\n            val['type'] = 'string'\n        if 'default' not in val:\n            val['default'] = '' if val['type'] in ['string', 'secret'] else [] if val['type'] == 'choice' else False\n        if val['type'] == 'string':\n            val['default'] = str(val['default'])\n    return input_args\n</code></pre>"},{"location":"reference/auth/","title":"auth","text":""},{"location":"reference/auth/ark_auth/","title":"ark_auth","text":""},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth","title":"<code>ArkAuth</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>class ArkAuth(ABC):\n    def __init__(self, cache_authentication: bool = True) -&gt; None:\n        self._logger = get_logger(app=self.__class__.__name__)\n        self._cache_authentication = cache_authentication\n        self._cache_keyring = None\n        if cache_authentication:\n            self._cache_keyring = ArkKeyring(self.authenticator_name())\n        self.__token = None\n        self._active_profile = None\n        self._active_auth_profile = None\n\n    def _resolve_cache_postfix(self, auth_profile: ArkAuthProfile) -&gt; str:\n        \"\"\"\n        Resolves the postfix used to get the token based on the auth method\n\n        Args:\n            auth_profile (ArkAuthProfile): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        postfix = auth_profile.username\n        if auth_profile.auth_method == ArkAuthMethod.Direct and auth_profile.auth_method_settings:\n            direct_method_settings = cast(DirectArkAuthMethodSettings, auth_profile.auth_method_settings)\n            if direct_method_settings.endpoint:\n                postfix = f'{postfix}_{urlparse(direct_method_settings.endpoint).netloc}'\n        return postfix\n\n    @abstractmethod\n    def _perform_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n    ) -&gt; ArkToken:\n        \"\"\"\n        Performs the actual authentication, based on the implementation\n\n        Args:\n            profile (ArkProfile): Profile to authenticate on\n            auth_profile (ArkAuthProfile): Specific auth profile for the authentication\n            secret (Optional[ArkSecret]): Secret used for authentication. Defaults to None\n            force (bool): Force authenticate and ignore caching\n\n        Returns:\n            Optional[ArkToken]: Token of the authentication to be used\n        \"\"\"\n\n    @abstractmethod\n    def _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        \"\"\"\n        Tries to perform refresh authentication on the existing token\n        This is not promised for all authenticators\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            token (ArkToken): _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n\n    def authenticate(\n        self,\n        profile: Optional[ArkProfile] = None,\n        auth_profile: Optional[ArkAuthProfile] = None,\n        secret: Optional[ArkSecret] = None,\n        force: bool = False,\n        refresh_auth: bool = False,\n    ) -&gt; ArkToken:\n        \"\"\"\n        Authenticates with the specific authenticator implementation\n        The implementation is based on the _perform_authentication method\n        Alongside that, if caching is allowed, will also cache / load from cache the credentials\n\n        Args:\n            profile (Optional[ArkProfile]): Profile containing information about the environemnt and authentication profiles\n            auth_profile (Optional[ArkAuthProfile]): Specific auth profile to be used instead of looking at the profile if given\n            secret (Optional[ArkSecret]): Secret used for authentication\n            force (bool): Whether to force authenticate and discard cache\n            refresh_auth (bool): Tries to refresh an existing cached auth if possible\n\n        Raises:\n            ArkAuthException: _description_\n\n        Returns:\n            ArkToken: Token of the authentication to be used, the token is also saved within the class\n        \"\"\"\n        if not auth_profile and not profile:\n            raise ArkAuthException('Either a profile or a specific auth profile must be supplied')\n        if not auth_profile and profile:\n            if self.authenticator_name() in profile.auth_profiles:\n                auth_profile = profile.auth_profiles[self.authenticator_name()]\n            else:\n                raise ArkAuthException(\n                    f'{self.authenticator_human_readable_name()} [{self.authenticator_name()}] is not defined within the authentication profiles'\n                )\n        if not profile:\n            profile = ArkProfileLoader.load_default_profile()\n        if auth_profile.auth_method not in self.supported_auth_methods() and auth_profile.auth_method != ArkAuthMethod.Default:\n            raise ArkAuthException(\n                f'{self.authenticator_human_readable_name()} does not support authentication method {auth_profile.auth_method}'\n            )\n        if auth_profile.auth_method == ArkAuthMethod.Default:\n            auth_profile.auth_method, auth_profile.auth_method_settings = self.default_auth_method()\n        if auth_profile.auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n            raise ArkAuthException(f'{self.authenticator_human_readable_name()} requires a username and optionally a secret')\n        ark_token = None\n        token_refreshed = False\n        if self._cache_authentication and self._cache_keyring and not force:\n            # Load the postfix of the token based on the auth profile and method type\n            ark_token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n            if ark_token and ark_token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                # Expired, try to refresh\n                if refresh_auth and ark_token.refresh_token:\n                    ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                    if ark_token:\n                        token_refreshed = True\n                else:\n                    ark_token = None\n        if not ark_token:\n            ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        elif refresh_auth and not token_refreshed:\n            try:\n                ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                if self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n            except Exception as ex:  # Fallback to normal authentication\n                self._logger.info(\n                    f'Refresh auth for [{self.authenticator_human_readable_name()}] failed, falling back to normal authentication [{str(ex)}]'\n                )\n                ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n                if self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        self.__token = ark_token\n        self._active_profile = profile\n        self._active_auth_profile = auth_profile\n        return ark_token\n\n    def is_authenticated(self, profile: ArkProfile) -&gt; bool:\n        \"\"\"\n        Checks whether we are authenticated, either from the keyring or in memory\n        If from keyring, will also load it into memory\n\n        Args:\n            profile (ArkProfile): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        self._logger.info(f'Checking if [{self.authenticator_name()}] is authenticated')\n        if self.__token:\n            self._logger.info('Token is already loaded')\n            return True\n        if self.authenticator_name() in profile.auth_profiles and self._cache_keyring:\n            self.__token = self._cache_keyring.load_token(profile, profile.auth_profiles[self.authenticator_name()].username)\n            if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                self.__token = None\n            else:\n                self._logger.info('Loaded token from cache successfully')\n            return self.__token != None\n        return False\n\n    def load_authentication(self, profile: Optional[ArkProfile] = None, refresh_auth: bool = False) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads the authentication token from the cache if exists and returns it\n        Can also refresh it if need be\n\n        Args:\n            profile (Optional[ArkProfile], optional): _description_. Defaults to None.\n            refresh_auth (bool, optional): _description_. Defaults to False.\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        self._logger.info(f'Trying to load [{self.authenticator_name()}] authentication')\n        if not profile:\n            if self._active_profile:\n                profile = self._active_profile\n            else:\n                profile = ArkProfileLoader.load_default_profile()\n        auth_profile = self._active_auth_profile\n        if not auth_profile and self.authenticator_name() in profile.auth_profiles:\n            auth_profile = profile.auth_profiles[self.authenticator_name()]\n        if auth_profile:\n            self._logger.info(\n                f'Loading authentication for profile [{profile.profile_name}] and auth profile [{self.authenticator_name()}] of type [{auth_profile.auth_method.value}]'\n            )\n            if self._cache_keyring:\n                self.__token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n            if refresh_auth:\n                if (\n                    self.__token\n                    and self.__token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)\n                    &gt; datetime.now()\n                ):\n                    self._logger.info('Token did not pass grace expiration, no need to refresh')\n                else:\n                    self._logger.info('Trying to refresh token authentication')\n                    self.__token = self._perform_refresh_authentication(profile, auth_profile, self.__token)\n                    if self.__token and self.__token.expires_in.replace(tzinfo=None) &gt; datetime.now():\n                        self._logger.info('Token refreshed')\n                    if self.__token and self._cache_authentication and self._cache_keyring:\n                        self._cache_keyring.save_token(profile, self.__token, self._resolve_cache_postfix(auth_profile))\n            if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n                self.__token = None\n            if self.__token:\n                self._active_profile = profile\n                self._active_auth_profile = auth_profile\n            return self.__token\n        return None\n\n    @property\n    def token(self) -&gt; Optional[ArkToken]:\n        return self.__token\n\n    @property\n    def active_profile(self) -&gt; Optional[ArkProfile]:\n        return self._active_profile\n\n    @property\n    def active_auth_profile(self) -&gt; Optional[ArkAuthProfile]:\n        return self._active_auth_profile\n\n    @staticmethod\n    @abstractmethod\n    def authenticator_name() -&gt; str:\n        \"\"\"\n        Name of the authenticator to be used for the auth profiles and services\n\n        Returns:\n            str: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def authenticator_human_readable_name() -&gt; str:\n        \"\"\"\n        Human readable name of the authenticator to be used for representation to the user\n\n        Returns:\n            str: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def supported_auth_methods() -&gt; List[ArkAuthMethod]:\n        \"\"\"\n        Supported authenticaton methods by this authenticator\n\n        Returns:\n            List[ArkAuthMethod]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n        \"\"\"\n        Default authentication method used by this authenticator with its default settings\n\n        Returns:\n            Tuple[ArkAuthMethod, ArkAuthMethodSettings]: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticate","title":"<code>authenticate(profile=None, auth_profile=None, secret=None, force=False, refresh_auth=False)</code>","text":"<p>Authenticates with the specific authenticator implementation The implementation is based on the _perform_authentication method Alongside that, if caching is allowed, will also cache / load from cache the credentials</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile containing information about the environemnt and authentication profiles</p> <code>None</code> <code>auth_profile</code> <code>Optional[ArkAuthProfile]</code> <p>Specific auth profile to be used instead of looking at the profile if given</p> <code>None</code> <code>secret</code> <code>Optional[ArkSecret]</code> <p>Secret used for authentication</p> <code>None</code> <code>force</code> <code>bool</code> <p>Whether to force authenticate and discard cache</p> <code>False</code> <code>refresh_auth</code> <code>bool</code> <p>Tries to refresh an existing cached auth if possible</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkToken</code> <code>ArkToken</code> <p>Token of the authentication to be used, the token is also saved within the class</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def authenticate(\n    self,\n    profile: Optional[ArkProfile] = None,\n    auth_profile: Optional[ArkAuthProfile] = None,\n    secret: Optional[ArkSecret] = None,\n    force: bool = False,\n    refresh_auth: bool = False,\n) -&gt; ArkToken:\n    \"\"\"\n    Authenticates with the specific authenticator implementation\n    The implementation is based on the _perform_authentication method\n    Alongside that, if caching is allowed, will also cache / load from cache the credentials\n\n    Args:\n        profile (Optional[ArkProfile]): Profile containing information about the environemnt and authentication profiles\n        auth_profile (Optional[ArkAuthProfile]): Specific auth profile to be used instead of looking at the profile if given\n        secret (Optional[ArkSecret]): Secret used for authentication\n        force (bool): Whether to force authenticate and discard cache\n        refresh_auth (bool): Tries to refresh an existing cached auth if possible\n\n    Raises:\n        ArkAuthException: _description_\n\n    Returns:\n        ArkToken: Token of the authentication to be used, the token is also saved within the class\n    \"\"\"\n    if not auth_profile and not profile:\n        raise ArkAuthException('Either a profile or a specific auth profile must be supplied')\n    if not auth_profile and profile:\n        if self.authenticator_name() in profile.auth_profiles:\n            auth_profile = profile.auth_profiles[self.authenticator_name()]\n        else:\n            raise ArkAuthException(\n                f'{self.authenticator_human_readable_name()} [{self.authenticator_name()}] is not defined within the authentication profiles'\n            )\n    if not profile:\n        profile = ArkProfileLoader.load_default_profile()\n    if auth_profile.auth_method not in self.supported_auth_methods() and auth_profile.auth_method != ArkAuthMethod.Default:\n        raise ArkAuthException(\n            f'{self.authenticator_human_readable_name()} does not support authentication method {auth_profile.auth_method}'\n        )\n    if auth_profile.auth_method == ArkAuthMethod.Default:\n        auth_profile.auth_method, auth_profile.auth_method_settings = self.default_auth_method()\n    if auth_profile.auth_method in ArkAuthMethodsRequireCredentials and not auth_profile.username:\n        raise ArkAuthException(f'{self.authenticator_human_readable_name()} requires a username and optionally a secret')\n    ark_token = None\n    token_refreshed = False\n    if self._cache_authentication and self._cache_keyring and not force:\n        # Load the postfix of the token based on the auth profile and method type\n        ark_token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n        if ark_token and ark_token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            # Expired, try to refresh\n            if refresh_auth and ark_token.refresh_token:\n                ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n                if ark_token:\n                    token_refreshed = True\n            else:\n                ark_token = None\n    if not ark_token:\n        ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n        if self._cache_authentication and self._cache_keyring:\n            self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n    elif refresh_auth and not token_refreshed:\n        try:\n            ark_token = self._perform_refresh_authentication(profile, auth_profile, ark_token)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n        except Exception as ex:  # Fallback to normal authentication\n            self._logger.info(\n                f'Refresh auth for [{self.authenticator_human_readable_name()}] failed, falling back to normal authentication [{str(ex)}]'\n            )\n            ark_token = self._perform_authentication(profile, auth_profile, secret, force)\n            if self._cache_authentication and self._cache_keyring:\n                self._cache_keyring.save_token(profile, ark_token, self._resolve_cache_postfix(auth_profile))\n    self.__token = ark_token\n    self._active_profile = profile\n    self._active_auth_profile = auth_profile\n    return ark_token\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticator_human_readable_name","title":"<code>authenticator_human_readable_name()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Human readable name of the authenticator to be used for representation to the user</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef authenticator_human_readable_name() -&gt; str:\n    \"\"\"\n    Human readable name of the authenticator to be used for representation to the user\n\n    Returns:\n        str: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.authenticator_name","title":"<code>authenticator_name()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Name of the authenticator to be used for the auth profiles and services</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef authenticator_name() -&gt; str:\n    \"\"\"\n    Name of the authenticator to be used for the auth profiles and services\n\n    Returns:\n        str: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.default_auth_method","title":"<code>default_auth_method()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Default authentication method used by this authenticator with its default settings</p> <p>Returns:</p> Type Description <code>Tuple[ArkAuthMethod, ArkAuthMethodSettings]</code> <p>Tuple[ArkAuthMethod, ArkAuthMethodSettings]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n    \"\"\"\n    Default authentication method used by this authenticator with its default settings\n\n    Returns:\n        Tuple[ArkAuthMethod, ArkAuthMethodSettings]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.is_authenticated","title":"<code>is_authenticated(profile)</code>","text":"<p>Checks whether we are authenticated, either from the keyring or in memory If from keyring, will also load it into memory</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def is_authenticated(self, profile: ArkProfile) -&gt; bool:\n    \"\"\"\n    Checks whether we are authenticated, either from the keyring or in memory\n    If from keyring, will also load it into memory\n\n    Args:\n        profile (ArkProfile): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    self._logger.info(f'Checking if [{self.authenticator_name()}] is authenticated')\n    if self.__token:\n        self._logger.info('Token is already loaded')\n        return True\n    if self.authenticator_name() in profile.auth_profiles and self._cache_keyring:\n        self.__token = self._cache_keyring.load_token(profile, profile.auth_profiles[self.authenticator_name()].username)\n        if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            self.__token = None\n        else:\n            self._logger.info('Loaded token from cache successfully')\n        return self.__token != None\n    return False\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.load_authentication","title":"<code>load_authentication(profile=None, refresh_auth=False)</code>","text":"<p>Loads the authentication token from the cache if exists and returns it Can also refresh it if need be</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>description. Defaults to None.</p> <code>None</code> <code>refresh_auth</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>def load_authentication(self, profile: Optional[ArkProfile] = None, refresh_auth: bool = False) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads the authentication token from the cache if exists and returns it\n    Can also refresh it if need be\n\n    Args:\n        profile (Optional[ArkProfile], optional): _description_. Defaults to None.\n        refresh_auth (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    self._logger.info(f'Trying to load [{self.authenticator_name()}] authentication')\n    if not profile:\n        if self._active_profile:\n            profile = self._active_profile\n        else:\n            profile = ArkProfileLoader.load_default_profile()\n    auth_profile = self._active_auth_profile\n    if not auth_profile and self.authenticator_name() in profile.auth_profiles:\n        auth_profile = profile.auth_profiles[self.authenticator_name()]\n    if auth_profile:\n        self._logger.info(\n            f'Loading authentication for profile [{profile.profile_name}] and auth profile [{self.authenticator_name()}] of type [{auth_profile.auth_method.value}]'\n        )\n        if self._cache_keyring:\n            self.__token = self._cache_keyring.load_token(profile, self._resolve_cache_postfix(auth_profile))\n        if refresh_auth:\n            if (\n                self.__token\n                and self.__token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)\n                &gt; datetime.now()\n            ):\n                self._logger.info('Token did not pass grace expiration, no need to refresh')\n            else:\n                self._logger.info('Trying to refresh token authentication')\n                self.__token = self._perform_refresh_authentication(profile, auth_profile, self.__token)\n                if self.__token and self.__token.expires_in.replace(tzinfo=None) &gt; datetime.now():\n                    self._logger.info('Token refreshed')\n                if self.__token and self._cache_authentication and self._cache_keyring:\n                    self._cache_keyring.save_token(profile, self.__token, self._resolve_cache_postfix(auth_profile))\n        if self.__token and self.__token.expires_in.replace(tzinfo=None) &lt;= datetime.now():\n            self.__token = None\n        if self.__token:\n            self._active_profile = profile\n            self._active_auth_profile = auth_profile\n        return self.__token\n    return None\n</code></pre>"},{"location":"reference/auth/ark_auth/#ark_sdk_python.auth.ark_auth.ArkAuth.supported_auth_methods","title":"<code>supported_auth_methods()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Supported authenticaton methods by this authenticator</p> <p>Returns:</p> Type Description <code>List[ArkAuthMethod]</code> <p>List[ArkAuthMethod]: description</p> Source code in <code>ark_sdk_python/auth/ark_auth.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef supported_auth_methods() -&gt; List[ArkAuthMethod]:\n    \"\"\"\n    Supported authenticaton methods by this authenticator\n\n    Returns:\n        List[ArkAuthMethod]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/auth/ark_isp_auth/","title":"ark_isp_auth","text":""},{"location":"reference/auth/ark_isp_auth/#ark_sdk_python.auth.ark_isp_auth.ArkISPAuth","title":"<code>ArkISPAuth</code>","text":"<p>             Bases: <code>ArkAuth</code></p> Source code in <code>ark_sdk_python/auth/ark_isp_auth.py</code> <pre><code>class ArkISPAuth(ArkAuth):\n    def __perform_identity_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret], force: bool\n    ) -&gt; ArkToken:\n        try:\n            method_settings = cast(IdentityArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentity(\n                username=auth_profile.username,\n                password=secret.secret.get_secret_value() if secret else None,\n                identity_url=method_settings.identity_url,\n                mfa_type=method_settings.identity_mfa_method,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n            )\n            identity.auth_identity(profile, ArkSystemConfig.is_interactive() and method_settings.identity_mfa_interactive, force)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            token_lifetime = identity.session_details.token_lifetime\n            if not token_lifetime:\n                token_lifetime = DEFAULT_TOKEN_LIFETIME\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.Identity,\n                expires_in=datetime.now() + timedelta(seconds=token_lifetime),\n                refresh_token=identity.session_details.refresh_token,\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            self._logger.exception(f'Failed to authenticate to identity security platform [{str(ex)}]')\n            raise ArkAuthException from ex\n\n    def __perform_identity_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        try:\n            method_settings = cast(IdentityArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentity(\n                username=auth_profile.username,\n                password=None,\n                identity_url=method_settings.identity_url,\n                mfa_type=method_settings.identity_mfa_method,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n                load_cache=True,\n                cache_profile=profile,\n            )\n            identity.refresh_auth_identity(profile, method_settings.identity_mfa_interactive, False)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            token_lifetime = identity.session_details.token_lifetime\n            if not token_lifetime:\n                token_lifetime = DEFAULT_TOKEN_LIFETIME\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.Identity,\n                expires_in=datetime.now() + timedelta(seconds=token_lifetime),\n                refresh_token=identity.session_details.refresh_token,\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            raise ArkAuthException('Failed to authenticate to isp via identity') from ex\n\n    def __perform_identity_service_user_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret], force: bool\n    ) -&gt; ArkToken:\n        try:\n            if not secret:\n                raise ArkException('Token secret is required for identity service user auth')\n            method_settings = cast(IdentityServiceUserArkAuthMethodSettings, auth_profile.auth_method_settings)\n            identity = ArkIdentityServiceUser(\n                username=auth_profile.username,\n                token=secret.secret.get_secret_value(),\n                app_name=method_settings.identity_authorization_application,\n                logger=self._logger,\n                cache_authentication=self._cache_authentication,\n            )\n            identity.auth_identity(profile, force)\n            env = AwsEnv(os.environ.get('DEPLOY_ENV', AwsEnv.PROD.value))\n            found_env = list(filter(lambda e: ROOT_DOMAIN[e] in identity.identity_url, ROOT_DOMAIN.keys()))\n            if found_env:\n                env = found_env[0]\n            return ArkToken(\n                token=identity.session_token,\n                username=auth_profile.username,\n                endpoint=identity.identity_url,\n                token_type=ArkTokenType.JWT,\n                auth_method=ArkAuthMethod.IdentityServiceUser,\n                expires_in=datetime.now() + timedelta(hours=4),\n                metadata={'env': env, 'cookies': codecs.encode(pickle.dumps(identity.session.cookies), 'base64').decode()},\n            )\n        except Exception as ex:\n            self._logger.exception(f'Failed to authenticate to identity security platform with service user [{str(ex)}]')\n            raise ArkAuthException from ex\n\n    @overrides\n    def _perform_authentication(\n        self, profile: ArkProfile, auth_profile: ArkAuthProfile, secret: Optional[ArkSecret] = None, force: bool = False\n    ) -&gt; ArkToken:\n        \"\"\"\n        Peforms authentication to the identity security platform identity tenant\n        Authentication can be done with either a service user or a normal user\n        Authentication Methods:\n        - Identity, Default\n        - IdentityServiceUser\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            secret (Optional[ArkSecret], optional): _description_. Defaults to None.\n            force (bool, optional): _description_. Defaults to False.\n\n        Raises:\n            ArkAuthException: _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n        self._logger.info('Performing authentication to ISP')\n        if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n            return self.__perform_identity_authentication(profile, auth_profile, secret, force)\n        if auth_profile.auth_method == ArkAuthMethod.IdentityServiceUser:\n            return self.__perform_identity_service_user_authentication(profile, auth_profile, secret, force)\n        raise ArkAuthException('Given auth method is not supported')\n\n    @overrides\n    def _perform_refresh_authentication(self, profile: ArkProfile, auth_profile: ArkAuthProfile, token: ArkToken) -&gt; ArkToken:\n        \"\"\"\n        Refresh for isp tenant is supported only for identity\n\n        Args:\n            profile (ArkProfile): _description_\n            auth_profile (ArkAuthProfile): _description_\n            token (ArkToken): _description_\n\n        Returns:\n            ArkToken: _description_\n        \"\"\"\n        self._logger.info('Performing refresh authentication to ISP')\n        if auth_profile.auth_method in [ArkAuthMethod.Identity, ArkAuthMethod.Default]:\n            return self.__perform_identity_refresh_authentication(profile, auth_profile, token)\n        return token\n\n    @staticmethod\n    @overrides\n    def authenticator_name() -&gt; str:\n        return AUTH_NAME\n\n    @staticmethod\n    @overrides\n    def authenticator_human_readable_name() -&gt; str:\n        return AUTH_HUMAN_READABLE_NAME\n\n    @staticmethod\n    @overrides\n    def supported_auth_methods() -&gt; List[ArkAuthMethod]:\n        return AUTH_METHODS\n\n    @staticmethod\n    @overrides\n    def default_auth_method() -&gt; Tuple[ArkAuthMethod, ArkAuthMethodSettings]:\n        return DEFAULT_AUTH_METHOD, DEFAULT_AUTH_METHOD_SETTINGS\n</code></pre>"},{"location":"reference/auth/identity/","title":"identity","text":""},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity","title":"<code>ArkIdentity</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>class ArkIdentity:\n    def __init__(\n        self,\n        username: str,\n        password: Optional[str],\n        identity_url: Optional[str] = None,\n        mfa_type: Optional[str] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__password = password\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        if not self.__identity_url.startswith('https://'):\n            self.__identity_url = f'https://{self.__identity_url}'\n        self.__mfa_type = mfa_type\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__interaction_process: Optional[Process] = None\n        self.__is_polling: bool = False\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_details = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__verify = verify\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity')\n            session = self.__keyring.load_token(profile, f'{self.__username}_identity_session')\n            if token and session:\n                import dill as pickle\n\n                try:\n                    self.__session_details = AdvanceAuthResult.parse_raw(token.token.get_secret_value())\n                except ValidationError:\n                    self.__session_details = IdpAuthStatusResult.parse_raw(token.token.get_secret_value())\n                self.__session_exp = token.expires_in\n                self.__session = pickle.loads(codecs.decode(session.token.get_secret_value().encode(), \"base64\"))\n                self.__session.verify = self.__verify\n                self.__identity_url = token.endpoint\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_details:\n            import dill as pickle\n\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_details.json(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                    refresh_token=self.__session_details.refresh_token,\n                ),\n                f'{self.__username}_identity',\n            )\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=codecs.encode(pickle.dumps(self.__session), 'base64').decode(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_session',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix=tenant_suffix)\n\n    def __start_authentication(self) -&gt; StartAuthResponse:\n        self.__logger.info(f'Starting authentication with user {self.__username} and fqdn {self.__identity_url}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/StartAuthentication',\n            json={'User': self.__username, 'Version': '1.0', 'PlatformTokenResponse': True},\n        )\n        try:\n            parsed_res: StartAuthResponse = StartAuthResponse.parse_raw(response.text)\n            if not parsed_res.result.challenges and not parsed_res.result.idp_redirect_url:\n                raise ValidationError('No challenges or idp redirect url on start auth')\n        except (ValidationError, TypeError) as ex:\n            try:\n                if 'PodFqdn' in response.text:\n                    fqdn = TenantFqdnResponse.parse_raw(response.text)\n                    self.__identity_url = f'https://{fqdn.result.pod_fqdn}'\n                    self.__session = Session()\n                    self.__session.verify = self.__verify\n                    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n                    return self.__start_authentication()\n            except Exception:\n                pass\n            raise ArkException('Identity start authentication failed to be parsed / validated') from ex\n        return parsed_res\n\n    def __advance_authentication(\n        self, mechanism_id: str, session_id: str, answer: str, action: str\n    ) -&gt; Union[AdvanceAuthMidResponse, AdvanceAuthResponse]:\n        self.__logger.info(f'Advancing authentication with user {self.__username} and fqdn {self.__identity_url} and action {action}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/AdvanceAuthentication',\n            json={'SessionId': session_id, 'MechanismId': mechanism_id, 'Action': action, 'Answer': answer},\n        )\n        try:\n            parsed_res: AdvanceAuthMidResponse = AdvanceAuthMidResponse.parse_raw(response.text)\n            if parsed_res.result.summary == 'LoginSuccess':\n                parsed_res: AdvanceAuthResponse = AdvanceAuthResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity advance authentication failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __identity_idp_auth_status(self, session_id: str) -&gt; IdpAuthStatusResponse:\n        self.__logger.info(f'Calling idp auth status for fqdn {self.__identity_url} and session id {session_id}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/OobAuthStatus',\n            json={'SessionId': session_id},\n        )\n        try:\n            parsed_res: IdpAuthStatusResponse = IdpAuthStatusResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity idp auth status failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __start_input_process(\n        self, pipe_write: Connection, pipe_read: Connection, mechanism: Mechanism, oob_advance_resp: AdvanceAuthMidResponse\n    ) -&gt; None:\n        if self.__interaction_process:\n            raise ArkException('Interaction thread is already in progress')\n        if sys.platform not in ['win32', 'cygwin']:\n            ctx = get_context('fork')\n        else:\n            ctx = get_context('spawn')\n        self.__interaction_process = ctx.Process(\n            target=input_process,\n            args=(\n                pipe_write,\n                pipe_read,\n                mechanism,\n                oob_advance_resp,\n            ),\n        )\n        self.__interaction_process.start()\n\n    def __stop_input_process(self) -&gt; None:\n        if self.__interaction_process:\n            self.__interaction_process.kill()\n            self.__interaction_process.join()\n            self.__interaction_process = None\n\n    def __poll_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        start_auth_response: StartAuthResponse,\n        oob_advance_resp: AdvanceAuthMidResponse,\n        is_interactive: bool,\n    ) -&gt; None:\n        try:\n            if self.__is_polling:\n                raise ArkException('MFA Polling is already in progress')\n            self.__is_polling = True\n            input_conn, output_conn = Pipe(duplex=True)\n            if is_interactive:\n                self.__start_input_process(input_conn, output_conn, mechanism, oob_advance_resp)\n            start_time = datetime.now()\n            while self.__is_polling:\n                current_time = datetime.now()\n                if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                    self.__is_polling = False\n                    raise ArkException('Timeout reached while polling for user answer')\n                if output_conn.poll():\n                    mfa_code = output_conn.recv()\n                    advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, mfa_code, 'Answer'\n                    )\n                    if isinstance(advance_resp, AdvanceAuthResponse):\n                        input_conn.send('DONE')\n                    else:\n                        input_conn.send('CONTINUE')\n                else:\n                    advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'Poll')\n                if isinstance(advance_resp, AdvanceAuthResponse):\n                    # Done here, save the token\n                    self.__is_polling = False\n                    if is_interactive:\n                        self.__stop_input_process()\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                time.sleep(POLL_INTERVAL_MS)\n        except Exception as ex:\n            if is_interactive:\n                self.__stop_input_process()\n            if not self.__session_details:\n                raise ex\n        finally:\n            if is_interactive:\n                self.__stop_input_process()\n\n    def __pick_mechanism(self, challenge: Challenge) -&gt; Mechanism:\n        factors = {'otp': '\ud83d\udcf2 Push / Code', 'sms': '\ud83d\udcdf SMS', 'email': '\ud83d\udce7 Email', 'pf': '\ud83d\udcde Phone call'}\n        supported_mechanisms = [m for m in challenge.mechanisms if m.name.lower() in SUPPORTED_MECHANISMS]\n        answers = inquirer.prompt(\n            [\n                inquirer.List(\n                    'mfa',\n                    'Please pick one of the following MFA methods',\n                    choices=[factors[m.name.lower()] for m in supported_mechanisms],\n                    default=factors[self.__mfa_type] if self.__mfa_type and self.__mfa_type in factors else None,\n                    carousel=True,\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            raise ArkException('Failed to get answer for which MFA method to use')\n        self.__mfa_type = next(filter(lambda f: factors[f] == answers['mfa'], factors.keys()))\n        return next(filter(lambda m: factors[m.name.lower()] == answers['mfa'], supported_mechanisms))\n\n    def __perform_idp_authentication(\n        self, start_auth_response: StartAuthResponse, profile: Optional[ArkProfile] = None, interactive: bool = False\n    ) -&gt; None:\n        if self.__is_polling:\n            raise ArkException('MFA / IDP Polling is already in progress')\n        # Print the user some info if we are interactive\n        if interactive:\n            ArkArgsFormatter.print_normal_bright(\n                \"\\nYou are now being redirected from your browser to your external identity provider for authentication\\n\"\n                \"If the browser did not open, you may also click the following URL to access your identity provider authentication\\n\\n\"\n                f\"{start_auth_response.result.idp_redirect_short_url}\\n\"\n            )\n\n        # Error can be ignored\n        webbrowser.open(start_auth_response.result.idp_redirect_short_url, new=0, autoraise=True)\n\n        # Start polling for idp auth\n        self.__is_polling = True\n        start_time = datetime.now()\n        while self.__is_polling:\n            current_time = datetime.now()\n            if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                self.__is_polling = False\n                raise ArkException('Timeout reached while polling for idp auth')\n            idp_auth_status = self.__identity_idp_auth_status(start_auth_response.result.idp_login_session_id)\n            if idp_auth_status.result.state == 'Success' and idp_auth_status.result.token:\n                # We managed to successfully authenticate\n                # Done here, save the token\n                self.__session_details = idp_auth_status.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {idp_auth_status.result.token}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                break\n            time.sleep(POLL_INTERVAL_MS)\n\n    @classmethod\n    def has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n        \"\"\"\n        Checks if a record exists within the identity cache for profile and username\n\n        Args:\n            profile (ArkProfile): _description_\n            username (str): _description_\n            refresh_auth_allowed (bool): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        keyring = ArkKeyring(cls.__name__.lower())\n        token = keyring.load_token(profile, f'{username}_identity')\n        session = keyring.load_token(profile, f'{username}_identity_session')\n        if token is not None and session is not None:\n            if token.expires_in and token.expires_in &lt; datetime.now():\n                if token.refresh_token and refresh_auth_allowed:\n                    return True\n                return False\n            return True\n        return False\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_idp_user(cls, username: str) -&gt; bool:\n        \"\"\"\n        Checks if a given username is an external id or not\n\n        Args:\n            username (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n            return False\n        identity = ArkIdentity(username=username, password='')\n        resp = identity.__start_authentication()\n        return resp.result.idp_redirect_url != None\n\n    def get_apps(self) -&gt; Dict:\n        \"\"\"\n        Get the applications for the logged in user\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            Dict: _description_\n        \"\"\"\n        if not self.__session_details:\n            raise ArkException('Identity authentication is required first')\n        cookies = self.__session.cookies.copy()\n        response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n        self.__session.cookies = cookies\n        return json.loads(response.text)\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to identity, based on the given information on the constructor\n        If MFA is needed, will also interact with user if allowed\n        Token and other details are stored in the object for later use\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n            interactive (bool): Whether interactiveness with the user is allowed or not\n            force (bool): Igonre cache and force authenticate. Defaults to False\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        self.__logger.debug('Attempting to authenticate to Identity')\n        self.__session_details = None\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity details from cache')\n                return\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n        # Start the authentication\n        start_auth_response = self.__start_authentication()\n        if start_auth_response.result.idp_redirect_url:\n            # External IDP Flow, ignore the mechanisms and just open a browser\n            self.__perform_idp_authentication(start_auth_response, profile, interactive)\n            return\n\n        # Check if password is part of the first challenges list and if so, answer it directly\n        current_challenge_idx = 0\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == 'up':\n                current_challenge_idx += 1\n                # Password, answer it\n                if not self.__password:\n                    if not interactive:\n                        raise ArkAuthException('No password and not interactive, cannot continue')\n                    answers = inquirer.prompt(\n                        [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                        render=ArkInquirerRender(),\n                    )\n                    if not answers:\n                        raise ArkAuthException('Canceled by user')\n                    self.__password = answers['answer']\n                advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n                )\n                if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                    # Done here, save the token\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                break\n\n        # Pick MFA for the user\n        if interactive:\n            self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n        # Handle a case where MFA type was supplied\n        if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n            for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n                if mechanism.name.lower() == self.__mfa_type.lower():\n                    oob_advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                    )\n                    self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                    return\n\n        if not interactive:\n            raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n        # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n        for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n            mechanism = self.__pick_mechanism(challenge)\n            oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n\n    # pylint: disable=unused-argument\n    def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Performs refresh platform token with the existing details in the class\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n            force (bool): Igonre cache and force authenticate. Defaults to False\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        from jose.jwt import get_unverified_claims\n\n        if not self.__session_details.token:\n            # We only refresh platform token at the moment, call the normal authentication instead\n            return self.auth_identity(profile, interactive, force)\n\n        self.__logger.debug('Attempting to refresh authenticate to Identity')\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        decoded_token = get_unverified_claims(self.__session_details.token)\n        platform_tenant_id = decoded_token['tenant_id']\n        cookies = {\n            f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n            f'idToken-{platform_tenant_id}': self.__session_details.token,\n        }\n        response = self.__session.post(\n            url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n            cookies=cookies,\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed to refresh token')\n        new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n        new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n        if not new_token or not new_refresh_token:\n            raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n        self.__session_details.token = new_token\n        self.__session_details.refresh_token = new_refresh_token\n        self.__session_details.token_lifetime = (\n            datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n            - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n        ).seconds\n        delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n        self.__session_exp = datetime.now() + timedelta(seconds=delta)\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        if self.__session_details:\n            if self.__session_details.token:\n                return self.__session_details.token\n            if 'auth' in self.__session_details.__dict__ and self.__session_details.auth:\n                return self.__session_details.auth\n        return None\n\n    @property\n    def session_details(self) -&gt; Optional[AdvanceAuthResult]:\n        return self.__session_details\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.auth_identity","title":"<code>auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Authenticates to identity, based on the given information on the constructor If MFA is needed, will also interact with user if allowed Token and other details are stored in the object for later use</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching if cache exists</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Whether interactiveness with the user is allowed or not</p> <code>False</code> <code>force</code> <code>bool</code> <p>Igonre cache and force authenticate. Defaults to False</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to identity, based on the given information on the constructor\n    If MFA is needed, will also interact with user if allowed\n    Token and other details are stored in the object for later use\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n        interactive (bool): Whether interactiveness with the user is allowed or not\n        force (bool): Igonre cache and force authenticate. Defaults to False\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    self.__logger.debug('Attempting to authenticate to Identity')\n    self.__session_details = None\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity details from cache')\n            return\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n    # Start the authentication\n    start_auth_response = self.__start_authentication()\n    if start_auth_response.result.idp_redirect_url:\n        # External IDP Flow, ignore the mechanisms and just open a browser\n        self.__perform_idp_authentication(start_auth_response, profile, interactive)\n        return\n\n    # Check if password is part of the first challenges list and if so, answer it directly\n    current_challenge_idx = 0\n    for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n        if mechanism.name.lower() == 'up':\n            current_challenge_idx += 1\n            # Password, answer it\n            if not self.__password:\n                if not interactive:\n                    raise ArkAuthException('No password and not interactive, cannot continue')\n                answers = inquirer.prompt(\n                    [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    raise ArkAuthException('Canceled by user')\n                self.__password = answers['answer']\n            advance_resp = self.__advance_authentication(\n                mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n            )\n            if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                # Done here, save the token\n                self.__session_details = advance_resp.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                return\n            break\n\n    # Pick MFA for the user\n    if interactive:\n        self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n    # Handle a case where MFA type was supplied\n    if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == self.__mfa_type.lower():\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                return\n\n    if not interactive:\n        raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n    # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n    for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n        mechanism = self.__pick_mechanism(challenge)\n        oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n        self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.get_apps","title":"<code>get_apps()</code>","text":"<p>Get the applications for the logged in user</p> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def get_apps(self) -&gt; Dict:\n    \"\"\"\n    Get the applications for the logged in user\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        Dict: _description_\n    \"\"\"\n    if not self.__session_details:\n        raise ArkException('Identity authentication is required first')\n    cookies = self.__session.cookies.copy()\n    response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n    self.__session.cookies = cookies\n    return json.loads(response.text)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.has_cache_record","title":"<code>has_cache_record(profile, username, refresh_auth_allowed)</code>  <code>classmethod</code>","text":"<p>Checks if a record exists within the identity cache for profile and username</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>username</code> <code>str</code> <p>description</p> required <code>refresh_auth_allowed</code> <code>bool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\ndef has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n    \"\"\"\n    Checks if a record exists within the identity cache for profile and username\n\n    Args:\n        profile (ArkProfile): _description_\n        username (str): _description_\n        refresh_auth_allowed (bool): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    keyring = ArkKeyring(cls.__name__.lower())\n    token = keyring.load_token(profile, f'{username}_identity')\n    session = keyring.load_token(profile, f'{username}_identity_session')\n    if token is not None and session is not None:\n        if token.expires_in and token.expires_in &lt; datetime.now():\n            if token.refresh_token and refresh_auth_allowed:\n                return True\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.is_idp_user","title":"<code>is_idp_user(username)</code>  <code>classmethod</code>","text":"<p>Checks if a given username is an external id or not</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_idp_user(cls, username: str) -&gt; bool:\n    \"\"\"\n    Checks if a given username is an external id or not\n\n    Args:\n        username (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n        return False\n    identity = ArkIdentity(username=username, password='')\n    resp = identity.__start_authentication()\n    return resp.result.idp_redirect_url != None\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentity.refresh_auth_identity","title":"<code>refresh_auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Performs refresh platform token with the existing details in the class</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching if cache exists</p> <code>None</code> <code>force</code> <code>bool</code> <p>Igonre cache and force authenticate. Defaults to False</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Performs refresh platform token with the existing details in the class\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n        force (bool): Igonre cache and force authenticate. Defaults to False\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    from jose.jwt import get_unverified_claims\n\n    if not self.__session_details.token:\n        # We only refresh platform token at the moment, call the normal authentication instead\n        return self.auth_identity(profile, interactive, force)\n\n    self.__logger.debug('Attempting to refresh authenticate to Identity')\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n    decoded_token = get_unverified_claims(self.__session_details.token)\n    platform_tenant_id = decoded_token['tenant_id']\n    cookies = {\n        f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n        f'idToken-{platform_tenant_id}': self.__session_details.token,\n    }\n    response = self.__session.post(\n        url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n        cookies=cookies,\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed to refresh token')\n    new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n    new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n    if not new_token or not new_refresh_token:\n        raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n    self.__session_details.token = new_token\n    self.__session_details.refresh_token = new_refresh_token\n    self.__session_details.token_lifetime = (\n        datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n        - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n    ).seconds\n    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver","title":"<code>ArkIdentityFQDNResolver</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>class ArkIdentityFQDNResolver:\n    __DISCOVERY_SERVICE_DOMAIN_NAME: Final[str] = 'platform-discovery'\n    __DISCOVERY_TIMEOUT: Final[int] = 30\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {\n            'Content-Type': 'application/json',\n            'X-IDAP-NATIVE-CLIENT': 'true',\n            'User-Agent': UserAgent(browsers=['chrome']).chrome,\n            'OobIdPAuth': 'true',\n        }\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_system_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {'X-IDAP-NATIVE-CLIENT': 'true', 'User-Agent': UserAgent(browsers=['chrome']).chrome}\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n        \"\"\"\n        Resolve the tenant FQDN url from platform discovery by its tenant subdomain.\n        This is based on the environment that currently being worked on and given as an input\n\n        Args:\n            tenant_subdomain (str): the tenant subdomain, e.g. 'mytenant'\n            env (AwsEnv): The environment to try and find the tenant on\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: result of the platform discovery request to get the tenant FQDN\n        \"\"\"\n        platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n        session = Session()\n        response = session.get(\n            f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n            headers={'Content-Type': 'application/json'},\n            timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n        )\n        try:\n            if response.status_code == HTTPStatus.OK:\n                parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n                return str(parsed_response.endpoint)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n        raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Resolve the tenant FQDN url in identity. By default it gets identity address according\n        to the current environment mapping (see get_identity_env_url()), but it can get it as argument (identity_env_url)\n\n        Args:\n            tenant_suffix (str): the tenant url suffix, e.g. '@tenant-a-527.shell.cyberark.cloud'\n            identity_env_url (str, optional): If specified, used as the identity pod0 url. Defaults to None (use environment mapping).\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: result of the identity request to get the tenant FQDN\n        \"\"\"\n        identity_env_url = identity_env_url or (\n            IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n        )\n        session = Session()\n        response = session.post(\n            f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n            json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n            headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n        )\n        try:\n            parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n        if not parsed_res.result.pod_fqdn.startswith('https://'):\n            parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n        return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain","title":"<code>resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain, env)</code>  <code>staticmethod</code>","text":"<p>Resolve the tenant FQDN url from platform discovery by its tenant subdomain. This is based on the environment that currently being worked on and given as an input</p> <p>Parameters:</p> Name Type Description Default <code>tenant_subdomain</code> <code>str</code> <p>the tenant subdomain, e.g. 'mytenant'</p> required <code>env</code> <code>AwsEnv</code> <p>The environment to try and find the tenant on</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>result of the platform discovery request to get the tenant FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n    \"\"\"\n    Resolve the tenant FQDN url from platform discovery by its tenant subdomain.\n    This is based on the environment that currently being worked on and given as an input\n\n    Args:\n        tenant_subdomain (str): the tenant subdomain, e.g. 'mytenant'\n        env (AwsEnv): The environment to try and find the tenant on\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: result of the platform discovery request to get the tenant FQDN\n    \"\"\"\n    platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n    session = Session()\n    response = session.get(\n        f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n        headers={'Content-Type': 'application/json'},\n        timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n    )\n    try:\n        if response.status_code == HTTPStatus.OK:\n            parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n            return str(parsed_response.endpoint)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n    raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix","title":"<code>resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix, identity_env_url=None)</code>  <code>staticmethod</code>","text":"<p>Resolve the tenant FQDN url in identity. By default it gets identity address according to the current environment mapping (see get_identity_env_url()), but it can get it as argument (identity_env_url)</p> <p>Parameters:</p> Name Type Description Default <code>tenant_suffix</code> <code>str</code> <p>the tenant url suffix, e.g. '@tenant-a-527.shell.cyberark.cloud'</p> required <code>identity_env_url</code> <code>str</code> <p>If specified, used as the identity pod0 url. Defaults to None (use environment mapping).</p> <code>None</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>result of the identity request to get the tenant FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Resolve the tenant FQDN url in identity. By default it gets identity address according\n    to the current environment mapping (see get_identity_env_url()), but it can get it as argument (identity_env_url)\n\n    Args:\n        tenant_suffix (str): the tenant url suffix, e.g. '@tenant-a-527.shell.cyberark.cloud'\n        identity_env_url (str, optional): If specified, used as the identity pod0 url. Defaults to None (use environment mapping).\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: result of the identity request to get the tenant FQDN\n    \"\"\"\n    identity_env_url = identity_env_url or (\n        IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n    )\n    session = Session()\n    response = session.post(\n        f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n        json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n    )\n    try:\n        parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n    if not parsed_res.result.pod_fqdn.startswith('https://'):\n        parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n    return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityServiceUser","title":"<code>ArkIdentityServiceUser</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>class ArkIdentityServiceUser:\n    def __init__(\n        self,\n        username: str,\n        token: str,\n        app_name: str,\n        identity_url: Optional[str] = None,\n        env: Optional[AwsEnv] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__token = token\n        self.__app_name = app_name\n        self.__env = env or AwsEnv(os.getenv(DEPLOY_ENV, AwsEnv.PROD.value))\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_token = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_system_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity_service_user')\n            if token and token.username == self.__username:\n                self.__session_token = token.token.get_secret_value()\n                self.__session_exp = token.expires_in\n                self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}'})\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_token:\n            self.__session_exp = datetime.now() + timedelta(hours=4)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_token,\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_service_user',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(\n            tenant_suffix=tenant_suffix, identity_env_url=IDENTITY_ENV_URLS[self.__env]\n        )\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates with a service user to identity\n        The authentication creates an identity token and authorizes to the given application\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n            force (bool): Whether to discard cache, Defaults to False.\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        # Login to identity with the service service user\n        self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity service user details from cache')\n                return\n\n        token_response: Response = self.__session.post(\n            url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n            auth=HTTPBasicAuth(self.__username, self.__token),\n            verify=True,\n            data={'grant_type': 'client_credentials', 'scope': 'api'},\n        )\n        if token_response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed logging in to identity service user')\n        auth_result = json.loads(token_response.text)\n        if 'access_token' not in auth_result.keys():\n            raise ArkAuthException('Failed logging in to identity service user, access token not found')\n        access_token = auth_result['access_token']\n\n        # Authorize to the application with the service user\n        params = {\n            'client_id': self.__app_name,\n            'response_type': 'id_token',\n            'scope': 'openid profile api',\n            'redirect_uri': 'https://cyberark.cloud/redirect',\n        }\n        self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n        authorize_response = self.__session.get(\n            url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n            headers={'Authorization': f'Bearer {access_token}'},\n            params=params,\n            allow_redirects=False,\n        )\n        if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n            raise ArkAuthException('Failed to authorize to application')\n        # Parse the authorized token and return the session with it\n        location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n        if len(location_header_splitted) != 2:\n            raise ArkAuthException('Failed to parse location header to retrieve token from')\n        parsed_query = parse_qs(location_header_splitted[1])\n        if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n            raise ArkAuthException('Failed to parse id token from location header')\n        self.__session_token = parsed_query['id_token'][0]\n        self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n        self.__session_exp = datetime.now() + timedelta(hours=4)\n        self.__logger.info(\n            f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n        )\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__session_token\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/#ark_sdk_python.auth.identity.ArkIdentityServiceUser.auth_identity","title":"<code>auth_identity(profile=None, force=False)</code>","text":"<p>Authenticates with a service user to identity The authentication creates an identity token and authorizes to the given application</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching if cache exists</p> <code>None</code> <code>force</code> <code>bool</code> <p>Whether to discard cache, Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates with a service user to identity\n    The authentication creates an identity token and authorizes to the given application\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n        force (bool): Whether to discard cache, Defaults to False.\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    # Login to identity with the service service user\n    self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity service user details from cache')\n            return\n\n    token_response: Response = self.__session.post(\n        url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n        auth=HTTPBasicAuth(self.__username, self.__token),\n        verify=True,\n        data={'grant_type': 'client_credentials', 'scope': 'api'},\n    )\n    if token_response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed logging in to identity service user')\n    auth_result = json.loads(token_response.text)\n    if 'access_token' not in auth_result.keys():\n        raise ArkAuthException('Failed logging in to identity service user, access token not found')\n    access_token = auth_result['access_token']\n\n    # Authorize to the application with the service user\n    params = {\n        'client_id': self.__app_name,\n        'response_type': 'id_token',\n        'scope': 'openid profile api',\n        'redirect_uri': 'https://cyberark.cloud/redirect',\n    }\n    self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n    authorize_response = self.__session.get(\n        url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n        headers={'Authorization': f'Bearer {access_token}'},\n        params=params,\n        allow_redirects=False,\n    )\n    if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n        raise ArkAuthException('Failed to authorize to application')\n    # Parse the authorized token and return the session with it\n    location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n    if len(location_header_splitted) != 2:\n        raise ArkAuthException('Failed to parse location header to retrieve token from')\n    parsed_query = parse_qs(location_header_splitted[1])\n    if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n        raise ArkAuthException('Failed to parse id token from location header')\n    self.__session_token = parsed_query['id_token'][0]\n    self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n    self.__session_exp = datetime.now() + timedelta(hours=4)\n    self.__logger.info(\n        f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n    )\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/","title":"ark_identity","text":""},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity","title":"<code>ArkIdentity</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>class ArkIdentity:\n    def __init__(\n        self,\n        username: str,\n        password: Optional[str],\n        identity_url: Optional[str] = None,\n        mfa_type: Optional[str] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__password = password\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        if not self.__identity_url.startswith('https://'):\n            self.__identity_url = f'https://{self.__identity_url}'\n        self.__mfa_type = mfa_type\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__interaction_process: Optional[Process] = None\n        self.__is_polling: bool = False\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_details = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__verify = verify\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity')\n            session = self.__keyring.load_token(profile, f'{self.__username}_identity_session')\n            if token and session:\n                import dill as pickle\n\n                try:\n                    self.__session_details = AdvanceAuthResult.parse_raw(token.token.get_secret_value())\n                except ValidationError:\n                    self.__session_details = IdpAuthStatusResult.parse_raw(token.token.get_secret_value())\n                self.__session_exp = token.expires_in\n                self.__session = pickle.loads(codecs.decode(session.token.get_secret_value().encode(), \"base64\"))\n                self.__session.verify = self.__verify\n                self.__identity_url = token.endpoint\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_details:\n            import dill as pickle\n\n            delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n            self.__session_exp = datetime.now() + timedelta(seconds=delta)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_details.json(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                    refresh_token=self.__session_details.refresh_token,\n                ),\n                f'{self.__username}_identity',\n            )\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=codecs.encode(pickle.dumps(self.__session), 'base64').decode(),\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_session',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix=tenant_suffix)\n\n    def __start_authentication(self) -&gt; StartAuthResponse:\n        self.__logger.info(f'Starting authentication with user {self.__username} and fqdn {self.__identity_url}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/StartAuthentication',\n            json={'User': self.__username, 'Version': '1.0', 'PlatformTokenResponse': True},\n        )\n        try:\n            parsed_res: StartAuthResponse = StartAuthResponse.parse_raw(response.text)\n            if not parsed_res.result.challenges and not parsed_res.result.idp_redirect_url:\n                raise ValidationError('No challenges or idp redirect url on start auth')\n        except (ValidationError, TypeError) as ex:\n            try:\n                if 'PodFqdn' in response.text:\n                    fqdn = TenantFqdnResponse.parse_raw(response.text)\n                    self.__identity_url = f'https://{fqdn.result.pod_fqdn}'\n                    self.__session = Session()\n                    self.__session.verify = self.__verify\n                    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n                    return self.__start_authentication()\n            except Exception:\n                pass\n            raise ArkException('Identity start authentication failed to be parsed / validated') from ex\n        return parsed_res\n\n    def __advance_authentication(\n        self, mechanism_id: str, session_id: str, answer: str, action: str\n    ) -&gt; Union[AdvanceAuthMidResponse, AdvanceAuthResponse]:\n        self.__logger.info(f'Advancing authentication with user {self.__username} and fqdn {self.__identity_url} and action {action}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/AdvanceAuthentication',\n            json={'SessionId': session_id, 'MechanismId': mechanism_id, 'Action': action, 'Answer': answer},\n        )\n        try:\n            parsed_res: AdvanceAuthMidResponse = AdvanceAuthMidResponse.parse_raw(response.text)\n            if parsed_res.result.summary == 'LoginSuccess':\n                parsed_res: AdvanceAuthResponse = AdvanceAuthResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity advance authentication failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __identity_idp_auth_status(self, session_id: str) -&gt; IdpAuthStatusResponse:\n        self.__logger.info(f'Calling idp auth status for fqdn {self.__identity_url} and session id {session_id}')\n        response = self.__session.post(\n            url=f'{self.__identity_url}/Security/OobAuthStatus',\n            json={'SessionId': session_id},\n        )\n        try:\n            parsed_res: IdpAuthStatusResponse = IdpAuthStatusResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException(f'Identity idp auth status failed to be parsed / validated [{response.text}]') from ex\n        return parsed_res\n\n    def __start_input_process(\n        self, pipe_write: Connection, pipe_read: Connection, mechanism: Mechanism, oob_advance_resp: AdvanceAuthMidResponse\n    ) -&gt; None:\n        if self.__interaction_process:\n            raise ArkException('Interaction thread is already in progress')\n        if sys.platform not in ['win32', 'cygwin']:\n            ctx = get_context('fork')\n        else:\n            ctx = get_context('spawn')\n        self.__interaction_process = ctx.Process(\n            target=input_process,\n            args=(\n                pipe_write,\n                pipe_read,\n                mechanism,\n                oob_advance_resp,\n            ),\n        )\n        self.__interaction_process.start()\n\n    def __stop_input_process(self) -&gt; None:\n        if self.__interaction_process:\n            self.__interaction_process.kill()\n            self.__interaction_process.join()\n            self.__interaction_process = None\n\n    def __poll_authentication(\n        self,\n        profile: ArkProfile,\n        mechanism: Mechanism,\n        start_auth_response: StartAuthResponse,\n        oob_advance_resp: AdvanceAuthMidResponse,\n        is_interactive: bool,\n    ) -&gt; None:\n        try:\n            if self.__is_polling:\n                raise ArkException('MFA Polling is already in progress')\n            self.__is_polling = True\n            input_conn, output_conn = Pipe(duplex=True)\n            if is_interactive:\n                self.__start_input_process(input_conn, output_conn, mechanism, oob_advance_resp)\n            start_time = datetime.now()\n            while self.__is_polling:\n                current_time = datetime.now()\n                if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                    self.__is_polling = False\n                    raise ArkException('Timeout reached while polling for user answer')\n                if output_conn.poll():\n                    mfa_code = output_conn.recv()\n                    advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, mfa_code, 'Answer'\n                    )\n                    if isinstance(advance_resp, AdvanceAuthResponse):\n                        input_conn.send('DONE')\n                    else:\n                        input_conn.send('CONTINUE')\n                else:\n                    advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'Poll')\n                if isinstance(advance_resp, AdvanceAuthResponse):\n                    # Done here, save the token\n                    self.__is_polling = False\n                    if is_interactive:\n                        self.__stop_input_process()\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                time.sleep(POLL_INTERVAL_MS)\n        except Exception as ex:\n            if is_interactive:\n                self.__stop_input_process()\n            if not self.__session_details:\n                raise ex\n        finally:\n            if is_interactive:\n                self.__stop_input_process()\n\n    def __pick_mechanism(self, challenge: Challenge) -&gt; Mechanism:\n        factors = {'otp': '\ud83d\udcf2 Push / Code', 'sms': '\ud83d\udcdf SMS', 'email': '\ud83d\udce7 Email', 'pf': '\ud83d\udcde Phone call'}\n        supported_mechanisms = [m for m in challenge.mechanisms if m.name.lower() in SUPPORTED_MECHANISMS]\n        answers = inquirer.prompt(\n            [\n                inquirer.List(\n                    'mfa',\n                    'Please pick one of the following MFA methods',\n                    choices=[factors[m.name.lower()] for m in supported_mechanisms],\n                    default=factors[self.__mfa_type] if self.__mfa_type and self.__mfa_type in factors else None,\n                    carousel=True,\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            raise ArkException('Failed to get answer for which MFA method to use')\n        self.__mfa_type = next(filter(lambda f: factors[f] == answers['mfa'], factors.keys()))\n        return next(filter(lambda m: factors[m.name.lower()] == answers['mfa'], supported_mechanisms))\n\n    def __perform_idp_authentication(\n        self, start_auth_response: StartAuthResponse, profile: Optional[ArkProfile] = None, interactive: bool = False\n    ) -&gt; None:\n        if self.__is_polling:\n            raise ArkException('MFA / IDP Polling is already in progress')\n        # Print the user some info if we are interactive\n        if interactive:\n            ArkArgsFormatter.print_normal_bright(\n                \"\\nYou are now being redirected from your browser to your external identity provider for authentication\\n\"\n                \"If the browser did not open, you may also click the following URL to access your identity provider authentication\\n\\n\"\n                f\"{start_auth_response.result.idp_redirect_short_url}\\n\"\n            )\n\n        # Error can be ignored\n        webbrowser.open(start_auth_response.result.idp_redirect_short_url, new=0, autoraise=True)\n\n        # Start polling for idp auth\n        self.__is_polling = True\n        start_time = datetime.now()\n        while self.__is_polling:\n            current_time = datetime.now()\n            if (current_time - start_time).seconds &gt;= POLL_TIME_SECONDS:\n                self.__is_polling = False\n                raise ArkException('Timeout reached while polling for idp auth')\n            idp_auth_status = self.__identity_idp_auth_status(start_auth_response.result.idp_login_session_id)\n            if idp_auth_status.result.state == 'Success' and idp_auth_status.result.token:\n                # We managed to successfully authenticate\n                # Done here, save the token\n                self.__session_details = idp_auth_status.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {idp_auth_status.result.token}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                break\n            time.sleep(POLL_INTERVAL_MS)\n\n    @classmethod\n    def has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n        \"\"\"\n        Checks if a record exists within the identity cache for profile and username\n\n        Args:\n            profile (ArkProfile): _description_\n            username (str): _description_\n            refresh_auth_allowed (bool): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        keyring = ArkKeyring(cls.__name__.lower())\n        token = keyring.load_token(profile, f'{username}_identity')\n        session = keyring.load_token(profile, f'{username}_identity_session')\n        if token is not None and session is not None:\n            if token.expires_in and token.expires_in &lt; datetime.now():\n                if token.refresh_token and refresh_auth_allowed:\n                    return True\n                return False\n            return True\n        return False\n\n    @classmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def is_idp_user(cls, username: str) -&gt; bool:\n        \"\"\"\n        Checks if a given username is an external id or not\n\n        Args:\n            username (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n            return False\n        identity = ArkIdentity(username=username, password='')\n        resp = identity.__start_authentication()\n        return resp.result.idp_redirect_url != None\n\n    def get_apps(self) -&gt; Dict:\n        \"\"\"\n        Get the applications for the logged in user\n\n        Raises:\n            ArkException: _description_\n\n        Returns:\n            Dict: _description_\n        \"\"\"\n        if not self.__session_details:\n            raise ArkException('Identity authentication is required first')\n        cookies = self.__session.cookies.copy()\n        response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n        self.__session.cookies = cookies\n        return json.loads(response.text)\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates to identity, based on the given information on the constructor\n        If MFA is needed, will also interact with user if allowed\n        Token and other details are stored in the object for later use\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n            interactive (bool): Whether interactiveness with the user is allowed or not\n            force (bool): Igonre cache and force authenticate. Defaults to False\n\n        Raises:\n            ArkException: _description_\n        \"\"\"\n        self.__logger.debug('Attempting to authenticate to Identity')\n        self.__session_details = None\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity details from cache')\n                return\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n        # Start the authentication\n        start_auth_response = self.__start_authentication()\n        if start_auth_response.result.idp_redirect_url:\n            # External IDP Flow, ignore the mechanisms and just open a browser\n            self.__perform_idp_authentication(start_auth_response, profile, interactive)\n            return\n\n        # Check if password is part of the first challenges list and if so, answer it directly\n        current_challenge_idx = 0\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == 'up':\n                current_challenge_idx += 1\n                # Password, answer it\n                if not self.__password:\n                    if not interactive:\n                        raise ArkAuthException('No password and not interactive, cannot continue')\n                    answers = inquirer.prompt(\n                        [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                        render=ArkInquirerRender(),\n                    )\n                    if not answers:\n                        raise ArkAuthException('Canceled by user')\n                    self.__password = answers['answer']\n                advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n                )\n                if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                    # Done here, save the token\n                    self.__session_details = advance_resp.result\n                    self.__session.headers.update(\n                        {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                    )\n                    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                    if self.__cache_authentication:\n                        self.__save_cache(profile)\n                    return\n                break\n\n        # Pick MFA for the user\n        if interactive:\n            self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n        # Handle a case where MFA type was supplied\n        if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n            for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n                if mechanism.name.lower() == self.__mfa_type.lower():\n                    oob_advance_resp = self.__advance_authentication(\n                        mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                    )\n                    self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                    return\n\n        if not interactive:\n            raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n        # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n        for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n            mechanism = self.__pick_mechanism(challenge)\n            oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n            self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n\n    # pylint: disable=unused-argument\n    def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n        \"\"\"\n        Performs refresh platform token with the existing details in the class\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n            force (bool): Igonre cache and force authenticate. Defaults to False\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        from jose.jwt import get_unverified_claims\n\n        if not self.__session_details.token:\n            # We only refresh platform token at the moment, call the normal authentication instead\n            return self.auth_identity(profile, interactive, force)\n\n        self.__logger.debug('Attempting to refresh authenticate to Identity')\n        self.__session = Session()\n        self.__session.verify = self.__verify\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n        decoded_token = get_unverified_claims(self.__session_details.token)\n        platform_tenant_id = decoded_token['tenant_id']\n        cookies = {\n            f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n            f'idToken-{platform_tenant_id}': self.__session_details.token,\n        }\n        response = self.__session.post(\n            url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n            cookies=cookies,\n        )\n        if response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed to refresh token')\n        new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n        new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n        if not new_token or not new_refresh_token:\n            raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n        self.__session_details.token = new_token\n        self.__session_details.refresh_token = new_refresh_token\n        self.__session_details.token_lifetime = (\n            datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n            - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n        ).seconds\n        delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n        self.__session_exp = datetime.now() + timedelta(seconds=delta)\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        if self.__session_details:\n            if self.__session_details.token:\n                return self.__session_details.token\n            if 'auth' in self.__session_details.__dict__ and self.__session_details.auth:\n                return self.__session_details.auth\n        return None\n\n    @property\n    def session_details(self) -&gt; Optional[AdvanceAuthResult]:\n        return self.__session_details\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.auth_identity","title":"<code>auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Authenticates to identity, based on the given information on the constructor If MFA is needed, will also interact with user if allowed Token and other details are stored in the object for later use</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching if cache exists</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Whether interactiveness with the user is allowed or not</p> <code>False</code> <code>force</code> <code>bool</code> <p>Igonre cache and force authenticate. Defaults to False</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates to identity, based on the given information on the constructor\n    If MFA is needed, will also interact with user if allowed\n    Token and other details are stored in the object for later use\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n        interactive (bool): Whether interactiveness with the user is allowed or not\n        force (bool): Igonre cache and force authenticate. Defaults to False\n\n    Raises:\n        ArkException: _description_\n    \"\"\"\n    self.__logger.debug('Attempting to authenticate to Identity')\n    self.__session_details = None\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity details from cache')\n            return\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n\n    # Start the authentication\n    start_auth_response = self.__start_authentication()\n    if start_auth_response.result.idp_redirect_url:\n        # External IDP Flow, ignore the mechanisms and just open a browser\n        self.__perform_idp_authentication(start_auth_response, profile, interactive)\n        return\n\n    # Check if password is part of the first challenges list and if so, answer it directly\n    current_challenge_idx = 0\n    for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n        if mechanism.name.lower() == 'up':\n            current_challenge_idx += 1\n            # Password, answer it\n            if not self.__password:\n                if not interactive:\n                    raise ArkAuthException('No password and not interactive, cannot continue')\n                answers = inquirer.prompt(\n                    [inquirer.Password('answer', message='Identity Security Platform Secret')],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    raise ArkAuthException('Canceled by user')\n                self.__password = answers['answer']\n            advance_resp = self.__advance_authentication(\n                mechanism.mechanism_id, start_auth_response.result.session_id, self.__password, 'Answer'\n            )\n            if isinstance(advance_resp, AdvanceAuthResponse) and len(start_auth_response.result.challenges) == 1:\n                # Done here, save the token\n                self.__session_details = advance_resp.result\n                self.__session.headers.update(\n                    {'Authorization': f'Bearer {advance_resp.result.auth}', **ArkIdentityFQDNResolver.default_headers()}\n                )\n                delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n                self.__session_exp = datetime.now() + timedelta(seconds=delta)\n                if self.__cache_authentication:\n                    self.__save_cache(profile)\n                return\n            break\n\n    # Pick MFA for the user\n    if interactive:\n        self.__pick_mechanism(start_auth_response.result.challenges[current_challenge_idx])\n\n    # Handle a case where MFA type was supplied\n    if self.__mfa_type and self.__mfa_type.lower() in SUPPORTED_MECHANISMS and current_challenge_idx == 1:\n        for mechanism in start_auth_response.result.challenges[current_challenge_idx].mechanisms:\n            if mechanism.name.lower() == self.__mfa_type.lower():\n                oob_advance_resp = self.__advance_authentication(\n                    mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB'\n                )\n                self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n                return\n\n    if not interactive:\n        raise ArkNonInteractiveException('User interaction is not supported while not interactive and mfa type given was not found')\n\n    # Handle the rest of the challenges, might also handle the first challenge if no password is in the mechanisms\n    for challenge in start_auth_response.result.challenges[current_challenge_idx:]:\n        mechanism = self.__pick_mechanism(challenge)\n        oob_advance_resp = self.__advance_authentication(mechanism.mechanism_id, start_auth_response.result.session_id, '', 'StartOOB')\n        self.__poll_authentication(profile, mechanism, start_auth_response, oob_advance_resp, interactive)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.get_apps","title":"<code>get_apps()</code>","text":"<p>Get the applications for the logged in user</p> <p>Raises:</p> Type Description <code>ArkException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def get_apps(self) -&gt; Dict:\n    \"\"\"\n    Get the applications for the logged in user\n\n    Raises:\n        ArkException: _description_\n\n    Returns:\n        Dict: _description_\n    \"\"\"\n    if not self.__session_details:\n        raise ArkException('Identity authentication is required first')\n    cookies = self.__session.cookies.copy()\n    response = self.__session.post(url=f'{self.__identity_url}/UPRest/GetUPData')\n    self.__session.cookies = cookies\n    return json.loads(response.text)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.has_cache_record","title":"<code>has_cache_record(profile, username, refresh_auth_allowed)</code>  <code>classmethod</code>","text":"<p>Checks if a record exists within the identity cache for profile and username</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>username</code> <code>str</code> <p>description</p> required <code>refresh_auth_allowed</code> <code>bool</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\ndef has_cache_record(cls, profile: ArkProfile, username: str, refresh_auth_allowed: bool) -&gt; bool:\n    \"\"\"\n    Checks if a record exists within the identity cache for profile and username\n\n    Args:\n        profile (ArkProfile): _description_\n        username (str): _description_\n        refresh_auth_allowed (bool): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    keyring = ArkKeyring(cls.__name__.lower())\n    token = keyring.load_token(profile, f'{username}_identity')\n    session = keyring.load_token(profile, f'{username}_identity_session')\n    if token is not None and session is not None:\n        if token.expires_in and token.expires_in &lt; datetime.now():\n            if token.refresh_token and refresh_auth_allowed:\n                return True\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.is_idp_user","title":"<code>is_idp_user(username)</code>  <code>classmethod</code>","text":"<p>Checks if a given username is an external id or not</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>@classmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef is_idp_user(cls, username: str) -&gt; bool:\n    \"\"\"\n    Checks if a given username is an external id or not\n\n    Args:\n        username (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    if re.match('.*@cyberark\\\\.cloud\\\\.(\\\\d)+', username) is not None:\n        return False\n    identity = ArkIdentity(username=username, password='')\n    resp = identity.__start_authentication()\n    return resp.result.idp_redirect_url != None\n</code></pre>"},{"location":"reference/auth/identity/ark_identity/#ark_sdk_python.auth.identity.ark_identity.ArkIdentity.refresh_auth_identity","title":"<code>refresh_auth_identity(profile=None, interactive=False, force=False)</code>","text":"<p>Performs refresh platform token with the existing details in the class</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching if cache exists</p> <code>None</code> <code>force</code> <code>bool</code> <p>Igonre cache and force authenticate. Defaults to False</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity.py</code> <pre><code>def refresh_auth_identity(self, profile: Optional[ArkProfile] = None, interactive: bool = False, force: bool = False) -&gt; None:\n    \"\"\"\n    Performs refresh platform token with the existing details in the class\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n        force (bool): Igonre cache and force authenticate. Defaults to False\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    from jose.jwt import get_unverified_claims\n\n    if not self.__session_details.token:\n        # We only refresh platform token at the moment, call the normal authentication instead\n        return self.auth_identity(profile, interactive, force)\n\n    self.__logger.debug('Attempting to refresh authenticate to Identity')\n    self.__session = Session()\n    self.__session.verify = self.__verify\n    self.__session.headers.update(ArkIdentityFQDNResolver.default_headers())\n    decoded_token = get_unverified_claims(self.__session_details.token)\n    platform_tenant_id = decoded_token['tenant_id']\n    cookies = {\n        f'refreshToken-{platform_tenant_id}': self.__session_details.refresh_token,\n        f'idToken-{platform_tenant_id}': self.__session_details.token,\n    }\n    response = self.__session.post(\n        url=f'{self.__identity_url}/OAuth2/RefreshPlatformToken',\n        cookies=cookies,\n    )\n    if response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed to refresh token')\n    new_token = response.cookies.get(f'idToken-{platform_tenant_id}')\n    new_refresh_token = response.cookies.get(f'refreshToken-{platform_tenant_id}')\n    if not new_token or not new_refresh_token:\n        raise ArkAuthException('Failed to retrieve refresh tokens cookies')\n    self.__session_details.token = new_token\n    self.__session_details.refresh_token = new_refresh_token\n    self.__session_details.token_lifetime = (\n        datetime.fromtimestamp(get_unverified_claims(new_token)['exp'])\n        - datetime.fromtimestamp(get_unverified_claims(new_token)['iat'])\n    ).seconds\n    delta = self.__session_details.token_lifetime or DEFAULT_TOKEN_LIFETIME_SECONDS\n    self.__session_exp = datetime.now() + timedelta(seconds=delta)\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/","title":"ark_identity_fqdn_resolver","text":""},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver","title":"<code>ArkIdentityFQDNResolver</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>class ArkIdentityFQDNResolver:\n    __DISCOVERY_SERVICE_DOMAIN_NAME: Final[str] = 'platform-discovery'\n    __DISCOVERY_TIMEOUT: Final[int] = 30\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {\n            'Content-Type': 'application/json',\n            'X-IDAP-NATIVE-CLIENT': 'true',\n            'User-Agent': UserAgent(browsers=['chrome']).chrome,\n            'OobIdPAuth': 'true',\n        }\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def default_system_headers() -&gt; Dict[str, str]:\n        from fake_useragent import UserAgent\n\n        return {'X-IDAP-NATIVE-CLIENT': 'true', 'User-Agent': UserAgent(browsers=['chrome']).chrome}\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n        \"\"\"\n        Resolve the tenant FQDN url from platform discovery by its tenant subdomain.\n        This is based on the environment that currently being worked on and given as an input\n\n        Args:\n            tenant_subdomain (str): the tenant subdomain, e.g. 'mytenant'\n            env (AwsEnv): The environment to try and find the tenant on\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: result of the platform discovery request to get the tenant FQDN\n        \"\"\"\n        platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n        session = Session()\n        response = session.get(\n            f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n            headers={'Content-Type': 'application/json'},\n            timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n        )\n        try:\n            if response.status_code == HTTPStatus.OK:\n                parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n                return str(parsed_response.endpoint)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n        raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @cached(cache=LRUCache(maxsize=1024))\n    def resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Resolve the tenant FQDN url in identity. By default it gets identity address according\n        to the current environment mapping (see get_identity_env_url()), but it can get it as argument (identity_env_url)\n\n        Args:\n            tenant_suffix (str): the tenant url suffix, e.g. '@tenant-a-527.shell.cyberark.cloud'\n            identity_env_url (str, optional): If specified, used as the identity pod0 url. Defaults to None (use environment mapping).\n\n        Raises:\n            ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n        Returns:\n            str: result of the identity request to get the tenant FQDN\n        \"\"\"\n        identity_env_url = identity_env_url or (\n            IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n        )\n        session = Session()\n        response = session.post(\n            f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n            json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n            headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n        )\n        try:\n            parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n        except (ValidationError, TypeError) as ex:\n            raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n        if not parsed_res.result.pod_fqdn.startswith('https://'):\n            parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n        return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_subdomain","title":"<code>resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain, env)</code>  <code>staticmethod</code>","text":"<p>Resolve the tenant FQDN url from platform discovery by its tenant subdomain. This is based on the environment that currently being worked on and given as an input</p> <p>Parameters:</p> Name Type Description Default <code>tenant_subdomain</code> <code>str</code> <p>the tenant subdomain, e.g. 'mytenant'</p> required <code>env</code> <code>AwsEnv</code> <p>The environment to try and find the tenant on</p> required <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>result of the platform discovery request to get the tenant FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_subdomain(tenant_subdomain: str, env: AwsEnv) -&gt; str:\n    \"\"\"\n    Resolve the tenant FQDN url from platform discovery by its tenant subdomain.\n    This is based on the environment that currently being worked on and given as an input\n\n    Args:\n        tenant_subdomain (str): the tenant subdomain, e.g. 'mytenant'\n        env (AwsEnv): The environment to try and find the tenant on\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: result of the platform discovery request to get the tenant FQDN\n    \"\"\"\n    platform_discovery_url = f'https://{ArkIdentityFQDNResolver.__DISCOVERY_SERVICE_DOMAIN_NAME}.{ROOT_DOMAIN[env]}'\n    session = Session()\n    response = session.get(\n        f'{platform_discovery_url}/api/identity-endpoint/{tenant_subdomain}',\n        headers={'Content-Type': 'application/json'},\n        timeout=ArkIdentityFQDNResolver.__DISCOVERY_TIMEOUT,\n    )\n    try:\n        if response.status_code == HTTPStatus.OK:\n            parsed_response: IdentityEndpointResponse = IdentityEndpointResponse.parse_raw(response.text)\n            return str(parsed_response.endpoint)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed from platform discovery to be parsed / validated') from ex\n    raise ArkException(f'Getting tenant FQDN failed from platform discovery [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_fqdn_resolver/#ark_sdk_python.auth.identity.ark_identity_fqdn_resolver.ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix","title":"<code>resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix, identity_env_url=None)</code>  <code>staticmethod</code>","text":"<p>Resolve the tenant FQDN url in identity. By default it gets identity address according to the current environment mapping (see get_identity_env_url()), but it can get it as argument (identity_env_url)</p> <p>Parameters:</p> Name Type Description Default <code>tenant_suffix</code> <code>str</code> <p>the tenant url suffix, e.g. '@tenant-a-527.shell.cyberark.cloud'</p> required <code>identity_env_url</code> <code>str</code> <p>If specified, used as the identity pod0 url. Defaults to None (use environment mapping).</p> <code>None</code> <p>Raises:</p> Type Description <code>ArkException</code> <p>In case of error, or tenant username prefix was not found in identity environment</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>result of the identity request to get the tenant FQDN</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_fqdn_resolver.py</code> <pre><code>@staticmethod\n@cached(cache=LRUCache(maxsize=1024))\ndef resolve_tenant_fqdn_from_tenant_suffix(tenant_suffix: str, identity_env_url: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Resolve the tenant FQDN url in identity. By default it gets identity address according\n    to the current environment mapping (see get_identity_env_url()), but it can get it as argument (identity_env_url)\n\n    Args:\n        tenant_suffix (str): the tenant url suffix, e.g. '@tenant-a-527.shell.cyberark.cloud'\n        identity_env_url (str, optional): If specified, used as the identity pod0 url. Defaults to None (use environment mapping).\n\n    Raises:\n        ArkException: In case of error, or tenant username prefix was not found in identity environment\n\n    Returns:\n        str: result of the identity request to get the tenant FQDN\n    \"\"\"\n    identity_env_url = identity_env_url or (\n        IDENTITY_ENV_URLS[AwsEnv(os.getenv('DEPLOY_ENV', None))] if os.getenv('DEPLOY_ENV', None) else IDENTITY_ENV_URLS[AwsEnv.PROD]\n    )\n    session = Session()\n    response = session.post(\n        f'https://pod0.{identity_env_url}/Security/StartAuthentication',\n        json={'User': tenant_suffix, 'Version': '1.0', 'PlatformTokenResponse': True, 'MfaRequestor': 'DeviceAgent'},\n        headers={'Content-Type': 'application/json', 'X-IDAP-NATIVE-CLIENT': 'true'},\n    )\n    try:\n        parsed_res: TenantFqdnResponse = TenantFqdnResponse.parse_raw(response.text)\n    except (ValidationError, TypeError) as ex:\n        raise ArkException('Getting tenant FQDN failed to be parsed / validated') from ex\n    if not parsed_res.result.pod_fqdn.startswith('https://'):\n        parsed_res.result.pod_fqdn = f'https://{parsed_res.result.pod_fqdn}'\n    return parsed_res.result.pod_fqdn\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_service_user/","title":"ark_identity_service_user","text":""},{"location":"reference/auth/identity/ark_identity_service_user/#ark_sdk_python.auth.identity.ark_identity_service_user.ArkIdentityServiceUser","title":"<code>ArkIdentityServiceUser</code>","text":"Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>class ArkIdentityServiceUser:\n    def __init__(\n        self,\n        username: str,\n        token: str,\n        app_name: str,\n        identity_url: Optional[str] = None,\n        env: Optional[AwsEnv] = None,\n        logger: Optional[logging.Logger] = None,\n        cache_authentication: bool = True,\n        verify: Optional[Union[str, bool]] = None,\n        load_cache: bool = False,\n        cache_profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        self.__username = username\n        self.__token = token\n        self.__app_name = app_name\n        self.__env = env or AwsEnv(os.getenv(DEPLOY_ENV, AwsEnv.PROD.value))\n        self.__identity_url = identity_url or self.__resolve_fqdn_from_username()\n        self.__logger = logger or get_logger(app=self.__class__.__name__)\n        self.__keyring = ArkKeyring(self.__class__.__name__.lower()) if cache_authentication else None\n        self.__cache_authentication = cache_authentication\n\n        self.__session = Session()\n        self.__session_token = None\n        self.__session_exp = None\n        self.__session.headers.update(ArkIdentityFQDNResolver.default_system_headers())\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        if load_cache and cache_authentication and cache_profile:\n            self.__load_cache(cache_profile)\n\n    def __load_cache(self, profile: Optional[ArkProfile] = None) -&gt; bool:\n        if self.__keyring and profile:\n            token = self.__keyring.load_token(profile, f'{self.__username}_identity_service_user')\n            if token and token.username == self.__username:\n                self.__session_token = token.token.get_secret_value()\n                self.__session_exp = token.expires_in\n                self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}'})\n                return True\n        return False\n\n    def __save_cache(self, profile: Optional[ArkProfile] = None) -&gt; None:\n        if self.__keyring and profile and self.__session_token:\n            self.__session_exp = datetime.now() + timedelta(hours=4)\n            self.__keyring.save_token(\n                profile,\n                ArkToken(\n                    token=self.__session_token,\n                    username=self.__username,\n                    endpoint=self.__identity_url,\n                    token_type=ArkTokenType.Internal,\n                    auth_method=ArkAuthMethod.Other,\n                    expires_in=self.__session_exp,\n                ),\n                f'{self.__username}_identity_service_user',\n            )\n\n    def __resolve_fqdn_from_username(self) -&gt; str:\n        tenant_suffix = self.__username[self.__username.index('@') :]\n        return ArkIdentityFQDNResolver.resolve_tenant_fqdn_from_tenant_suffix(\n            tenant_suffix=tenant_suffix, identity_env_url=IDENTITY_ENV_URLS[self.__env]\n        )\n\n    def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n        \"\"\"\n        Authenticates with a service user to identity\n        The authentication creates an identity token and authorizes to the given application\n\n        Args:\n            profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n            force (bool): Whether to discard cache, Defaults to False.\n\n        Raises:\n            ArkAuthException: _description_\n        \"\"\"\n        # Login to identity with the service service user\n        self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n        if self.__cache_authentication and not force and self.__load_cache(profile):\n            # Check if expired\n            if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n                self.__logger.info('Loaded identity service user details from cache')\n                return\n\n        token_response: Response = self.__session.post(\n            url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n            auth=HTTPBasicAuth(self.__username, self.__token),\n            verify=True,\n            data={'grant_type': 'client_credentials', 'scope': 'api'},\n        )\n        if token_response.status_code != HTTPStatus.OK:\n            raise ArkAuthException('Failed logging in to identity service user')\n        auth_result = json.loads(token_response.text)\n        if 'access_token' not in auth_result.keys():\n            raise ArkAuthException('Failed logging in to identity service user, access token not found')\n        access_token = auth_result['access_token']\n\n        # Authorize to the application with the service user\n        params = {\n            'client_id': self.__app_name,\n            'response_type': 'id_token',\n            'scope': 'openid profile api',\n            'redirect_uri': 'https://cyberark.cloud/redirect',\n        }\n        self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n        authorize_response = self.__session.get(\n            url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n            headers={'Authorization': f'Bearer {access_token}'},\n            params=params,\n            allow_redirects=False,\n        )\n        if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n            raise ArkAuthException('Failed to authorize to application')\n        # Parse the authorized token and return the session with it\n        location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n        if len(location_header_splitted) != 2:\n            raise ArkAuthException('Failed to parse location header to retrieve token from')\n        parsed_query = parse_qs(location_header_splitted[1])\n        if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n            raise ArkAuthException('Failed to parse id token from location header')\n        self.__session_token = parsed_query['id_token'][0]\n        self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n        self.__session_exp = datetime.now() + timedelta(hours=4)\n        self.__logger.info(\n            f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n        )\n        if self.__cache_authentication:\n            self.__save_cache(profile)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__session_token\n\n    @property\n    def identity_url(self) -&gt; str:\n        return self.__identity_url\n</code></pre>"},{"location":"reference/auth/identity/ark_identity_service_user/#ark_sdk_python.auth.identity.ark_identity_service_user.ArkIdentityServiceUser.auth_identity","title":"<code>auth_identity(profile=None, force=False)</code>","text":"<p>Authenticates with a service user to identity The authentication creates an identity token and authorizes to the given application</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[ArkProfile]</code> <p>Profile to be used to load from caching if cache exists</p> <code>None</code> <code>force</code> <code>bool</code> <p>Whether to discard cache, Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ArkAuthException</code> <p>description</p> Source code in <code>ark_sdk_python/auth/identity/ark_identity_service_user.py</code> <pre><code>def auth_identity(self, profile: Optional[ArkProfile] = None, force: bool = False) -&gt; None:\n    \"\"\"\n    Authenticates with a service user to identity\n    The authentication creates an identity token and authorizes to the given application\n\n    Args:\n        profile (Optional[ArkProfile]): Profile to be used to load from caching if cache exists\n        force (bool): Whether to discard cache, Defaults to False.\n\n    Raises:\n        ArkAuthException: _description_\n    \"\"\"\n    # Login to identity with the service service user\n    self.__logger.info(f'Authenticating to service user via endpoint [{self.__identity_url}]')\n    if self.__cache_authentication and not force and self.__load_cache(profile):\n        # Check if expired\n        if self.__session_exp.replace(tzinfo=None) &gt; datetime.now():\n            self.__logger.info('Loaded identity service user details from cache')\n            return\n\n    token_response: Response = self.__session.post(\n        url=f'{self.__identity_url}/Oauth2/Token/{self.__app_name}',\n        auth=HTTPBasicAuth(self.__username, self.__token),\n        verify=True,\n        data={'grant_type': 'client_credentials', 'scope': 'api'},\n    )\n    if token_response.status_code != HTTPStatus.OK:\n        raise ArkAuthException('Failed logging in to identity service user')\n    auth_result = json.loads(token_response.text)\n    if 'access_token' not in auth_result.keys():\n        raise ArkAuthException('Failed logging in to identity service user, access token not found')\n    access_token = auth_result['access_token']\n\n    # Authorize to the application with the service user\n    params = {\n        'client_id': self.__app_name,\n        'response_type': 'id_token',\n        'scope': 'openid profile api',\n        'redirect_uri': 'https://cyberark.cloud/redirect',\n    }\n    self.__logger.info(f'Trying to request a platform authorization with params [{params}]')\n    authorize_response = self.__session.get(\n        url=f'{self.__identity_url}/OAuth2/Authorize/{self.__app_name}',\n        headers={'Authorization': f'Bearer {access_token}'},\n        params=params,\n        allow_redirects=False,\n    )\n    if authorize_response.status_code != HTTPStatus.FOUND or 'Location' not in authorize_response.headers:\n        raise ArkAuthException('Failed to authorize to application')\n    # Parse the authorized token and return the session with it\n    location_header_splitted = authorize_response.headers['Location'].split('#', 1)\n    if len(location_header_splitted) != 2:\n        raise ArkAuthException('Failed to parse location header to retrieve token from')\n    parsed_query = parse_qs(location_header_splitted[1])\n    if 'id_token' not in parsed_query or len(parsed_query['id_token']) != 1:\n        raise ArkAuthException('Failed to parse id token from location header')\n    self.__session_token = parsed_query['id_token'][0]\n    self.__session.headers.update({'Authorization': f'Bearer {self.__session_token}', **ArkIdentityFQDNResolver.default_headers()})\n    self.__session_exp = datetime.now() + timedelta(hours=4)\n    self.__logger.info(\n        f'Created a service user session via endpoint [{self.__identity_url}] ' f'with user [{self.__username}] to platform'\n    )\n    if self.__cache_authentication:\n        self.__save_cache(profile)\n</code></pre>"},{"location":"reference/cli_services/","title":"cli_services","text":""},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI","title":"<code>ArkCLIAPI</code>","text":"<p>             Bases: <code>ArkAPI</code></p> Source code in <code>ark_sdk_python/cli_services/ark_cli_api.py</code> <pre><code>class ArkCLIAPI(ArkAPI):\n    @property\n    def dpa_policies_db_editor(self) -&gt; \"ArkDPADBPoliciesEditorService\":\n        \"\"\"\n        DB Policies Editor CLI Service\n\n        Returns:\n            ArkDPADBPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.dpa.db import ArkDPADBPoliciesEditorService\n\n        return ArkDPADBPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n</code></pre>"},{"location":"reference/cli_services/#ark_sdk_python.cli_services.ArkCLIAPI.dpa_policies_db_editor","title":"<code>dpa_policies_db_editor: 'ArkDPADBPoliciesEditorService'</code>  <code>property</code>","text":"<p>DB Policies Editor CLI Service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesEditorService</code> <code>'ArkDPADBPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/ark_cli_api/","title":"ark_cli_api","text":""},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI","title":"<code>ArkCLIAPI</code>","text":"<p>             Bases: <code>ArkAPI</code></p> Source code in <code>ark_sdk_python/cli_services/ark_cli_api.py</code> <pre><code>class ArkCLIAPI(ArkAPI):\n    @property\n    def dpa_policies_db_editor(self) -&gt; \"ArkDPADBPoliciesEditorService\":\n        \"\"\"\n        DB Policies Editor CLI Service\n\n        Returns:\n            ArkDPADBPoliciesEditorService: _description_\n        \"\"\"\n        from ark_sdk_python.cli_services.dpa.db import ArkDPADBPoliciesEditorService\n\n        return ArkDPADBPoliciesEditorService(self.authenticator('isp'), profile=self.profile)\n</code></pre>"},{"location":"reference/cli_services/ark_cli_api/#ark_sdk_python.cli_services.ark_cli_api.ArkCLIAPI.dpa_policies_db_editor","title":"<code>dpa_policies_db_editor: 'ArkDPADBPoliciesEditorService'</code>  <code>property</code>","text":"<p>DB Policies Editor CLI Service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesEditorService</code> <code>'ArkDPADBPoliciesEditorService'</code> <p>description</p>"},{"location":"reference/cli_services/dpa/","title":"dpa","text":""},{"location":"reference/cli_services/dpa/common/","title":"common","text":""},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/","title":"ark_dpa_base_policies_editor_service","text":""},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService","title":"<code>ArkDPABasePoliciesEditorService</code>","text":"<p>             Bases: <code>ArkService</code>, <code>ABC</code>, <code>Generic[PolicyType, PolicyListItemType, AddPolicyType, UpdatePolicyType, GeneratePolicyType]</code></p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>class ArkDPABasePoliciesEditorService(\n    ArkService, ABC, Generic[PolicyType, PolicyListItemType, AddPolicyType, UpdatePolicyType, GeneratePolicyType]\n):\n    def __init__(\n        self,\n        policy_type: PolicyType,\n        add_policy_type: AddPolicyType,\n        update_policy_type: UpdatePolicyType,\n        isp_auth: ArkISPAuth,\n        policies_family: str,\n        tenant_id: str,\n        policies_cache_dir: Optional[str] = None,\n        profile: Optional[ArkProfile] = None,\n    ) -&gt; None:\n        super().__init__(isp_auth)\n        profile = profile or ArkProfileLoader.load_default_profile()\n        self._policies_family = policies_family\n        self.__policies_cache_dir = Path(policies_cache_dir or Path.home() / '.ark_cache' / 'profiles' / profile.profile_name / tenant_id)\n        if not policies_cache_dir and 'ARK_DPA_POLICIES_EDITOR_FOLDER' in os.environ:\n            self.__policies_cache_dir = Path(os.environ['ARK_DPA_POLICIES_EDITOR_FOLDER'])\n        self.__policies_cache_dir = self.__policies_cache_dir / policies_family\n        self.__policies_cache_dir.mkdir(exist_ok=True, parents=True)\n        self.__policy_type = policy_type\n        self.__add_policy_type = add_policy_type\n        self.__update_policy_type = update_policy_type\n\n    @abstractmethod\n    def _policy(self, get_policy: ArkDPAGetPolicy) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _list_policies(self) -&gt; List[PolicyListItemType]:\n        pass\n\n    @abstractmethod\n    def _add_policy(self, add_policy: AddPolicyType) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _update_policy(self, update_policy: UpdatePolicyType) -&gt; PolicyType:\n        pass\n\n    @abstractmethod\n    def _delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        pass\n\n    @abstractmethod\n    def _generate_policy(self, generate_policy: GeneratePolicyType, workspace_policies: List[PolicyType]) -&gt; PolicyType:\n        pass\n\n    def __load_policy_diff(self, workspace_policy: PolicyType) -&gt; Optional[Tuple[PolicyType, PolicyType]]:\n        remote_policy = self._policy(ArkDPAGetPolicy(policy_id=str(workspace_policy.policy_id)))\n        if remote_policy != workspace_policy:\n            return (workspace_policy, remote_policy)\n        return None\n\n    def __load_policies_diff(self) -&gt; Dict[str, Tuple[PolicyType, PolicyType]]:\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        with ThreadPoolExecutor() as executor:\n            remote_policies = {\n                p[0].policy_name: p for p in executor.map(self.__load_policy_diff, workspace_policies.values()) if p is not None\n            }\n            return remote_policies\n\n    def __load_policies_from_workspace_by_suffix(self, suffix: str = '') -&gt; Dict[str, PolicyType]:\n        p = Path(self.__policies_cache_dir).glob(f'*.json{suffix}')\n        policies_files = [x for x in p if x.is_file() and x.suffix == suffix or '.json']\n        policies = {}\n        for f in policies_files:\n            policy = self.__policy_type.parse_file(f)\n            policies[policy.policy_name] = policy\n        return policies\n\n    def __load_removed_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix('.removed')\n\n    def __load_generated_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix('.generated')\n\n    def __load_existing_policies_from_workspace(self) -&gt; Dict[str, PolicyType]:\n        return self.__load_policies_from_workspace_by_suffix()\n\n    def __load_policy_to_workspace(self, policy: PolicyListItemType, override: bool) -&gt; Optional[PolicyType]:\n        policy_data = self._policy(ArkDPAGetPolicy(policy_id=policy.policy_id))\n        policy_path = Path(self.__policies_cache_dir) / (policy_data.policy_name + '.json')\n        if policy_path.exists():\n            existing_data = self.__policy_type.parse_raw(policy_path.read_text())\n            if existing_data != policy_data:\n                if not override:\n                    return policy_data\n        if not policy_data.policy_id:\n            policy_data.policy_id = policy.policy_id\n        policy_path.write_text(policy_data.json(indent=4))\n        (Path(self.__policies_cache_dir) / (policy_data.policy_name + '.json.removed')).unlink(missing_ok=True)\n\n    def load_policies(self, load_policies: ArkDPALoadPolicies) -&gt; ArkDPALoadedPolicies:\n        \"\"\"\n        Loads all the remote policies into the workspace\n        Will ask the user whether to override already existing policies which were changed either locally or remotely\n        If the user supplied to override by default, will not prompt the user for questions\n\n        Args:\n            load_policies (ArkDPALoadPolicies): _description_\n\n        Returns:\n            ArkDPALoadedPolicies: _description_\n        \"\"\"\n        policies = self._list_policies()\n        policies_to_query: Dict[str, PolicyType] = []\n        with ThreadPoolExecutor() as executor:\n            policies_to_query = {\n                p.policy_name: p\n                for p in executor.map(lambda p: self.__load_policy_to_workspace(p, load_policies.override), policies)\n                if p is not None\n            }\n        # Build the query editor to ask the user\n        policies_to_override = []\n        if policies_to_query:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'override',\n                        message=f'Conflicts detected, please choose if you wish to override local {self._policies_family} policies or leave them as is',\n                        choices=[p.policy_name for p in policies_to_query.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policies_to_override = answers['override']\n            for policy_name in policies_to_override:\n                policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n                if policy_path.exists() and policy_name in policies_to_query:\n                    policy_path.write_text(policies_to_query[policy_name].json(indent=4))\n        return ArkDPALoadedPolicies(\n            loaded_path=str(self.__policies_cache_dir),\n            overall_policies_count=len(policies),\n            loaded_policies_count=len(policies) - len(policies_to_query),\n            overriden_policies_count=len(policies_to_override),\n            untouched_policies_count=len(policies_to_query) - len(policies_to_override),\n        )\n\n    def edit_policies(self, edit_policies: ArkDPAEditPolicies) -&gt; None:\n        \"\"\"\n        For given set of policies, either from the cli or from prompt questions\n        Edits the policies one by one using the defined machine editor\n        Each policy can be edited and later on, will be saved to the local workspace\n        Edited policies are not updated remotely until a commit action is executed\n\n        Args:\n            edit_policies (ArkDPAEditPolicies): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        if not workspace_policies:\n            raise ArkServiceException(\n                f'No {self._policies_family} policies to edit in the workspace, please load the policies or generate a new one'\n            )\n        policy_names = edit_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to edit?, press space to select',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        try:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Editor(f'{name}_edit', message=f'Chosen {self._policies_family} policy [{name}] is about to be edited')\n                    for name in policy_names\n                ],\n                render=ArkInquirerRender(),\n                answers={f'{name}_edit': workspace_policies[name].json(indent=4) for name in policy_names},\n            )\n            for name in policy_names:\n                policy = self.__policy_type.parse_raw(answers[f'{name}_edit'])\n                for path in [\n                    Path(self.__policies_cache_dir) / (name + '.json'),\n                    Path(self.__policies_cache_dir) / (name + '.json.generated'),\n                ]:\n                    if path.exists():\n                        path.write_text(policy.json(indent=4))\n                        break\n        except EditorError as ex:\n            self._logger.error(\n                f'An error occurred while trying to edit {self._policies_family} policies, '\n                f'you can edit the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def remove_policies(self, remove_policies: ArkDPARemovePolicies) -&gt; None:\n        \"\"\"\n        Removes one or more policies from the workspace\n        Removing a remote policy will result in only renaming it to .deleted\n        This will ignore the policy locally on actions performed by the editor\n        Once a commit action is performed, the policy is deleted both locally and remotely\n        For newly generated policies which were not committed yet, they will be just deleted from the machine after the user consents to it\n\n        Args:\n            remove_policies (ArkDPARemovePolicies): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        if not workspace_policies:\n            raise ArkServiceException(\n                f'No {self._policies_family} policies to remove in the workspace, please load the policies or generate a new one'\n            )\n        policy_names = remove_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to remove?, press space to select',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        for policy_name in policy_names:\n            for path in [\n                Path(self.__policies_cache_dir) / (policy_name + '.json'),\n                Path(self.__policies_cache_dir) / (policy_name + '.json.generated'),\n            ]:\n                if path.exists():\n                    if path.suffix == '.json':\n                        path.rename(Path(self.__policies_cache_dir) / (policy_name + '.json.removed'))\n                    else:\n                        answers = inquirer.prompt(\n                            [\n                                inquirer.Confirm(\n                                    'remove',\n                                    message=f'Are you sure you want to remove local {self._policies_family} policy [{policy_name}]?, removing an uncommitted local policy cannot be reverted',\n                                )\n                            ],\n                            render=ArkInquirerRender(),\n                        )\n                        if not answers:\n                            return\n                        if answers['remove']:\n                            path.unlink(missing_ok=True)\n\n    def view_policies(self, view_policies: ArkDPAViewPolicies) -&gt; None:\n        \"\"\"\n        Allows the user to view one or more policies together or seperetly, picked by the cli or by prompt to the user\n        Each policy viewed by the editor of the machine, both for existing policies and newly generated policies\n\n        Args:\n            view_policies (ArkDPAViewPolicies): _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        policy_names = view_policies.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to view?',\n                        choices=[p.policy_name for p in workspace_policies.values()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        if not policy_names:\n            return\n        try:\n            if view_policies.unified:\n                inquirer.prompt(\n                    [inquirer.Editor('views', f'Show all selected {self._policies_family} policies')],\n                    answers={\n                        'views': '\\n\\n\\n'.join(\n                            [f'# Policy [{policy_name}]\\n{workspace_policies[policy_name].json(indent=4)}' for policy_name in policy_names]\n                        )\n                    },\n                    render=ArkInquirerRender(),\n                )\n            else:\n                inquirer.prompt(\n                    [inquirer.Editor(f'{policy_name}_view', f'Show [{policy_name}]') for policy_name in policy_names],\n                    render=ArkInquirerRender(),\n                    answers={f'{policy_name}_view': workspace_policies[policy_name].json(indent=4) for policy_name in policy_names},\n                )\n        except EditorError as ex:\n            self._logger.error(\n                f'An error occurred while trying to view the {self._policies_family} policies, '\n                f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def reset_policies(self, reset_policy: ArkDPAResetPolicies) -&gt; None:\n        \"\"\"\n        Resets the local workspace policies\n        If all policies reset was given, will reload all the policies and override the local policies and delete any already removed policies\n        Newly generated uncommitted policies are not touched\n        If not all policies reset was given, the user can choose which policies he would like to reset\n\n        Args:\n            reset_policy (ArkDPAResetPolicies): _description_\n        \"\"\"\n        if reset_policy.all:\n            answers = inquirer.prompt(\n                [inquirer.Confirm('reset', message=f'Are you sure you want to reset all edited {self._policies_family} policies?')]\n            )\n            if not answers:\n                return\n            if answers['reset']:\n                self.load_policies(ArkDPALoadPolicies(override=True))\n        else:\n            policies_diff = self.__load_policies_diff()\n            removed_policies = self.__load_removed_policies_from_workspace()\n            if not policies_diff and not removed_policies:\n                return\n            policy_names = reset_policy.names\n            if not policy_names:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Checkbox(\n                            'names',\n                            f'Which {self._policies_family} policies would you like to reset?, press space to select',\n                            choices=[p for p in policies_diff.keys() + removed_policies.keys()],\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    return\n                policy_names = answers['names']\n            policy_names = [p for p in policy_names if p in policies_diff or p in removed_policies]\n            for policy_name in policy_names:\n                policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n                if policy_name in policies_diff:\n                    policy_path.write_text(policies_diff[policy_name][1].json(indent=4))\n                elif policy_name in removed_policies:\n                    policy_path.write_text(removed_policies[policy_name].json(indent=4))\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n\n    def generate_policy(self, generate_policy: GeneratePolicyType) -&gt; None:\n        \"\"\"\n        Generates a new policy from a template and from the users parameters\n        The user will be prompted for the parameters if not supplied by the CLI\n        Once the parameters were decided, generates a policy in memory and lets the user edit it\n        Once the user finishes editing the policy, saves it on the workspace until it is committed\n\n        Args:\n            generate_policy (GeneratePolicyType): _description_\n        \"\"\"\n        workspace_policies = self.__load_existing_policies_from_workspace()\n        workspace_policies.update(self.__load_generated_policies_from_workspace())\n        policy = self._generate_policy(generate_policy, workspace_policies)\n        policy_path = Path(self.__policies_cache_dir) / (policy.policy_name + '.json.generated')\n        # Let the user edit the generated policy\n        if not generate_policy.disable_edit:\n            try:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Editor(\n                            'policy_editor',\n                            f'Newly {self._policies_family} policy is generated and ready to be edited, once edited, it will be saved to the local workspace',\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                    answers={'policy_editor': policy.json(indent=4, exclude_none=True)},\n                )\n                if not answers:\n                    return\n                policy = self.__policy_type.parse_raw(answers['policy_editor'])\n            except EditorError as ex:\n                self._logger.error(\n                    f'An error occurred while trying to edit the {self._policies_family} policy, '\n                    f'the policy will be saved to [{policy_path}] and can be edited manually [{str(ex)}]'\n                )\n        policy_path.write_text(policy.json(indent=4))\n\n    def policies_diff(self, policies_diff: ArkDPAPoliciesDiff) -&gt; None:\n        \"\"\"\n        Calculates the policies diff between the local workspace policies and the remote policies\n        Alongside that, also loads the already removed policies which were not committed\n        Displays the diffs unified or per policy\n\n        Args:\n            policies_diff (ArkDPAPoliciesDiff): _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        if not loaded_policies_diff and not removed_policies:\n            return\n        if policies_diff.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in policies_diff.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in policies_diff.names}\n        if not loaded_policies_diff and not removed_policies:\n            return\n        diffs = {\n            policy_name: difflib.unified_diff(\n                policy_tuple[1].json(indent=4).splitlines(True),\n                policy_tuple[0].json(indent=4).splitlines(True),\n                fromfile=f'local policy [{policy_name}]',\n                tofile=f'remote policy [{policy_name}]',\n                n=MAX_LINE_DIFF,\n            )\n            for policy_name, policy_tuple in loaded_policies_diff.items()\n        }\n        diffs.update(\n            {\n                policy_name: difflib.unified_diff(\n                    policy.json(indent=4).splitlines(True),\n                    '',\n                    fromfile=f'local policy [{policy_name}]',\n                    tofile=f'remote policy [{policy_name}]',\n                    n=MAX_LINE_DIFF,\n                )\n                for policy_name, policy in removed_policies.items()\n            }\n        )\n        try:\n            if policies_diff.unified:\n                inquirer.prompt(\n                    [inquirer.Editor('diffs', 'Show all diffs')],\n                    render=ArkInquirerRender(),\n                    answers={'diffs': '\\n\\n\\n'.join([''.join(d) for d in diffs.values()])},\n                )\n            else:\n                inquirer.prompt(\n                    [inquirer.Editor(f'{policy_name}_diff', f'Show [{policy_name}] diff') for policy_name in diffs.keys()],\n                    render=ArkInquirerRender(),\n                    answers={f'{policy_name}_diff': ''.join(policy_diffs) for policy_name, policy_diffs in diffs.items()},\n                )\n        except EditorError as ex:\n            self._logger.error(\n                f'An error occurred while trying to show {self._policies_family} policies diff, '\n                f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n            )\n\n    def policies_status(self, get_policies_status: ArkDPAGetPoliciesStatus) -&gt; ArkDPAPoliciesStatus:\n        \"\"\"\n        Gets the currently locally altered policies status\n\n        Args:\n            get_policies_status (ArkDPAGetPoliciesStatus): _description_\n\n        Returns:\n            ArkDPAPoliciesStatus: _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        generated_policies = self.__load_generated_policies_from_workspace()\n        if get_policies_status.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in get_policies_status.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in get_policies_status.names}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in get_policies_status.names}\n        return ArkDPAPoliciesStatus(\n            modified_policies=list(loaded_policies_diff.keys()),\n            removed_policies=list(removed_policies.keys()),\n            added_policies=list(generated_policies.keys()),\n        )\n\n    def commit_policies(self, commit_policies: ArkDPACommitPolicies) -&gt; None:\n        \"\"\"\n        Committes all the edited policies\n        First calculates the differences between the local and remote policies to find out which policies were edited\n        Alongside that, loads the policies that were chosen to be deleted, and policies that were generated and not committed yet\n        Lets the user choose whether he wants to commit all the edited policies, or only specific names\n        Once all policies were committed, re-organizes the workspace accordingly\n\n        Args:\n            commit_policies (ArkDPACommitPolicies): _description_\n        \"\"\"\n        loaded_policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        generated_policies = self.__load_generated_policies_from_workspace()\n        if not loaded_policies_diff and not removed_policies and not generated_policies:\n            return\n        if commit_policies.all:\n            answers = inquirer.prompt(\n                [inquirer.Confirm('reset', message=f'Are you sure you want to commit all edited {self._policies_family} policies?')]\n            )\n            if not answers or not answers['reset']:\n                return\n        else:\n            if commit_policies.names:\n                loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in commit_policies.names}\n                removed_policies = {k: v for k, v in removed_policies.items() if k in commit_policies.names}\n                generated_policies = {k: v for k, v in generated_policies.items() if k in commit_policies.names}\n            else:\n                answers = inquirer.prompt(\n                    [\n                        inquirer.Checkbox(\n                            'names',\n                            f'Which {self._policies_family} policies would you like to commit?, press space to select',\n                            choices=list(loaded_policies_diff.keys()) + list(removed_policies.keys()) + list(generated_policies.keys()),\n                        )\n                    ],\n                    render=ArkInquirerRender(),\n                )\n                if not answers:\n                    return\n                loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in answers['names']}\n                removed_policies = {k: v for k, v in removed_policies.items() if k in answers['names']}\n                generated_policies = {k: v for k, v in generated_policies.items() if k in answers['names']}\n            if not loaded_policies_diff and not removed_policies and not generated_policies:\n                return\n        with ThreadPoolExecutor() as executor:\n            added = executor.map(lambda p: self._add_policy(self.__add_policy_type(**p.dict())), generated_policies.values())\n            updated = executor.map(lambda p: self._update_policy(self.__update_policy_type(**p[0].dict())), loaded_policies_diff.values())\n            deleted = executor.map(\n                lambda p: self._delete_policy(ArkDPADeletePolicy(policy_id=p.policy_id, policy_name=p.policy_name)),\n                removed_policies.values(),\n            )\n            # Loop for exception checking\n            added_policies = list(added)\n            for _ in itertools.chain(updated, deleted):\n                pass\n        for policy_name in removed_policies.keys():\n            (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n        for policy_name in generated_policies.keys():\n            for policy in added_policies:\n                if policy.policy_name == policy_name:\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json.generated')).rename(\n                        (Path(self.__policies_cache_dir) / (policy_name + '.json'))\n                    )\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json')).write_text(policy.json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.commit_policies","title":"<code>commit_policies(commit_policies)</code>","text":"<p>Committes all the edited policies First calculates the differences between the local and remote policies to find out which policies were edited Alongside that, loads the policies that were chosen to be deleted, and policies that were generated and not committed yet Lets the user choose whether he wants to commit all the edited policies, or only specific names Once all policies were committed, re-organizes the workspace accordingly</p> <p>Parameters:</p> Name Type Description Default <code>commit_policies</code> <code>ArkDPACommitPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def commit_policies(self, commit_policies: ArkDPACommitPolicies) -&gt; None:\n    \"\"\"\n    Committes all the edited policies\n    First calculates the differences between the local and remote policies to find out which policies were edited\n    Alongside that, loads the policies that were chosen to be deleted, and policies that were generated and not committed yet\n    Lets the user choose whether he wants to commit all the edited policies, or only specific names\n    Once all policies were committed, re-organizes the workspace accordingly\n\n    Args:\n        commit_policies (ArkDPACommitPolicies): _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    generated_policies = self.__load_generated_policies_from_workspace()\n    if not loaded_policies_diff and not removed_policies and not generated_policies:\n        return\n    if commit_policies.all:\n        answers = inquirer.prompt(\n            [inquirer.Confirm('reset', message=f'Are you sure you want to commit all edited {self._policies_family} policies?')]\n        )\n        if not answers or not answers['reset']:\n            return\n    else:\n        if commit_policies.names:\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in commit_policies.names}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in commit_policies.names}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in commit_policies.names}\n        else:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to commit?, press space to select',\n                        choices=list(loaded_policies_diff.keys()) + list(removed_policies.keys()) + list(generated_policies.keys()),\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in answers['names']}\n            removed_policies = {k: v for k, v in removed_policies.items() if k in answers['names']}\n            generated_policies = {k: v for k, v in generated_policies.items() if k in answers['names']}\n        if not loaded_policies_diff and not removed_policies and not generated_policies:\n            return\n    with ThreadPoolExecutor() as executor:\n        added = executor.map(lambda p: self._add_policy(self.__add_policy_type(**p.dict())), generated_policies.values())\n        updated = executor.map(lambda p: self._update_policy(self.__update_policy_type(**p[0].dict())), loaded_policies_diff.values())\n        deleted = executor.map(\n            lambda p: self._delete_policy(ArkDPADeletePolicy(policy_id=p.policy_id, policy_name=p.policy_name)),\n            removed_policies.values(),\n        )\n        # Loop for exception checking\n        added_policies = list(added)\n        for _ in itertools.chain(updated, deleted):\n            pass\n    for policy_name in removed_policies.keys():\n        (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n    for policy_name in generated_policies.keys():\n        for policy in added_policies:\n            if policy.policy_name == policy_name:\n                (Path(self.__policies_cache_dir) / (policy_name + '.json.generated')).rename(\n                    (Path(self.__policies_cache_dir) / (policy_name + '.json'))\n                )\n                (Path(self.__policies_cache_dir) / (policy_name + '.json')).write_text(policy.json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.edit_policies","title":"<code>edit_policies(edit_policies)</code>","text":"<p>For given set of policies, either from the cli or from prompt questions Edits the policies one by one using the defined machine editor Each policy can be edited and later on, will be saved to the local workspace Edited policies are not updated remotely until a commit action is executed</p> <p>Parameters:</p> Name Type Description Default <code>edit_policies</code> <code>ArkDPAEditPolicies</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def edit_policies(self, edit_policies: ArkDPAEditPolicies) -&gt; None:\n    \"\"\"\n    For given set of policies, either from the cli or from prompt questions\n    Edits the policies one by one using the defined machine editor\n    Each policy can be edited and later on, will be saved to the local workspace\n    Edited policies are not updated remotely until a commit action is executed\n\n    Args:\n        edit_policies (ArkDPAEditPolicies): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    if not workspace_policies:\n        raise ArkServiceException(\n            f'No {self._policies_family} policies to edit in the workspace, please load the policies or generate a new one'\n        )\n    policy_names = edit_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to edit?, press space to select',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    try:\n        answers = inquirer.prompt(\n            [\n                inquirer.Editor(f'{name}_edit', message=f'Chosen {self._policies_family} policy [{name}] is about to be edited')\n                for name in policy_names\n            ],\n            render=ArkInquirerRender(),\n            answers={f'{name}_edit': workspace_policies[name].json(indent=4) for name in policy_names},\n        )\n        for name in policy_names:\n            policy = self.__policy_type.parse_raw(answers[f'{name}_edit'])\n            for path in [\n                Path(self.__policies_cache_dir) / (name + '.json'),\n                Path(self.__policies_cache_dir) / (name + '.json.generated'),\n            ]:\n                if path.exists():\n                    path.write_text(policy.json(indent=4))\n                    break\n    except EditorError as ex:\n        self._logger.error(\n            f'An error occurred while trying to edit {self._policies_family} policies, '\n            f'you can edit the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.generate_policy","title":"<code>generate_policy(generate_policy)</code>","text":"<p>Generates a new policy from a template and from the users parameters The user will be prompted for the parameters if not supplied by the CLI Once the parameters were decided, generates a policy in memory and lets the user edit it Once the user finishes editing the policy, saves it on the workspace until it is committed</p> <p>Parameters:</p> Name Type Description Default <code>generate_policy</code> <code>GeneratePolicyType</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def generate_policy(self, generate_policy: GeneratePolicyType) -&gt; None:\n    \"\"\"\n    Generates a new policy from a template and from the users parameters\n    The user will be prompted for the parameters if not supplied by the CLI\n    Once the parameters were decided, generates a policy in memory and lets the user edit it\n    Once the user finishes editing the policy, saves it on the workspace until it is committed\n\n    Args:\n        generate_policy (GeneratePolicyType): _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    policy = self._generate_policy(generate_policy, workspace_policies)\n    policy_path = Path(self.__policies_cache_dir) / (policy.policy_name + '.json.generated')\n    # Let the user edit the generated policy\n    if not generate_policy.disable_edit:\n        try:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Editor(\n                        'policy_editor',\n                        f'Newly {self._policies_family} policy is generated and ready to be edited, once edited, it will be saved to the local workspace',\n                    )\n                ],\n                render=ArkInquirerRender(),\n                answers={'policy_editor': policy.json(indent=4, exclude_none=True)},\n            )\n            if not answers:\n                return\n            policy = self.__policy_type.parse_raw(answers['policy_editor'])\n        except EditorError as ex:\n            self._logger.error(\n                f'An error occurred while trying to edit the {self._policies_family} policy, '\n                f'the policy will be saved to [{policy_path}] and can be edited manually [{str(ex)}]'\n            )\n    policy_path.write_text(policy.json(indent=4))\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.load_policies","title":"<code>load_policies(load_policies)</code>","text":"<p>Loads all the remote policies into the workspace Will ask the user whether to override already existing policies which were changed either locally or remotely If the user supplied to override by default, will not prompt the user for questions</p> <p>Parameters:</p> Name Type Description Default <code>load_policies</code> <code>ArkDPALoadPolicies</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPALoadedPolicies</code> <code>ArkDPALoadedPolicies</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def load_policies(self, load_policies: ArkDPALoadPolicies) -&gt; ArkDPALoadedPolicies:\n    \"\"\"\n    Loads all the remote policies into the workspace\n    Will ask the user whether to override already existing policies which were changed either locally or remotely\n    If the user supplied to override by default, will not prompt the user for questions\n\n    Args:\n        load_policies (ArkDPALoadPolicies): _description_\n\n    Returns:\n        ArkDPALoadedPolicies: _description_\n    \"\"\"\n    policies = self._list_policies()\n    policies_to_query: Dict[str, PolicyType] = []\n    with ThreadPoolExecutor() as executor:\n        policies_to_query = {\n            p.policy_name: p\n            for p in executor.map(lambda p: self.__load_policy_to_workspace(p, load_policies.override), policies)\n            if p is not None\n        }\n    # Build the query editor to ask the user\n    policies_to_override = []\n    if policies_to_query:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'override',\n                    message=f'Conflicts detected, please choose if you wish to override local {self._policies_family} policies or leave them as is',\n                    choices=[p.policy_name for p in policies_to_query.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policies_to_override = answers['override']\n        for policy_name in policies_to_override:\n            policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n            if policy_path.exists() and policy_name in policies_to_query:\n                policy_path.write_text(policies_to_query[policy_name].json(indent=4))\n    return ArkDPALoadedPolicies(\n        loaded_path=str(self.__policies_cache_dir),\n        overall_policies_count=len(policies),\n        loaded_policies_count=len(policies) - len(policies_to_query),\n        overriden_policies_count=len(policies_to_override),\n        untouched_policies_count=len(policies_to_query) - len(policies_to_override),\n    )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.policies_diff","title":"<code>policies_diff(policies_diff)</code>","text":"<p>Calculates the policies diff between the local workspace policies and the remote policies Alongside that, also loads the already removed policies which were not committed Displays the diffs unified or per policy</p> <p>Parameters:</p> Name Type Description Default <code>policies_diff</code> <code>ArkDPAPoliciesDiff</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def policies_diff(self, policies_diff: ArkDPAPoliciesDiff) -&gt; None:\n    \"\"\"\n    Calculates the policies diff between the local workspace policies and the remote policies\n    Alongside that, also loads the already removed policies which were not committed\n    Displays the diffs unified or per policy\n\n    Args:\n        policies_diff (ArkDPAPoliciesDiff): _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    if not loaded_policies_diff and not removed_policies:\n        return\n    if policies_diff.names:\n        loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in policies_diff.names}\n        removed_policies = {k: v for k, v in removed_policies.items() if k in policies_diff.names}\n    if not loaded_policies_diff and not removed_policies:\n        return\n    diffs = {\n        policy_name: difflib.unified_diff(\n            policy_tuple[1].json(indent=4).splitlines(True),\n            policy_tuple[0].json(indent=4).splitlines(True),\n            fromfile=f'local policy [{policy_name}]',\n            tofile=f'remote policy [{policy_name}]',\n            n=MAX_LINE_DIFF,\n        )\n        for policy_name, policy_tuple in loaded_policies_diff.items()\n    }\n    diffs.update(\n        {\n            policy_name: difflib.unified_diff(\n                policy.json(indent=4).splitlines(True),\n                '',\n                fromfile=f'local policy [{policy_name}]',\n                tofile=f'remote policy [{policy_name}]',\n                n=MAX_LINE_DIFF,\n            )\n            for policy_name, policy in removed_policies.items()\n        }\n    )\n    try:\n        if policies_diff.unified:\n            inquirer.prompt(\n                [inquirer.Editor('diffs', 'Show all diffs')],\n                render=ArkInquirerRender(),\n                answers={'diffs': '\\n\\n\\n'.join([''.join(d) for d in diffs.values()])},\n            )\n        else:\n            inquirer.prompt(\n                [inquirer.Editor(f'{policy_name}_diff', f'Show [{policy_name}] diff') for policy_name in diffs.keys()],\n                render=ArkInquirerRender(),\n                answers={f'{policy_name}_diff': ''.join(policy_diffs) for policy_name, policy_diffs in diffs.items()},\n            )\n    except EditorError as ex:\n        self._logger.error(\n            f'An error occurred while trying to show {self._policies_family} policies diff, '\n            f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.policies_status","title":"<code>policies_status(get_policies_status)</code>","text":"<p>Gets the currently locally altered policies status</p> <p>Parameters:</p> Name Type Description Default <code>get_policies_status</code> <code>ArkDPAGetPoliciesStatus</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPAPoliciesStatus</code> <code>ArkDPAPoliciesStatus</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def policies_status(self, get_policies_status: ArkDPAGetPoliciesStatus) -&gt; ArkDPAPoliciesStatus:\n    \"\"\"\n    Gets the currently locally altered policies status\n\n    Args:\n        get_policies_status (ArkDPAGetPoliciesStatus): _description_\n\n    Returns:\n        ArkDPAPoliciesStatus: _description_\n    \"\"\"\n    loaded_policies_diff = self.__load_policies_diff()\n    removed_policies = self.__load_removed_policies_from_workspace()\n    generated_policies = self.__load_generated_policies_from_workspace()\n    if get_policies_status.names:\n        loaded_policies_diff = {k: v for k, v in loaded_policies_diff.items() if k in get_policies_status.names}\n        removed_policies = {k: v for k, v in removed_policies.items() if k in get_policies_status.names}\n        generated_policies = {k: v for k, v in generated_policies.items() if k in get_policies_status.names}\n    return ArkDPAPoliciesStatus(\n        modified_policies=list(loaded_policies_diff.keys()),\n        removed_policies=list(removed_policies.keys()),\n        added_policies=list(generated_policies.keys()),\n    )\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.remove_policies","title":"<code>remove_policies(remove_policies)</code>","text":"<p>Removes one or more policies from the workspace Removing a remote policy will result in only renaming it to .deleted This will ignore the policy locally on actions performed by the editor Once a commit action is performed, the policy is deleted both locally and remotely For newly generated policies which were not committed yet, they will be just deleted from the machine after the user consents to it</p> <p>Parameters:</p> Name Type Description Default <code>remove_policies</code> <code>ArkDPARemovePolicies</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def remove_policies(self, remove_policies: ArkDPARemovePolicies) -&gt; None:\n    \"\"\"\n    Removes one or more policies from the workspace\n    Removing a remote policy will result in only renaming it to .deleted\n    This will ignore the policy locally on actions performed by the editor\n    Once a commit action is performed, the policy is deleted both locally and remotely\n    For newly generated policies which were not committed yet, they will be just deleted from the machine after the user consents to it\n\n    Args:\n        remove_policies (ArkDPARemovePolicies): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    if not workspace_policies:\n        raise ArkServiceException(\n            f'No {self._policies_family} policies to remove in the workspace, please load the policies or generate a new one'\n        )\n    policy_names = remove_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to remove?, press space to select',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    for policy_name in policy_names:\n        for path in [\n            Path(self.__policies_cache_dir) / (policy_name + '.json'),\n            Path(self.__policies_cache_dir) / (policy_name + '.json.generated'),\n        ]:\n            if path.exists():\n                if path.suffix == '.json':\n                    path.rename(Path(self.__policies_cache_dir) / (policy_name + '.json.removed'))\n                else:\n                    answers = inquirer.prompt(\n                        [\n                            inquirer.Confirm(\n                                'remove',\n                                message=f'Are you sure you want to remove local {self._policies_family} policy [{policy_name}]?, removing an uncommitted local policy cannot be reverted',\n                            )\n                        ],\n                        render=ArkInquirerRender(),\n                    )\n                    if not answers:\n                        return\n                    if answers['remove']:\n                        path.unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.reset_policies","title":"<code>reset_policies(reset_policy)</code>","text":"<p>Resets the local workspace policies If all policies reset was given, will reload all the policies and override the local policies and delete any already removed policies Newly generated uncommitted policies are not touched If not all policies reset was given, the user can choose which policies he would like to reset</p> <p>Parameters:</p> Name Type Description Default <code>reset_policy</code> <code>ArkDPAResetPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def reset_policies(self, reset_policy: ArkDPAResetPolicies) -&gt; None:\n    \"\"\"\n    Resets the local workspace policies\n    If all policies reset was given, will reload all the policies and override the local policies and delete any already removed policies\n    Newly generated uncommitted policies are not touched\n    If not all policies reset was given, the user can choose which policies he would like to reset\n\n    Args:\n        reset_policy (ArkDPAResetPolicies): _description_\n    \"\"\"\n    if reset_policy.all:\n        answers = inquirer.prompt(\n            [inquirer.Confirm('reset', message=f'Are you sure you want to reset all edited {self._policies_family} policies?')]\n        )\n        if not answers:\n            return\n        if answers['reset']:\n            self.load_policies(ArkDPALoadPolicies(override=True))\n    else:\n        policies_diff = self.__load_policies_diff()\n        removed_policies = self.__load_removed_policies_from_workspace()\n        if not policies_diff and not removed_policies:\n            return\n        policy_names = reset_policy.names\n        if not policy_names:\n            answers = inquirer.prompt(\n                [\n                    inquirer.Checkbox(\n                        'names',\n                        f'Which {self._policies_family} policies would you like to reset?, press space to select',\n                        choices=[p for p in policies_diff.keys() + removed_policies.keys()],\n                    )\n                ],\n                render=ArkInquirerRender(),\n            )\n            if not answers:\n                return\n            policy_names = answers['names']\n        policy_names = [p for p in policy_names if p in policies_diff or p in removed_policies]\n        for policy_name in policy_names:\n            policy_path = Path(self.__policies_cache_dir) / (policy_name + '.json')\n            if policy_name in policies_diff:\n                policy_path.write_text(policies_diff[policy_name][1].json(indent=4))\n            elif policy_name in removed_policies:\n                policy_path.write_text(removed_policies[policy_name].json(indent=4))\n                (Path(self.__policies_cache_dir) / (policy_name + '.json.removed')).unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/cli_services/dpa/common/ark_dpa_base_policies_editor_service/#ark_sdk_python.cli_services.dpa.common.ark_dpa_base_policies_editor_service.ArkDPABasePoliciesEditorService.view_policies","title":"<code>view_policies(view_policies)</code>","text":"<p>Allows the user to view one or more policies together or seperetly, picked by the cli or by prompt to the user Each policy viewed by the editor of the machine, both for existing policies and newly generated policies</p> <p>Parameters:</p> Name Type Description Default <code>view_policies</code> <code>ArkDPAViewPolicies</code> <p>description</p> required Source code in <code>ark_sdk_python/cli_services/dpa/common/ark_dpa_base_policies_editor_service.py</code> <pre><code>def view_policies(self, view_policies: ArkDPAViewPolicies) -&gt; None:\n    \"\"\"\n    Allows the user to view one or more policies together or seperetly, picked by the cli or by prompt to the user\n    Each policy viewed by the editor of the machine, both for existing policies and newly generated policies\n\n    Args:\n        view_policies (ArkDPAViewPolicies): _description_\n    \"\"\"\n    workspace_policies = self.__load_existing_policies_from_workspace()\n    workspace_policies.update(self.__load_generated_policies_from_workspace())\n    policy_names = view_policies.names\n    if not policy_names:\n        answers = inquirer.prompt(\n            [\n                inquirer.Checkbox(\n                    'names',\n                    f'Which {self._policies_family} policies would you like to view?',\n                    choices=[p.policy_name for p in workspace_policies.values()],\n                )\n            ],\n            render=ArkInquirerRender(),\n        )\n        if not answers:\n            return\n        policy_names = answers['names']\n    if not policy_names:\n        return\n    try:\n        if view_policies.unified:\n            inquirer.prompt(\n                [inquirer.Editor('views', f'Show all selected {self._policies_family} policies')],\n                answers={\n                    'views': '\\n\\n\\n'.join(\n                        [f'# Policy [{policy_name}]\\n{workspace_policies[policy_name].json(indent=4)}' for policy_name in policy_names]\n                    )\n                },\n                render=ArkInquirerRender(),\n            )\n        else:\n            inquirer.prompt(\n                [inquirer.Editor(f'{policy_name}_view', f'Show [{policy_name}]') for policy_name in policy_names],\n                render=ArkInquirerRender(),\n                answers={f'{policy_name}_view': workspace_policies[policy_name].json(indent=4) for policy_name in policy_names},\n            )\n    except EditorError as ex:\n        self._logger.error(\n            f'An error occurred while trying to view the {self._policies_family} policies, '\n            f'you can view the policies at [{self.__policies_cache_dir}] [{str(ex)}]'\n        )\n</code></pre>"},{"location":"reference/cli_services/dpa/db/","title":"db","text":""},{"location":"reference/cli_services/dpa/db/ark_dpa_db_policies_editor_service/","title":"ark_dpa_db_policies_editor_service","text":""},{"location":"reference/cli_services/dpa/vm/","title":"vm","text":""},{"location":"reference/cli_services/dpa/vm/ark_dpa_vm_policies_editor_service/","title":"ark_dpa_vm_policies_editor_service","text":""},{"location":"reference/common/","title":"common","text":""},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient","title":"<code>ArkAsyncClient</code>","text":"<p>             Bases: <code>ABC</code>, <code>ArkClient</code></p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>class ArkAsyncClient(ABC, ArkClient):\n    def __init__(\n        self,\n        async_request_settings: ArkAsyncRequestSettings = None,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        super().__init__(\n            base_url, token, token_type, cookies, auth_header_name, auth, refresh_connection_callback=refresh_connection_callback\n        )\n        self.__async_request_settings = async_request_settings or ArkAsyncRequestSettings()\n\n    @abstractmethod\n    def async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n        \"\"\"\n        Creates an async request for the given model and task\n        The request will poll for async operations based on the implementation\n\n        Args:\n            poll_model (ArkPollableModel): _description_\n            async_task (ArkAsyncTask): _description_\n\n        Returns:\n            ArkAsyncRequest: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_task_type() -&gt; Type[ArkAsyncTask]:\n        \"\"\"\n        Returns the type of async task used in the client\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_request_type() -&gt; Type[ArkAsyncRequest]:\n        \"\"\"\n        Returns the type of async request used in the client\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @property\n    def async_request_settings(self) -&gt; ArkAsyncRequestSettings:\n        return self.__async_request_settings\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_request_for","title":"<code>async_request_for(poll_model, async_task)</code>  <code>abstractmethod</code>","text":"<p>Creates an async request for the given model and task The request will poll for async operations based on the implementation</p> <p>Parameters:</p> Name Type Description Default <code>poll_model</code> <code>ArkPollableModel</code> <p>description</p> required <code>async_task</code> <code>ArkAsyncTask</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkAsyncRequest</code> <code>ArkAsyncRequest</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@abstractmethod\ndef async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n    \"\"\"\n    Creates an async request for the given model and task\n    The request will poll for async operations based on the implementation\n\n    Args:\n        poll_model (ArkPollableModel): _description_\n        async_task (ArkAsyncTask): _description_\n\n    Returns:\n        ArkAsyncRequest: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_request_type","title":"<code>async_request_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the type of async request used in the client</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncRequest]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_request_type() -&gt; Type[ArkAsyncRequest]:\n    \"\"\"\n    Returns the type of async request used in the client\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncClient.async_task_type","title":"<code>async_task_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the type of async task used in the client</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncTask]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_task_type() -&gt; Type[ArkAsyncTask]:\n    \"\"\"\n    Returns the type of async task used in the client\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest","title":"<code>ArkAsyncRequest</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>class ArkAsyncRequest(ABC):\n    def __init__(self, client: ArkClient, async_task: ArkAsyncTask, async_request_settings: ArkAsyncRequestSettings):\n        self._async_task = async_task\n        self._client = client\n        self._async_request_settings = async_request_settings\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def is_finished(self) -&gt; bool:\n        \"\"\"\n        Checks whether the current async request is finished or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_failed(self) -&gt; bool:\n        \"\"\"\n        Checks whether the current async request failed or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_timeout(self) -&gt; bool:\n        \"\"\"\n        Checks whether the current async request has timed out\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n        \"\"\"\n        Polls for the async request until it is finished\n        Progress callbacks may also be used to be notified whats the async request status\n\n        Args:\n            timeout_seconds (int): _description_\n            progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @property\n    def async_task(self) -&gt; ArkAsyncTask:\n        return self._async_task\n\n    @property\n    def client(self) -&gt; ArkClient:\n        return self._client\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.is_finished","title":"<code>is_finished()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the current async request is finished or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request is finished or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.poll","title":"<code>poll(timeout_seconds, progress_callback)</code>  <code>abstractmethod</code>","text":"<p>Polls for the async request until it is finished Progress callbacks may also be used to be notified whats the async request status</p> <p>Parameters:</p> Name Type Description Default <code>timeout_seconds</code> <code>int</code> <p>description</p> required <code>progress_callback</code> <code>Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls for the async request until it is finished\n    Progress callbacks may also be used to be notified whats the async request status\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.task_failed","title":"<code>task_failed()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the current async request failed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request failed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkAsyncRequest.task_timeout","title":"<code>task_timeout()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the current async request has timed out</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request has timed out\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient","title":"<code>ArkClient</code>","text":"Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>class ArkClient:\n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        cookie_jar: Optional[RequestsCookieJar] = None,\n        verify: Optional[Union[str, bool]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        from fake_useragent import UserAgent\n\n        self.__session = Session()\n        self.__base_url = base_url\n        self.__token = token\n        self.__token_type = token_type\n        self.__auth_header_name = auth_header_name\n        self.__refresh_connection_callback = refresh_connection_callback\n        if self.__base_url and not self.__base_url.startswith('https://'):\n            self.__base_url = f'https://{self.__base_url}'\n        if auth:\n            self.__session.auth = auth\n        self.update_token(token)\n        self.update_cookies(cookies, cookie_jar)\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        self.__session.headers['User-Agent'] = UserAgent(browsers=['chrome']).googlechrome\n\n    @property\n    def base_url(self) -&gt; Optional[str]:\n        return self.__base_url\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__token\n\n    @property\n    def refresh_connection_callback(self) -&gt; Optional[Callable[['ArkClient'], None]]:\n        return self.__refresh_connection_callback\n\n    def add_header(self, key: str, value: str) -&gt; None:\n        self.__session.headers.update({key: value})\n\n    def add_headers(self, headers: Dict[str, str]) -&gt; None:\n        self.__session.headers.update(headers)\n\n    def add_cookie(self, key: str, value: str) -&gt; None:\n        self.__session.cookies[key] = value\n\n    def generic_http_method_request(self, method: str, route: str, **kwargs) -&gt; Response:\n        url = route\n        if self.__base_url:\n            url = f'{self.__base_url}'\n            if route and route != '':\n                if self.__base_url.endswith('/') or route.startswith('/'):\n                    url = f'{self.__base_url}{route}'\n                else:\n                    url = f'{self.__base_url}/{route}'\n        http_method = getattr(self.__session, method)\n        response: Response = http_method(url, **kwargs)\n        return response\n\n    def get(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a GET request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('get', route, **kwargs)\n\n    def post(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a POST request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('post', route, **kwargs)\n\n    def put(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PUT request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('put', route, **kwargs)\n\n    def delete(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a DELETE request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('delete', route, **kwargs)\n\n    def patch(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PATCH request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('patch', route, **kwargs)\n\n    def options(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a OPTIONS request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('options', route, **kwargs)\n\n    def update_token(self, token: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Updates session token\n\n        Args:\n            token (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\n        self.__token = token\n        if token:\n            if self.__token_type == 'Basic':\n                user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n                self.__session.auth = (user, password)\n            else:\n                if len(self.__token_type) == 0:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n                else:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n\n    def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n        \"\"\"\n        Updates session cookies\n\n        Args:\n            cookies (Optional[List], optional): _description_. Defaults to None.\n            cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n        \"\"\"\n        if cookies:\n            for c in cookies:\n                self.__session.cookies.set_cookie(c)\n        if cookie_jar:\n            self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.delete","title":"<code>delete(route, **kwargs)</code>","text":"<p>Performs a DELETE request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def delete(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a DELETE request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('delete', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.get","title":"<code>get(route, **kwargs)</code>","text":"<p>Performs a GET request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def get(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a GET request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('get', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.options","title":"<code>options(route, **kwargs)</code>","text":"<p>Performs a OPTIONS request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def options(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a OPTIONS request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('options', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.patch","title":"<code>patch(route, **kwargs)</code>","text":"<p>Performs a PATCH request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def patch(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PATCH request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('patch', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.post","title":"<code>post(route, **kwargs)</code>","text":"<p>Performs a POST request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def post(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a POST request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('post', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.put","title":"<code>put(route, **kwargs)</code>","text":"<p>Performs a PUT request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def put(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PUT request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('put', route, **kwargs)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.update_cookies","title":"<code>update_cookies(cookies=None, cookie_jar=None)</code>","text":"<p>Updates session cookies</p> <p>Parameters:</p> Name Type Description Default <code>cookies</code> <code>Optional[List]</code> <p>description. Defaults to None.</p> <code>None</code> <code>cookie_jar</code> <code>Optional[RequestsCookieJar]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n    \"\"\"\n    Updates session cookies\n\n    Args:\n        cookies (Optional[List], optional): _description_. Defaults to None.\n        cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n    \"\"\"\n    if cookies:\n        for c in cookies:\n            self.__session.cookies.set_cookie(c)\n    if cookie_jar:\n        self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkClient.update_token","title":"<code>update_token(token=None)</code>","text":"<p>Updates session token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_token(self, token: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Updates session token\n\n    Args:\n        token (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\n    self.__token = token\n    if token:\n        if self.__token_type == 'Basic':\n            user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n            self.__session.auth = (user, password)\n        else:\n            if len(self.__token_type) == 0:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n            else:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring","title":"<code>ArkKeyring</code>","text":"Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>class ArkKeyring:\n    def __init__(self, service_name: str) -&gt; None:\n        self.__service_name = service_name\n        self.__logger = get_logger(self.__class__.__name__)\n\n    @staticmethod\n    def __is_docker():\n        path = '/proc/self/cgroup'\n        return os.path.exists('/.dockerenv') or os.path.isfile(path) and any('docker' in line for line in open(path, encoding='utf-8'))\n\n    @staticmethod\n    def get_keyring():\n        try:\n            from keyring.backends import SecretService, macOS  # pylint: disable=unused-import\n            from keyrings.cryptfile.cryptfile import CryptFileKeyring  # pylint: disable=import-error\n\n            # Docker or WSL\n            if ArkKeyring.__is_docker() or 'Microsoft' in uname().release or ARK_BASIC_KEYRING_OVERRIDE_ENV_VAR in os.environ:\n                return BasicKeyring()\n            if sys.platform == 'win32':\n                kr = CryptFileKeyring()\n                kr.keyring_key = socket.gethostname()\n                return kr\n            elif sys.platform == 'darwin' or os.path.exists('/etc/redhat-release'):\n                return BasicKeyring()\n            else:\n                if DBUS_SESSION_ENV_VAR not in os.environ:\n                    return BasicKeyring()\n                return SecretService.Keyring()\n        except Exception:\n            return BasicKeyring()\n\n    def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str) -&gt; None:\n        \"\"\"\n        Saves a given token for a profile in the keyring\n        Keyring is OS based implementation with fallback to BasicKeyring\n\n        Args:\n            profile (ArkProfile): _description_\n            token (ArkToken): _description_\n            postfix (str): _description_\n        \"\"\"\n        try:\n            self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            kr = self.get_keyring()\n            kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n            self.__logger.info('Saved token successfully')\n        except Exception as ex:\n            self.__logger.warning(f'Failed to save token [{str(ex)}]')\n\n    def load_token(self, profile: ArkProfile, postfix: str) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads a token for a profile in the keyring\n        Keyring is OS based implementation with fallback to BasicKeyring\n        If the token is expired and no refresh token exists, deletes it from the keyring and does not return anything\n        If the token is expired but theres a refresh token, the token will only be deleted if the max token time was passed (48 hours)\n\n        Args:\n            profile (ArkProfile): _description_\n            postfix (str): _description_\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        try:\n            kr = self.get_keyring()\n            self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            if not token_val:\n                self.__logger.info('No token found')\n                return None\n            token = ArkToken.parse_raw(token_val)\n            if token.expires_in:\n                if (\n                    not token.refresh_token\n                    and token.token_type != ArkTokenType.Internal\n                    and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and no refresh token exists')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n                elif (\n                    token.refresh_token\n                    and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n            self.__logger.info('Loaded token successfully')\n            return token\n        except Exception as ex:\n            self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n            try:\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            except Exception as ex_deletion:\n                self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n            return None\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring.load_token","title":"<code>load_token(profile, postfix)</code>","text":"<p>Loads a token for a profile in the keyring Keyring is OS based implementation with fallback to BasicKeyring If the token is expired and no refresh token exists, deletes it from the keyring and does not return anything If the token is expired but theres a refresh token, the token will only be deleted if the max token time was passed (48 hours)</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def load_token(self, profile: ArkProfile, postfix: str) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads a token for a profile in the keyring\n    Keyring is OS based implementation with fallback to BasicKeyring\n    If the token is expired and no refresh token exists, deletes it from the keyring and does not return anything\n    If the token is expired but theres a refresh token, the token will only be deleted if the max token time was passed (48 hours)\n\n    Args:\n        profile (ArkProfile): _description_\n        postfix (str): _description_\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    try:\n        kr = self.get_keyring()\n        self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        if not token_val:\n            self.__logger.info('No token found')\n            return None\n        token = ArkToken.parse_raw(token_val)\n        if token.expires_in:\n            if (\n                not token.refresh_token\n                and token.token_type != ArkTokenType.Internal\n                and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and no refresh token exists')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n            elif (\n                token.refresh_token\n                and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n        self.__logger.info('Loaded token successfully')\n        return token\n    except Exception as ex:\n        self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n        try:\n            kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        except Exception as ex_deletion:\n            self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n        return None\n</code></pre>"},{"location":"reference/common/#ark_sdk_python.common.ArkKeyring.save_token","title":"<code>save_token(profile, token, postfix)</code>","text":"<p>Saves a given token for a profile in the keyring Keyring is OS based implementation with fallback to BasicKeyring</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str) -&gt; None:\n    \"\"\"\n    Saves a given token for a profile in the keyring\n    Keyring is OS based implementation with fallback to BasicKeyring\n\n    Args:\n        profile (ArkProfile): _description_\n        token (ArkToken): _description_\n        postfix (str): _description_\n    \"\"\"\n    try:\n        self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        kr = self.get_keyring()\n        kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n        self.__logger.info('Saved token successfully')\n    except Exception as ex:\n        self.__logger.warning(f'Failed to save token [{str(ex)}]')\n</code></pre>"},{"location":"reference/common/ark_async_client/","title":"ark_async_client","text":""},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient","title":"<code>ArkAsyncClient</code>","text":"<p>             Bases: <code>ABC</code>, <code>ArkClient</code></p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>class ArkAsyncClient(ABC, ArkClient):\n    def __init__(\n        self,\n        async_request_settings: ArkAsyncRequestSettings = None,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        super().__init__(\n            base_url, token, token_type, cookies, auth_header_name, auth, refresh_connection_callback=refresh_connection_callback\n        )\n        self.__async_request_settings = async_request_settings or ArkAsyncRequestSettings()\n\n    @abstractmethod\n    def async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n        \"\"\"\n        Creates an async request for the given model and task\n        The request will poll for async operations based on the implementation\n\n        Args:\n            poll_model (ArkPollableModel): _description_\n            async_task (ArkAsyncTask): _description_\n\n        Returns:\n            ArkAsyncRequest: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_task_type() -&gt; Type[ArkAsyncTask]:\n        \"\"\"\n        Returns the type of async task used in the client\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def async_request_type() -&gt; Type[ArkAsyncRequest]:\n        \"\"\"\n        Returns the type of async request used in the client\n\n        Returns:\n            Type[ArkAsyncTask]: _description_\n        \"\"\"\n\n    @property\n    def async_request_settings(self) -&gt; ArkAsyncRequestSettings:\n        return self.__async_request_settings\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_request_for","title":"<code>async_request_for(poll_model, async_task)</code>  <code>abstractmethod</code>","text":"<p>Creates an async request for the given model and task The request will poll for async operations based on the implementation</p> <p>Parameters:</p> Name Type Description Default <code>poll_model</code> <code>ArkPollableModel</code> <p>description</p> required <code>async_task</code> <code>ArkAsyncTask</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkAsyncRequest</code> <code>ArkAsyncRequest</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@abstractmethod\ndef async_request_for(self, poll_model: ArkPollableModel, async_task: ArkAsyncTask) -&gt; ArkAsyncRequest:\n    \"\"\"\n    Creates an async request for the given model and task\n    The request will poll for async operations based on the implementation\n\n    Args:\n        poll_model (ArkPollableModel): _description_\n        async_task (ArkAsyncTask): _description_\n\n    Returns:\n        ArkAsyncRequest: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_request_type","title":"<code>async_request_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the type of async request used in the client</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncRequest]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_request_type() -&gt; Type[ArkAsyncRequest]:\n    \"\"\"\n    Returns the type of async request used in the client\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_client/#ark_sdk_python.common.ark_async_client.ArkAsyncClient.async_task_type","title":"<code>async_task_type()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the type of async task used in the client</p> <p>Returns:</p> Type Description <code>Type[ArkAsyncTask]</code> <p>Type[ArkAsyncTask]: description</p> Source code in <code>ark_sdk_python/common/ark_async_client.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef async_task_type() -&gt; Type[ArkAsyncTask]:\n    \"\"\"\n    Returns the type of async task used in the client\n\n    Returns:\n        Type[ArkAsyncTask]: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/","title":"ark_async_request","text":""},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest","title":"<code>ArkAsyncRequest</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>class ArkAsyncRequest(ABC):\n    def __init__(self, client: ArkClient, async_task: ArkAsyncTask, async_request_settings: ArkAsyncRequestSettings):\n        self._async_task = async_task\n        self._client = client\n        self._async_request_settings = async_request_settings\n        self._logger = get_logger(self.__class__.__name__)\n\n    @abstractmethod\n    def is_finished(self) -&gt; bool:\n        \"\"\"\n        Checks whether the current async request is finished or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_failed(self) -&gt; bool:\n        \"\"\"\n        Checks whether the current async request failed or not\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def task_timeout(self) -&gt; bool:\n        \"\"\"\n        Checks whether the current async request has timed out\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @abstractmethod\n    def poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n        \"\"\"\n        Polls for the async request until it is finished\n        Progress callbacks may also be used to be notified whats the async request status\n\n        Args:\n            timeout_seconds (int): _description_\n            progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n\n    @property\n    def async_task(self) -&gt; ArkAsyncTask:\n        return self._async_task\n\n    @property\n    def client(self) -&gt; ArkClient:\n        return self._client\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.is_finished","title":"<code>is_finished()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the current async request is finished or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request is finished or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.poll","title":"<code>poll(timeout_seconds, progress_callback)</code>  <code>abstractmethod</code>","text":"<p>Polls for the async request until it is finished Progress callbacks may also be used to be notified whats the async request status</p> <p>Parameters:</p> Name Type Description Default <code>timeout_seconds</code> <code>int</code> <p>description</p> required <code>progress_callback</code> <code>Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls for the async request until it is finished\n    Progress callbacks may also be used to be notified whats the async request status\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.task_failed","title":"<code>task_failed()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the current async request failed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request failed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_async_request/#ark_sdk_python.common.ark_async_request.ArkAsyncRequest.task_timeout","title":"<code>task_timeout()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the current async request has timed out</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_async_request.py</code> <pre><code>@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request has timed out\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/common/ark_client/","title":"ark_client","text":""},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient","title":"<code>ArkClient</code>","text":"Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>class ArkClient:\n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        token: Optional[str] = None,\n        token_type: str = 'Bearer',\n        cookies: Optional[List] = None,\n        auth_header_name: str = 'Authorization',\n        auth: Optional[Tuple[str, str]] = None,\n        cookie_jar: Optional[RequestsCookieJar] = None,\n        verify: Optional[Union[str, bool]] = None,\n        refresh_connection_callback: Optional[Callable[['ArkClient'], None]] = None,\n    ) -&gt; None:\n        from fake_useragent import UserAgent\n\n        self.__session = Session()\n        self.__base_url = base_url\n        self.__token = token\n        self.__token_type = token_type\n        self.__auth_header_name = auth_header_name\n        self.__refresh_connection_callback = refresh_connection_callback\n        if self.__base_url and not self.__base_url.startswith('https://'):\n            self.__base_url = f'https://{self.__base_url}'\n        if auth:\n            self.__session.auth = auth\n        self.update_token(token)\n        self.update_cookies(cookies, cookie_jar)\n        if verify is None:\n            if ArkSystemConfig.trusted_certificate() is not None:\n                verify = ArkSystemConfig.trusted_certificate()\n            else:\n                verify = ArkSystemConfig.is_verifiying_certificates()\n        self.__session.verify = verify\n        self.__session.headers['User-Agent'] = UserAgent(browsers=['chrome']).googlechrome\n\n    @property\n    def base_url(self) -&gt; Optional[str]:\n        return self.__base_url\n\n    @property\n    def session(self) -&gt; Session:\n        return self.__session\n\n    @property\n    def session_token(self) -&gt; Optional[str]:\n        return self.__token\n\n    @property\n    def refresh_connection_callback(self) -&gt; Optional[Callable[['ArkClient'], None]]:\n        return self.__refresh_connection_callback\n\n    def add_header(self, key: str, value: str) -&gt; None:\n        self.__session.headers.update({key: value})\n\n    def add_headers(self, headers: Dict[str, str]) -&gt; None:\n        self.__session.headers.update(headers)\n\n    def add_cookie(self, key: str, value: str) -&gt; None:\n        self.__session.cookies[key] = value\n\n    def generic_http_method_request(self, method: str, route: str, **kwargs) -&gt; Response:\n        url = route\n        if self.__base_url:\n            url = f'{self.__base_url}'\n            if route and route != '':\n                if self.__base_url.endswith('/') or route.startswith('/'):\n                    url = f'{self.__base_url}{route}'\n                else:\n                    url = f'{self.__base_url}/{route}'\n        http_method = getattr(self.__session, method)\n        response: Response = http_method(url, **kwargs)\n        return response\n\n    def get(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a GET request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('get', route, **kwargs)\n\n    def post(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a POST request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('post', route, **kwargs)\n\n    def put(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PUT request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('put', route, **kwargs)\n\n    def delete(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a DELETE request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('delete', route, **kwargs)\n\n    def patch(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a PATCH request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('patch', route, **kwargs)\n\n    def options(self, route: str, **kwargs) -&gt; Response:\n        \"\"\"\n        Performs a OPTIONS request with the session details and given headers / tokens\n\n        Args:\n            route (str): _description_\n\n        Returns:\n            Response: _description_\n        \"\"\"\n        return self.generic_http_method_request('options', route, **kwargs)\n\n    def update_token(self, token: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Updates session token\n\n        Args:\n            token (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\n        self.__token = token\n        if token:\n            if self.__token_type == 'Basic':\n                user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n                self.__session.auth = (user, password)\n            else:\n                if len(self.__token_type) == 0:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n                else:\n                    self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n\n    def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n        \"\"\"\n        Updates session cookies\n\n        Args:\n            cookies (Optional[List], optional): _description_. Defaults to None.\n            cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n        \"\"\"\n        if cookies:\n            for c in cookies:\n                self.__session.cookies.set_cookie(c)\n        if cookie_jar:\n            self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.delete","title":"<code>delete(route, **kwargs)</code>","text":"<p>Performs a DELETE request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def delete(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a DELETE request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('delete', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.get","title":"<code>get(route, **kwargs)</code>","text":"<p>Performs a GET request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def get(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a GET request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('get', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.options","title":"<code>options(route, **kwargs)</code>","text":"<p>Performs a OPTIONS request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def options(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a OPTIONS request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('options', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.patch","title":"<code>patch(route, **kwargs)</code>","text":"<p>Performs a PATCH request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def patch(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PATCH request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('patch', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.post","title":"<code>post(route, **kwargs)</code>","text":"<p>Performs a POST request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def post(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a POST request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('post', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.put","title":"<code>put(route, **kwargs)</code>","text":"<p>Performs a PUT request with the session details and given headers / tokens</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>description</p> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def put(self, route: str, **kwargs) -&gt; Response:\n    \"\"\"\n    Performs a PUT request with the session details and given headers / tokens\n\n    Args:\n        route (str): _description_\n\n    Returns:\n        Response: _description_\n    \"\"\"\n    return self.generic_http_method_request('put', route, **kwargs)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.update_cookies","title":"<code>update_cookies(cookies=None, cookie_jar=None)</code>","text":"<p>Updates session cookies</p> <p>Parameters:</p> Name Type Description Default <code>cookies</code> <code>Optional[List]</code> <p>description. Defaults to None.</p> <code>None</code> <code>cookie_jar</code> <code>Optional[RequestsCookieJar]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_cookies(self, cookies: Optional[List] = None, cookie_jar: Optional[RequestsCookieJar] = None) -&gt; None:\n    \"\"\"\n    Updates session cookies\n\n    Args:\n        cookies (Optional[List], optional): _description_. Defaults to None.\n        cookie_jar (Optional[RequestsCookieJar], optional): _description_. Defaults to None.\n    \"\"\"\n    if cookies:\n        for c in cookies:\n            self.__session.cookies.set_cookie(c)\n    if cookie_jar:\n        self.__session.cookies.update(cookie_jar)\n</code></pre>"},{"location":"reference/common/ark_client/#ark_sdk_python.common.ark_client.ArkClient.update_token","title":"<code>update_token(token=None)</code>","text":"<p>Updates session token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>ark_sdk_python/common/ark_client.py</code> <pre><code>def update_token(self, token: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Updates session token\n\n    Args:\n        token (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\n    self.__token = token\n    if token:\n        if self.__token_type == 'Basic':\n            user, password = b64decode(token.encode('ascii')).decode('ascii').split(':')\n            self.__session.auth = (user, password)\n        else:\n            if len(self.__token_type) == 0:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token}'})\n            else:\n                self.__session.headers.update({self.__auth_header_name: f'{self.__token_type} {self.__token}'})\n</code></pre>"},{"location":"reference/common/ark_keyring/","title":"ark_keyring","text":""},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring","title":"<code>ArkKeyring</code>","text":"Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>class ArkKeyring:\n    def __init__(self, service_name: str) -&gt; None:\n        self.__service_name = service_name\n        self.__logger = get_logger(self.__class__.__name__)\n\n    @staticmethod\n    def __is_docker():\n        path = '/proc/self/cgroup'\n        return os.path.exists('/.dockerenv') or os.path.isfile(path) and any('docker' in line for line in open(path, encoding='utf-8'))\n\n    @staticmethod\n    def get_keyring():\n        try:\n            from keyring.backends import SecretService, macOS  # pylint: disable=unused-import\n            from keyrings.cryptfile.cryptfile import CryptFileKeyring  # pylint: disable=import-error\n\n            # Docker or WSL\n            if ArkKeyring.__is_docker() or 'Microsoft' in uname().release or ARK_BASIC_KEYRING_OVERRIDE_ENV_VAR in os.environ:\n                return BasicKeyring()\n            if sys.platform == 'win32':\n                kr = CryptFileKeyring()\n                kr.keyring_key = socket.gethostname()\n                return kr\n            elif sys.platform == 'darwin' or os.path.exists('/etc/redhat-release'):\n                return BasicKeyring()\n            else:\n                if DBUS_SESSION_ENV_VAR not in os.environ:\n                    return BasicKeyring()\n                return SecretService.Keyring()\n        except Exception:\n            return BasicKeyring()\n\n    def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str) -&gt; None:\n        \"\"\"\n        Saves a given token for a profile in the keyring\n        Keyring is OS based implementation with fallback to BasicKeyring\n\n        Args:\n            profile (ArkProfile): _description_\n            token (ArkToken): _description_\n            postfix (str): _description_\n        \"\"\"\n        try:\n            self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            kr = self.get_keyring()\n            kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n            self.__logger.info('Saved token successfully')\n        except Exception as ex:\n            self.__logger.warning(f'Failed to save token [{str(ex)}]')\n\n    def load_token(self, profile: ArkProfile, postfix: str) -&gt; Optional[ArkToken]:\n        \"\"\"\n        Loads a token for a profile in the keyring\n        Keyring is OS based implementation with fallback to BasicKeyring\n        If the token is expired and no refresh token exists, deletes it from the keyring and does not return anything\n        If the token is expired but theres a refresh token, the token will only be deleted if the max token time was passed (48 hours)\n\n        Args:\n            profile (ArkProfile): _description_\n            postfix (str): _description_\n\n        Returns:\n            Optional[ArkToken]: _description_\n        \"\"\"\n        try:\n            kr = self.get_keyring()\n            self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n            token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            if not token_val:\n                self.__logger.info('No token found')\n                return None\n            token = ArkToken.parse_raw(token_val)\n            if token.expires_in:\n                if (\n                    not token.refresh_token\n                    and token.token_type != ArkTokenType.Internal\n                    and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and no refresh token exists')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n                elif (\n                    token.refresh_token\n                    and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n                ):\n                    self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                    kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                    return None\n            self.__logger.info('Loaded token successfully')\n            return token\n        except Exception as ex:\n            self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n            try:\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n            except Exception as ex_deletion:\n                self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n            return None\n</code></pre>"},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring.load_token","title":"<code>load_token(profile, postfix)</code>","text":"<p>Loads a token for a profile in the keyring Keyring is OS based implementation with fallback to BasicKeyring If the token is expired and no refresh token exists, deletes it from the keyring and does not return anything If the token is expired but theres a refresh token, the token will only be deleted if the max token time was passed (48 hours)</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkToken]</code> <p>Optional[ArkToken]: description</p> Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def load_token(self, profile: ArkProfile, postfix: str) -&gt; Optional[ArkToken]:\n    \"\"\"\n    Loads a token for a profile in the keyring\n    Keyring is OS based implementation with fallback to BasicKeyring\n    If the token is expired and no refresh token exists, deletes it from the keyring and does not return anything\n    If the token is expired but theres a refresh token, the token will only be deleted if the max token time was passed (48 hours)\n\n    Args:\n        profile (ArkProfile): _description_\n        postfix (str): _description_\n\n    Returns:\n        Optional[ArkToken]: _description_\n    \"\"\"\n    try:\n        kr = self.get_keyring()\n        self.__logger.info(f'Trying to load token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        token_val = kr.get_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        if not token_val:\n            self.__logger.info('No token found')\n            return None\n        token = ArkToken.parse_raw(token_val)\n        if token.expires_in:\n            if (\n                not token.refresh_token\n                and token.token_type != ArkTokenType.Internal\n                and (token.expires_in.replace(tzinfo=None) - timedelta(seconds=DEFAULT_EXPIRATION_GRACE_DELTA_SECONDS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and no refresh token exists')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n            elif (\n                token.refresh_token\n                and (token.expires_in.replace(tzinfo=None) + timedelta(hours=MAX_KEYRING_RECORD_TIME_HOURS)) &lt; datetime.now()\n            ):\n                self.__logger.info('Token is expired and has been in the cache for too long before another usage')\n                kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n                return None\n        self.__logger.info('Loaded token successfully')\n        return token\n    except Exception as ex:\n        self.__logger.warning(f'Failed to load cached token [{str(ex)}]')\n        try:\n            kr.delete_password(f'{self.__service_name}-{postfix}', profile.profile_name)\n        except Exception as ex_deletion:\n            self.__logger.warning(f'Failed to delete failed loaded cached token [{str(ex_deletion)}]')\n        return None\n</code></pre>"},{"location":"reference/common/ark_keyring/#ark_sdk_python.common.ark_keyring.ArkKeyring.save_token","title":"<code>save_token(profile, token, postfix)</code>","text":"<p>Saves a given token for a profile in the keyring Keyring is OS based implementation with fallback to BasicKeyring</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required <code>token</code> <code>ArkToken</code> <p>description</p> required <code>postfix</code> <code>str</code> <p>description</p> required Source code in <code>ark_sdk_python/common/ark_keyring.py</code> <pre><code>def save_token(self, profile: ArkProfile, token: ArkToken, postfix: str) -&gt; None:\n    \"\"\"\n    Saves a given token for a profile in the keyring\n    Keyring is OS based implementation with fallback to BasicKeyring\n\n    Args:\n        profile (ArkProfile): _description_\n        token (ArkToken): _description_\n        postfix (str): _description_\n    \"\"\"\n    try:\n        self.__logger.info(f'Trying to save token [{self.__service_name}-{postfix}] of profile [{profile.profile_name}]')\n        kr = self.get_keyring()\n        kr.set_password(f'{self.__service_name}-{postfix}', profile.profile_name, token.json())\n        self.__logger.info('Saved token successfully')\n    except Exception as ex:\n        self.__logger.warning(f'Failed to save token [{str(ex)}]')\n</code></pre>"},{"location":"reference/common/ark_logger/","title":"ark_logger","text":""},{"location":"reference/common/ark_page/","title":"ark_page","text":""},{"location":"reference/common/ark_pollers/","title":"ark_pollers","text":""},{"location":"reference/common/ark_random_utils/","title":"ark_random_utils","text":""},{"location":"reference/common/ark_system_config/","title":"ark_system_config","text":""},{"location":"reference/common/env/","title":"env","text":""},{"location":"reference/common/env/ark_env_mapping/","title":"ark_env_mapping","text":""},{"location":"reference/common/isp/","title":"isp","text":""},{"location":"reference/common/isp/ark_isp_service_client/","title":"ark_isp_service_client","text":""},{"location":"reference/models/","title":"models","text":""},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader","title":"<code>ArkProfileLoader</code>","text":"Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>class ArkProfileLoader:\n    @staticmethod\n    def profiles_folder() -&gt; str:\n        \"\"\"\n        Retrieves the profiles folder, optionally from an env var with fallback to the default\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n\n    @staticmethod\n    def default_profile_name() -&gt; str:\n        \"\"\"\n        Getter for the default profile name\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return 'ark'\n\n    @staticmethod\n    def deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Deduces the right profile name from the env\n\n        Args:\n            profile_name (Optional[str], optional): Defaults to None.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n            return profile_name\n        if 'ARK_PROFILE' in os.environ:\n            return os.environ['ARK_PROFILE']\n        if profile_name:\n            return profile_name\n        return ArkProfileLoader.default_profile_name()\n\n    @staticmethod\n    def load_default_profile() -&gt; ArkProfile:\n        \"\"\"\n        Loads the default profile either from OS or a new one\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        profile_name = ArkProfileLoader.deduce_profile_name()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return ArkProfile()\n\n    @staticmethod\n    def load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n        \"\"\"\n        Loads the profile from the os profiles folder\n        Will return None if no profile is found for the name\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            Optional[ArkProfile]: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return None\n\n    @staticmethod\n    def save_profile(profile: ArkProfile) -&gt; None:\n        \"\"\"\n        Saves the profile to the profiles folder on the filesystem\n\n        Args:\n            profile (ArkProfile): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n            f.write(profile.json(indent=4, by_alias=False))\n\n    @staticmethod\n    def load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n        \"\"\"\n        Loads all the profiles that exist on the machine\n\n        Returns:\n            Optional[List[ArkProfile]]: _description_\n        \"\"\"\n        logger = get_logger('load_all_profiles')\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        profiles: List[ArkProfile] = []\n        for profile_name in os.listdir(folder):\n            try:\n                profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n            except Exception as ex:\n                logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n                continue\n        return profiles\n\n    @staticmethod\n    def delete_profile(profile_name: str) -&gt; None:\n        \"\"\"\n        Deletes the profile by given name\n\n        Args:\n            profile_name (str): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        if os.path.exists(os.path.join(folder, profile_name)):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def clear_all_profiles() -&gt; None:\n        \"\"\"\n        Clears all profiles\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        for profile_name in os.listdir(folder):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def profile_exists(profile_name: str) -&gt; bool:\n        \"\"\"\n        Checks if a given profile name exists or not\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return False\n        return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.clear_all_profiles","title":"<code>clear_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Clears all profiles</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef clear_all_profiles() -&gt; None:\n    \"\"\"\n    Clears all profiles\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    for profile_name in os.listdir(folder):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.deduce_profile_name","title":"<code>deduce_profile_name(profile_name=None)</code>  <code>staticmethod</code>","text":"<p>Deduces the right profile name from the env</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>Optional[str]</code> <p>Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Deduces the right profile name from the env\n\n    Args:\n        profile_name (Optional[str], optional): Defaults to None.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n        return profile_name\n    if 'ARK_PROFILE' in os.environ:\n        return os.environ['ARK_PROFILE']\n    if profile_name:\n        return profile_name\n    return ArkProfileLoader.default_profile_name()\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.default_profile_name","title":"<code>default_profile_name()</code>  <code>staticmethod</code>","text":"<p>Getter for the default profile name</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef default_profile_name() -&gt; str:\n    \"\"\"\n    Getter for the default profile name\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return 'ark'\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.delete_profile","title":"<code>delete_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Deletes the profile by given name</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef delete_profile(profile_name: str) -&gt; None:\n    \"\"\"\n    Deletes the profile by given name\n\n    Args:\n        profile_name (str): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    if os.path.exists(os.path.join(folder, profile_name)):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_all_profiles","title":"<code>load_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Loads all the profiles that exist on the machine</p> <p>Returns:</p> Type Description <code>Optional[List[ArkProfile]]</code> <p>Optional[List[ArkProfile]]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n    \"\"\"\n    Loads all the profiles that exist on the machine\n\n    Returns:\n        Optional[List[ArkProfile]]: _description_\n    \"\"\"\n    logger = get_logger('load_all_profiles')\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    profiles: List[ArkProfile] = []\n    for profile_name in os.listdir(folder):\n        try:\n            profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n        except Exception as ex:\n            logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n            continue\n    return profiles\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_default_profile","title":"<code>load_default_profile()</code>  <code>staticmethod</code>","text":"<p>Loads the default profile either from OS or a new one</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_default_profile() -&gt; ArkProfile:\n    \"\"\"\n    Loads the default profile either from OS or a new one\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    profile_name = ArkProfileLoader.deduce_profile_name()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return ArkProfile()\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.load_profile","title":"<code>load_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Loads the profile from the os profiles folder Will return None if no profile is found for the name</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkProfile]</code> <p>Optional[ArkProfile]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n    \"\"\"\n    Loads the profile from the os profiles folder\n    Will return None if no profile is found for the name\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        Optional[ArkProfile]: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return None\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.profile_exists","title":"<code>profile_exists(profile_name)</code>  <code>staticmethod</code>","text":"<p>Checks if a given profile name exists or not</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profile_exists(profile_name: str) -&gt; bool:\n    \"\"\"\n    Checks if a given profile name exists or not\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return False\n    return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.profiles_folder","title":"<code>profiles_folder()</code>  <code>staticmethod</code>","text":"<p>Retrieves the profiles folder, optionally from an env var with fallback to the default</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profiles_folder() -&gt; str:\n    \"\"\"\n    Retrieves the profiles folder, optionally from an env var with fallback to the default\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n</code></pre>"},{"location":"reference/models/#ark_sdk_python.models.ArkProfileLoader.save_profile","title":"<code>save_profile(profile)</code>  <code>staticmethod</code>","text":"<p>Saves the profile to the profiles folder on the filesystem</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef save_profile(profile: ArkProfile) -&gt; None:\n    \"\"\"\n    Saves the profile to the profiles folder on the filesystem\n\n    Args:\n        profile (ArkProfile): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n        f.write(profile.json(indent=4, by_alias=False))\n</code></pre>"},{"location":"reference/models/ark_exceptions/","title":"ark_exceptions","text":""},{"location":"reference/models/ark_model/","title":"ark_model","text":""},{"location":"reference/models/ark_profile/","title":"ark_profile","text":""},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader","title":"<code>ArkProfileLoader</code>","text":"Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>class ArkProfileLoader:\n    @staticmethod\n    def profiles_folder() -&gt; str:\n        \"\"\"\n        Retrieves the profiles folder, optionally from an env var with fallback to the default\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n\n    @staticmethod\n    def default_profile_name() -&gt; str:\n        \"\"\"\n        Getter for the default profile name\n\n        Returns:\n            str: _description_\n        \"\"\"\n        return 'ark'\n\n    @staticmethod\n    def deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Deduces the right profile name from the env\n\n        Args:\n            profile_name (Optional[str], optional): Defaults to None.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n            return profile_name\n        if 'ARK_PROFILE' in os.environ:\n            return os.environ['ARK_PROFILE']\n        if profile_name:\n            return profile_name\n        return ArkProfileLoader.default_profile_name()\n\n    @staticmethod\n    def load_default_profile() -&gt; ArkProfile:\n        \"\"\"\n        Loads the default profile either from OS or a new one\n\n        Returns:\n            ArkProfile: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        profile_name = ArkProfileLoader.deduce_profile_name()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return ArkProfile()\n\n    @staticmethod\n    def load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n        \"\"\"\n        Loads the profile from the os profiles folder\n        Will return None if no profile is found for the name\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            Optional[ArkProfile]: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if os.path.exists(os.path.join(folder, profile_name)):\n            profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n            return profile\n        return None\n\n    @staticmethod\n    def save_profile(profile: ArkProfile) -&gt; None:\n        \"\"\"\n        Saves the profile to the profiles folder on the filesystem\n\n        Args:\n            profile (ArkProfile): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n            f.write(profile.json(indent=4, by_alias=False))\n\n    @staticmethod\n    def load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n        \"\"\"\n        Loads all the profiles that exist on the machine\n\n        Returns:\n            Optional[List[ArkProfile]]: _description_\n        \"\"\"\n        logger = get_logger('load_all_profiles')\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        profiles: List[ArkProfile] = []\n        for profile_name in os.listdir(folder):\n            try:\n                profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n            except Exception as ex:\n                logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n                continue\n        return profiles\n\n    @staticmethod\n    def delete_profile(profile_name: str) -&gt; None:\n        \"\"\"\n        Deletes the profile by given name\n\n        Args:\n            profile_name (str): _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        if os.path.exists(os.path.join(folder, profile_name)):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def clear_all_profiles() -&gt; None:\n        \"\"\"\n        Clears all profiles\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return None\n        for profile_name in os.listdir(folder):\n            os.unlink(os.path.join(folder, profile_name))\n\n    @staticmethod\n    def profile_exists(profile_name: str) -&gt; bool:\n        \"\"\"\n        Checks if a given profile name exists or not\n\n        Args:\n            profile_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        folder = ArkProfileLoader.profiles_folder()\n        if not os.path.exists(folder):\n            return False\n        return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.clear_all_profiles","title":"<code>clear_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Clears all profiles</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef clear_all_profiles() -&gt; None:\n    \"\"\"\n    Clears all profiles\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    for profile_name in os.listdir(folder):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.deduce_profile_name","title":"<code>deduce_profile_name(profile_name=None)</code>  <code>staticmethod</code>","text":"<p>Deduces the right profile name from the env</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>Optional[str]</code> <p>Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef deduce_profile_name(profile_name: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Deduces the right profile name from the env\n\n    Args:\n        profile_name (Optional[str], optional): Defaults to None.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    if profile_name and profile_name != ArkProfileLoader.default_profile_name():\n        return profile_name\n    if 'ARK_PROFILE' in os.environ:\n        return os.environ['ARK_PROFILE']\n    if profile_name:\n        return profile_name\n    return ArkProfileLoader.default_profile_name()\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.default_profile_name","title":"<code>default_profile_name()</code>  <code>staticmethod</code>","text":"<p>Getter for the default profile name</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef default_profile_name() -&gt; str:\n    \"\"\"\n    Getter for the default profile name\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return 'ark'\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.delete_profile","title":"<code>delete_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Deletes the profile by given name</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef delete_profile(profile_name: str) -&gt; None:\n    \"\"\"\n    Deletes the profile by given name\n\n    Args:\n        profile_name (str): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    if os.path.exists(os.path.join(folder, profile_name)):\n        os.unlink(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_all_profiles","title":"<code>load_all_profiles()</code>  <code>staticmethod</code>","text":"<p>Loads all the profiles that exist on the machine</p> <p>Returns:</p> Type Description <code>Optional[List[ArkProfile]]</code> <p>Optional[List[ArkProfile]]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_all_profiles() -&gt; Optional[List[ArkProfile]]:\n    \"\"\"\n    Loads all the profiles that exist on the machine\n\n    Returns:\n        Optional[List[ArkProfile]]: _description_\n    \"\"\"\n    logger = get_logger('load_all_profiles')\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return None\n    profiles: List[ArkProfile] = []\n    for profile_name in os.listdir(folder):\n        try:\n            profiles.append(ArkProfile.parse_file(os.path.join(folder, profile_name)))\n        except Exception as ex:\n            logger.warning(f'Profile {profile_name} failed to be loaded successfully [{str(ex)}]')\n            continue\n    return profiles\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_default_profile","title":"<code>load_default_profile()</code>  <code>staticmethod</code>","text":"<p>Loads the default profile either from OS or a new one</p> <p>Returns:</p> Name Type Description <code>ArkProfile</code> <code>ArkProfile</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_default_profile() -&gt; ArkProfile:\n    \"\"\"\n    Loads the default profile either from OS or a new one\n\n    Returns:\n        ArkProfile: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    profile_name = ArkProfileLoader.deduce_profile_name()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return ArkProfile()\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.load_profile","title":"<code>load_profile(profile_name)</code>  <code>staticmethod</code>","text":"<p>Loads the profile from the os profiles folder Will return None if no profile is found for the name</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[ArkProfile]</code> <p>Optional[ArkProfile]: description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef load_profile(profile_name: str) -&gt; Optional[ArkProfile]:\n    \"\"\"\n    Loads the profile from the os profiles folder\n    Will return None if no profile is found for the name\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        Optional[ArkProfile]: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if os.path.exists(os.path.join(folder, profile_name)):\n        profile: ArkProfile = ArkProfile.parse_file(os.path.join(folder, profile_name))\n        return profile\n    return None\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.profile_exists","title":"<code>profile_exists(profile_name)</code>  <code>staticmethod</code>","text":"<p>Checks if a given profile name exists or not</p> <p>Parameters:</p> Name Type Description Default <code>profile_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profile_exists(profile_name: str) -&gt; bool:\n    \"\"\"\n    Checks if a given profile name exists or not\n\n    Args:\n        profile_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        return False\n    return os.path.exists(os.path.join(folder, profile_name))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.profiles_folder","title":"<code>profiles_folder()</code>  <code>staticmethod</code>","text":"<p>Retrieves the profiles folder, optionally from an env var with fallback to the default</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef profiles_folder() -&gt; str:\n    \"\"\"\n    Retrieves the profiles folder, optionally from an env var with fallback to the default\n\n    Returns:\n        str: _description_\n    \"\"\"\n    return os.getenv('ARK_PROFILES_FOLDER', os.path.join(Path.home(), '.ark_profiles'))\n</code></pre>"},{"location":"reference/models/ark_profile/#ark_sdk_python.models.ark_profile.ArkProfileLoader.save_profile","title":"<code>save_profile(profile)</code>  <code>staticmethod</code>","text":"<p>Saves the profile to the profiles folder on the filesystem</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>ArkProfile</code> <p>description</p> required Source code in <code>ark_sdk_python/models/ark_profile.py</code> <pre><code>@staticmethod\ndef save_profile(profile: ArkProfile) -&gt; None:\n    \"\"\"\n    Saves the profile to the profiles folder on the filesystem\n\n    Args:\n        profile (ArkProfile): _description_\n    \"\"\"\n    folder = ArkProfileLoader.profiles_folder()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    with open(os.path.join(folder, profile.profile_name), 'w', encoding='utf-8') as f:\n        f.write(profile.json(indent=4, by_alias=False))\n</code></pre>"},{"location":"reference/models/actions/","title":"actions","text":""},{"location":"reference/models/actions/ark_configure_action_consts/","title":"ark_configure_action_consts","text":""},{"location":"reference/models/actions/ark_service_action_definition/","title":"ark_service_action_definition","text":""},{"location":"reference/models/actions/services/","title":"services","text":""},{"location":"reference/models/actions/services/ark_dpa_exec_action_consts/","title":"ark_dpa_exec_action_consts","text":""},{"location":"reference/models/auth/","title":"auth","text":""},{"location":"reference/models/auth/ark_auth_method/","title":"ark_auth_method","text":""},{"location":"reference/models/auth/ark_auth_profile/","title":"ark_auth_profile","text":""},{"location":"reference/models/auth/ark_secret/","title":"ark_secret","text":""},{"location":"reference/models/auth/ark_token/","title":"ark_token","text":""},{"location":"reference/models/cli_services/","title":"cli_services","text":""},{"location":"reference/models/cli_services/dpa/","title":"dpa","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/","title":"policies_editor","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/","title":"common","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_base_generate_policy/","title":"ark_dpa_base_generate_policy","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_commit_policies/","title":"ark_dpa_commit_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_edit_policies/","title":"ark_dpa_edit_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_get_policies_status/","title":"ark_dpa_get_policies_status","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_load_policies/","title":"ark_dpa_load_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_loaded_policies/","title":"ark_dpa_loaded_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_policies_diff/","title":"ark_dpa_policies_diff","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_policies_status/","title":"ark_dpa_policies_status","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_remove_policies/","title":"ark_dpa_remove_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_reset_policies/","title":"ark_dpa_reset_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/common/ark_dpa_view_policies/","title":"ark_dpa_view_policies","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/db/","title":"db","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/db/ark_dpa_db_generate_policy/","title":"ark_dpa_db_generate_policy","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/vm/","title":"vm","text":""},{"location":"reference/models/cli_services/dpa/policies_editor/vm/ark_dpa_vm_generate_policy/","title":"ark_dpa_vm_generate_policy","text":""},{"location":"reference/models/common/","title":"common","text":""},{"location":"reference/models/common/ark_async_request_settings/","title":"ark_async_request_settings","text":""},{"location":"reference/models/common/ark_async_status/","title":"ark_async_status","text":""},{"location":"reference/models/common/ark_async_task/","title":"ark_async_task","text":""},{"location":"reference/models/common/ark_connection_method/","title":"ark_connection_method","text":""},{"location":"reference/models/common/ark_connector_type/","title":"ark_connector_type","text":""},{"location":"reference/models/common/ark_counted_values/","title":"ark_counted_values","text":""},{"location":"reference/models/common/ark_network_entity_type/","title":"ark_network_entity_type","text":""},{"location":"reference/models/common/ark_os_type/","title":"ark_os_type","text":""},{"location":"reference/models/common/ark_protocol_type/","title":"ark_protocol_type","text":""},{"location":"reference/models/common/ark_region/","title":"ark_region","text":""},{"location":"reference/models/common/ark_status/","title":"ark_status","text":""},{"location":"reference/models/common/ark_status_stats/","title":"ark_status_stats","text":""},{"location":"reference/models/common/ark_validations/","title":"ark_validations","text":""},{"location":"reference/models/common/ark_workspace_type/","title":"ark_workspace_type","text":""},{"location":"reference/models/common/aws/","title":"aws","text":""},{"location":"reference/models/common/aws/ark_cfn_async_task/","title":"ark_cfn_async_task","text":""},{"location":"reference/models/common/connections/","title":"connections","text":""},{"location":"reference/models/common/connections/ark_connection_command/","title":"ark_connection_command","text":""},{"location":"reference/models/common/connections/ark_connection_credentials/","title":"ark_connection_credentials","text":""},{"location":"reference/models/common/connections/ark_connection_details/","title":"ark_connection_details","text":""},{"location":"reference/models/common/connections/ark_connection_result/","title":"ark_connection_result","text":""},{"location":"reference/models/common/connections/connection_data/","title":"connection_data","text":""},{"location":"reference/models/common/connections/connection_data/ark_ssh_connection_data/","title":"ark_ssh_connection_data","text":""},{"location":"reference/models/common/connections/connection_data/ark_winrm_connection_data/","title":"ark_winrm_connection_data","text":""},{"location":"reference/models/common/identity/","title":"identity","text":""},{"location":"reference/models/common/identity/ark_identity_auth_schemas/","title":"ark_identity_auth_schemas","text":""},{"location":"reference/models/common/identity/ark_identity_common_schemas/","title":"ark_identity_common_schemas","text":""},{"location":"reference/models/common/identity/ark_identity_directory_schemas/","title":"ark_identity_directory_schemas","text":""},{"location":"reference/models/common/isp/","title":"isp","text":""},{"location":"reference/models/common/isp/ark_platform_discovery_schemas/","title":"ark_platform_discovery_schemas","text":""},{"location":"reference/models/services/","title":"services","text":""},{"location":"reference/models/services/ark_service_config/","title":"ark_service_config","text":""},{"location":"reference/models/services/dpa/","title":"dpa","text":""},{"location":"reference/models/services/dpa/certificates/","title":"certificates","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_certificate/","title":"ark_dpa_certificates_certificate","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_delete_certificate/","title":"ark_dpa_certificates_delete_certificate","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_filter/","title":"ark_dpa_certificates_filter","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_get_certificate/","title":"ark_dpa_certificates_get_certificate","text":""},{"location":"reference/models/services/dpa/certificates/ark_dpa_certificates_update_certificate/","title":"ark_dpa_certificates_update_certificate","text":""},{"location":"reference/models/services/dpa/db/","title":"db","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_base_execution/","title":"ark_dpa_db_base_execution","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_base_generate_assets/","title":"ark_dpa_db_base_generate_assets","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_generated_assets/","title":"ark_dpa_db_generated_assets","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_mysql_execution/","title":"ark_dpa_db_mysql_execution","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_oracle_generate_assets/","title":"ark_dpa_db_oracle_generate_assets","text":""},{"location":"reference/models/services/dpa/db/ark_dpa_db_psql_execution/","title":"ark_dpa_db_psql_execution","text":""},{"location":"reference/models/services/dpa/k8s/","title":"k8s","text":""},{"location":"reference/models/services/dpa/k8s/ark_dpa_k8s_generate_kubeconfig/","title":"ark_dpa_k8s_generate_kubeconfig","text":""},{"location":"reference/models/services/dpa/policies/","title":"policies","text":""},{"location":"reference/models/services/dpa/policies/common/","title":"common","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_add_policy/","title":"ark_dpa_base_add_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_authorization_rule/","title":"ark_dpa_base_authorization_rule","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_connection_information/","title":"ark_dpa_base_connection_information","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policies_filter/","title":"ark_dpa_base_policies_filter","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policies_stats/","title":"ark_dpa_base_policies_stats","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policy/","title":"ark_dpa_base_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_policy_list_item/","title":"ark_dpa_base_policy_list_item","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_base_update_policy/","title":"ark_dpa_base_update_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_delete_policy/","title":"ark_dpa_delete_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_get_policy/","title":"ark_dpa_get_policy","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_rule_status/","title":"ark_dpa_rule_status","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_update_policy_status/","title":"ark_dpa_update_policy_status","text":""},{"location":"reference/models/services/dpa/policies/common/ark_dpa_user_data/","title":"ark_dpa_user_data","text":""},{"location":"reference/models/services/dpa/policies/db/","title":"db","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_add_policy/","title":"ark_dpa_db_add_policy","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_authorization_rule/","title":"ark_dpa_db_authorization_rule","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_connection_data/","title":"ark_dpa_db_connection_data","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policies_filter/","title":"ark_dpa_db_policies_filter","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policies_stats/","title":"ark_dpa_db_policies_stats","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policies_workspace_type_serializer/","title":"ark_dpa_db_policies_workspace_type_serializer","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policy/","title":"ark_dpa_db_policy","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_policy_list_item/","title":"ark_dpa_db_policy_list_item","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_providers/","title":"ark_dpa_db_providers","text":""},{"location":"reference/models/services/dpa/policies/db/ark_dpa_db_update_policy/","title":"ark_dpa_db_update_policy","text":""},{"location":"reference/models/services/dpa/policies/vm/","title":"vm","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_add_policy/","title":"ark_dpa_vm_add_policy","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_authorization_rule/","title":"ark_dpa_vm_authorization_rule","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_connection_data/","title":"ark_dpa_vm_connection_data","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_filter/","title":"ark_dpa_vm_policies_filter","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_protocol_type_serializer/","title":"ark_dpa_vm_policies_protocol_type_serializer","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_stats/","title":"ark_dpa_vm_policies_stats","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policies_workspace_type_serializer/","title":"ark_dpa_vm_policies_workspace_type_serializer","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policy/","title":"ark_dpa_vm_policy","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_policy_list_item/","title":"ark_dpa_vm_policy_list_item","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_providers/","title":"ark_dpa_vm_providers","text":""},{"location":"reference/models/services/dpa/policies/vm/ark_dpa_vm_update_policy/","title":"ark_dpa_vm_update_policy","text":""},{"location":"reference/models/services/dpa/secrets/","title":"secrets","text":""},{"location":"reference/models/services/dpa/secrets/db/","title":"db","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_add_secret/","title":"ark_dpa_db_add_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_delete_secret/","title":"ark_dpa_db_delete_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_disable_secret/","title":"ark_dpa_db_disable_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_enable_secret/","title":"ark_dpa_db_enable_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_get_secret/","title":"ark_dpa_db_get_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secret_metadata/","title":"ark_dpa_db_secret_metadata","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secret_type/","title":"ark_dpa_db_secret_type","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secrets_filter/","title":"ark_dpa_db_secrets_filter","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_secrets_stats/","title":"ark_dpa_db_secrets_stats","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_store_descriptor/","title":"ark_dpa_db_store_descriptor","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_store_type/","title":"ark_dpa_db_store_type","text":""},{"location":"reference/models/services/dpa/secrets/db/ark_dpa_db_update_secret/","title":"ark_dpa_db_update_secret","text":""},{"location":"reference/models/services/dpa/secrets/db/secret_links/","title":"secret_links","text":""},{"location":"reference/models/services/dpa/secrets/db/secret_links/ark_dpa_db_pam_account_secret_link/","title":"ark_dpa_db_pam_account_secret_link","text":""},{"location":"reference/models/services/dpa/secrets/db/secrets_data/","title":"secrets_data","text":""},{"location":"reference/models/services/dpa/secrets/db/secrets_data/ark_dpa_db_user_password_secret_data/","title":"ark_dpa_db_user_password_secret_data","text":""},{"location":"reference/models/services/dpa/sso/","title":"sso","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_acquire_token_response/","title":"ark_dpa_sso_acquire_token_response","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_get_short_lived_client_certificate/","title":"ark_dpa_sso_get_short_lived_client_certificate","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_get_short_lived_oracle_wallet/","title":"ark_dpa_sso_get_short_lived_oracle_wallet","text":""},{"location":"reference/models/services/dpa/sso/ark_dpa_sso_get_short_lived_password/","title":"ark_dpa_sso_get_short_lived_password","text":""},{"location":"reference/models/services/dpa/workspaces/","title":"workspaces","text":""},{"location":"reference/models/services/dpa/workspaces/db/","title":"db","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_add_database/","title":"ark_dpa_db_add_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_database/","title":"ark_dpa_db_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_database_info/","title":"ark_dpa_db_database_info","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_databases_filter/","title":"ark_dpa_db_databases_filter","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_databases_stats/","title":"ark_dpa_db_databases_stats","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_delete_database/","title":"ark_dpa_db_delete_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_get_database/","title":"ark_dpa_db_get_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_platform_type_serializer/","title":"ark_dpa_db_platform_type_serializer","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_provider/","title":"ark_dpa_db_provider","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_tag/","title":"ark_dpa_db_tag","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_update_database/","title":"ark_dpa_db_update_database","text":""},{"location":"reference/models/services/dpa/workspaces/db/ark_dpa_db_warning/","title":"ark_dpa_db_warning","text":""},{"location":"reference/services/","title":"services","text":""},{"location":"reference/services/ark_service/","title":"ark_service","text":""},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService","title":"<code>ArkService</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>class ArkService(ABC):\n    def __init__(self, *authenticators: Any) -&gt; None:\n        self._logger = get_logger(self.__class__.__name__)\n        self._authenticators = [auth for auth in authenticators if issubclass(type(auth), ArkAuth)]\n        given_auth_names = [auth.authenticator_name() for auth in self._authenticators]\n        if any(a not in given_auth_names for a in self.service_config().required_authenticator_names):\n            raise ArkValidationException(f'{self.service_config().service_name} missing required authenticators for service')\n\n    @property\n    def authenticators(self) -&gt; List[ArkAuth]:\n        \"\"\"\n        Returns all the authenticators for this service\n\n        Returns:\n            List[ArkAuth]: _description_\n        \"\"\"\n        return self._authenticators\n\n    def authenticator(self, auth_name: str) -&gt; ArkAuth:\n        \"\"\"\n        For a given authenticator name, finds the fitting ark authenticator class\n\n        Args:\n            auth_name (str): _description_\n\n        Raises:\n            ArkNotFoundException: _description_\n\n        Returns:\n            ArkAuth: _description_\n        \"\"\"\n        for auth in self.authenticators:\n            if auth.authenticator_name() == auth_name:\n                return auth\n        raise ArkNotFoundException(f'{self.service_config().service_name} Failed to find authenticator {auth_name}')\n\n    def has_authenticator(self, auth_name: str) -&gt; bool:\n        \"\"\"\n        Checks whether the given authenticator name exists\n\n        Args:\n            auth_name (str): _description_\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        return any(auth.authenticator_name() == auth_name for auth in self.authenticators)\n\n    @staticmethod\n    @abstractmethod\n    def service_config() -&gt; ArkServiceConfig:\n        \"\"\"\n        Returns the service config containing the service name, and required / optional authenticators\n\n        Returns:\n            ArkServiceConfig: _description_\n        \"\"\"\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.authenticators","title":"<code>authenticators: List[ArkAuth]</code>  <code>property</code>","text":"<p>Returns all the authenticators for this service</p> <p>Returns:</p> Type Description <code>List[ArkAuth]</code> <p>List[ArkAuth]: description</p>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.authenticator","title":"<code>authenticator(auth_name)</code>","text":"<p>For a given authenticator name, finds the fitting ark authenticator class</p> <p>Parameters:</p> Name Type Description Default <code>auth_name</code> <code>str</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkNotFoundException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkAuth</code> <code>ArkAuth</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>def authenticator(self, auth_name: str) -&gt; ArkAuth:\n    \"\"\"\n    For a given authenticator name, finds the fitting ark authenticator class\n\n    Args:\n        auth_name (str): _description_\n\n    Raises:\n        ArkNotFoundException: _description_\n\n    Returns:\n        ArkAuth: _description_\n    \"\"\"\n    for auth in self.authenticators:\n        if auth.authenticator_name() == auth_name:\n            return auth\n    raise ArkNotFoundException(f'{self.service_config().service_name} Failed to find authenticator {auth_name}')\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.has_authenticator","title":"<code>has_authenticator(auth_name)</code>","text":"<p>Checks whether the given authenticator name exists</p> <p>Parameters:</p> Name Type Description Default <code>auth_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>def has_authenticator(self, auth_name: str) -&gt; bool:\n    \"\"\"\n    Checks whether the given authenticator name exists\n\n    Args:\n        auth_name (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    return any(auth.authenticator_name() == auth_name for auth in self.authenticators)\n</code></pre>"},{"location":"reference/services/ark_service/#ark_sdk_python.services.ark_service.ArkService.service_config","title":"<code>service_config()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the service config containing the service name, and required / optional authenticators</p> <p>Returns:</p> Name Type Description <code>ArkServiceConfig</code> <code>ArkServiceConfig</code> <p>description</p> Source code in <code>ark_sdk_python/services/ark_service.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef service_config() -&gt; ArkServiceConfig:\n    \"\"\"\n    Returns the service config containing the service name, and required / optional authenticators\n\n    Returns:\n        ArkServiceConfig: _description_\n    \"\"\"\n</code></pre>"},{"location":"reference/services/dpa/","title":"dpa","text":""},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI","title":"<code>ArkDPAAPI</code>","text":"Source code in <code>ark_sdk_python/services/dpa/ark_dpa_api.py</code> <pre><code>class ArkDPAAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__db_workspace_service = ArkDPADBWorkspaceService(isp_auth)\n        self.__db_policies_service = ArkDPADBPoliciesService(isp_auth)\n        self.__db_secrets_service = ArkDPADBSecretsService(isp_auth)\n        self.__sso_service = ArkDPASSOService(isp_auth)\n        self.__db_service = ArkDPADBService(isp_auth)\n        self.__certificates_service = ArkDPACertificatesService(isp_auth)\n        self.__k8s_service = ArkDPAK8SService(isp_auth)\n\n    @property\n    def workspace_db(self) -&gt; ArkDPADBWorkspaceService:\n        \"\"\"\n        Getter for the DB workspace service\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        return self.__db_workspace_service\n\n    @property\n    def policies_db(self) -&gt; ArkDPADBPoliciesService:\n        \"\"\"\n        Getter for the policies db service\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        return self.__db_policies_service\n\n    @property\n    def secrets_db(self) -&gt; ArkDPADBSecretsService:\n        \"\"\"\n        Getter for the db secrets service\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        return self.__db_secrets_service\n\n    @property\n    def sso(self) -&gt; ArkDPASSOService:\n        \"\"\"\n        Getter for the sso service\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        return self.__sso_service\n\n    @property\n    def db(self) -&gt; ArkDPADBService:\n        \"\"\"\n        Getter for the db service\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        return self.__db_service\n\n    @property\n    def certificates(self) -&gt; ArkDPACertificatesService:\n        \"\"\"\n        Getter for the certificates service\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        return self.__certificates_service\n\n    @property\n    def k8s(self) -&gt; ArkDPAK8SService:\n        \"\"\"\n        Getter for the k8s service\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        return self.__k8s_service\n</code></pre>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.certificates","title":"<code>certificates: ArkDPACertificatesService</code>  <code>property</code>","text":"<p>Getter for the certificates service</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>ArkDPACertificatesService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.db","title":"<code>db: ArkDPADBService</code>  <code>property</code>","text":"<p>Getter for the db service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>ArkDPADBService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.k8s","title":"<code>k8s: ArkDPAK8SService</code>  <code>property</code>","text":"<p>Getter for the k8s service</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>ArkDPAK8SService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.policies_db","title":"<code>policies_db: ArkDPADBPoliciesService</code>  <code>property</code>","text":"<p>Getter for the policies db service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>ArkDPADBPoliciesService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.secrets_db","title":"<code>secrets_db: ArkDPADBSecretsService</code>  <code>property</code>","text":"<p>Getter for the db secrets service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>ArkDPADBSecretsService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.sso","title":"<code>sso: ArkDPASSOService</code>  <code>property</code>","text":"<p>Getter for the sso service</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>ArkDPASSOService</code> <p>description</p>"},{"location":"reference/services/dpa/#ark_sdk_python.services.dpa.ArkDPAAPI.workspace_db","title":"<code>workspace_db: ArkDPADBWorkspaceService</code>  <code>property</code>","text":"<p>Getter for the DB workspace service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>ArkDPADBWorkspaceService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/","title":"ark_dpa_api","text":""},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI","title":"<code>ArkDPAAPI</code>","text":"Source code in <code>ark_sdk_python/services/dpa/ark_dpa_api.py</code> <pre><code>class ArkDPAAPI:\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        self.__db_workspace_service = ArkDPADBWorkspaceService(isp_auth)\n        self.__db_policies_service = ArkDPADBPoliciesService(isp_auth)\n        self.__db_secrets_service = ArkDPADBSecretsService(isp_auth)\n        self.__sso_service = ArkDPASSOService(isp_auth)\n        self.__db_service = ArkDPADBService(isp_auth)\n        self.__certificates_service = ArkDPACertificatesService(isp_auth)\n        self.__k8s_service = ArkDPAK8SService(isp_auth)\n\n    @property\n    def workspace_db(self) -&gt; ArkDPADBWorkspaceService:\n        \"\"\"\n        Getter for the DB workspace service\n\n        Returns:\n            ArkDPADBWorkspaceService: _description_\n        \"\"\"\n        return self.__db_workspace_service\n\n    @property\n    def policies_db(self) -&gt; ArkDPADBPoliciesService:\n        \"\"\"\n        Getter for the policies db service\n\n        Returns:\n            ArkDPADBPoliciesService: _description_\n        \"\"\"\n        return self.__db_policies_service\n\n    @property\n    def secrets_db(self) -&gt; ArkDPADBSecretsService:\n        \"\"\"\n        Getter for the db secrets service\n\n        Returns:\n            ArkDPADBSecretsService: _description_\n        \"\"\"\n        return self.__db_secrets_service\n\n    @property\n    def sso(self) -&gt; ArkDPASSOService:\n        \"\"\"\n        Getter for the sso service\n\n        Returns:\n            ArkDPASSOService: _description_\n        \"\"\"\n        return self.__sso_service\n\n    @property\n    def db(self) -&gt; ArkDPADBService:\n        \"\"\"\n        Getter for the db service\n\n        Returns:\n            ArkDPADBService: _description_\n        \"\"\"\n        return self.__db_service\n\n    @property\n    def certificates(self) -&gt; ArkDPACertificatesService:\n        \"\"\"\n        Getter for the certificates service\n\n        Returns:\n            ArkDPACertificatesService: _description_\n        \"\"\"\n        return self.__certificates_service\n\n    @property\n    def k8s(self) -&gt; ArkDPAK8SService:\n        \"\"\"\n        Getter for the k8s service\n\n        Returns:\n            ArkDPAK8SService: _description_\n        \"\"\"\n        return self.__k8s_service\n</code></pre>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.certificates","title":"<code>certificates: ArkDPACertificatesService</code>  <code>property</code>","text":"<p>Getter for the certificates service</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificatesService</code> <code>ArkDPACertificatesService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.db","title":"<code>db: ArkDPADBService</code>  <code>property</code>","text":"<p>Getter for the db service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBService</code> <code>ArkDPADBService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.k8s","title":"<code>k8s: ArkDPAK8SService</code>  <code>property</code>","text":"<p>Getter for the k8s service</p> <p>Returns:</p> Name Type Description <code>ArkDPAK8SService</code> <code>ArkDPAK8SService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.policies_db","title":"<code>policies_db: ArkDPADBPoliciesService</code>  <code>property</code>","text":"<p>Getter for the policies db service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesService</code> <code>ArkDPADBPoliciesService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.secrets_db","title":"<code>secrets_db: ArkDPADBSecretsService</code>  <code>property</code>","text":"<p>Getter for the db secrets service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsService</code> <code>ArkDPADBSecretsService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.sso","title":"<code>sso: ArkDPASSOService</code>  <code>property</code>","text":"<p>Getter for the sso service</p> <p>Returns:</p> Name Type Description <code>ArkDPASSOService</code> <code>ArkDPASSOService</code> <p>description</p>"},{"location":"reference/services/dpa/ark_dpa_api/#ark_sdk_python.services.dpa.ark_dpa_api.ArkDPAAPI.workspace_db","title":"<code>workspace_db: ArkDPADBWorkspaceService</code>  <code>property</code>","text":"<p>Getter for the DB workspace service</p> <p>Returns:</p> Name Type Description <code>ArkDPADBWorkspaceService</code> <code>ArkDPADBWorkspaceService</code> <p>description</p>"},{"location":"reference/services/dpa/certificates/","title":"certificates","text":""},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService","title":"<code>ArkDPACertificatesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>class ArkDPACertificatesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Adds a new certificate through Access Certificates Service.\n\n        Args:\n            create_certificate (ArkDPACreateCertificate): The certificate to add.\n\n        Raises:\n            ArkServiceException: If the certificate could not be added.\n\n        Returns:\n            ArkDPACertificate: The certificate that was added.\n        \"\"\"\n        self._logger.info(\"Adding new certificate.\")\n        cert_body = ''\n        try:\n            with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n        create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n        resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                cert_id = resp.json()['certificate_id']\n                return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n                raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n        raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n\n    def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Retrieves a certificate from Access Certificates Service by its id.\n\n        Args:\n            get_certificate (ArkDPAGetCertificate): The id of the certificate to retrieve.\n\n        Raises:\n            ArkServiceException: If the certificate could not be retrieved.\n\n        Returns:\n            ArkDPACertificate: The certificate that was retrieved.\n        \"\"\"\n        self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n        resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n        try:\n            return ArkDPACertificate.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n        \"\"\"\n        Delete an existing certificate.\n\n        Args:\n            cert (ArkDPADeleteCertificate): The id of the certificate to delete.\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n        resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n\n    def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n        \"\"\"\n        Update an existing certificate.\n\n        Args:\n            update_certificate (ArkDPAUpdateCertificate): The id of the certificate to update.\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n        try:\n            with open(update_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n        update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n        resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n\n    def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        List all certificates.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            list[ArkDPACertificate]: _description_\n        \"\"\"\n        self._logger.info(\"Listing certificates.\")\n        resp = self.__client.get(CERTIFICATES_API)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n        try:\n            return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n\n    def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        List certificates by given filters.\n\n        Args:\n            certificates_filter (ArkDPACertificatesFilter): _description_\n\n        Returns:\n            List[ArkDPAShortCertificate]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n        certs = self.list_certificates()\n\n        if certificates_filter.domain_name:\n            certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n        if certificates_filter.cert_name:\n            certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n        return certs\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.add_certificate","title":"<code>add_certificate(create_certificate)</code>","text":"<p>Adds a new certificate through Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>create_certificate</code> <code>ArkDPACreateCertificate</code> <p>The certificate to add.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>If the certificate could not be added.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The certificate that was added.</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Adds a new certificate through Access Certificates Service.\n\n    Args:\n        create_certificate (ArkDPACreateCertificate): The certificate to add.\n\n    Raises:\n        ArkServiceException: If the certificate could not be added.\n\n    Returns:\n        ArkDPACertificate: The certificate that was added.\n    \"\"\"\n    self._logger.info(\"Adding new certificate.\")\n    cert_body = ''\n    try:\n        with open(create_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n    create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n    resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            cert_id = resp.json()['certificate_id']\n            return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n            raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n    raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.certificate","title":"<code>certificate(get_certificate)</code>","text":"<p>Retrieves a certificate from Access Certificates Service by its id.</p> <p>Parameters:</p> Name Type Description Default <code>get_certificate</code> <code>ArkDPAGetCertificate</code> <p>The id of the certificate to retrieve.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>If the certificate could not be retrieved.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The certificate that was retrieved.</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Retrieves a certificate from Access Certificates Service by its id.\n\n    Args:\n        get_certificate (ArkDPAGetCertificate): The id of the certificate to retrieve.\n\n    Raises:\n        ArkServiceException: If the certificate could not be retrieved.\n\n    Returns:\n        ArkDPACertificate: The certificate that was retrieved.\n    \"\"\"\n    self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n    resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n    try:\n        return ArkDPACertificate.parse_obj(resp.json())\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.delete_certificate","title":"<code>delete_certificate(cert)</code>","text":"<p>Delete an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>cert</code> <code>ArkDPADeleteCertificate</code> <p>The id of the certificate to delete.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n    \"\"\"\n    Delete an existing certificate.\n\n    Args:\n        cert (ArkDPADeleteCertificate): The id of the certificate to delete.\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n    resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.list_certificates","title":"<code>list_certificates()</code>","text":"<p>List all certificates.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>list[ArkDPACertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    List all certificates.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        list[ArkDPACertificate]: _description_\n    \"\"\"\n    self._logger.info(\"Listing certificates.\")\n    resp = self.__client.get(CERTIFICATES_API)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n    try:\n        return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.list_certificates_by","title":"<code>list_certificates_by(certificates_filter)</code>","text":"<p>List certificates by given filters.</p> <p>Parameters:</p> Name Type Description Default <code>certificates_filter</code> <code>ArkDPACertificatesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>List[ArkDPAShortCertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    List certificates by given filters.\n\n    Args:\n        certificates_filter (ArkDPACertificatesFilter): _description_\n\n    Returns:\n        List[ArkDPAShortCertificate]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n    certs = self.list_certificates()\n\n    if certificates_filter.domain_name:\n        certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n    if certificates_filter.cert_name:\n        certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n    return certs\n</code></pre>"},{"location":"reference/services/dpa/certificates/#ark_sdk_python.services.dpa.certificates.ArkDPACertificatesService.update_certificate","title":"<code>update_certificate(update_certificate)</code>","text":"<p>Update an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>update_certificate</code> <code>ArkDPAUpdateCertificate</code> <p>The id of the certificate to update.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n    \"\"\"\n    Update an existing certificate.\n\n    Args:\n        update_certificate (ArkDPAUpdateCertificate): The id of the certificate to update.\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n    try:\n        with open(update_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n    update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n    resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/","title":"ark_dpa_certificates_service","text":""},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService","title":"<code>ArkDPACertificatesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>class ArkDPACertificatesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Adds a new certificate through Access Certificates Service.\n\n        Args:\n            create_certificate (ArkDPACreateCertificate): The certificate to add.\n\n        Raises:\n            ArkServiceException: If the certificate could not be added.\n\n        Returns:\n            ArkDPACertificate: The certificate that was added.\n        \"\"\"\n        self._logger.info(\"Adding new certificate.\")\n        cert_body = ''\n        try:\n            with open(create_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n        create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n        resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                cert_id = resp.json()['certificate_id']\n                return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n                raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n        raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n\n    def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n        \"\"\"\n        Retrieves a certificate from Access Certificates Service by its id.\n\n        Args:\n            get_certificate (ArkDPAGetCertificate): The id of the certificate to retrieve.\n\n        Raises:\n            ArkServiceException: If the certificate could not be retrieved.\n\n        Returns:\n            ArkDPACertificate: The certificate that was retrieved.\n        \"\"\"\n        self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n        resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n        try:\n            return ArkDPACertificate.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n\n    def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n        \"\"\"\n        Delete an existing certificate.\n\n        Args:\n            cert (ArkDPADeleteCertificate): The id of the certificate to delete.\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n        resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n\n    def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n        \"\"\"\n        Update an existing certificate.\n\n        Args:\n            update_certificate (ArkDPAUpdateCertificate): The id of the certificate to update.\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n        try:\n            with open(update_certificate.file, 'r', encoding='utf-8') as f:\n                cert_body = f.read()\n        except Exception as ex:\n            raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n        if not cert_body:\n            raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n        update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n        resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n\n    def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        List all certificates.\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            list[ArkDPACertificate]: _description_\n        \"\"\"\n        self._logger.info(\"Listing certificates.\")\n        resp = self.__client.get(CERTIFICATES_API)\n        if resp.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n        try:\n            return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n\n    def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n        \"\"\"\n        List certificates by given filters.\n\n        Args:\n            certificates_filter (ArkDPACertificatesFilter): _description_\n\n        Returns:\n            List[ArkDPAShortCertificate]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n        certs = self.list_certificates()\n\n        if certificates_filter.domain_name:\n            certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n        if certificates_filter.cert_name:\n            certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n        return certs\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.add_certificate","title":"<code>add_certificate(create_certificate)</code>","text":"<p>Adds a new certificate through Access Certificates Service.</p> <p>Parameters:</p> Name Type Description Default <code>create_certificate</code> <code>ArkDPACreateCertificate</code> <p>The certificate to add.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>If the certificate could not be added.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The certificate that was added.</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def add_certificate(self, create_certificate: ArkDPACreateCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Adds a new certificate through Access Certificates Service.\n\n    Args:\n        create_certificate (ArkDPACreateCertificate): The certificate to add.\n\n    Raises:\n        ArkServiceException: If the certificate could not be added.\n\n    Returns:\n        ArkDPACertificate: The certificate that was added.\n    \"\"\"\n    self._logger.info(\"Adding new certificate.\")\n    cert_body = ''\n    try:\n        with open(create_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{create_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{create_certificate.file}] is empty')\n    create_certificate_req = ArkDPACreateCertificateRequest(cert_body=cert_body, **create_certificate.dict()).dict()\n    resp = self.__client.post(CERTIFICATES_API, json=create_certificate_req)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            cert_id = resp.json()['certificate_id']\n            return self.certificate(ArkDPAGetCertificate(certificate_id=cert_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f\"Failed to parse response from create certificate [{str(ex)}]\")\n            raise ArkServiceException(f\"Failed to parse response from create certificate [{str(ex)}]\") from ex\n    raise ArkServiceException(f'Failed to add a new certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.certificate","title":"<code>certificate(get_certificate)</code>","text":"<p>Retrieves a certificate from Access Certificates Service by its id.</p> <p>Parameters:</p> Name Type Description Default <code>get_certificate</code> <code>ArkDPAGetCertificate</code> <p>The id of the certificate to retrieve.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>If the certificate could not be retrieved.</p> <p>Returns:</p> Name Type Description <code>ArkDPACertificate</code> <code>ArkDPACertificate</code> <p>The certificate that was retrieved.</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def certificate(self, get_certificate: ArkDPAGetCertificate) -&gt; ArkDPACertificate:\n    \"\"\"\n    Retrieves a certificate from Access Certificates Service by its id.\n\n    Args:\n        get_certificate (ArkDPAGetCertificate): The id of the certificate to retrieve.\n\n    Raises:\n        ArkServiceException: If the certificate could not be retrieved.\n\n    Returns:\n        ArkDPACertificate: The certificate that was retrieved.\n    \"\"\"\n    self._logger.info(f'Retrieving certificate [{get_certificate.certificate_id}]')\n    resp = self.__client.get(CERTIFICATE_API.format(certificate_id=get_certificate.certificate_id))\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to retrieve certificate [{get_certificate.certificate_id}] [{resp.text}]')\n    try:\n        return ArkDPACertificate.parse_obj(resp.json())\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse policy response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.delete_certificate","title":"<code>delete_certificate(cert)</code>","text":"<p>Delete an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>cert</code> <code>ArkDPADeleteCertificate</code> <p>The id of the certificate to delete.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def delete_certificate(self, cert: ArkDPADeleteCertificate) -&gt; None:\n    \"\"\"\n    Delete an existing certificate.\n\n    Args:\n        cert (ArkDPADeleteCertificate): The id of the certificate to delete.\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Deleting certificate [{cert.certificate_id}]\")\n    resp: Response = self.__client.delete(CERTIFICATE_API.format(certificate_id=cert.certificate_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete certificate [{cert.certificate_id}] [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.list_certificates","title":"<code>list_certificates()</code>","text":"<p>List all certificates.</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>list[ArkDPACertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates(self) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    List all certificates.\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        list[ArkDPACertificate]: _description_\n    \"\"\"\n    self._logger.info(\"Listing certificates.\")\n    resp = self.__client.get(CERTIFICATES_API)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to list certificates [{resp.text}] - [{resp.status_code}]')\n    try:\n        return [ArkDPAShortCertificate.parse_obj(cert) for cert in resp.json()['certificates']['items']]\n    except (ValidationError, JSONDecodeError) as ex:\n        self._logger.exception(f'Failed to parse certificate response [{str(ex)}] - [{resp.text}]')\n        raise ArkServiceException(f'Failed to parse certificate response [{str(ex)}]') from ex\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.list_certificates_by","title":"<code>list_certificates_by(certificates_filter)</code>","text":"<p>List certificates by given filters.</p> <p>Parameters:</p> Name Type Description Default <code>certificates_filter</code> <code>ArkDPACertificatesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAShortCertificate]</code> <p>List[ArkDPAShortCertificate]: description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def list_certificates_by(self, certificates_filter: ArkDPACertificatesFilter) -&gt; List[ArkDPAShortCertificate]:\n    \"\"\"\n    List certificates by given filters.\n\n    Args:\n        certificates_filter (ArkDPACertificatesFilter): _description_\n\n    Returns:\n        List[ArkDPAShortCertificate]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving certificates by filter [{certificates_filter}]')\n    certs = self.list_certificates()\n\n    if certificates_filter.domain_name:\n        certs = [cert for cert in certs if certificates_filter.domain_name.lower() in cert.domain.lower()]\n\n    if certificates_filter.cert_name:\n        certs = [cert for cert in certs if certificates_filter.cert_name.lower() in cert.cert_name.lower()]\n\n    return certs\n</code></pre>"},{"location":"reference/services/dpa/certificates/ark_dpa_certificates_service/#ark_sdk_python.services.dpa.certificates.ark_dpa_certificates_service.ArkDPACertificatesService.update_certificate","title":"<code>update_certificate(update_certificate)</code>","text":"<p>Update an existing certificate.</p> <p>Parameters:</p> Name Type Description Default <code>update_certificate</code> <code>ArkDPAUpdateCertificate</code> <p>The id of the certificate to update.</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/certificates/ark_dpa_certificates_service.py</code> <pre><code>def update_certificate(self, update_certificate: ArkDPAUpdateCertificate) -&gt; None:\n    \"\"\"\n    Update an existing certificate.\n\n    Args:\n        update_certificate (ArkDPAUpdateCertificate): The id of the certificate to update.\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info(f\"Updating certificate [{update_certificate.certificate_id}]\")\n    try:\n        with open(update_certificate.file, 'r', encoding='utf-8') as f:\n            cert_body = f.read()\n    except Exception as ex:\n        raise ArkServiceException(f'Failed to read certificate file [{update_certificate.file}] [{str(ex)}]') from ex\n    if not cert_body:\n        raise ArkServiceException(f'Certificate file [{update_certificate.file}] is empty')\n    update_certificate_req = ArkDPAUpdateCertificateRequest(cert_body=cert_body, **update_certificate.dict()).dict()\n    resp = self.__client.put(CERTIFICATE_API.format(certificate_id=update_certificate.certificate_id), json=update_certificate_req)\n    if resp.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to update the certificate [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/db/","title":"db","text":""},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService","title":"<code>ArkDPADBService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>class ArkDPADBService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__sso_service = ArkDPASSOService(self.__isp_auth)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __proxy_address(self, db_type: str):\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        return f'{claims[\"subdomain\"]}.{db_type}.{claims[\"platform_domain\"]}'\n\n    def __connection_string(self, target_address: str, target_username: Optional[str] = None) -&gt; None:\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        if target_username:\n            # Standing\n            return f'{claims[\"unique_name\"]}@{target_username}@{target_address}'\n        # Dynamic\n        return f'{claims[\"unique_name\"]}@{target_address}'\n\n    def __create_mylogin_cnf(self, username: str, address: str, password: str) -&gt; str:\n        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8')\n        temp_file.write('[client]\\n' f'user = {username}\\n' f'password = {password}\\n' f'host = {address}\\n')\n        temp_file.close()\n        os.chmod(temp_file.name, 0o600)\n        return temp_file.name\n\n    def __add_to_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        flags = 'r+'\n        change_chomd = False\n        path = f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'\n        if not os.path.exists(path):\n            flags = 'w+'\n            change_chomd = True\n        with open(path, flags, encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            for line in lines:\n                if line == pass_format:\n                    return\n            lines.append(pass_format)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(lines)\n        if change_chomd:\n            os.chmod(path, 0o600)\n\n    def __remove_from_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        if not os.path.exists(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'):\n            return\n        with open(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass', 'r+', encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            updated_lines = []\n            for line in lines:\n                if line == pass_format:\n                    continue\n                updated_lines.append(line)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(updated_lines)\n\n    def __execute(self, command_line: str) -&gt; None:\n        p = subprocess.Popen(command_line, shell=True)\n        p.communicate()\n\n    def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n        \"\"\"\n        Exectues psql command line for postgres via CyberArk's Database Proxy\n\n        Args:\n            psql_execution (ArkDPADBPsqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"postgres\")\n        connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n        self.__add_to_pgpass(connection_string, proxy_address, password)\n        try:\n            self.__execute(execution_action)\n        finally:\n            self.__remove_from_pgpass(connection_string, proxy_address, password)\n\n    def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n        \"\"\"\n        Exectues mysql command line for mysql via CyberArk's Database Proxy\n\n        Args:\n            mysql_execution (ArkDPADBMysqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"mysql\")\n        connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n        execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n        try:\n            self.__execute(execution_action)\n        finally:\n            os.unlink(temp_cnf_login)\n\n    def __generate_assets(\n        self,\n        resource_type: ArkDPADBDatabaseFamilyType,\n        connection_method: ArkConnectionMethod,\n        response_format: ArkDPADBAssetsResponseFormat,\n        include_sso: bool,\n        generation_hints: Dict[str, Any],\n    ) -&gt; ArkDPADBGeneratedAssets:\n        resp: Response = self.__client.post(\n            ASSETS_API,\n            json={\n                'resource_type': resource_type.value,\n                'os_type': running_os().value,\n                'connection_method': connection_method.value,\n                'response_format': response_format.value,\n                'include_sso': include_sso,\n                'generation_hints': generation_hints,\n            },\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                if response_format == ArkDPADBAssetsResponseFormat.RAW:\n                    return resp.text\n                return ArkDPADBGeneratedAssets.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to generate assets [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to generate assets [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate assets [{resp.text}] - [{resp.status_code}]')\n\n    def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates oracle tns names and optionally oracle wallet if allowed\n\n        Args:\n            generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating oracle tns names')\n        assets_data = self.__generate_assets(\n            ArkDPADBDatabaseFamilyType.Oracle,\n            generate_oracle_assets.connection_method,\n            generate_oracle_assets.response_format,\n            generate_oracle_assets.include_sso,\n            {'folder': generate_oracle_assets.folder},\n        )\n        if isinstance(assets_data, ArkDPADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        assets_data = base64.b64decode(assets_data)\n        if not os.path.exists(generate_oracle_assets.folder):\n            os.makedirs(generate_oracle_assets.folder)\n        if not generate_oracle_assets.unzip:\n            with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n                file_handle.write(assets_data)\n        else:\n            assets_bytes = BytesIO(assets_data)\n            with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n                zipf.extractall(generate_oracle_assets.folder)\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService.generate_oracle_tnsnames","title":"<code>generate_oracle_tnsnames(generate_oracle_assets)</code>","text":"<p>Generates oracle tns names and optionally oracle wallet if allowed</p> <p>Parameters:</p> Name Type Description Default <code>generate_oracle_assets</code> <code>ArkDPADBOracleGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates oracle tns names and optionally oracle wallet if allowed\n\n    Args:\n        generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating oracle tns names')\n    assets_data = self.__generate_assets(\n        ArkDPADBDatabaseFamilyType.Oracle,\n        generate_oracle_assets.connection_method,\n        generate_oracle_assets.response_format,\n        generate_oracle_assets.include_sso,\n        {'folder': generate_oracle_assets.folder},\n    )\n    if isinstance(assets_data, ArkDPADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    assets_data = base64.b64decode(assets_data)\n    if not os.path.exists(generate_oracle_assets.folder):\n        os.makedirs(generate_oracle_assets.folder)\n    if not generate_oracle_assets.unzip:\n        with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n            file_handle.write(assets_data)\n    else:\n        assets_bytes = BytesIO(assets_data)\n        with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n            zipf.extractall(generate_oracle_assets.folder)\n</code></pre>"},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService.mysql","title":"<code>mysql(mysql_execution)</code>","text":"<p>Exectues mysql command line for mysql via CyberArk's Database Proxy</p> <p>Parameters:</p> Name Type Description Default <code>mysql_execution</code> <code>ArkDPADBMysqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n    \"\"\"\n    Exectues mysql command line for mysql via CyberArk's Database Proxy\n\n    Args:\n        mysql_execution (ArkDPADBMysqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"mysql\")\n    connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n    execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n    try:\n        self.__execute(execution_action)\n    finally:\n        os.unlink(temp_cnf_login)\n</code></pre>"},{"location":"reference/services/dpa/db/#ark_sdk_python.services.dpa.db.ArkDPADBService.psql","title":"<code>psql(psql_execution)</code>","text":"<p>Exectues psql command line for postgres via CyberArk's Database Proxy</p> <p>Parameters:</p> Name Type Description Default <code>psql_execution</code> <code>ArkDPADBPsqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n    \"\"\"\n    Exectues psql command line for postgres via CyberArk's Database Proxy\n\n    Args:\n        psql_execution (ArkDPADBPsqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"postgres\")\n    connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n    self.__add_to_pgpass(connection_string, proxy_address, password)\n    try:\n        self.__execute(execution_action)\n    finally:\n        self.__remove_from_pgpass(connection_string, proxy_address, password)\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/","title":"ark_dpa_db_service","text":""},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService","title":"<code>ArkDPADBService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>class ArkDPADBService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__sso_service = ArkDPASSOService(self.__isp_auth)\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __proxy_address(self, db_type: str):\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        return f'{claims[\"subdomain\"]}.{db_type}.{claims[\"platform_domain\"]}'\n\n    def __connection_string(self, target_address: str, target_username: Optional[str] = None) -&gt; None:\n        claims = get_unverified_claims(self.__isp_auth.token.token.get_secret_value())\n        if target_username:\n            # Standing\n            return f'{claims[\"unique_name\"]}@{target_username}@{target_address}'\n        # Dynamic\n        return f'{claims[\"unique_name\"]}@{target_address}'\n\n    def __create_mylogin_cnf(self, username: str, address: str, password: str) -&gt; str:\n        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8')\n        temp_file.write('[client]\\n' f'user = {username}\\n' f'password = {password}\\n' f'host = {address}\\n')\n        temp_file.close()\n        os.chmod(temp_file.name, 0o600)\n        return temp_file.name\n\n    def __add_to_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        flags = 'r+'\n        change_chomd = False\n        path = f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'\n        if not os.path.exists(path):\n            flags = 'w+'\n            change_chomd = True\n        with open(path, flags, encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            for line in lines:\n                if line == pass_format:\n                    return\n            lines.append(pass_format)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(lines)\n        if change_chomd:\n            os.chmod(path, 0o600)\n\n    def __remove_from_pgpass(self, username: str, address: str, password: str) -&gt; None:\n        pass_format = f'{address}:*:*:{username}:{password}'\n        if not os.path.exists(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass'):\n            return\n        with open(f'{os.path.expanduser(\"~\")}{os.path.sep}.pgpass', 'r+', encoding='utf-8') as pg_file_handler:\n            lines = pg_file_handler.readlines()\n            updated_lines = []\n            for line in lines:\n                if line == pass_format:\n                    continue\n                updated_lines.append(line)\n            pg_file_handler.seek(0)\n            pg_file_handler.truncate()\n            pg_file_handler.writelines(updated_lines)\n\n    def __execute(self, command_line: str) -&gt; None:\n        p = subprocess.Popen(command_line, shell=True)\n        p.communicate()\n\n    def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n        \"\"\"\n        Exectues psql command line for postgres via CyberArk's Database Proxy\n\n        Args:\n            psql_execution (ArkDPADBPsqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"postgres\")\n        connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n        self.__add_to_pgpass(connection_string, proxy_address, password)\n        try:\n            self.__execute(execution_action)\n        finally:\n            self.__remove_from_pgpass(connection_string, proxy_address, password)\n\n    def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n        \"\"\"\n        Exectues mysql command line for mysql via CyberArk's Database Proxy\n\n        Args:\n            mysql_execution (ArkDPADBMysqlExecution): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        proxy_address = self.__proxy_address(\"mysql\")\n        connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n        password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n        temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n        execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n        try:\n            self.__execute(execution_action)\n        finally:\n            os.unlink(temp_cnf_login)\n\n    def __generate_assets(\n        self,\n        resource_type: ArkDPADBDatabaseFamilyType,\n        connection_method: ArkConnectionMethod,\n        response_format: ArkDPADBAssetsResponseFormat,\n        include_sso: bool,\n        generation_hints: Dict[str, Any],\n    ) -&gt; ArkDPADBGeneratedAssets:\n        resp: Response = self.__client.post(\n            ASSETS_API,\n            json={\n                'resource_type': resource_type.value,\n                'os_type': running_os().value,\n                'connection_method': connection_method.value,\n                'response_format': response_format.value,\n                'include_sso': include_sso,\n                'generation_hints': generation_hints,\n            },\n        )\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                if response_format == ArkDPADBAssetsResponseFormat.RAW:\n                    return resp.text\n                return ArkDPADBGeneratedAssets.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to generate assets [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to generate assets [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to generate assets [{resp.text}] - [{resp.status_code}]')\n\n    def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n        \"\"\"\n        Generates oracle tns names and optionally oracle wallet if allowed\n\n        Args:\n            generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        self._logger.info('Generating oracle tns names')\n        assets_data = self.__generate_assets(\n            ArkDPADBDatabaseFamilyType.Oracle,\n            generate_oracle_assets.connection_method,\n            generate_oracle_assets.response_format,\n            generate_oracle_assets.include_sso,\n            {'folder': generate_oracle_assets.folder},\n        )\n        if isinstance(assets_data, ArkDPADBGeneratedAssets):\n            assets_data = assets_data.assets['generated_assets']\n        assets_data = base64.b64decode(assets_data)\n        if not os.path.exists(generate_oracle_assets.folder):\n            os.makedirs(generate_oracle_assets.folder)\n        if not generate_oracle_assets.unzip:\n            with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n                file_handle.write(assets_data)\n        else:\n            assets_bytes = BytesIO(assets_data)\n            with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n                zipf.extractall(generate_oracle_assets.folder)\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService.generate_oracle_tnsnames","title":"<code>generate_oracle_tnsnames(generate_oracle_assets)</code>","text":"<p>Generates oracle tns names and optionally oracle wallet if allowed</p> <p>Parameters:</p> Name Type Description Default <code>generate_oracle_assets</code> <code>ArkDPADBOracleGenerateAssets</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def generate_oracle_tnsnames(self, generate_oracle_assets: ArkDPADBOracleGenerateAssets) -&gt; None:\n    \"\"\"\n    Generates oracle tns names and optionally oracle wallet if allowed\n\n    Args:\n        generate_oracle_assets (ArkDPADBOracleGenerateAssets): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    self._logger.info('Generating oracle tns names')\n    assets_data = self.__generate_assets(\n        ArkDPADBDatabaseFamilyType.Oracle,\n        generate_oracle_assets.connection_method,\n        generate_oracle_assets.response_format,\n        generate_oracle_assets.include_sso,\n        {'folder': generate_oracle_assets.folder},\n    )\n    if isinstance(assets_data, ArkDPADBGeneratedAssets):\n        assets_data = assets_data.assets['generated_assets']\n    assets_data = base64.b64decode(assets_data)\n    if not os.path.exists(generate_oracle_assets.folder):\n        os.makedirs(generate_oracle_assets.folder)\n    if not generate_oracle_assets.unzip:\n        with open(f'{generate_oracle_assets.folder}{os.path.sep}oracle_assets.zip', 'wb') as file_handle:\n            file_handle.write(assets_data)\n    else:\n        assets_bytes = BytesIO(assets_data)\n        with zipfile.ZipFile(assets_bytes, 'r') as zipf:\n            zipf.extractall(generate_oracle_assets.folder)\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService.mysql","title":"<code>mysql(mysql_execution)</code>","text":"<p>Exectues mysql command line for mysql via CyberArk's Database Proxy</p> <p>Parameters:</p> Name Type Description Default <code>mysql_execution</code> <code>ArkDPADBMysqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def mysql(self, mysql_execution: ArkDPADBMysqlExecution) -&gt; None:\n    \"\"\"\n    Exectues mysql command line for mysql via CyberArk's Database Proxy\n\n    Args:\n        mysql_execution (ArkDPADBMysqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"mysql\")\n    connection_string = self.__connection_string(mysql_execution.target_address, mysql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    temp_cnf_login = self.__create_mylogin_cnf(connection_string, proxy_address, password)\n    execution_action = f'{mysql_execution.mysql_path} --defaults-file={temp_cnf_login}'\n    try:\n        self.__execute(execution_action)\n    finally:\n        os.unlink(temp_cnf_login)\n</code></pre>"},{"location":"reference/services/dpa/db/ark_dpa_db_service/#ark_sdk_python.services.dpa.db.ark_dpa_db_service.ArkDPADBService.psql","title":"<code>psql(psql_execution)</code>","text":"<p>Exectues psql command line for postgres via CyberArk's Database Proxy</p> <p>Parameters:</p> Name Type Description Default <code>psql_execution</code> <code>ArkDPADBPsqlExecution</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/db/ark_dpa_db_service.py</code> <pre><code>def psql(self, psql_execution: ArkDPADBPsqlExecution) -&gt; None:\n    \"\"\"\n    Exectues psql command line for postgres via CyberArk's Database Proxy\n\n    Args:\n        psql_execution (ArkDPADBPsqlExecution): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    proxy_address = self.__proxy_address(\"postgres\")\n    connection_string = self.__connection_string(psql_execution.target_address, psql_execution.target_username)\n    password = self.__sso_service.short_lived_password(ArkDPASSOGetShortLivedPassword())\n    execution_action = f'{psql_execution.psql_path} \"host={proxy_address} user={connection_string}\"'\n    self.__add_to_pgpass(connection_string, proxy_address, password)\n    try:\n        self.__execute(execution_action)\n    finally:\n        self.__remove_from_pgpass(connection_string, proxy_address, password)\n</code></pre>"},{"location":"reference/services/dpa/k8s/","title":"k8s","text":""},{"location":"reference/services/dpa/k8s/#ark_sdk_python.services.dpa.k8s.ArkDPAK8SService","title":"<code>ArkDPAK8SService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>class ArkDPAK8SService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @staticmethod\n    def _save_kube_config_file(folder: str, result: str) -&gt; None:\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(f'{folder}{os.path.sep}config', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result)\n\n    def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n        \"\"\"\n        Building a kube config file to be used to connect to k8s clusters\n\n        Args:\n            generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Building kube config file')\n        response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n        result = response.text\n        if generate_kubeconfig.folder:\n            ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n            return None\n        return result\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/k8s/#ark_sdk_python.services.dpa.k8s.ArkDPAK8SService.generate_kubeconfig","title":"<code>generate_kubeconfig(generate_kubeconfig)</code>","text":"<p>Building a kube config file to be used to connect to k8s clusters</p> <p>Parameters:</p> Name Type Description Default <code>generate_kubeconfig</code> <code>ArkDPAK8SGenerateKubeConfig</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n    \"\"\"\n    Building a kube config file to be used to connect to k8s clusters\n\n    Args:\n        generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Building kube config file')\n    response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n    result = response.text\n    if generate_kubeconfig.folder:\n        ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n        return None\n    return result\n</code></pre>"},{"location":"reference/services/dpa/k8s/ark_dpa_k8s_service/","title":"ark_dpa_k8s_service","text":""},{"location":"reference/services/dpa/k8s/ark_dpa_k8s_service/#ark_sdk_python.services.dpa.k8s.ark_dpa_k8s_service.ArkDPAK8SService","title":"<code>ArkDPAK8SService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>class ArkDPAK8SService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @staticmethod\n    def _save_kube_config_file(folder: str, result: str) -&gt; None:\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        with open(f'{folder}{os.path.sep}config', 'w', encoding='utf-8') as file_handle:\n            file_handle.write(result)\n\n    def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n        \"\"\"\n        Building a kube config file to be used to connect to k8s clusters\n\n        Args:\n            generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Building kube config file')\n        response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n        if response.status_code != HTTPStatus.OK:\n            raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n        result = response.text\n        if generate_kubeconfig.folder:\n            ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n            return None\n        return result\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/k8s/ark_dpa_k8s_service/#ark_sdk_python.services.dpa.k8s.ark_dpa_k8s_service.ArkDPAK8SService.generate_kubeconfig","title":"<code>generate_kubeconfig(generate_kubeconfig)</code>","text":"<p>Building a kube config file to be used to connect to k8s clusters</p> <p>Parameters:</p> Name Type Description Default <code>generate_kubeconfig</code> <code>ArkDPAK8SGenerateKubeConfig</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/k8s/ark_dpa_k8s_service.py</code> <pre><code>def generate_kubeconfig(self, generate_kubeconfig: ArkDPAK8SGenerateKubeConfig) -&gt; Optional[str]:\n    \"\"\"\n    Building a kube config file to be used to connect to k8s clusters\n\n    Args:\n        generate_kubeconfig (ArkDPAK8SGenerateKubeConfig): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Building kube config file')\n    response: Response = self.__client.get(BUILD_KUBE_CONFIG_PATH)\n    if response.status_code != HTTPStatus.OK:\n        raise ArkServiceException(f'Failed to build kube config file - [{response.status_code}] - [{response.text}]')\n    result = response.text\n    if generate_kubeconfig.folder:\n        ArkDPAK8SService._save_kube_config_file(generate_kubeconfig.folder, result)\n        return None\n    return result\n</code></pre>"},{"location":"reference/services/dpa/policies/","title":"policies","text":""},{"location":"reference/services/dpa/policies/db/","title":"db","text":""},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService","title":"<code>ArkDPADBPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>class ArkDPADBPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPADBPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find db policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Adds a new db policy with the given information\n\n        Args:\n            add_policy (ArkDPADBAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n        resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes a db policy by id or name\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates a db policy with new information\n\n        Args:\n            update_policy (ArkDPADBUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates the status of the db policy by id\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists all the db policies of the tenant\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all db policies')\n        resp: Response = self.__client.get(DB_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists db policies by given filters\n\n        Args:\n            policies_filter (ArkDPADBPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Retrieves a db policy by its id\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n        \"\"\"\n        Calculates policies statistics\n\n        Returns:\n            ArkDPADBPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating db policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPADBPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.providers:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new db policy with the given information</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPADBAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Adds a new db policy with the given information\n\n    Args:\n        add_policy (ArkDPADBAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n    resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes a db policy by id or name</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes a db policy by id or name\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all the db policies of the tenant</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists all the db policies of the tenant\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all db policies')\n    resp: Response = self.__client.get(DB_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists db policies by given filters</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPADBPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists db policies by given filters\n\n    Args:\n        policies_filter (ArkDPADBPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates policies statistics</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesStats</code> <code>ArkDPADBPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n    \"\"\"\n    Calculates policies statistics\n\n    Returns:\n        ArkDPADBPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating db policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPADBPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.providers:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a db policy by its id</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Retrieves a db policy by its id\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a db policy with new information</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPADBUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates a db policy with new information\n\n    Args:\n        update_policy (ArkDPADBUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/#ark_sdk_python.services.dpa.policies.db.ArkDPADBPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the db policy by id</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates the status of the db policy by id\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/","title":"ark_dpa_db_policies_service","text":""},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService","title":"<code>ArkDPADBPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>class ArkDPADBPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPADBPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find db policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Adds a new db policy with the given information\n\n        Args:\n            add_policy (ArkDPADBAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n        resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes a db policy by id or name\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates a db policy with new information\n\n        Args:\n            update_policy (ArkDPADBUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Updates the status of the db policy by id\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists all the db policies of the tenant\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all db policies')\n        resp: Response = self.__client.get(DB_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n        \"\"\"\n        Lists db policies by given filters\n\n        Args:\n            policies_filter (ArkDPADBPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPADBPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n        \"\"\"\n        Retrieves a db policy by its id\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n        \"\"\"\n        Calculates policies statistics\n\n        Returns:\n            ArkDPADBPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating db policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPADBPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.providers:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new db policy with the given information</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPADBAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPADBAddPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Adds a new db policy with the given information\n\n    Args:\n        add_policy (ArkDPADBAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new db policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True, exclude_none=True)\n    resp: Response = self.__client.post(DB_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add sb policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes a db policy by id or name</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes a db policy by id or name\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting db policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(DB_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all the db policies of the tenant</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists all the db policies of the tenant\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all db policies')\n    resp: Response = self.__client.get(DB_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPADBPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list db policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list db policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list db policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists db policies by given filters</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPADBPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPADBPolicyListItem]</code> <p>List[ArkDPADBPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPADBPoliciesFilter) -&gt; List[ArkDPADBPolicyListItem]:\n    \"\"\"\n    Lists db policies by given filters\n\n    Args:\n        policies_filter (ArkDPADBPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPADBPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving db policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.providers for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates policies statistics</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPoliciesStats</code> <code>ArkDPADBPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPADBPoliciesStats:\n    \"\"\"\n    Calculates policies statistics\n\n    Returns:\n        ArkDPADBPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating db policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPADBPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.providers:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a db policy by its id</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Retrieves a db policy by its id\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving db policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(DB_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a db policy with new information</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPADBUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPADBUpdatePolicy) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates a db policy with new information\n\n    Args:\n        update_policy (ArkDPADBUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating db policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    resp: Response = self.__client.put(DB_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update db policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update db policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update db policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/db/ark_dpa_db_policies_service/#ark_sdk_python.services.dpa.policies.db.ark_dpa_db_policies_service.ArkDPADBPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the db policy by id</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBPolicy</code> <code>ArkDPADBPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/db/ark_dpa_db_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPADBPolicy:\n    \"\"\"\n    Updates the status of the db policy by id\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating db policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        DB_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update db policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/","title":"vm","text":""},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService","title":"<code>ArkDPAVMPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>class ArkDPAVMPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPAVMPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find vm policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    @staticmethod\n    def __serialize_providers_dict(providers_data: ArkDPAVMProvidersDict) -&gt; Dict:\n        serialized_providers_data = {}\n        for k in list(providers_data.keys()):\n            serialized_providers_data[serialize_dpa_vm_policies_workspace_type(k)] = providers_data[k].dict(by_alias=True)\n        return serialized_providers_data\n\n    @staticmethod\n    def __serialize_authorization_rules_dict(authorization_rules: List[Dict]) -&gt; None:\n        for rule in authorization_rules:\n            for k in list(rule['connectionInformation']['connectAs'].keys()):\n                for pk in list(rule['connectionInformation']['connectAs'][k].keys()):\n                    item = rule['connectionInformation']['connectAs'][k][pk]\n                    del rule['connectionInformation']['connectAs'][k][pk]\n                    rule['connectionInformation']['connectAs'][k][serialize_dpa_vm_policies_protocol_type(pk)] = item\n                item = rule['connectionInformation']['connectAs'][k]\n                del rule['connectionInformation']['connectAs'][k]\n                rule['connectionInformation']['connectAs'][serialize_dpa_vm_policies_workspace_type(k)] = item\n\n    def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Adds a new vm policy with the given information\n\n        Args:\n            add_policy (ArkDPVMAAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True)\n        add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n        self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n        resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes a vm policy by id or name\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates a vm policy with new information\n\n        Args:\n            update_policy (ArkDPAVMUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        if update_policy.providers_data:\n            update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n        if 'userAccessRules' in update_dict:\n            self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n        resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates the status of the vm policy by id\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists all the vm policies of the tenant\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all vm policies')\n        resp: Response = self.__client.get(VM_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists vm policies by given filters\n\n        Args:\n            policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Retrieves a vm policy by its id\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n        \"\"\"\n        Calculates vm policies statistics\n\n        Returns:\n            ArkDPAVMPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPAVMPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.platforms:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new vm policy with the given information</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPVMAAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Adds a new vm policy with the given information\n\n    Args:\n        add_policy (ArkDPVMAAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True)\n    add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n    self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n    resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes a vm policy by id or name</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes a vm policy by id or name\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all the vm policies of the tenant</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists all the vm policies of the tenant\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all vm policies')\n    resp: Response = self.__client.get(VM_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists vm policies by given filters</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPAVMPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists vm policies by given filters\n\n    Args:\n        policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates vm policies statistics</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesStats</code> <code>ArkDPAVMPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n    \"\"\"\n    Calculates vm policies statistics\n\n    Returns:\n        ArkDPAVMPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPAVMPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.platforms:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a vm policy by its id</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Retrieves a vm policy by its id\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a vm policy with new information</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPAVMUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates a vm policy with new information\n\n    Args:\n        update_policy (ArkDPAVMUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    if update_policy.providers_data:\n        update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n    if 'userAccessRules' in update_dict:\n        self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n    resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/#ark_sdk_python.services.dpa.policies.vm.ArkDPAVMPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the vm policy by id</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates the status of the vm policy by id\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/","title":"ark_dpa_vm_policies_service","text":""},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService","title":"<code>ArkDPAVMPoliciesService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>class ArkDPAVMPoliciesService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    @property\n    def isp_client(self) -&gt; ArkISPServiceClient:\n        return self.__client\n\n    def __policy_id_by_name(self, policy_name: str) -&gt; str:\n        policies = self.list_policies_by(ArkDPAVMPoliciesFilter(name=policy_name))\n        if not policies:\n            raise ArkServiceException(f'Failed to find vm policy id by name [{policy_name}]')\n        return policies[0].policy_id\n\n    @staticmethod\n    def __serialize_providers_dict(providers_data: ArkDPAVMProvidersDict) -&gt; Dict:\n        serialized_providers_data = {}\n        for k in list(providers_data.keys()):\n            serialized_providers_data[serialize_dpa_vm_policies_workspace_type(k)] = providers_data[k].dict(by_alias=True)\n        return serialized_providers_data\n\n    @staticmethod\n    def __serialize_authorization_rules_dict(authorization_rules: List[Dict]) -&gt; None:\n        for rule in authorization_rules:\n            for k in list(rule['connectionInformation']['connectAs'].keys()):\n                for pk in list(rule['connectionInformation']['connectAs'][k].keys()):\n                    item = rule['connectionInformation']['connectAs'][k][pk]\n                    del rule['connectionInformation']['connectAs'][k][pk]\n                    rule['connectionInformation']['connectAs'][k][serialize_dpa_vm_policies_protocol_type(pk)] = item\n                item = rule['connectionInformation']['connectAs'][k]\n                del rule['connectionInformation']['connectAs'][k]\n                rule['connectionInformation']['connectAs'][serialize_dpa_vm_policies_workspace_type(k)] = item\n\n    def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Adds a new vm policy with the given information\n\n        Args:\n            add_policy (ArkDPVMAAddPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n        add_policy_dict = add_policy.dict(by_alias=True)\n        add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n        self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n        resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                policy_id = resp.json()['policyId']\n                return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n        \"\"\"\n        Deletes a vm policy by id or name\n\n        Args:\n            delete_policy (ArkDPADeletePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_policy.policy_name and not delete_policy.policy_id:\n            delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n        self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n        resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates a vm policy with new information\n\n        Args:\n            update_policy (ArkDPAVMUpdatePolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy.policy_name and not update_policy.policy_id:\n            update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n        self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n        update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n        if update_policy.new_policy_name:\n            update_dict['policyName'] = update_policy.new_policy_name\n        else:\n            update_dict['policyName'] = update_policy.policy_name\n        if update_policy.providers_data:\n            update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n        if 'userAccessRules' in update_dict:\n            self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n        resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n\n    def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Updates the status of the vm policy by id\n\n        Args:\n            update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if update_policy_status.policy_name and not update_policy_status.policy_id:\n            update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n        self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n        resp: Response = self.__client.put(\n            VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n            json=update_policy_status.dict(exclude={'policy_id'}),\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n        raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists all the vm policies of the tenant\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info('Retrieving all vm policies')\n        resp: Response = self.__client.get(VM_POLICIES_API)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n\n    def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n        \"\"\"\n        Lists vm policies by given filters\n\n        Args:\n            policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n        Returns:\n            List[ArkDPAVMPolicyListItem]: _description_\n        \"\"\"\n        self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n        policies = self.list_policies()\n\n        # Filter by statuses\n        if policies_filter.statuses:\n            policies = [p for p in policies if p.status in policies_filter.statuses]\n\n        # Filter by name wildcard\n        if policies_filter.name:\n            policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n        # Filter by cloud providers\n        if policies_filter.providers:\n            policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n        return policies\n\n    def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n        \"\"\"\n        Retrieves a vm policy by its id\n\n        Args:\n            get_policy (ArkDPAGetPolicy): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPAVMPolicy: _description_\n        \"\"\"\n        if get_policy.policy_name and not get_policy.policy_id:\n            get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n        self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n        resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPAVMPolicy.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n\n    def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n        \"\"\"\n        Calculates vm policies statistics\n\n        Returns:\n            ArkDPAVMPoliciesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating vm policies stats')\n        policies = self.list_policies()\n        policies_stats = ArkDPAVMPoliciesStats.construct()\n        policies_stats.policies_count = len(policies)\n\n        # Count policies per status\n        status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n        policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n        # Count policies per platforms\n        policies_stats.policies_count_per_provider = {}\n        for policy in policies:\n            for platform in policy.platforms:\n                if platform not in policies_stats.policies_count_per_provider:\n                    policies_stats.policies_count_per_provider[platform] = 0\n                policies_stats.policies_count_per_provider[platform] += 1\n\n        return policies_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.add_policy","title":"<code>add_policy(add_policy)</code>","text":"<p>Adds a new vm policy with the given information</p> <p>Parameters:</p> Name Type Description Default <code>add_policy</code> <code>ArkDPVMAAddPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def add_policy(self, add_policy: ArkDPAVMAddPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Adds a new vm policy with the given information\n\n    Args:\n        add_policy (ArkDPVMAAddPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    self._logger.info(f'Adding new vm policy [{add_policy.policy_name}]')\n    add_policy_dict = add_policy.dict(by_alias=True)\n    add_policy_dict['providersData'] = self.__serialize_providers_dict(add_policy.providers_data)\n    self.__serialize_authorization_rules_dict(add_policy_dict['userAccessRules'])\n    resp: Response = self.__client.post(VM_POLICIES_API, json=add_policy_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            policy_id = resp.json()['policyId']\n            return self.policy(ArkDPAGetPolicy(policy_id=policy_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.delete_policy","title":"<code>delete_policy(delete_policy)</code>","text":"<p>Deletes a vm policy by id or name</p> <p>Parameters:</p> Name Type Description Default <code>delete_policy</code> <code>ArkDPADeletePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def delete_policy(self, delete_policy: ArkDPADeletePolicy) -&gt; None:\n    \"\"\"\n    Deletes a vm policy by id or name\n\n    Args:\n        delete_policy (ArkDPADeletePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_policy.policy_name and not delete_policy.policy_id:\n        delete_policy.policy_id = self.__policy_id_by_name(delete_policy.policy_name)\n    self._logger.info(f'Deleting vm policy [{delete_policy.policy_id}]')\n    resp: Response = self.__client.delete(VM_POLICY_API.format(policy_id=delete_policy.policy_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.list_policies","title":"<code>list_policies()</code>","text":"<p>Lists all the vm policies of the tenant</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies(self) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists all the vm policies of the tenant\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info('Retrieving all vm policies')\n    resp: Response = self.__client.get(VM_POLICIES_API)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return parse_obj_as(List[ArkDPAVMPolicyListItem], resp.json()['items'])\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse list vm policies response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse list vm policies response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to list vm policies [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.list_policies_by","title":"<code>list_policies_by(policies_filter)</code>","text":"<p>Lists vm policies by given filters</p> <p>Parameters:</p> Name Type Description Default <code>policies_filter</code> <code>ArkDPAVMPoliciesFilter</code> <p>description</p> required <p>Returns:</p> Type Description <code>List[ArkDPAVMPolicyListItem]</code> <p>List[ArkDPAVMPolicyListItem]: description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def list_policies_by(self, policies_filter: ArkDPAVMPoliciesFilter) -&gt; List[ArkDPAVMPolicyListItem]:\n    \"\"\"\n    Lists vm policies by given filters\n\n    Args:\n        policies_filter (ArkDPAVMPoliciesFilter): _description_\n\n    Returns:\n        List[ArkDPAVMPolicyListItem]: _description_\n    \"\"\"\n    self._logger.info(f'Retrieving vm policies by filter [{policies_filter}]')\n    policies = self.list_policies()\n\n    # Filter by statuses\n    if policies_filter.statuses:\n        policies = [p for p in policies if p.status in policies_filter.statuses]\n\n    # Filter by name wildcard\n    if policies_filter.name:\n        policies = [p for p in policies if fnmatch(p.policy_name, policies_filter.name)]\n\n    # Filter by cloud providers\n    if policies_filter.providers:\n        policies = [p for p in policies if all(cp.value in p.platforms for cp in policies_filter.providers)]\n\n    return policies\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.policies_stats","title":"<code>policies_stats()</code>","text":"<p>Calculates vm policies statistics</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPoliciesStats</code> <code>ArkDPAVMPoliciesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policies_stats(self) -&gt; ArkDPAVMPoliciesStats:\n    \"\"\"\n    Calculates vm policies statistics\n\n    Returns:\n        ArkDPAVMPoliciesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating vm policies stats')\n    policies = self.list_policies()\n    policies_stats = ArkDPAVMPoliciesStats.construct()\n    policies_stats.policies_count = len(policies)\n\n    # Count policies per status\n    status_types: Set[ArkDPARuleStatus] = {p.status for p in policies if p.status}\n    policies_stats.policies_count_per_status = {st: len([p for p in policies if p.status and p.status == st]) for st in status_types}\n\n    # Count policies per platforms\n    policies_stats.policies_count_per_provider = {}\n    for policy in policies:\n        for platform in policy.platforms:\n            if platform not in policies_stats.policies_count_per_provider:\n                policies_stats.policies_count_per_provider[platform] = 0\n            policies_stats.policies_count_per_provider[platform] += 1\n\n    return policies_stats\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.policy","title":"<code>policy(get_policy)</code>","text":"<p>Retrieves a vm policy by its id</p> <p>Parameters:</p> Name Type Description Default <code>get_policy</code> <code>ArkDPAGetPolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def policy(self, get_policy: ArkDPAGetPolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Retrieves a vm policy by its id\n\n    Args:\n        get_policy (ArkDPAGetPolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if get_policy.policy_name and not get_policy.policy_id:\n        get_policy.policy_id = self.__policy_id_by_name(get_policy.policy_name)\n    self._logger.info(f'Retrieving vm policy [{get_policy.policy_id}]')\n    resp: Response = self.__client.get(VM_POLICY_API.format(policy_id=get_policy.policy_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve vm policy [{get_policy.policy_id}] [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.update_policy","title":"<code>update_policy(update_policy)</code>","text":"<p>Updates a vm policy with new information</p> <p>Parameters:</p> Name Type Description Default <code>update_policy</code> <code>ArkDPAVMUpdatePolicy</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy(self, update_policy: ArkDPAVMUpdatePolicy) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates a vm policy with new information\n\n    Args:\n        update_policy (ArkDPAVMUpdatePolicy): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy.policy_name and not update_policy.policy_id:\n        update_policy.policy_id = self.__policy_id_by_name(update_policy.policy_name)\n    self._logger.info(f'Updating vm policy [{update_policy.policy_id}]')\n    update_dict = json.loads(update_policy.json(by_alias=True, exclude_none=True, exclude={'new_policy_name', 'policy_name'}))\n    if update_policy.new_policy_name:\n        update_dict['policyName'] = update_policy.new_policy_name\n    else:\n        update_dict['policyName'] = update_policy.policy_name\n    if update_policy.providers_data:\n        update_dict['providersData'] = self.__serialize_providers_dict(update_policy.providers_data)\n    if 'userAccessRules' in update_dict:\n        self.__serialize_authorization_rules_dict(update_dict['userAccessRules'])\n    resp: Response = self.__client.put(VM_POLICY_API.format(policy_id=update_policy.policy_id), json=update_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPAVMPolicy.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse update vm policy response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update vm policy response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update vm policy [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/policies/vm/ark_dpa_vm_policies_service/#ark_sdk_python.services.dpa.policies.vm.ark_dpa_vm_policies_service.ArkDPAVMPoliciesService.update_policy_status","title":"<code>update_policy_status(update_policy_status)</code>","text":"<p>Updates the status of the vm policy by id</p> <p>Parameters:</p> Name Type Description Default <code>update_policy_status</code> <code>ArkDPAUpdatePolicyStatus</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPAVMPolicy</code> <code>ArkDPAVMPolicy</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/policies/vm/ark_dpa_vm_policies_service.py</code> <pre><code>def update_policy_status(self, update_policy_status: ArkDPAUpdatePolicyStatus) -&gt; ArkDPAVMPolicy:\n    \"\"\"\n    Updates the status of the vm policy by id\n\n    Args:\n        update_policy_status (ArkDPAUpdatePolicyStatus): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPAVMPolicy: _description_\n    \"\"\"\n    if update_policy_status.policy_name and not update_policy_status.policy_id:\n        update_policy_status.policy_id = self.__policy_id_by_name(update_policy_status.policy_name)\n    self._logger.info(f'Updating vm policy status [{update_policy_status.policy_id}]')\n    resp: Response = self.__client.put(\n        VM_UPDATE_POLICY_STATUS_API.format(policy_id=update_policy_status.policy_id),\n        json=update_policy_status.dict(exclude={'policy_id'}),\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.policy(ArkDPAGetPolicy(policy_id=update_policy_status.policy_id))\n    raise ArkServiceException(f'Failed to update vm policy status [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/","title":"secrets","text":""},{"location":"reference/services/dpa/secrets/db/","title":"db","text":""},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService","title":"<code>ArkDPADBSecretsService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>class ArkDPADBSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkDPADBSecretType] = None,\n        tags: Optional[List[ArkDPADBTag]] = None,\n    ) -&gt; ArkDPADBSecretMetadataList:\n        params = {}\n        if secret_type:\n            params['secret_type'] = secret_type.value\n        if tags:\n            params.update({t.key: t.value for t in tags})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadataList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Adds a new db secret to the secret store\n\n        Args:\n            add_secret (ArkDPADBAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        self._logger.info('Adding new db secret')\n        add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n        if not add_secret.store_type:\n            add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n        add_secret_dict['secret_store'] = {\n            'store_type': add_secret.store_type.value,\n        }\n        if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n            if not add_secret.username or not add_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password type, both username and password parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'username': add_secret.username,\n                'password': add_secret.password.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n            if not add_secret.pam_account_name or not add_secret.pam_safe:\n                raise ArkServiceException(\n                    'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n                )\n            add_secret_dict['secret_link'] = {\n                'safe': add_secret.pam_safe,\n                'account_name': add_secret.pam_account_name,\n            }\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json=add_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n\n    def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Updates an existing db secret\n\n        Args:\n            update_secret (ArkDPADBUpdateSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if update_secret.secret_name and not update_secret.secret_id:\n            update_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n        update_secret_dict = update_secret.dict(\n            exclude_none=True,\n            exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n        )\n        if update_secret.new_secret_name:\n            update_secret_dict['secret_name'] = update_secret.new_secret_name\n        if update_secret.pam_account_name or update_secret.pam_safe:\n            if not update_secret.pam_account_name or not update_secret.pam_safe:\n                raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n            update_secret_dict['secret_link'] = {\n                'safe': update_secret.pam_safe,\n                'account_name': update_secret.pam_account_name,\n            }\n        if update_secret.username or update_secret.password:\n            if not update_secret.username or not update_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password secret, both username and password name parameters must be supplied'\n                )\n            update_secret_dict['secret_data'] = {\n                'username': update_secret.username,\n                'password': update_secret.password.get_secret_value(),\n            }\n        resp: Response = self.__client.post(\n            SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n            json=update_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n        raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a db secret if exists\n\n        Args:\n            delete_secret (ArkDPADBDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_secret.secret_name and not delete_secret.secret_id:\n            delete_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists all tenant db secrets\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info('Listing all db secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists db secrets by given filters\n\n        Args:\n            secrets_filter (ArkDPADBSecretsFilter): _description_\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n        secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n        # Filter by secret types\n        if secrets_filter.store_type:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n        # Filter by name\n        if secrets_filter.secret_name:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n        secrets.total_count = len(secrets.secrets)\n\n        return secrets\n\n    def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Enables a db secret\n\n        Args:\n            enable_secret (ArkDPADBEnableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if enable_secret.secret_name and not enable_secret.secret_id:\n            enable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n        resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Disables a db secret\n\n        Args:\n            disable_secret (ArkDPADBDisableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if disable_secret.secret_name and not disable_secret.secret_id:\n            disable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n        resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Retrieves a db secret\n\n        Args:\n            get_secret (ArkDPADBGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if get_secret.secret_name and not get_secret.secret_id:\n            get_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n        \"\"\"\n        Calculates db secrets statistics\n\n        Returns:\n            ArkDPADBSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkDPADBSecretsStats.construct()\n        secrets_stats.secrets_count = len(secrets.secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n        # Count secrets per secret type\n        secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n        secrets_stats.secrets_count_by_secret_type = {\n            st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        # Count secrets per store type\n        store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n        secrets_stats.secrets_count_by_store_type = {\n            st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new db secret to the secret store</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkDPADBAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Adds a new db secret to the secret store\n\n    Args:\n        add_secret (ArkDPADBAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    self._logger.info('Adding new db secret')\n    add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n    if not add_secret.store_type:\n        add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n    add_secret_dict['secret_store'] = {\n        'store_type': add_secret.store_type.value,\n    }\n    if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n        if not add_secret.username or not add_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password type, both username and password parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'username': add_secret.username,\n            'password': add_secret.password.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n        if not add_secret.pam_account_name or not add_secret.pam_safe:\n            raise ArkServiceException(\n                'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n            )\n        add_secret_dict['secret_link'] = {\n            'safe': add_secret.pam_safe,\n            'account_name': add_secret.pam_account_name,\n        }\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json=add_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a db secret if exists</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkDPADBDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a db secret if exists\n\n    Args:\n        delete_secret (ArkDPADBDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_secret.secret_name and not delete_secret.secret_id:\n        delete_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.disable_secret","title":"<code>disable_secret(disable_secret)</code>","text":"<p>Disables a db secret</p> <p>Parameters:</p> Name Type Description Default <code>disable_secret</code> <code>ArkDPADBDisableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Disables a db secret\n\n    Args:\n        disable_secret (ArkDPADBDisableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if disable_secret.secret_name and not disable_secret.secret_id:\n        disable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n    resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.enable_secret","title":"<code>enable_secret(enable_secret)</code>","text":"<p>Enables a db secret</p> <p>Parameters:</p> Name Type Description Default <code>enable_secret</code> <code>ArkDPADBEnableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Enables a db secret\n\n    Args:\n        enable_secret (ArkDPADBEnableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if enable_secret.secret_name and not enable_secret.secret_id:\n        enable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n    resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant db secrets</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists all tenant db secrets\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info('Listing all db secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists db secrets by given filters</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkDPADBSecretsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists db secrets by given filters\n\n    Args:\n        secrets_filter (ArkDPADBSecretsFilter): _description_\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n    secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n    # Filter by secret types\n    if secrets_filter.store_type:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n    # Filter by name\n    if secrets_filter.secret_name:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n    secrets.total_count = len(secrets.secrets)\n\n    return secrets\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a db secret</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkDPADBGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Retrieves a db secret\n\n    Args:\n        get_secret (ArkDPADBGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if get_secret.secret_name and not get_secret.secret_id:\n        get_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates db secrets statistics</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsStats</code> <code>ArkDPADBSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n    \"\"\"\n    Calculates db secrets statistics\n\n    Returns:\n        ArkDPADBSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkDPADBSecretsStats.construct()\n    secrets_stats.secrets_count = len(secrets.secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n    # Count secrets per secret type\n    secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n    secrets_stats.secrets_count_by_secret_type = {\n        st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    # Count secrets per store type\n    store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n    secrets_stats.secrets_count_by_store_type = {\n        st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/#ark_sdk_python.services.dpa.secrets.db.ArkDPADBSecretsService.update_secret","title":"<code>update_secret(update_secret)</code>","text":"<p>Updates an existing db secret</p> <p>Parameters:</p> Name Type Description Default <code>update_secret</code> <code>ArkDPADBUpdateSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Updates an existing db secret\n\n    Args:\n        update_secret (ArkDPADBUpdateSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if update_secret.secret_name and not update_secret.secret_id:\n        update_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n    update_secret_dict = update_secret.dict(\n        exclude_none=True,\n        exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n    )\n    if update_secret.new_secret_name:\n        update_secret_dict['secret_name'] = update_secret.new_secret_name\n    if update_secret.pam_account_name or update_secret.pam_safe:\n        if not update_secret.pam_account_name or not update_secret.pam_safe:\n            raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n        update_secret_dict['secret_link'] = {\n            'safe': update_secret.pam_safe,\n            'account_name': update_secret.pam_account_name,\n        }\n    if update_secret.username or update_secret.password:\n        if not update_secret.username or not update_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password secret, both username and password name parameters must be supplied'\n            )\n        update_secret_dict['secret_data'] = {\n            'username': update_secret.username,\n            'password': update_secret.password.get_secret_value(),\n        }\n    resp: Response = self.__client.post(\n        SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n        json=update_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n    raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/","title":"ark_dpa_db_secrets_service","text":""},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService","title":"<code>ArkDPADBSecretsService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>class ArkDPADBSecretsService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_secrets_with_filters(\n        self,\n        secret_type: Optional[ArkDPADBSecretType] = None,\n        tags: Optional[List[ArkDPADBTag]] = None,\n    ) -&gt; ArkDPADBSecretMetadataList:\n        params = {}\n        if secret_type:\n            params['secret_type'] = secret_type.value\n        if tags:\n            params.update({t.key: t.value for t in tags})\n        resp: Response = self.__client.get(SECRETS_ROUTE, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadataList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse list secrets response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list secrets response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list secrets [{resp.text}] - [{resp.status_code}]')\n\n    def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Adds a new db secret to the secret store\n\n        Args:\n            add_secret (ArkDPADBAddSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        self._logger.info('Adding new db secret')\n        add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n        if not add_secret.store_type:\n            add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n        add_secret_dict['secret_store'] = {\n            'store_type': add_secret.store_type.value,\n        }\n        if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n            if not add_secret.username or not add_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password type, both username and password parameters must be supplied'\n                )\n            add_secret_dict['secret_data'] = {\n                'username': add_secret.username,\n                'password': add_secret.password.get_secret_value(),\n            }\n        elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n            if not add_secret.pam_account_name or not add_secret.pam_safe:\n                raise ArkServiceException(\n                    'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n                )\n            add_secret_dict['secret_link'] = {\n                'safe': add_secret.pam_safe,\n                'account_name': add_secret.pam_account_name,\n            }\n        resp: Response = self.__client.post(\n            SECRETS_ROUTE,\n            json=add_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n\n    def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Updates an existing db secret\n\n        Args:\n            update_secret (ArkDPADBUpdateSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if update_secret.secret_name and not update_secret.secret_id:\n            update_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n        update_secret_dict = update_secret.dict(\n            exclude_none=True,\n            exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n        )\n        if update_secret.new_secret_name:\n            update_secret_dict['secret_name'] = update_secret.new_secret_name\n        if update_secret.pam_account_name or update_secret.pam_safe:\n            if not update_secret.pam_account_name or not update_secret.pam_safe:\n                raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n            update_secret_dict['secret_link'] = {\n                'safe': update_secret.pam_safe,\n                'account_name': update_secret.pam_account_name,\n            }\n        if update_secret.username or update_secret.password:\n            if not update_secret.username or not update_secret.password:\n                raise ArkServiceException(\n                    'When specifying a username password secret, both username and password name parameters must be supplied'\n                )\n            update_secret_dict['secret_data'] = {\n                'username': update_secret.username,\n                'password': update_secret.password.get_secret_value(),\n            }\n        resp: Response = self.__client.post(\n            SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n            json=update_secret_dict,\n        )\n        if resp.status_code == HTTPStatus.OK:\n            return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n        raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n\n    def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n        \"\"\"\n        Deletes a db secret if exists\n\n        Args:\n            delete_secret (ArkDPADBDeleteSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_secret.secret_name and not delete_secret.secret_id:\n            delete_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n        resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n\n    def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists all tenant db secrets\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info('Listing all db secrets')\n        return self.__list_secrets_with_filters()\n\n    def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n        \"\"\"\n        Lists db secrets by given filters\n\n        Args:\n            secrets_filter (ArkDPADBSecretsFilter): _description_\n\n        Returns:\n            ArkDPADBSecretMetadataList: _description_\n        \"\"\"\n        self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n        secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n        # Filter by secret types\n        if secrets_filter.store_type:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n        # Filter by name\n        if secrets_filter.secret_name:\n            secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n        # Filter by is active\n        if secrets_filter.is_active is not None:\n            secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n        secrets.total_count = len(secrets.secrets)\n\n        return secrets\n\n    def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Enables a db secret\n\n        Args:\n            enable_secret (ArkDPADBEnableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if enable_secret.secret_name and not enable_secret.secret_id:\n            enable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n        resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Disables a db secret\n\n        Args:\n            disable_secret (ArkDPADBDisableSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if disable_secret.secret_name and not disable_secret.secret_id:\n            disable_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n        resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n        \"\"\"\n        Retrieves a db secret\n\n        Args:\n            get_secret (ArkDPADBGetSecret): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBSecretMetadata: _description_\n        \"\"\"\n        if get_secret.secret_name and not get_secret.secret_id:\n            get_secret.secret_id = (\n                self.list_secrets_by(\n                    secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n                )\n                .secrets[0]\n                .secret_id\n            )\n        self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n        resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBSecretMetadata.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError) as ex:\n                self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n\n    def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n        \"\"\"\n        Calculates db secrets statistics\n\n        Returns:\n            ArkDPADBSecretsStats: _description_\n        \"\"\"\n        self._logger.info('Calculating secrets statistics')\n        secrets = self.list_secrets()\n        secrets_stats = ArkDPADBSecretsStats.construct()\n        secrets_stats.secrets_count = len(secrets.secrets)\n        secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n        secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n        # Count secrets per secret type\n        secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n        secrets_stats.secrets_count_by_secret_type = {\n            st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n        }\n\n        # Count secrets per store type\n        store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n        secrets_stats.secrets_count_by_store_type = {\n            st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n        }\n\n        return secrets_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.add_secret","title":"<code>add_secret(add_secret)</code>","text":"<p>Adds a new db secret to the secret store</p> <p>Parameters:</p> Name Type Description Default <code>add_secret</code> <code>ArkDPADBAddSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def add_secret(self, add_secret: ArkDPADBAddSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Adds a new db secret to the secret store\n\n    Args:\n        add_secret (ArkDPADBAddSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    self._logger.info('Adding new db secret')\n    add_secret_dict = add_secret.dict(exclude_none=True, exclude={'store_type', 'username', 'password', 'pam_safe', 'pam_account_name'})\n    if not add_secret.store_type:\n        add_secret.store_type = SECRET_TYPE_TO_STORE_DICT[add_secret.secret_type]\n    add_secret_dict['secret_store'] = {\n        'store_type': add_secret.store_type.value,\n    }\n    if add_secret.secret_type == ArkDPADBSecretType.UsernamePassword:\n        if not add_secret.username or not add_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password type, both username and password parameters must be supplied'\n            )\n        add_secret_dict['secret_data'] = {\n            'username': add_secret.username,\n            'password': add_secret.password.get_secret_value(),\n        }\n    elif add_secret.secret_type == ArkDPADBSecretType.CyberArkPAM:\n        if not add_secret.pam_account_name or not add_secret.pam_safe:\n            raise ArkServiceException(\n                'When specifying a pam secret type, both pam safe and pam account name parameters must be supplied'\n            )\n        add_secret_dict['secret_link'] = {\n            'safe': add_secret.pam_safe,\n            'account_name': add_secret.pam_account_name,\n        }\n    resp: Response = self.__client.post(\n        SECRETS_ROUTE,\n        json=add_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse add db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.delete_secret","title":"<code>delete_secret(delete_secret)</code>","text":"<p>Deletes a db secret if exists</p> <p>Parameters:</p> Name Type Description Default <code>delete_secret</code> <code>ArkDPADBDeleteSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def delete_secret(self, delete_secret: ArkDPADBDeleteSecret) -&gt; None:\n    \"\"\"\n    Deletes a db secret if exists\n\n    Args:\n        delete_secret (ArkDPADBDeleteSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_secret.secret_name and not delete_secret.secret_id:\n        delete_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=delete_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Deleting db secret by id [{delete_secret.secret_id}]')\n    resp: Response = self.__client.delete(SECRET_ROUTE.format(secret_id=delete_secret.secret_id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.disable_secret","title":"<code>disable_secret(disable_secret)</code>","text":"<p>Disables a db secret</p> <p>Parameters:</p> Name Type Description Default <code>disable_secret</code> <code>ArkDPADBDisableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def disable_secret(self, disable_secret: ArkDPADBDisableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Disables a db secret\n\n    Args:\n        disable_secret (ArkDPADBDisableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if disable_secret.secret_name and not disable_secret.secret_id:\n        disable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=disable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Disabling db secret by id [{disable_secret.secret_id}]')\n    resp: Response = self.__client.post(DISABLE_SECRET_ROUTE.format(secret_id=disable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse disable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse disable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve disable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.enable_secret","title":"<code>enable_secret(enable_secret)</code>","text":"<p>Enables a db secret</p> <p>Parameters:</p> Name Type Description Default <code>enable_secret</code> <code>ArkDPADBEnableSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def enable_secret(self, enable_secret: ArkDPADBEnableSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Enables a db secret\n\n    Args:\n        enable_secret (ArkDPADBEnableSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if enable_secret.secret_name and not enable_secret.secret_id:\n        enable_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=enable_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Enabling db secret by id [{enable_secret.secret_id}]')\n    resp: Response = self.__client.post(ENABLE_SECRET_ROUTE.format(secret_id=enable_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse enable db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse enable db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve enable db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.list_secrets","title":"<code>list_secrets()</code>","text":"<p>Lists all tenant db secrets</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets(self) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists all tenant db secrets\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info('Listing all db secrets')\n    return self.__list_secrets_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.list_secrets_by","title":"<code>list_secrets_by(secrets_filter)</code>","text":"<p>Lists db secrets by given filters</p> <p>Parameters:</p> Name Type Description Default <code>secrets_filter</code> <code>ArkDPADBSecretsFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadataList</code> <code>ArkDPADBSecretMetadataList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def list_secrets_by(self, secrets_filter: ArkDPADBSecretsFilter) -&gt; ArkDPADBSecretMetadataList:\n    \"\"\"\n    Lists db secrets by given filters\n\n    Args:\n        secrets_filter (ArkDPADBSecretsFilter): _description_\n\n    Returns:\n        ArkDPADBSecretMetadataList: _description_\n    \"\"\"\n    self._logger.info(f'Listing db secrets by filters [{secrets_filter}]')\n    secrets = self.__list_secrets_with_filters(secrets_filter.secret_type, secrets_filter.tags)\n\n    # Filter by secret types\n    if secrets_filter.store_type:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_store.store_type == secrets_filter.store_type]\n\n    # Filter by name\n    if secrets_filter.secret_name:\n        secrets.secrets = [s for s in secrets.secrets if s.secret_name and fnmatch(s.secret_name, secrets_filter.secret_name)]\n\n    # Filter by is active\n    if secrets_filter.is_active is not None:\n        secrets.secrets = [s for s in secrets.secrets if s.is_active == secrets_filter.is_active]\n    secrets.total_count = len(secrets.secrets)\n\n    return secrets\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.secret","title":"<code>secret(get_secret)</code>","text":"<p>Retrieves a db secret</p> <p>Parameters:</p> Name Type Description Default <code>get_secret</code> <code>ArkDPADBGetSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secret(self, get_secret: ArkDPADBGetSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Retrieves a db secret\n\n    Args:\n        get_secret (ArkDPADBGetSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if get_secret.secret_name and not get_secret.secret_id:\n        get_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=get_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Retrieving db secret by id [{get_secret.secret_id}]')\n    resp: Response = self.__client.get(SECRET_ROUTE.format(secret_id=get_secret.secret_id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBSecretMetadata.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError) as ex:\n            self._logger.exception(f'Failed to parse db secret response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse db secret response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to retrieve db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.secrets_stats","title":"<code>secrets_stats()</code>","text":"<p>Calculates db secrets statistics</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretsStats</code> <code>ArkDPADBSecretsStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def secrets_stats(self) -&gt; ArkDPADBSecretsStats:\n    \"\"\"\n    Calculates db secrets statistics\n\n    Returns:\n        ArkDPADBSecretsStats: _description_\n    \"\"\"\n    self._logger.info('Calculating secrets statistics')\n    secrets = self.list_secrets()\n    secrets_stats = ArkDPADBSecretsStats.construct()\n    secrets_stats.secrets_count = len(secrets.secrets)\n    secrets_stats.active_secrets_count = len([s for s in secrets.secrets if s.is_active])\n    secrets_stats.inactive_secrets_count = len([s for s in secrets.secrets if not s.is_active])\n\n    # Count secrets per secret type\n    secret_types: Set[ArkDPADBSecretType] = {s.secret_type for s in secrets.secrets if s.secret_type}\n    secrets_stats.secrets_count_by_secret_type = {\n        st: len([s for s in secrets.secrets if s.secret_type and s.secret_type == st]) for st in secret_types\n    }\n\n    # Count secrets per store type\n    store_types: Set[ArkDPADBStoreType] = {s.secret_store.store_type for s in secrets.secrets if s.secret_store.store_type}\n    secrets_stats.secrets_count_by_store_type = {\n        st: len([s for s in secrets.secrets if s.secret_store.store_type and s.secret_store.store_type == st]) for st in store_types\n    }\n\n    return secrets_stats\n</code></pre>"},{"location":"reference/services/dpa/secrets/db/ark_dpa_db_secrets_service/#ark_sdk_python.services.dpa.secrets.db.ark_dpa_db_secrets_service.ArkDPADBSecretsService.update_secret","title":"<code>update_secret(update_secret)</code>","text":"<p>Updates an existing db secret</p> <p>Parameters:</p> Name Type Description Default <code>update_secret</code> <code>ArkDPADBUpdateSecret</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBSecretMetadata</code> <code>ArkDPADBSecretMetadata</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/secrets/db/ark_dpa_db_secrets_service.py</code> <pre><code>def update_secret(self, update_secret: ArkDPADBUpdateSecret) -&gt; ArkDPADBSecretMetadata:\n    \"\"\"\n    Updates an existing db secret\n\n    Args:\n        update_secret (ArkDPADBUpdateSecret): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBSecretMetadata: _description_\n    \"\"\"\n    if update_secret.secret_name and not update_secret.secret_id:\n        update_secret.secret_id = (\n            self.list_secrets_by(\n                secrets_filter=ArkDPADBSecretsFilter(secret_name=update_secret.secret_name),\n            )\n            .secrets[0]\n            .secret_id\n        )\n    self._logger.info(f'Updating existing db secret with id [{update_secret.secret_id}]')\n    update_secret_dict = update_secret.dict(\n        exclude_none=True,\n        exclude={'secret_id', 'secret_name', 'new_secret_name', 'username', 'password', 'pam_safe', 'pam_account_name'},\n    )\n    if update_secret.new_secret_name:\n        update_secret_dict['secret_name'] = update_secret.new_secret_name\n    if update_secret.pam_account_name or update_secret.pam_safe:\n        if not update_secret.pam_account_name or not update_secret.pam_safe:\n            raise ArkServiceException('When specifying a pam secret, both pam safe and pam account name parameters must be supplied')\n        update_secret_dict['secret_link'] = {\n            'safe': update_secret.pam_safe,\n            'account_name': update_secret.pam_account_name,\n        }\n    if update_secret.username or update_secret.password:\n        if not update_secret.username or not update_secret.password:\n            raise ArkServiceException(\n                'When specifying a username password secret, both username and password name parameters must be supplied'\n            )\n        update_secret_dict['secret_data'] = {\n            'username': update_secret.username,\n            'password': update_secret.password.get_secret_value(),\n        }\n    resp: Response = self.__client.post(\n        SECRET_ROUTE.format(secret_id=update_secret.secret_id),\n        json=update_secret_dict,\n    )\n    if resp.status_code == HTTPStatus.OK:\n        return self.secret(ArkDPADBSecretMetadata(secret_id=update_secret.secret_id))\n    raise ArkServiceException(f'Failed to update db secret [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/","title":"sso","text":""},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService","title":"<code>ArkDPASSOService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>class ArkDPASSOService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n        self.__cache_keyring = ArkKeyring(self.service_config().service_name)\n\n    def __load_from_cache(self, token_type: str) -&gt; Optional[ArkDPASSOAcquireTokenResponse]:\n        claims = get_unverified_claims(self.__client.session_token)\n        token = self.__cache_keyring.load_token(\n            ArkProfileLoader.load_default_profile(),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n        if token:\n            return ArkDPASSOAcquireTokenResponse.parse_raw(token.token.get_secret_value())\n        return None\n\n    def __save_to_cache(self, result: ArkDPASSOAcquireTokenResponse, token_type: str) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        expires_in = datetime.now() + (parse(result.metadata['expires_at']) - parse(result.metadata['created_at']))\n        self.__cache_keyring.save_token(\n            ArkProfileLoader.load_default_profile(),\n            ArkToken(\n                token=result.json(),\n                token_type=ArkTokenType.Token,\n                expires_in=expires_in,\n            ),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n\n    def __output_client_certificate(\n        self, folder: str, output_format: ArkDPASSOShortLiveClientCertificateFormat, result: ArkDPASSOAcquireTokenResponse\n    ) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        client_certificate = result.token['client_certificate']\n        private_key = result.token['private_key']\n\n        if output_format == ArkDPASSOShortLiveClientCertificateFormat.RAW:\n            ArkArgsFormatter.print_normal(f'client-certificate-data: {client_certificate}')\n            ArkArgsFormatter.print_normal(f'client-key-data: {private_key}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.BASE64:\n            ArkArgsFormatter.print_normal(\n                f'client-certificate-data: {base64.b64encode(client_certificate.encode(\"utf-8\")).decode(\"utf-8\")}'\n            )\n            ArkArgsFormatter.print_normal(f'client-key-data: {base64.b64encode(private_key.encode(\"utf-8\")).decode(\"utf-8\")}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkDPASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder):\n                os.makedirs(folder)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_cert.crt', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_key.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(private_key)\n        else:\n            raise ArkServiceException(f'Unknown format {output_format}')\n\n    def __save_oracle_wallet(self, folder: str, unzip_wallet: bool, result: ArkDPASSOAcquireTokenResponse) -&gt; None:\n        result.token['wallet'] = base64.b64decode(result.token['wallet'])\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        if not unzip_wallet:\n            with open(f'{folder}{os.path.sep}wallet.zip', 'wb') as file_handle:\n                file_handle.write(result.token['wallet'])\n        else:\n            wallet_bytes = BytesIO(result.token['wallet'])\n            with zipfile.ZipFile(wallet_bytes, 'r') as zipf:\n                zipf.extractall(folder)\n\n    def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n        \"\"\"\n        Generates a short lived password to be used to connect to dpa infrastructure\n\n        Args:\n            get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived password token')\n        if get_short_lived_password.allow_caching:\n            result = self.__load_from_cache('password')\n            if result:\n                return result.token['key']\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'password',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'key' in result.token:\n            if get_short_lived_password.allow_caching:\n                self.__save_to_cache(result, 'password')\n            return result.token['key']\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n        \"\"\"\n        Generates a short lived client certificate to be used to connect to dpa infrastructure\n\n        Args:\n            get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived client certificate')\n        if get_short_lived_client_certificate.allow_caching:\n            result = self.__load_from_cache('client_certificate')\n            if result:\n                self.__output_client_certificate(\n                    get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n                )\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'client_certificate',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'client_certificate' in result.token and 'private_key' in result.token:\n            if get_short_lived_client_certificate.allow_caching:\n                self.__save_to_cache(result, 'client_certificate')\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n        \"\"\"\n        Generates a short lived oracle wallet to be used to connect via dpa infrastructure to oracle databases\n\n        Args:\n            get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived oracle wallet')\n        if get_short_lived_oracle_wallet.allow_caching:\n            result = self.__load_from_cache('oracle_wallet')\n            if result:\n                self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'oracle_wallet',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'wallet' in result.token:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService.short_lived_client_certificate","title":"<code>short_lived_client_certificate(get_short_lived_client_certificate)</code>","text":"<p>Generates a short lived client certificate to be used to connect to dpa infrastructure</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_client_certificate</code> <code>ArkDPASSOGetShortLivedClientCertificate</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n    \"\"\"\n    Generates a short lived client certificate to be used to connect to dpa infrastructure\n\n    Args:\n        get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived client certificate')\n    if get_short_lived_client_certificate.allow_caching:\n        result = self.__load_from_cache('client_certificate')\n        if result:\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'client_certificate',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'client_certificate' in result.token and 'private_key' in result.token:\n        if get_short_lived_client_certificate.allow_caching:\n            self.__save_to_cache(result, 'client_certificate')\n        self.__output_client_certificate(\n            get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n        )\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService.short_lived_oracle_wallet","title":"<code>short_lived_oracle_wallet(get_short_lived_oracle_wallet)</code>","text":"<p>Generates a short lived oracle wallet to be used to connect via dpa infrastructure to oracle databases</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_oracle_wallet</code> <code>ArkDPASSOGetShortLivedOracleWallet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n    \"\"\"\n    Generates a short lived oracle wallet to be used to connect via dpa infrastructure to oracle databases\n\n    Args:\n        get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived oracle wallet')\n    if get_short_lived_oracle_wallet.allow_caching:\n        result = self.__load_from_cache('oracle_wallet')\n        if result:\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'oracle_wallet',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'wallet' in result.token:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/#ark_sdk_python.services.dpa.sso.ArkDPASSOService.short_lived_password","title":"<code>short_lived_password(get_short_lived_password)</code>","text":"<p>Generates a short lived password to be used to connect to dpa infrastructure</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_password</code> <code>ArkDPASSOGetShortLivedPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n    \"\"\"\n    Generates a short lived password to be used to connect to dpa infrastructure\n\n    Args:\n        get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived password token')\n    if get_short_lived_password.allow_caching:\n        result = self.__load_from_cache('password')\n        if result:\n            return result.token['key']\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'password',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'key' in result.token:\n        if get_short_lived_password.allow_caching:\n            self.__save_to_cache(result, 'password')\n        return result.token['key']\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/","title":"ark_dpa_sso_service","text":""},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService","title":"<code>ArkDPASSOService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>class ArkDPASSOService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n        self.__cache_keyring = ArkKeyring(self.service_config().service_name)\n\n    def __load_from_cache(self, token_type: str) -&gt; Optional[ArkDPASSOAcquireTokenResponse]:\n        claims = get_unverified_claims(self.__client.session_token)\n        token = self.__cache_keyring.load_token(\n            ArkProfileLoader.load_default_profile(),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n        if token:\n            return ArkDPASSOAcquireTokenResponse.parse_raw(token.token.get_secret_value())\n        return None\n\n    def __save_to_cache(self, result: ArkDPASSOAcquireTokenResponse, token_type: str) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        expires_in = datetime.now() + (parse(result.metadata['expires_at']) - parse(result.metadata['created_at']))\n        self.__cache_keyring.save_token(\n            ArkProfileLoader.load_default_profile(),\n            ArkToken(\n                token=result.json(),\n                token_type=ArkTokenType.Token,\n                expires_in=expires_in,\n            ),\n            postfix=f'{claims[\"tenant_id\"]}_{claims[\"unique_name\"]}_dpa_sso_short_lived_{token_type}',\n        )\n\n    def __output_client_certificate(\n        self, folder: str, output_format: ArkDPASSOShortLiveClientCertificateFormat, result: ArkDPASSOAcquireTokenResponse\n    ) -&gt; None:\n        claims = get_unverified_claims(self.__client.session_token)\n        client_certificate = result.token['client_certificate']\n        private_key = result.token['private_key']\n\n        if output_format == ArkDPASSOShortLiveClientCertificateFormat.RAW:\n            ArkArgsFormatter.print_normal(f'client-certificate-data: {client_certificate}')\n            ArkArgsFormatter.print_normal(f'client-key-data: {private_key}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.BASE64:\n            ArkArgsFormatter.print_normal(\n                f'client-certificate-data: {base64.b64encode(client_certificate.encode(\"utf-8\")).decode(\"utf-8\")}'\n            )\n            ArkArgsFormatter.print_normal(f'client-key-data: {base64.b64encode(private_key.encode(\"utf-8\")).decode(\"utf-8\")}')\n        elif output_format == ArkDPASSOShortLiveClientCertificateFormat.FILE:\n            if not folder:\n                raise ArkServiceException(\n                    f'Folder parameter is required if format is {ArkDPASSOShortLiveClientCertificateFormat.FILE.value}'\n                )\n            if not os.path.exists(folder):\n                os.makedirs(folder)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_cert.crt', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(client_certificate)\n            with open(f'{folder}{os.path.sep}{claims[\"unique_name\"]}client_key.pem', 'w', encoding='utf-8') as file_handle:\n                file_handle.write(private_key)\n        else:\n            raise ArkServiceException(f'Unknown format {output_format}')\n\n    def __save_oracle_wallet(self, folder: str, unzip_wallet: bool, result: ArkDPASSOAcquireTokenResponse) -&gt; None:\n        result.token['wallet'] = base64.b64decode(result.token['wallet'])\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        if not unzip_wallet:\n            with open(f'{folder}{os.path.sep}wallet.zip', 'wb') as file_handle:\n                file_handle.write(result.token['wallet'])\n        else:\n            wallet_bytes = BytesIO(result.token['wallet'])\n            with zipfile.ZipFile(wallet_bytes, 'r') as zipf:\n                zipf.extractall(folder)\n\n    def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n        \"\"\"\n        Generates a short lived password to be used to connect to dpa infrastructure\n\n        Args:\n            get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived password token')\n        if get_short_lived_password.allow_caching:\n            result = self.__load_from_cache('password')\n            if result:\n                return result.token['key']\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'password',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'key' in result.token:\n            if get_short_lived_password.allow_caching:\n                self.__save_to_cache(result, 'password')\n            return result.token['key']\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n        \"\"\"\n        Generates a short lived client certificate to be used to connect to dpa infrastructure\n\n        Args:\n            get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived client certificate')\n        if get_short_lived_client_certificate.allow_caching:\n            result = self.__load_from_cache('client_certificate')\n            if result:\n                self.__output_client_certificate(\n                    get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n                )\n                return\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'client_certificate',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'client_certificate' in result.token and 'private_key' in result.token:\n            if get_short_lived_client_certificate.allow_caching:\n                self.__save_to_cache(result, 'client_certificate')\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n        \"\"\"\n        Generates a short lived oracle wallet to be used to connect via dpa infrastructure to oracle databases\n\n        Args:\n            get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            str: __description__\n        \"\"\"\n        self._logger.info('Generating short lived oracle wallet')\n        if get_short_lived_oracle_wallet.allow_caching:\n            result = self.__load_from_cache('oracle_wallet')\n            if result:\n                self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        response: Response = self.__client.post(\n            ACQUIRE_SSO_TOKEN_URL,\n            json={\n                'token_type': 'oracle_wallet',\n            },\n        )\n        if response.status_code != HTTPStatus.CREATED:\n            raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n        result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n        if 'wallet' in result.token:\n            if get_short_lived_oracle_wallet.allow_caching:\n                self.__save_to_cache(result, 'oracle_wallet')\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n            return\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService.short_lived_client_certificate","title":"<code>short_lived_client_certificate(get_short_lived_client_certificate)</code>","text":"<p>Generates a short lived client certificate to be used to connect to dpa infrastructure</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_client_certificate</code> <code>ArkDPASSOGetShortLivedClientCertificate</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_client_certificate(self, get_short_lived_client_certificate: ArkDPASSOGetShortLivedClientCertificate) -&gt; None:\n    \"\"\"\n    Generates a short lived client certificate to be used to connect to dpa infrastructure\n\n    Args:\n        get_short_lived_client_certificate (ArkDPASSOGetShortLivedClientCertificate): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived client certificate')\n    if get_short_lived_client_certificate.allow_caching:\n        result = self.__load_from_cache('client_certificate')\n        if result:\n            self.__output_client_certificate(\n                get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n            )\n            return\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'client_certificate',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived client certificate - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'client_certificate' in result.token and 'private_key' in result.token:\n        if get_short_lived_client_certificate.allow_caching:\n            self.__save_to_cache(result, 'client_certificate')\n        self.__output_client_certificate(\n            get_short_lived_client_certificate.folder, get_short_lived_client_certificate.output_format, result\n        )\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService.short_lived_oracle_wallet","title":"<code>short_lived_oracle_wallet(get_short_lived_oracle_wallet)</code>","text":"<p>Generates a short lived oracle wallet to be used to connect via dpa infrastructure to oracle databases</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_oracle_wallet</code> <code>ArkDPASSOGetShortLivedOracleWallet</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_oracle_wallet(self, get_short_lived_oracle_wallet: ArkDPASSOGetShortLivedOracleWallet) -&gt; None:\n    \"\"\"\n    Generates a short lived oracle wallet to be used to connect via dpa infrastructure to oracle databases\n\n    Args:\n        get_short_lived_oracle_wallet (ArkDPASSOGetShortLivedOracleWallet): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived oracle wallet')\n    if get_short_lived_oracle_wallet.allow_caching:\n        result = self.__load_from_cache('oracle_wallet')\n        if result:\n            self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'oracle_wallet',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived oracle wallet - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'wallet' in result.token:\n        if get_short_lived_oracle_wallet.allow_caching:\n            self.__save_to_cache(result, 'oracle_wallet')\n        self.__save_oracle_wallet(get_short_lived_oracle_wallet.folder, get_short_lived_oracle_wallet.unzip_wallet, result)\n        return\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/sso/ark_dpa_sso_service/#ark_sdk_python.services.dpa.sso.ark_dpa_sso_service.ArkDPASSOService.short_lived_password","title":"<code>short_lived_password(get_short_lived_password)</code>","text":"<p>Generates a short lived password to be used to connect to dpa infrastructure</p> <p>Parameters:</p> Name Type Description Default <code>get_short_lived_password</code> <code>ArkDPASSOGetShortLivedPassword</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/sso/ark_dpa_sso_service.py</code> <pre><code>def short_lived_password(self, get_short_lived_password: ArkDPASSOGetShortLivedPassword) -&gt; str:\n    \"\"\"\n    Generates a short lived password to be used to connect to dpa infrastructure\n\n    Args:\n        get_short_lived_password (ArkDPASSOGetShortLivedPassword): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        str: __description__\n    \"\"\"\n    self._logger.info('Generating short lived password token')\n    if get_short_lived_password.allow_caching:\n        result = self.__load_from_cache('password')\n        if result:\n            return result.token['key']\n    response: Response = self.__client.post(\n        ACQUIRE_SSO_TOKEN_URL,\n        json={\n            'token_type': 'password',\n        },\n    )\n    if response.status_code != HTTPStatus.CREATED:\n        raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n    result: ArkDPASSOAcquireTokenResponse = ArkDPASSOAcquireTokenResponse.parse_obj(response.json())\n    if 'key' in result.token:\n        if get_short_lived_password.allow_caching:\n            self.__save_to_cache(result, 'password')\n        return result.token['key']\n    raise ArkServiceException(f'Failed to generate short lived password - [{response.status_code}] - [{response.text}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/","title":"workspaces","text":""},{"location":"reference/services/dpa/workspaces/db/","title":"db","text":""},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService","title":"<code>ArkDPADBWorkspaceService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>class ArkDPADBWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_databases_with_filters(\n        self, provider_family: Optional[ArkDPADBDatabaseFamilyType] = None, tags: Optional[List[ArkDPADBTag]] = None\n    ) -&gt; ArkDPADBDatabaseInfoList:\n        params = {}\n        if provider_family:\n            params['provider-family'] = provider_family.value\n        if tags:\n            for tag in tags:\n                params[f'key.{tag.key}'] = tag.value\n        resp: Response = self.__client.get(RESOURCES_API, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabaseInfoList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list databases response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list databases response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list databases [{resp.text}] - [{resp.status_code}]')\n\n    def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Add a new database\n\n        Args:\n            add_database (ArkDPADBAddDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        self._logger.info(f'Adding database [{add_database.name}]')\n        if not add_database.port:\n            add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n        add_database_dict = add_database.dict(exclude_none=True)\n        add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n        resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                database_id = resp.json()['target_id']\n                return self.database(ArkDPADBGetDatabase(id=database_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n\n    def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n        \"\"\"\n        Delete an existing database\n\n        Args:\n            delete_database (ArkDPADBDeleteDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_database.name and not delete_database.id:\n            delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n        self._logger.info(f'Deleting database [{delete_database.id}]')\n        resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n\n    def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Update an existing database\n\n        Args:\n            update_database (ArkDPADBUpdateDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if update_database.name and not update_database.id:\n            update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n        self._logger.info(f'Updating database [{update_database.id}]')\n        update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_database.new_name:\n            update_database_dict[\"name\"] = update_database.new_name\n        resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return self.database(ArkDPADBGetDatabase(id=update_database.id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n\n    def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        List all databases\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info('Listing all databases')\n        return self.__list_databases_with_filters()\n\n    def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        List databases by given filters\n\n        Args:\n            databases_filter (ArkDPADBDatabasesFilter): _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info(f'Listing databases by filters [{databases_filter}]')\n        databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n        if databases_filter.name:\n            databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n        if databases_filter.provider_engine:\n            databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n        if databases_filter.provider_workspace:\n            databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n        if databases_filter.db_warnings_filter:\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoCertificates,\n            ):\n                databases.items = [d for d in databases.items if not d.certificate]\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoSecrets,\n            ):\n                databases.items = [d for d in databases.items if not d.secret_id]\n        databases.total_count = len(databases.items)\n        return databases\n\n    def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Get specific database\n\n        Args:\n            get_database (ArkDPADBGetDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if get_database.name and not get_database.id:\n            get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n        self._logger.info(f'Getting database [{get_database.id}]')\n        resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabase.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n\n    def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n        \"\"\"\n        Calculate stats about the databases of the tenant\n\n        Returns:\n            ArkDPADBDatabasesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating databases stats')\n        databases = self.list_databases()\n        databases_stats = ArkDPADBDatabasesStats.construct()\n        databases_stats.databases_count = len(databases.items)\n\n        # Get databases per engine\n        engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n        databases_stats.databases_count_by_engine = {\n            et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n        }\n\n        # Get databases per workspace\n        workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n        databases_stats.databases_count_by_workspace = {\n            wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n        }\n\n        # Get databases per family\n        family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n        databases_stats.databases_count_by_family = {\n            ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n        }\n\n        # Get databases per db warning\n        databases_stats.databases_count_by_warning = {\n            ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n            ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n        }\n\n        return databases_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.add_database","title":"<code>add_database(add_database)</code>","text":"<p>Add a new database</p> <p>Parameters:</p> Name Type Description Default <code>add_database</code> <code>ArkDPADBAddDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Add a new database\n\n    Args:\n        add_database (ArkDPADBAddDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    self._logger.info(f'Adding database [{add_database.name}]')\n    if not add_database.port:\n        add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n    add_database_dict = add_database.dict(exclude_none=True)\n    add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n    resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            database_id = resp.json()['target_id']\n            return self.database(ArkDPADBGetDatabase(id=database_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.database","title":"<code>database(get_database)</code>","text":"<p>Get specific database</p> <p>Parameters:</p> Name Type Description Default <code>get_database</code> <code>ArkDPADBGetDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Get specific database\n\n    Args:\n        get_database (ArkDPADBGetDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if get_database.name and not get_database.id:\n        get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n    self._logger.info(f'Getting database [{get_database.id}]')\n    resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBDatabase.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.databases_stats","title":"<code>databases_stats()</code>","text":"<p>Calculate stats about the databases of the tenant</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabasesStats</code> <code>ArkDPADBDatabasesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n    \"\"\"\n    Calculate stats about the databases of the tenant\n\n    Returns:\n        ArkDPADBDatabasesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating databases stats')\n    databases = self.list_databases()\n    databases_stats = ArkDPADBDatabasesStats.construct()\n    databases_stats.databases_count = len(databases.items)\n\n    # Get databases per engine\n    engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n    databases_stats.databases_count_by_engine = {\n        et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n    }\n\n    # Get databases per workspace\n    workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n    databases_stats.databases_count_by_workspace = {\n        wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n    }\n\n    # Get databases per family\n    family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n    databases_stats.databases_count_by_family = {\n        ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n    }\n\n    # Get databases per db warning\n    databases_stats.databases_count_by_warning = {\n        ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n        ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n    }\n\n    return databases_stats\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.delete_database","title":"<code>delete_database(delete_database)</code>","text":"<p>Delete an existing database</p> <p>Parameters:</p> Name Type Description Default <code>delete_database</code> <code>ArkDPADBDeleteDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n    \"\"\"\n    Delete an existing database\n\n    Args:\n        delete_database (ArkDPADBDeleteDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_database.name and not delete_database.id:\n        delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n    self._logger.info(f'Deleting database [{delete_database.id}]')\n    resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.list_databases","title":"<code>list_databases()</code>","text":"<p>List all databases</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    List all databases\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info('Listing all databases')\n    return self.__list_databases_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.list_databases_by","title":"<code>list_databases_by(databases_filter)</code>","text":"<p>List databases by given filters</p> <p>Parameters:</p> Name Type Description Default <code>databases_filter</code> <code>ArkDPADBDatabasesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    List databases by given filters\n\n    Args:\n        databases_filter (ArkDPADBDatabasesFilter): _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info(f'Listing databases by filters [{databases_filter}]')\n    databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n    if databases_filter.name:\n        databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n    if databases_filter.provider_engine:\n        databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n    if databases_filter.provider_workspace:\n        databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n    if databases_filter.db_warnings_filter:\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoCertificates,\n        ):\n            databases.items = [d for d in databases.items if not d.certificate]\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoSecrets,\n        ):\n            databases.items = [d for d in databases.items if not d.secret_id]\n    databases.total_count = len(databases.items)\n    return databases\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/#ark_sdk_python.services.dpa.workspaces.db.ArkDPADBWorkspaceService.update_database","title":"<code>update_database(update_database)</code>","text":"<p>Update an existing database</p> <p>Parameters:</p> Name Type Description Default <code>update_database</code> <code>ArkDPADBUpdateDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Update an existing database\n\n    Args:\n        update_database (ArkDPADBUpdateDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if update_database.name and not update_database.id:\n        update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n    self._logger.info(f'Updating database [{update_database.id}]')\n    update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_database.new_name:\n        update_database_dict[\"name\"] = update_database.new_name\n    resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return self.database(ArkDPADBGetDatabase(id=update_database.id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/","title":"ark_dpa_db_workspace_service","text":""},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService","title":"<code>ArkDPADBWorkspaceService</code>","text":"<p>             Bases: <code>ArkService</code></p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>class ArkDPADBWorkspaceService(ArkService):\n    def __init__(self, isp_auth: ArkISPAuth) -&gt; None:\n        super().__init__(isp_auth)\n        self.__isp_auth = isp_auth\n        self.__client: ArkISPServiceClient = ArkISPServiceClient.from_isp_auth(self.__isp_auth, 'dpa')\n\n    def __list_databases_with_filters(\n        self, provider_family: Optional[ArkDPADBDatabaseFamilyType] = None, tags: Optional[List[ArkDPADBTag]] = None\n    ) -&gt; ArkDPADBDatabaseInfoList:\n        params = {}\n        if provider_family:\n            params['provider-family'] = provider_family.value\n        if tags:\n            for tag in tags:\n                params[f'key.{tag.key}'] = tag.value\n        resp: Response = self.__client.get(RESOURCES_API, params=params)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabaseInfoList.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse list databases response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse list databases response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to list databases [{resp.text}] - [{resp.status_code}]')\n\n    def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Add a new database\n\n        Args:\n            add_database (ArkDPADBAddDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        self._logger.info(f'Adding database [{add_database.name}]')\n        if not add_database.port:\n            add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n        add_database_dict = add_database.dict(exclude_none=True)\n        add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n        resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n        if resp.status_code == HTTPStatus.CREATED:\n            try:\n                database_id = resp.json()['target_id']\n                return self.database(ArkDPADBGetDatabase(id=database_id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n\n    def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n        \"\"\"\n        Delete an existing database\n\n        Args:\n            delete_database (ArkDPADBDeleteDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n        \"\"\"\n        if delete_database.name and not delete_database.id:\n            delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n        self._logger.info(f'Deleting database [{delete_database.id}]')\n        resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n        if resp.status_code != HTTPStatus.NO_CONTENT:\n            raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n\n    def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Update an existing database\n\n        Args:\n            update_database (ArkDPADBUpdateDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if update_database.name and not update_database.id:\n            update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n        self._logger.info(f'Updating database [{update_database.id}]')\n        update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n        if update_database.new_name:\n            update_database_dict[\"name\"] = update_database.new_name\n        resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return self.database(ArkDPADBGetDatabase(id=update_database.id))\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n\n    def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        List all databases\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info('Listing all databases')\n        return self.__list_databases_with_filters()\n\n    def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n        \"\"\"\n        List databases by given filters\n\n        Args:\n            databases_filter (ArkDPADBDatabasesFilter): _description_\n\n        Returns:\n            ArkDPADBDatabaseInfoList: _description_\n        \"\"\"\n        self._logger.info(f'Listing databases by filters [{databases_filter}]')\n        databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n        if databases_filter.name:\n            databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n        if databases_filter.provider_engine:\n            databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n        if databases_filter.provider_workspace:\n            databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n        if databases_filter.db_warnings_filter:\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoCertificates,\n            ):\n                databases.items = [d for d in databases.items if not d.certificate]\n            if databases_filter.db_warnings_filter in (\n                ArkDPADBWarning.AnyError,\n                ArkDPADBWarning.NoSecrets,\n            ):\n                databases.items = [d for d in databases.items if not d.secret_id]\n        databases.total_count = len(databases.items)\n        return databases\n\n    def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n        \"\"\"\n        Get specific database\n\n        Args:\n            get_database (ArkDPADBGetDatabase): _description_\n\n        Raises:\n            ArkServiceException: _description_\n\n        Returns:\n            ArkDPADBDatabase: _description_\n        \"\"\"\n        if get_database.name and not get_database.id:\n            get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n        self._logger.info(f'Getting database [{get_database.id}]')\n        resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n        if resp.status_code == HTTPStatus.OK:\n            try:\n                return ArkDPADBDatabase.parse_obj(resp.json())\n            except (ValidationError, JSONDecodeError, KeyError) as ex:\n                self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n                raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n        raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n\n    def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n        \"\"\"\n        Calculate stats about the databases of the tenant\n\n        Returns:\n            ArkDPADBDatabasesStats: _description_\n        \"\"\"\n        self._logger.info('Calculating databases stats')\n        databases = self.list_databases()\n        databases_stats = ArkDPADBDatabasesStats.construct()\n        databases_stats.databases_count = len(databases.items)\n\n        # Get databases per engine\n        engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n        databases_stats.databases_count_by_engine = {\n            et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n        }\n\n        # Get databases per workspace\n        workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n        databases_stats.databases_count_by_workspace = {\n            wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n        }\n\n        # Get databases per family\n        family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n        databases_stats.databases_count_by_family = {\n            ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n        }\n\n        # Get databases per db warning\n        databases_stats.databases_count_by_warning = {\n            ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n            ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n        }\n\n        return databases_stats\n\n    @staticmethod\n    @overrides\n    def service_config() -&gt; ArkServiceConfig:\n        return SERVICE_CONFIG\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.add_database","title":"<code>add_database(add_database)</code>","text":"<p>Add a new database</p> <p>Parameters:</p> Name Type Description Default <code>add_database</code> <code>ArkDPADBAddDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def add_database(self, add_database: ArkDPADBAddDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Add a new database\n\n    Args:\n        add_database (ArkDPADBAddDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    self._logger.info(f'Adding database [{add_database.name}]')\n    if not add_database.port:\n        add_database.port = DATABASE_FAMILIES_DEFAULT_PORTS[DATABASES_ENGINES_TO_FAMILY[add_database.provider_engine]]\n    add_database_dict = add_database.dict(exclude_none=True)\n    add_database_dict['platform'] = serialize_db_platform_type(add_database.platform)\n    resp: Response = self.__client.post(RESOURCES_API, json=add_database_dict)\n    if resp.status_code == HTTPStatus.CREATED:\n        try:\n            database_id = resp.json()['target_id']\n            return self.database(ArkDPADBGetDatabase(id=database_id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse add database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse add database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to add database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.database","title":"<code>database(get_database)</code>","text":"<p>Get specific database</p> <p>Parameters:</p> Name Type Description Default <code>get_database</code> <code>ArkDPADBGetDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def database(self, get_database: ArkDPADBGetDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Get specific database\n\n    Args:\n        get_database (ArkDPADBGetDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if get_database.name and not get_database.id:\n        get_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=get_database.name))\n    self._logger.info(f'Getting database [{get_database.id}]')\n    resp: Response = self.__client.get(RESOURCE_API.format(resource_id=get_database.id))\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return ArkDPADBDatabase.parse_obj(resp.json())\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to get database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.databases_stats","title":"<code>databases_stats()</code>","text":"<p>Calculate stats about the databases of the tenant</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabasesStats</code> <code>ArkDPADBDatabasesStats</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def databases_stats(self) -&gt; ArkDPADBDatabasesStats:\n    \"\"\"\n    Calculate stats about the databases of the tenant\n\n    Returns:\n        ArkDPADBDatabasesStats: _description_\n    \"\"\"\n    self._logger.info('Calculating databases stats')\n    databases = self.list_databases()\n    databases_stats = ArkDPADBDatabasesStats.construct()\n    databases_stats.databases_count = len(databases.items)\n\n    # Get databases per engine\n    engines_types: Set[ArkDPADBDatabaseEngineType] = {d.provider_info.engine for d in databases.items}\n    databases_stats.databases_count_by_engine = {\n        et: len([d for d in databases.items if d.provider_info.engine == et]) for et in engines_types\n    }\n\n    # Get databases per workspace\n    workspaces_types: Set[ArkDPADBDatabaseWorkspaceType] = {d.provider_info.workspace for d in databases.items}\n    databases_stats.databases_count_by_workspace = {\n        wt: len([d for d in databases.items if d.provider_info.workspace == wt]) for wt in workspaces_types\n    }\n\n    # Get databases per family\n    family_types: Set[ArkDPADBDatabaseFamilyType] = {d.provider_info.family for d in databases.items}\n    databases_stats.databases_count_by_family = {\n        ft: len([d for d in databases.items if d.provider_info.family == ft]) for ft in family_types\n    }\n\n    # Get databases per db warning\n    databases_stats.databases_count_by_warning = {\n        ArkDPADBWarning.NoCertificates: len([d for d in databases.items if not d.certificate]),\n        ArkDPADBWarning.NoSecrets: len([d for d in databases.items if not d.secret_id]),\n    }\n\n    return databases_stats\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.delete_database","title":"<code>delete_database(delete_database)</code>","text":"<p>Delete an existing database</p> <p>Parameters:</p> Name Type Description Default <code>delete_database</code> <code>ArkDPADBDeleteDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def delete_database(self, delete_database: ArkDPADBDeleteDatabase) -&gt; None:\n    \"\"\"\n    Delete an existing database\n\n    Args:\n        delete_database (ArkDPADBDeleteDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n    \"\"\"\n    if delete_database.name and not delete_database.id:\n        delete_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=delete_database.name))\n    self._logger.info(f'Deleting database [{delete_database.id}]')\n    resp: Response = self.__client.delete(RESOURCE_API.format(resource_id=delete_database.id))\n    if resp.status_code != HTTPStatus.NO_CONTENT:\n        raise ArkServiceException(f'Failed to delete database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.list_databases","title":"<code>list_databases()</code>","text":"<p>List all databases</p> <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases(self) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    List all databases\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info('Listing all databases')\n    return self.__list_databases_with_filters()\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.list_databases_by","title":"<code>list_databases_by(databases_filter)</code>","text":"<p>List databases by given filters</p> <p>Parameters:</p> Name Type Description Default <code>databases_filter</code> <code>ArkDPADBDatabasesFilter</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>ArkDPADBDatabaseInfoList</code> <code>ArkDPADBDatabaseInfoList</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def list_databases_by(self, databases_filter: ArkDPADBDatabasesFilter) -&gt; ArkDPADBDatabaseInfoList:\n    \"\"\"\n    List databases by given filters\n\n    Args:\n        databases_filter (ArkDPADBDatabasesFilter): _description_\n\n    Returns:\n        ArkDPADBDatabaseInfoList: _description_\n    \"\"\"\n    self._logger.info(f'Listing databases by filters [{databases_filter}]')\n    databases = self.__list_databases_with_filters(databases_filter.provider_family, databases_filter.tags)\n    if databases_filter.name:\n        databases.items = [d for d in databases.items if fnmatch(d.name, databases_filter.name)]\n    if databases_filter.provider_engine:\n        databases.items = [d for d in databases.items if d.provider_info.engine == databases_filter.provider_engine]\n    if databases_filter.provider_workspace:\n        databases.items = [d for d in databases.items if d.provider_info.workspace == databases_filter.provider_workspace]\n    if databases_filter.db_warnings_filter:\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoCertificates,\n        ):\n            databases.items = [d for d in databases.items if not d.certificate]\n        if databases_filter.db_warnings_filter in (\n            ArkDPADBWarning.AnyError,\n            ArkDPADBWarning.NoSecrets,\n        ):\n            databases.items = [d for d in databases.items if not d.secret_id]\n    databases.total_count = len(databases.items)\n    return databases\n</code></pre>"},{"location":"reference/services/dpa/workspaces/db/ark_dpa_db_workspace_service/#ark_sdk_python.services.dpa.workspaces.db.ark_dpa_db_workspace_service.ArkDPADBWorkspaceService.update_database","title":"<code>update_database(update_database)</code>","text":"<p>Update an existing database</p> <p>Parameters:</p> Name Type Description Default <code>update_database</code> <code>ArkDPADBUpdateDatabase</code> <p>description</p> required <p>Raises:</p> Type Description <code>ArkServiceException</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ArkDPADBDatabase</code> <code>ArkDPADBDatabase</code> <p>description</p> Source code in <code>ark_sdk_python/services/dpa/workspaces/db/ark_dpa_db_workspace_service.py</code> <pre><code>def update_database(self, update_database: ArkDPADBUpdateDatabase) -&gt; ArkDPADBDatabase:\n    \"\"\"\n    Update an existing database\n\n    Args:\n        update_database (ArkDPADBUpdateDatabase): _description_\n\n    Raises:\n        ArkServiceException: _description_\n\n    Returns:\n        ArkDPADBDatabase: _description_\n    \"\"\"\n    if update_database.name and not update_database.id:\n        update_database.id = self.list_databases_by(ArkDPADBDatabasesFilter(name=update_database.name))\n    self._logger.info(f'Updating database [{update_database.id}]')\n    update_database_dict = update_database.dict(exclude={'name', 'new_name'}, exclude_none=True)\n    if update_database.new_name:\n        update_database_dict[\"name\"] = update_database.new_name\n    resp: Response = self.__client.put(RESOURCE_API.format(resource_id=update_database.id), json=update_database_dict)\n    if resp.status_code == HTTPStatus.OK:\n        try:\n            return self.database(ArkDPADBGetDatabase(id=update_database.id))\n        except (ValidationError, JSONDecodeError, KeyError) as ex:\n            self._logger.exception(f'Failed to parse update database response [{str(ex)}] - [{resp.text}]')\n            raise ArkServiceException(f'Failed to parse update database response [{str(ex)}]') from ex\n    raise ArkServiceException(f'Failed to update database [{resp.text}] - [{resp.status_code}]')\n</code></pre>"},{"location":"sdk/async_requests/","title":"Async Requests","text":""},{"location":"sdk/async_requests/#motivation","title":"Motivation","text":"<p>Some of the requests may be async requests, such as creating a tenant, and those requests do not end straight away</p> <p>To support such a mechanism, API's that have this kind of behaviour can return an ArkAsyncRequest</p> <p>The request implements the following interface <pre><code>@abstractmethod\ndef is_finished(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request is finished or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef task_failed(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request failed or not\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef task_timeout(self) -&gt; bool:\n    \"\"\"\n    Checks whether the current async request has timed out\n\n    Returns:\n        bool: _description_\n    \"\"\"\n\n@abstractmethod\ndef poll(self, timeout_seconds: int, progress_callback: Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]) -&gt; bool:\n    \"\"\"\n    Polls for the async request until it is finished\n    Progress callbacks may also be used to be notified whats the async request status\n\n    Args:\n        timeout_seconds (int): _description_\n        progress_callback (Callable[[ArkAsyncTask, int, ArkAsyncStatus], None]): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n</code></pre></p> <p>A user can then use the returned request, to poll or check whether a request is finished or not</p> <p>Each of the existing services that have async requests, already have their respective requests implemented</p> <p>The requests which are async, receive an ArkPollableModel type of request model, which also has information to whether to poll the request or not, and for how long to wait until timeout</p> <p>Another feature of the pollable model, is if the authentication is refreshable, will also refresh it automatically during the polling operations if allowed and possible</p>"},{"location":"sdk/async_requests/#predefined-pollers","title":"Predefined Pollers","text":"<p>There are pre defined pollers that can already be used, and are located in ark_pollers.py</p> <p>Existing pollers are:</p> <ul> <li>default_poller - Default console logger polling</li> <li>line_spinner_poller</li> <li>pixel_spinner_poller</li> <li>moon_spinner_poller</li> <li>spinner_poller</li> <li>pie_spinner_poller</li> </ul>"},{"location":"sdk/authenticators/","title":"Authenticators","text":""},{"location":"sdk/authenticators/#motivation","title":"Motivation","text":"<p>An authenticator provides the abilities to authenticate to a cyberark resource based on authentication profiles, where an authentication profile contains the auth method to authenticate with, along with settings that are coupled to the authentication method</p> <p>An example of creating an authenticator can be seen as follows:</p> <pre><code>from ark_sdk_python.auth import ArkISPAuth\n\nauth = ArkISPAuth(cache_authentication=False)\n</code></pre> <p>Notice that each authenticator can cache its authenticated credentials if need be, and we can disable it on the constructor</p> <p>Each authentictor has a base authenticate method, which receives a auth profile or a profile as an input and outputs / saves a token</p> <p>Alongside that, each authenticator class exposes what the auth methods that are authenticator supports</p> <p>The token can be used as a return value or can be ignored as it is also saved internally</p> <p>There are different types of authenticators and auth methods implemented:</p>"},{"location":"sdk/authenticators/#auth-methods","title":"Auth methods","text":"<ul> <li>Identity (identity) - Identity authentication, to a tenant or to an application within the identity tenant, used in conjunction with IdentityArkAuthMethodSettings</li> <li>IdentityServiceUser (identity_service_user) - Same idea as identity, but with a service user, used in conjunction with IdentityServiceUserArkAuthMethodSettings</li> <li>Direct (direct) - Direct authentication to an endpoint, used in conjunction with DirectArkAuthMethodSettings</li> <li>default - Default authenticator auth method for the authenticator</li> <li>other - Custom implemented</li> </ul> <p>More on the auth methods can be seen on ark_auth_method.py</p>"},{"location":"sdk/authenticators/#authenticator-types","title":"Authenticator Types","text":"<ul> <li>ArkISPAuth (isp) - Authenticator to a specific tenant in the platform<ul> <li>Auth Methods: identity, identity_service_user</li> <li>Default: identity</li> </ul> </li> </ul>"},{"location":"sdk/authenticators/#authenticating-in-the-sdk","title":"Authenticating in the SDK","text":"<p>When u wish to authenticate to a resource, an example authentication flow would look as follows:</p> <pre><code>from ark_sdk_python.auth import ArkISPAuth\n\nisp_auth = ArkISPAuth(cache_authentication=False)\nisp_auth.authenticate(\n    auth_profile=ArkAuthProfile(\n        username='smarom@cyberark.cloud.84573',\n        auth_method=ArkAuthMethod.Identity,\n        auth_method_settings=IdentityArkAuthMethodSettings(),\n    ),\n    secret=ArkSecret(secret=\"CoolPassword\"),\n)\ndpa_api = ArkDPAAPI(isp_auth=isp_auth)\n</code></pre> <p>Where in the above example, we create an authenticator, and authenticate to a specific ISP tenant, using identity authentication type with a given username and password</p> <p>Once authenticated, the authenticate method can return a token but it can also be ignored if not needed as it is stored internally.</p> <p>The authenticator can be passed on to the fitting service for the service execution.</p>"},{"location":"sdk/pagination/","title":"Pagination","text":""},{"location":"sdk/pagination/#motivation","title":"Motivation","text":"<p>When a request returns many items, or can be paginated and return pages of items, we paginate the request and return an iterator of pages instead of all the items</p> <p>This is to not overload the request and wait for too long until a timeout, or just return a subset of the needed items</p> <p>A request that does return a pagination response will return an Iterator of a page that contains an item</p>"},{"location":"sdk/schemas/","title":"Schemas","text":""},{"location":"sdk/schemas/#motivation","title":"Motivation","text":"<p>Ark SDK is entirely based on schemas that are constructed from pydantic</p> <p>Pydantic is a schema and data validation library and settings management using python type annotations</p> <p>All of the exec actions in ark sdk receive a model either parsed from the CLI in a generic fashion or from the SDK in code, and some of them, also return a model or set of models as well</p> <p>All of the models inherit from a base model called ArkModel</p> <pre><code>class ArkModel(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n</code></pre> <p>Following the above model, there are different types of models which serve different base purpose such as aliasing all the attributes with camelCase, or adding polling parameters to the model</p>"},{"location":"sdk/schemas/#example","title":"Example","text":"<p>Any request can be called with a fitting model, an example of that would be:</p> <pre><code>policies_service = ArkDPADBPoliciesService(isp_auth)\npolicies = policies_service.list_policies()\n</code></pre> <p>In the above example, we create the identity service, and call create_role, passing the ArkIdentityCreateRole model, which is based on the model, and returns an ArkIdentityRole model</p> <p>Where the models are specified as follows: <pre><code>class ArkDPDBAGetPolicy(ArkModel):\n    policy_id: Optional[str] = Field(description='Policy id to get')\n    policy_name: Optional[str] = Field(description='Policy name to get')\n</code></pre></p> <p>All of the models can be found here and are seperated to folders based on topic, from auth to services</p>"},{"location":"sdk/services/","title":"Services","text":""},{"location":"sdk/services/#motivation","title":"Motivation","text":"<p>A service is whats executing the actual requests, in a context of the authenticators that were created with it</p> <p>Each service exposes a set of API's specifically to the service, and receives in its constructor a set of authenticators to work with</p> <p>A service exposes its service_config, containing which authenticators are required and which are optional for the service to work</p> <p>A service usage can be seen as follows:</p> <pre><code>import pprint\n\nfrom ark_sdk_python.auth import ArkISPAuth\nfrom ark_sdk_python.models.auth import ArkAuthMethod, ArkAuthProfile, ArkSecret, IdentityArkAuthMethodSettings\nfrom ark_sdk_python.services.dpa.policies import ArkDPAPoliciesService\n\nif __name__ == '__main__':\n    isp_auth = ArkISPAuth(cache_authentication=False)\n    isp_auth.authenticate(\n        auth_profile=ArkAuthProfile(\n            username='tina@cyberark.cloud.12345',\n            auth_method=ArkAuthMethod.Identity,\n            auth_method_settings=IdentityArkAuthMethodSettings(),\n        ),\n        secret=ArkSecret(secret=\"CoolPassword\"),\n    )\n    policies_service = ArkDPADBPoliciesService(isp_auth=isp_auth)\n    policies = policies_service.list_policies()\n    for policy in policies:\n        pprint.pprint(policy.json(indent=4))\n</code></pre> <p>Where in the above example, we authenticate to a specific ISP tenant, and create a DPA policies service, and then use it to list the policies</p> <p>Each service only needs to expose its service_config in order to be supported in the SDK</p>"},{"location":"sdk/services/#services_1","title":"Services","text":"<p>There are alot of different supported functions, the following is a list of supported services and their authenticators</p> <ul> <li>Dynamic Privilege Access Services<ul> <li>ArkDPACertificatesService (certificates) - DPA Certificates service<ul> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> <li>ArkDPASSOService (sso) - DPA Enduser SSO service<ul> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> <li>ArkDPAK8SService (kubernetes) - DPA Enduser Kubernetes service<ul> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> <li>ArkDPADBService (db) - DPA Endusr DB service<ul> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> <li>ArkDPAPoliciesService (policies) - DPA Policies Management<ul> <li>ArkDPADBPoliciesService (db) - DPA DB Policies Management<ul> <li>ArkDPADBPoliciesEditorService (editor) - DPA DB Policies Interactive</li> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> <li>ArkDPAVMPoliciesService (vm) - DPA VM Policies Management<ul> <li>ArkDPAVMPoliciesEditorService (editor) - DPA VM Policies Interactive</li> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> </ul> </li> <li>ArkDPASecretsService (secrets) - DPA Secrets Management<ul> <li>ArkDPADBSecretsService (db) - DPA DB Secrets Services<ul> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> </ul> </li> <li>ArkDPAWorkspacesService (workspaces) - DPA Workspaces Management<ul> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> <li>ArkDPADBWorkspaceService (db) - DPA DB Workspace Management<ul> <li>Required Authenticators: isp</li> <li>Optional Authenticators: None</li> </ul> </li> </ul> </li> </ul> </li> </ul>"}]}